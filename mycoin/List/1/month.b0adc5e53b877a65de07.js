webpackJsonp([1],[function(g,I,C){g.exports=C(15)},,,,,,,function(module,exports,__webpack_require__){eval("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (false) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(8)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qcz82YjJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiAgTW9kaWZpZWQgYnkgRXZhbiBZb3UgQHl5eDk5MDgwM1xuKi9cblxudmFyIGhhc0RvY3VtZW50ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuXG5pZiAodHlwZW9mIERFQlVHICE9PSAndW5kZWZpbmVkJyAmJiBERUJVRykge1xuICBpZiAoIWhhc0RvY3VtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2dWUtc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQuICcgK1xuICAgIFwiVXNlIHsgdGFyZ2V0OiAnbm9kZScgfSBpbiB5b3VyIFdlYnBhY2sgY29uZmlnIHRvIGluZGljYXRlIGEgc2VydmVyLXJlbmRlcmluZyBlbnZpcm9ubWVudC5cIlxuICApIH1cbn1cblxudmFyIGxpc3RUb1N0eWxlcyA9IHJlcXVpcmUoJy4vbGlzdFRvU3R5bGVzJylcblxuLypcbnR5cGUgU3R5bGVPYmplY3QgPSB7XG4gIGlkOiBudW1iZXI7XG4gIHBhcnRzOiBBcnJheTxTdHlsZU9iamVjdFBhcnQ+XG59XG5cbnR5cGUgU3R5bGVPYmplY3RQYXJ0ID0ge1xuICBjc3M6IHN0cmluZztcbiAgbWVkaWE6IHN0cmluZztcbiAgc291cmNlTWFwOiA/c3RyaW5nXG59XG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7LypcbiAgW2lkOiBudW1iZXJdOiB7XG4gICAgaWQ6IG51bWJlcixcbiAgICByZWZzOiBudW1iZXIsXG4gICAgcGFydHM6IEFycmF5PChvYmo/OiBTdHlsZU9iamVjdFBhcnQpID0+IHZvaWQ+XG4gIH1cbiovfVxuXG52YXIgaGVhZCA9IGhhc0RvY3VtZW50ICYmIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0pXG52YXIgc2luZ2xldG9uRWxlbWVudCA9IG51bGxcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMFxudmFyIGlzUHJvZHVjdGlvbiA9IGZhbHNlXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG5cbi8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxudmFyIGlzT2xkSUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvbXNpZSBbNi05XVxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhcmVudElkLCBsaXN0LCBfaXNQcm9kdWN0aW9uKSB7XG4gIGlzUHJvZHVjdGlvbiA9IF9pc1Byb2R1Y3Rpb25cblxuICB2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBsaXN0KVxuICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuICAgIHZhciBtYXlSZW1vdmUgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICAgIGRvbVN0eWxlLnJlZnMtLVxuICAgICAgbWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpXG4gICAgfVxuICAgIGlmIChuZXdMaXN0KSB7XG4gICAgICBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIG5ld0xpc3QpXG4gICAgICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcyA9IFtdXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV1cbiAgICAgIGlmIChkb21TdHlsZS5yZWZzID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXSgpXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzIC8qIEFycmF5PFN0eWxlT2JqZWN0PiAqLykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgIGRvbVN0eWxlLnJlZnMrK1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKVxuICAgICAgfVxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBpZiAoZG9tU3R5bGUucGFydHMubGVuZ3RoID4gaXRlbS5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMubGVuZ3RoID0gaXRlbS5wYXJ0cy5sZW5ndGhcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnRzID0gW11cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgc3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7IGlkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHMgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKCkge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBzdHlsZUVsZW1lbnQudHlwZSA9ICd0ZXh0L2NzcydcbiAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpXG4gIHJldHVybiBzdHlsZUVsZW1lbnRcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgdmFyIHVwZGF0ZSwgcmVtb3ZlXG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLXZ1ZS1zc3ItaWR+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qcz9lNmFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAocGFyZW50SWQsIGxpc3QpIHtcbiAgdmFyIHN0eWxlcyA9IFtdXG4gIHZhciBuZXdTdHlsZXMgPSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICB2YXIgaWQgPSBpdGVtWzBdXG4gICAgdmFyIGNzcyA9IGl0ZW1bMV1cbiAgICB2YXIgbWVkaWEgPSBpdGVtWzJdXG4gICAgdmFyIHNvdXJjZU1hcCA9IGl0ZW1bM11cbiAgICB2YXIgcGFydCA9IHtcbiAgICAgIGlkOiBwYXJlbnRJZCArICc6JyArIGksXG4gICAgICBjc3M6IGNzcyxcbiAgICAgIG1lZGlhOiBtZWRpYSxcbiAgICAgIHNvdXJjZU1hcDogc291cmNlTWFwXG4gICAgfVxuICAgIGlmICghbmV3U3R5bGVzW2lkXSkge1xuICAgICAgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHsgaWQ6IGlkLCBwYXJ0czogW3BhcnRdIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVzXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sInNvdXJjZVJvb3QiOiIifQ==")},,,,,,,function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _vue = __webpack_require__(2);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _vCharts = __webpack_require__(16);\n\nvar _vCharts2 = _interopRequireDefault(_vCharts);\n\nvar _month = __webpack_require__(204);\n\nvar _month2 = _interopRequireDefault(_month);\n\n__webpack_require__(12);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_vue2.default.use(_vCharts2.default);\n\nnew _vue2.default({\n\tel: \"#month\",\n\trender: function render(h) {\n\t\treturn h(_month2.default);\n\t}\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9udGguanM/OTJhMCJdLCJuYW1lcyI6WyJ1c2UiLCJlbCIsInJlbmRlciIsImgiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQSxjQUFJQSxHQUFKOztBQUVBLGtCQUFRO0FBQ1BDLEtBQUcsUUFESTtBQUVQQyxTQUFRO0FBQUEsU0FBSUMsa0JBQUo7QUFBQTtBQUZELENBQVIiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCBWQ2hhcnRzIGZyb20gJ3YtY2hhcnRzJ1xuaW1wb3J0IE1vbnRoIGZyb20gJy4vY29tcG9uZW50cy9tb250aCdcbmltcG9ydCAnLi9zY3NzL2NvbW1vbi5zY3NzJ1xuXG5WdWUudXNlKFZDaGFydHMpXG5cbm5ldyBWdWUoe1xuXHRlbDpcIiNtb250aFwiLFxuXHRyZW5kZXI6IGggPT5oKE1vbnRoKVxufSlcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9udGguanMiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar echarts = _interopDefault(__webpack_require__(17));\n__webpack_require__(129);\n__webpack_require__(146);\n__webpack_require__(152);\n__webpack_require__(170);\n__webpack_require__(181);\n__webpack_require__(190);\n__webpack_require__(194);\n\nif (typeof Object.assign !== 'function') {\n  Object.assign = function (target) {\n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    target = Object(target);\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n      if (source != null) {\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n    }\n    return target;\n  };\n}\n\necharts.registerTheme('ve-chart', {\n  color: ['#19d4ae', '#5ab1ef', '#fa6e86', '#ffb980', '#0067a6', '#c4b4e4', '#d87a80', '#9cbbff', '#d9d0c7', '#87a997', '#d49ea2', '#5b4947', '#7ba3a8'],\n  categoryAxis: {\n    axisLine: { show: false },\n    axisTick: { show: false },\n    splitLine: { show: false }\n  },\n  valueAxis: {\n    axisLine: { show: false }\n  },\n  line: {\n    smooth: true\n  },\n  grid: {\n    containLabel: true,\n    left: 10,\n    right: 10\n  }\n});\n\nvar itemPoint = function itemPoint(color) {\n  return ['<span style=\"', 'background-color:' + color + ';', 'display: inline-block;', 'width: 10px;', 'height: 10px;', 'border-radius: 50%;', 'margin-right:2px;', '\"></span>'].join('');\n};\n\nvar numberFormat = function numberFormat(val) {\n  var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n\n  if (isNaN(+val)) return val;\n\n  var symbolMap = [{ value: 1E18, symbol: 'E' }, { value: 1E15, symbol: 'P' }, { value: 1E12, symbol: 'T' }, { value: 1E9, symbol: 'B' }, { value: 1E6, symbol: 'M' }, { value: 1E3, symbol: 'k' }];\n\n  for (var i = 0; i < symbolMap.length; i++) {\n    if (Math.abs(val) >= symbolMap[i].value) {\n      return (val / symbolMap[i].value).toFixed(digits) + symbolMap[i].symbol;\n    }\n  }\n\n  return val.toString();\n};\n\nvar formatTausends = function formatTausends(num) {\n  return String(num).replace(/^(\\s+|-)?\\d+(?=.?\\d*($|\\s))/g, function (m) {\n    return m.replace(/(?=(?!\\b)(\\d{3})+$)/g, ',');\n  });\n};\n\nvar getFormated = function getFormated(val, type) {\n  switch (type) {\n    case 'KMB':\n      return numberFormat(val);\n    case 'percent':\n      return parseFloat((val * 100).toFixed(2)) + '%';\n    case 'normal':\n      return formatTausends(val);\n    default:\n      return val;\n  }\n};\n\n\n\nvar getStackMap = function getStackMap(stack) {\n  var stackMap = {};\n  Object.keys(stack).forEach(function (item) {\n    stack[item].forEach(function (name) {\n      stackMap[name] = item;\n    });\n  });\n  return stackMap;\n};\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nfunction getBarDimAxis(args) {\n  var rows = args.rows,\n      dimAxisName = args.dimAxisName,\n      dimension = args.dimension,\n      axisVisible = args.axisVisible;\n\n  return dimension.map(function (item) {\n    return {\n      type: 'category',\n      name: dimAxisName,\n      nameLocation: 'middle',\n      nameGap: 22,\n      data: rows.map(function (row) {\n        return row[item];\n      }),\n      axisLabel: {\n        formatter: function formatter(v) {\n          return String(v);\n        }\n      },\n      show: axisVisible\n    };\n  });\n}\n\nfunction getBarMeaAxis(args) {\n  var meaAxisName = args.meaAxisName,\n      meaAxisType = args.meaAxisType,\n      axisVisible = args.axisVisible;\n\n  var meaAxisBase = {\n    type: 'value',\n    axisTick: {\n      show: false\n    },\n    show: axisVisible\n  };\n  var meaAxis = [];\n\n  var _loop = function _loop(i) {\n    if (meaAxisType[i]) {\n      meaAxis[i] = Object.assign({}, meaAxisBase, {\n        axisLabel: {\n          formatter: function formatter(val) {\n            return getFormated(val, meaAxisType[i]);\n          }\n        }\n      });\n    } else {\n      meaAxis[i] = Object.assign({}, meaAxisBase);\n    }\n    meaAxis[i].name = meaAxisName[i] || '';\n  };\n\n  for (var i = 0; i < 2; i++) {\n    _loop(i);\n  }\n\n  return meaAxis;\n}\n\nfunction getBarTooltip(args) {\n  var axisSite = args.axisSite,\n      isHistogram = args.isHistogram,\n      meaAxisType = args.meaAxisType;\n\n  var secondAxis = isHistogram ? axisSite.right : axisSite.top;\n  return {\n    trigger: 'axis',\n    formatter: function formatter(items) {\n      var tpl = [];\n      tpl.push(items[0].name + '<br>');\n      items.forEach(function (item) {\n        var seriesName = item.seriesName;\n        var type = ~secondAxis.indexOf(seriesName) ? meaAxisType[1] : meaAxisType[0];\n        tpl.push(itemPoint(item.color));\n        tpl.push(seriesName + ': ');\n        tpl.push(getFormated(item.value, type));\n        tpl.push('<br>');\n      });\n\n      return tpl.join('');\n    }\n  };\n}\n\nfunction getBarSeries(args) {\n  var rows = args.rows,\n      metrics = args.metrics,\n      stack = args.stack,\n      axisSite = args.axisSite,\n      isHistogram = args.isHistogram;\n\n  var series = [];\n  var seriesTemp = {};\n  var secondAxis = isHistogram ? axisSite.right : axisSite.top;\n  var secondDimAxisIndex = isHistogram ? 'yAxisIndex' : 'xAxisIndex';\n  var stackMap = stack && getStackMap(stack);\n  metrics.forEach(function (item) {\n    seriesTemp[item] = [];\n  });\n  rows.forEach(function (row) {\n    metrics.forEach(function (item) {\n      seriesTemp[item].push(row[item]);\n    });\n  });\n  series = Object.keys(seriesTemp).map(function (item) {\n    var seriesItem = defineProperty({\n      name: item,\n      type: 'bar',\n      data: seriesTemp[item]\n    }, secondDimAxisIndex, ~secondAxis.indexOf(item) ? '1' : '0');\n\n    if (stack && stackMap[item]) seriesItem.stack = stackMap[item];\n\n    return seriesItem;\n  });\n\n  return series.length ? series : false;\n}\n\nvar bar = function bar(columns, rows, settings, extra) {\n  var _settings$axisSite = settings.axisSite,\n      axisSite = _settings$axisSite === undefined ? { top: [] } : _settings$axisSite,\n      _settings$dimension = settings.dimension,\n      dimension = _settings$dimension === undefined ? [columns[0]] : _settings$dimension,\n      _settings$stack = settings.stack,\n      stack = _settings$stack === undefined ? {} : _settings$stack,\n      _settings$axisVisible = settings.axisVisible,\n      axisVisible = _settings$axisVisible === undefined ? true : _settings$axisVisible;\n  var tooltipVisible = extra.tooltipVisible,\n      legendVisible = extra.legendVisible;\n\n  var metrics = columns.slice();\n  if (settings.metrics) {\n    metrics = settings.metrics;\n  } else {\n    metrics.splice(columns.indexOf(dimension[0]), 1);\n  }\n  var meaAxisType = settings.xAxisType || ['normal', 'normal'];\n  var meaAxisName = settings.xAxisName || [];\n  var dimAxisName = settings.yAxisName || '';\n  var isHistogram = false;\n\n  var legend = legendVisible && { data: metrics };\n  var yAxis = getBarDimAxis({ rows: rows, dimAxisName: dimAxisName, dimension: dimension, axisVisible: axisVisible });\n  var xAxis = getBarMeaAxis({ meaAxisName: meaAxisName, meaAxisType: meaAxisType, axisVisible: axisVisible });\n  var series = getBarSeries({ rows: rows, metrics: metrics, stack: stack, axisSite: axisSite, isHistogram: isHistogram });\n  var tooltipParams = { axisSite: axisSite, isHistogram: isHistogram, meaAxisType: meaAxisType };\n  var tooltip = tooltipVisible && getBarTooltip(tooltipParams);\n  var options = { legend: legend, yAxis: yAxis, series: series, xAxis: xAxis, tooltip: tooltip };\n  return options;\n};\n\nvar histogram = function histogram(columns, rows, settings, status) {\n  var _settings$axisSite2 = settings.axisSite,\n      axisSite = _settings$axisSite2 === undefined ? { right: [] } : _settings$axisSite2,\n      _settings$dimension2 = settings.dimension,\n      dimension = _settings$dimension2 === undefined ? [columns[0]] : _settings$dimension2,\n      _settings$stack2 = settings.stack,\n      stack = _settings$stack2 === undefined ? {} : _settings$stack2,\n      _settings$axisVisible2 = settings.axisVisible,\n      axisVisible = _settings$axisVisible2 === undefined ? true : _settings$axisVisible2;\n  var tooltipVisible = status.tooltipVisible,\n      legendVisible = status.legendVisible;\n\n  var metrics = columns.slice();\n  if (settings.metrics) {\n    metrics = settings.metrics;\n  } else {\n    metrics.splice(columns.indexOf(dimension[0]), 1);\n  }\n  var meaAxisType = settings.yAxisType || ['normal', 'normal'];\n  var meaAxisName = settings.yAxisName || [];\n  var dimAxisName = settings.xAxisName || '';\n  var isHistogram = true;\n\n  var legend = legendVisible && { data: metrics };\n  var xAxis = getBarDimAxis({ rows: rows, dimAxisName: dimAxisName, dimension: dimension, axisVisible: axisVisible });\n  var yAxis = getBarMeaAxis({ meaAxisName: meaAxisName, meaAxisType: meaAxisType, axisVisible: axisVisible });\n  var series = getBarSeries({ rows: rows, metrics: metrics, stack: stack, axisSite: axisSite, isHistogram: isHistogram });\n  var tooltipParams = { axisSite: axisSite, isHistogram: isHistogram, meaAxisType: meaAxisType };\n  var tooltip = tooltipVisible && getBarTooltip(tooltipParams);\n  var options = { legend: legend, yAxis: yAxis, series: series, xAxis: xAxis, tooltip: tooltip };\n  return options;\n};\n\nvar chartMixin = {\n  props: {\n    data: { type: [Object, Array], default: null },\n    settings: { type: Object, default: function _default() {\n        return {};\n      }\n    },\n    width: { type: String, default: 'auto' },\n    height: { type: String, default: '400px' },\n    beforeConfig: { type: Function },\n    afterConfig: { type: Function },\n    events: { type: Object },\n    grid: { type: Object },\n    colors: { type: Array },\n    tooltipVisible: { type: Boolean, default: true },\n    legendVisible: { type: Boolean, default: true },\n    legendPosition: { type: String },\n    markLine: { type: Object },\n    markArea: { type: Object },\n    markPoint: { type: Object },\n    visualMap: { type: [Object, Array] },\n    dataZoom: { type: [Object, Array] },\n    toolbox: { type: Object },\n    initOptions: { type: Object, default: function _default() {\n        return {};\n      }\n    }\n  },\n\n  watch: {\n    data: {\n      deep: true,\n      handler: function handler(v) {\n        if (v) {\n          this.dataHandler(v);\n        }\n      }\n    },\n\n    settings: {\n      deep: true,\n      handler: function handler(v) {\n        if (v.type && this.chartLib) this.chartHandler = this.chartLib[v.type];\n        this.dataHandler(this.data);\n      }\n    }\n  },\n\n  computed: {\n    canvasStyle: function canvasStyle() {\n      return {\n        width: this.width,\n        height: this.height,\n        position: 'relative'\n      };\n    }\n  },\n\n  methods: {\n    dataHandler: function dataHandler(data) {\n      var _this = this;\n\n      if (!this.chartHandler) return;\n      if (!data || !Array.isArray(data.columns) || !Array.isArray(data.rows)) return false;\n      var _data = data,\n          columns = _data.columns,\n          rows = _data.rows;\n\n      var extra = {\n        tooltipVisible: this.tooltipVisible,\n        legendVisible: this.legendVisible\n      };\n      if (this.beforeConfig) data = this.beforeConfig(data);\n\n      var options = this.chartHandler(columns, rows, this.settings, extra);\n\n      if (options) {\n        if (this.colors) options.color = this.colors;\n        if (this.grid) options.grid = this.grid;\n        if (this.legendPosition && options.legend) {\n          options.legend[this.legendPosition] = 10;\n          if (~['left', 'right'].indexOf(this.legendPosition)) {\n            options.legend.top = 'middle';\n            options.legend.orient = 'vertical';\n          }\n        }\n        if (this.dataZoom) options.dataZoom = this.dataZoom;\n        if (this.visualMap) options.visualMap = this.visualMap;\n        if (this.toolbox) options.toolbox = this.toolbox;\n        if (this.markArea || this.markLine || this.markPoint) {\n          var marks = {\n            markArea: this.markArea,\n            markLine: this.markLine,\n            markPoint: this.markPoint\n          };\n          var series = options.series;\n          if (this.getType(series) === '[object Array]') {\n            series.forEach(function (item) {\n              _this.addMark(item, marks);\n            });\n          } else if (this.getType(series) === '[object Object]') {\n            this.addMark(series, marks);\n          }\n        }\n        if (this.afterConfig) options = this.afterConfig(options);\n        this.echarts.setOption(options, true);\n      }\n    },\n    addMark: function addMark(seriesItem, marks) {\n      Object.keys(marks).forEach(function (key) {\n        if (marks[key]) {\n          seriesItem[key] = marks[key];\n        }\n      });\n    },\n    getType: function getType(v) {\n      return Object.prototype.toString.call(v);\n    },\n    init: function init() {\n      if (this.echarts) return;\n      this.echarts = this.echartsLib.init(this.$refs.canvas, 've-chart', this.initOptions);\n      if (this.data) this.dataHandler(this.data);\n      if (this.events) this.bindEvents();\n    },\n    bindEvents: function bindEvents() {\n      var _this2 = this;\n\n      Object.keys(this.events).forEach(function (event) {\n        _this2.echarts.on(event, _this2.events[event]);\n      });\n    }\n  },\n\n  mounted: function mounted() {\n    var _this3 = this;\n\n    this.$nextTick(function () {\n      _this3.init();\n      window.addEventListener('resize', _this3.echarts.resize);\n    });\n  },\n  beforeDestory: function beforeDestory() {\n    window.removeEventListener('resize', this.echarts.resize);\n    this.echarts.dispose();\n  }\n};\n\nvar VeBar = {\n  render: function render() {\n    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: \"canvas\", staticClass: \"ve-bar\", style: _vm.canvasStyle });\n  },\n  staticRenderFns: [],\n  name: 'VeBar',\n  mixins: [chartMixin],\n  created: function created() {\n    this.chartHandler = bar;\n    this.echartsLib = echarts;\n  }\n};\n\nvar VeHistogram = {\n  render: function render() {\n    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: \"canvas\", staticClass: \"ve-histogram\", style: _vm.canvasStyle });\n  },\n  staticRenderFns: [],\n  name: 'VeHistogram',\n  mixins: [chartMixin],\n  created: function created() {\n    this.chartHandler = histogram;\n    this.echartsLib = echarts;\n  }\n};\n\nfunction getLineXAxis(args) {\n  var dimension = args.dimension,\n      rows = args.rows,\n      xAxisName = args.xAxisName,\n      axisVisible = args.axisVisible;\n\n  return dimension.map(function (item, index) {\n    return {\n      type: 'category',\n      nameLocation: 'middle',\n      nameGap: 22,\n      boundaryGap: false,\n      name: xAxisName[index] || '',\n      axisTick: { show: true, lineStyle: { color: '#eee' } },\n      data: rows.map(function (row) {\n        return row[item];\n      }),\n      axisLabel: {\n        formatter: function formatter(v) {\n          return String(v);\n        }\n      },\n      show: axisVisible\n    };\n  });\n}\n\nfunction getLineSeries(args) {\n  var rows = args.rows,\n      axisSite = args.axisSite,\n      metrics = args.metrics,\n      area = args.area,\n      stack = args.stack,\n      nullAddZero = args.nullAddZero;\n\n  var series = [];\n  var dataTemp = {};\n  var stackMap = stack && getStackMap(stack);\n  metrics.forEach(function (item) {\n    dataTemp[item] = [];\n  });\n  rows.forEach(function (row) {\n    metrics.forEach(function (item) {\n      var value = null;\n      if (row[item] != null) {\n        value = row[item];\n      } else if (nullAddZero) {\n        value = 0;\n      }\n      dataTemp[item].push(value);\n    });\n  });\n  metrics.forEach(function (item) {\n    var seriesItem = {\n      name: item,\n      type: 'line',\n      data: dataTemp[item]\n    };\n\n    if (area) seriesItem.areaStyle = { normal: {} };\n    seriesItem.yAxisIndex = ~axisSite.right.indexOf(item) ? 1 : 0;\n\n    if (stack && stackMap[item]) seriesItem.stack = stackMap[item];\n\n    series.push(seriesItem);\n  });\n  return series.length ? series : false;\n}\n\nfunction getLineYAxis(args) {\n  var yAxisName = args.yAxisName,\n      yAxisType = args.yAxisType,\n      axisVisible = args.axisVisible,\n      scale = args.scale,\n      min = args.min,\n      max = args.max;\n\n  var yAxisBase = {\n    type: 'value',\n    axisTick: {\n      show: false\n    },\n    show: axisVisible\n  };\n  var yAxis = [];\n\n  var _loop = function _loop(i) {\n    if (yAxisType[i]) {\n      yAxis[i] = Object.assign({}, yAxisBase, {\n        axisLabel: {\n          formatter: function formatter(val) {\n            return getFormated(val, yAxisType[i]);\n          }\n        }\n      });\n    } else {\n      yAxis[i] = Object.assign({}, yAxisBase);\n    }\n    yAxis[i].name = yAxisName[i] || '';\n    yAxis[i].scale = scale[i] || false;\n    yAxis[i].min = min[i] || null;\n    yAxis[i].max = max[i] || null;\n  };\n\n  for (var i = 0; i < 2; i++) {\n    _loop(i);\n  }\n  return yAxis;\n}\n\nfunction getLineTooltip(axisSite, yAxisType) {\n  return {\n    trigger: 'axis',\n    formatter: function formatter(items) {\n      var tpl = [];\n      tpl.push(items[0].name + '<br>');\n      items.forEach(function (item) {\n        var showData = void 0;\n        var type = ~axisSite.right.indexOf(item.seriesName) ? yAxisType[1] : yAxisType[0];\n        showData = getFormated(item.data, type);\n        tpl.push(itemPoint(item.color));\n        tpl.push(item.seriesName + ': ' + showData);\n        tpl.push('<br>');\n      });\n      return tpl.join('');\n    }\n  };\n}\n\nvar line = function line(columns, rows, settings, extra) {\n  var _settings$axisSite = settings.axisSite,\n      axisSite = _settings$axisSite === undefined ? { right: [] } : _settings$axisSite,\n      _settings$yAxisType = settings.yAxisType,\n      yAxisType = _settings$yAxisType === undefined ? ['normal', 'normal'] : _settings$yAxisType,\n      _settings$yAxisName = settings.yAxisName,\n      yAxisName = _settings$yAxisName === undefined ? [] : _settings$yAxisName,\n      _settings$dimension = settings.dimension,\n      dimension = _settings$dimension === undefined ? [columns[0]] : _settings$dimension,\n      _settings$xAxisName = settings.xAxisName,\n      xAxisName = _settings$xAxisName === undefined ? [] : _settings$xAxisName,\n      _settings$axisVisible = settings.axisVisible,\n      axisVisible = _settings$axisVisible === undefined ? true : _settings$axisVisible,\n      area = settings.area,\n      stack = settings.stack,\n      _settings$scale = settings.scale,\n      scale = _settings$scale === undefined ? [false, false] : _settings$scale,\n      _settings$min = settings.min,\n      min = _settings$min === undefined ? [null, null] : _settings$min,\n      _settings$max = settings.max,\n      max = _settings$max === undefined ? [null, null] : _settings$max,\n      _settings$nullAddZero = settings.nullAddZero,\n      nullAddZero = _settings$nullAddZero === undefined ? false : _settings$nullAddZero;\n  var tooltipVisible = extra.tooltipVisible,\n      legendVisible = extra.legendVisible;\n\n  var metrics = columns.slice();\n\n  if (settings.metrics) {\n    metrics = settings.metrics;\n  } else {\n    metrics.splice(columns.indexOf(dimension[0]), 1);\n  }\n\n  var legend = legendVisible && { data: metrics };\n  var tooltip = tooltipVisible && getLineTooltip(axisSite, yAxisType);\n  var xAxis = getLineXAxis({ dimension: dimension, rows: rows, xAxisName: xAxisName, axisVisible: axisVisible });\n  var yAxisParams = {\n    yAxisName: yAxisName,\n    yAxisType: yAxisType,\n    axisVisible: axisVisible,\n    scale: scale,\n    min: min,\n    max: max\n  };\n  var yAxis = getLineYAxis(yAxisParams);\n  var seriesParams = {\n    rows: rows,\n    axisSite: axisSite,\n    metrics: metrics,\n    area: area,\n    stack: stack,\n    nullAddZero: nullAddZero\n  };\n  var series = getLineSeries(seriesParams);\n  if (!xAxis || !series) return false;\n\n  var options = { legend: legend, xAxis: xAxis, series: series, yAxis: yAxis, tooltip: tooltip };\n  return options;\n};\n\nvar VeLine = {\n  render: function render() {\n    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: \"canvas\", staticClass: \"ve-line\", style: _vm.canvasStyle });\n  },\n  staticRenderFns: [],\n  name: 'VeLine',\n  mixins: [chartMixin],\n  created: function created() {\n    this.chartHandler = line;\n    this.echartsLib = echarts;\n  }\n};\n\nvar pieRadius = 100;\nvar ringRadius = [80, 100];\nvar pieOffsetY = 200;\n\nfunction getPieSeries(args) {\n  var rows = args.rows,\n      dataType = args.dataType,\n      percentShow = args.percentShow,\n      dimension = args.dimension,\n      metrics = args.metrics,\n      radius = args.radius,\n      offsetY = args.offsetY,\n      selectedMode = args.selectedMode,\n      hoverAnimation = args.hoverAnimation;\n\n\n  var series = {\n    type: 'pie',\n    radius: radius,\n    selectedMode: selectedMode,\n    hoverAnimation: hoverAnimation,\n    data: [],\n    center: ['50%', offsetY]\n  };\n  if (percentShow) {\n    series.label = {\n      normal: {\n        show: true,\n        formatter: function formatter(item) {\n          var tpl = [];\n          tpl.push(item.name + ':');\n          tpl.push(getFormated(item.value, dataType));\n          tpl.push('(' + item.percent + '%)');\n          return tpl.join(' ');\n        }\n      }\n    };\n  }\n  series.data = rows.map(function (row) {\n    return {\n      name: row[dimension],\n      value: row[metrics]\n    };\n  });\n\n  return series;\n}\n\nfunction getPieLegend(args) {\n  var rows = args.rows,\n      dimension = args.dimension,\n      legendLimit = args.legendLimit;\n\n  var legend = rows.map(function (row) {\n    return row[dimension];\n  });\n  return legend.length ? { data: legend, show: legend.length < legendLimit } : false;\n}\n\nfunction getPieTooltip(dataType) {\n  return {\n    formatter: function formatter(item) {\n      var tpl = [];\n      tpl.push(itemPoint(item.color));\n      tpl.push(item.name + ':');\n      tpl.push(getFormated(item.value, dataType));\n      tpl.push('(' + item.percent + '%)');\n      return tpl.join(' ');\n    }\n  };\n}\n\nvar pie = function pie(columns, rows, settings, extra, isRing) {\n  var _settings$dataType = settings.dataType,\n      dataType = _settings$dataType === undefined ? 'normal' : _settings$dataType,\n      percentShow = settings.percentShow,\n      _settings$dimension = settings.dimension,\n      dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,\n      _settings$metrics = settings.metrics,\n      metrics = _settings$metrics === undefined ? columns[1] : _settings$metrics,\n      _settings$radius = settings.radius,\n      radius = _settings$radius === undefined ? isRing ? ringRadius : pieRadius : _settings$radius,\n      _settings$offsetY = settings.offsetY,\n      offsetY = _settings$offsetY === undefined ? pieOffsetY : _settings$offsetY,\n      _settings$legendLimit = settings.legendLimit,\n      legendLimit = _settings$legendLimit === undefined ? 30 : _settings$legendLimit,\n      _settings$selectedMod = settings.selectedMode,\n      selectedMode = _settings$selectedMod === undefined ? false : _settings$selectedMod,\n      _settings$hoverAnimat = settings.hoverAnimation,\n      hoverAnimation = _settings$hoverAnimat === undefined ? true : _settings$hoverAnimat;\n  var tooltipVisible = extra.tooltipVisible,\n      legendVisible = extra.legendVisible;\n\n  var seriesParams = {\n    rows: rows,\n    dataType: dataType,\n    percentShow: percentShow,\n    dimension: dimension,\n    metrics: metrics,\n    radius: radius,\n    offsetY: offsetY,\n    selectedMode: selectedMode,\n    hoverAnimation: hoverAnimation\n  };\n  var series = getPieSeries(seriesParams);\n  var legend = legendVisible && getPieLegend({ rows: rows, dimension: dimension, legendLimit: legendLimit });\n  var tooltip = tooltipVisible && getPieTooltip(dataType);\n  var options = { series: series, legend: legend, tooltip: tooltip };\n  return options;\n};\n\nvar ring = function ring(columns, rows, settings, extra) {\n  return pie(columns, rows, settings, extra, true);\n};\n\nvar VePie = {\n  render: function render() {\n    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: \"canvas\", staticClass: \"ve-pie\", style: _vm.canvasStyle });\n  },\n  staticRenderFns: [],\n  name: 'VePie',\n  mixins: [chartMixin],\n  created: function created() {\n    this.chartHandler = pie;\n    this.echartsLib = echarts;\n  }\n};\n\nvar VeRing = {\n  render: function render() {\n    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: \"canvas\", staticClass: \"ve-ring\", style: _vm.canvasStyle });\n  },\n  staticRenderFns: [],\n  name: 'VeRing',\n  mixins: [chartMixin],\n  created: function created() {\n    this.chartHandler = ring;\n    this.echartsLib = echarts;\n  }\n};\n\nfunction getWaterfallTooltip(dataType) {\n  return {\n    trigger: 'axis',\n    axisPointer: { type: 'shadow' },\n    formatter: function formatter(items) {\n      var item = items[1];\n      return [item.name + '<br/>' + item.seriesName + ' :', '' + getFormated(item.value, dataType)].join('');\n    }\n  };\n}\n\nfunction getWaterfallXAxis(args) {\n  var dimension = args.dimension,\n      rows = args.rows,\n      remainStatus = args.remainStatus,\n      totalName = args.totalName,\n      remainName = args.remainName,\n      xAxisName = args.xAxisName,\n      axisVisible = args.axisVisible;\n\n  var xAxisData = [totalName].concat(rows.map(function (row) {\n    return row[dimension];\n  }));\n  if (remainStatus === 'have-remain') {\n    xAxisData = xAxisData.concat([remainName]);\n  }\n\n  return {\n    type: 'category',\n    name: xAxisName,\n    splitLine: { show: false },\n    data: xAxisData,\n    show: axisVisible\n  };\n}\n\nfunction getWaterfallYAxis(args) {\n  var dataType = args.dataType,\n      yAxisName = args.yAxisName,\n      axisVisible = args.axisVisible;\n\n  return {\n    type: 'value',\n    name: yAxisName,\n    axisTick: { show: false },\n    axisLabel: {\n      formatter: function formatter(val) {\n        return getFormated(val, dataType);\n      }\n    },\n    show: axisVisible\n  };\n}\n\nfunction getWaterfallSeries(args) {\n  var dataType = args.dataType,\n      rows = args.rows,\n      metrics = args.metrics,\n      totalNum = args.totalNum,\n      remainStatus = args.remainStatus,\n      dataSum = args.dataSum;\n\n  var seriesBase = { type: 'bar', stack: '总量' };\n  var dataSumTemp = dataSum;\n  var totalNumTemp = totalNum;\n  var assistData = void 0;\n  var mainData = void 0;\n  var rowData = rows.map(function (row) {\n    return row[metrics];\n  });\n\n  if (remainStatus === 'have-remain') {\n    assistData = [0].concat(rows.map(function (row) {\n      totalNumTemp -= row[metrics];\n      return totalNumTemp;\n    })).concat([0]);\n    mainData = [totalNum].concat(rowData).concat([totalNum - dataSum]);\n  } else {\n    assistData = [0].concat(rows.map(function (row) {\n      dataSumTemp -= row[metrics];\n      return dataSumTemp;\n    }));\n    mainData = [dataSum].concat(rowData);\n  }\n  var series = [];\n\n  series.push(Object.assign({\n    name: '辅助',\n    itemStyle: {\n      normal: { opacity: 0 },\n      emphasis: { opacity: 0 }\n    },\n    data: assistData\n  }, seriesBase));\n\n  series.push(Object.assign({\n    name: '数值',\n    label: {\n      normal: {\n        show: true,\n        position: 'top',\n        formatter: function formatter(item) {\n          return getFormated(item.value, dataType);\n        }\n      }\n    },\n    data: mainData\n  }, seriesBase));\n  return series;\n}\n\nfunction getWaterfallRemainStatus(dataSum, totalNum) {\n  if (!totalNum) return 'not-total';\n  return totalNum > dataSum ? 'have-remain' : 'none-remain';\n}\n\nvar waterfall = function waterfall(columns, rows, settings, extra) {\n  var _settings$dataType = settings.dataType,\n      dataType = _settings$dataType === undefined ? 'normal' : _settings$dataType,\n      _settings$dimension = settings.dimension,\n      dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,\n      _settings$totalName = settings.totalName,\n      totalName = _settings$totalName === undefined ? '总计' : _settings$totalName,\n      totalNum = settings.totalNum,\n      _settings$remainName = settings.remainName,\n      remainName = _settings$remainName === undefined ? '其他' : _settings$remainName,\n      _settings$xAxisName = settings.xAxisName,\n      xAxisName = _settings$xAxisName === undefined ? dimension : _settings$xAxisName,\n      _settings$axisVisible = settings.axisVisible,\n      axisVisible = _settings$axisVisible === undefined ? true : _settings$axisVisible;\n  var tooltipVisible = extra.tooltipVisible;\n\n  var metricsTemp = columns.slice();\n  metricsTemp.splice(metricsTemp.indexOf(dimension), 1);\n  var metrics = metricsTemp[0];\n  var yAxisName = metrics;\n  var tooltip = tooltipVisible && getWaterfallTooltip(dataType);\n  var dataSum = rows.reduce(function (pre, cur) {\n    return pre + Number(cur[metrics]);\n  }, 0).toFixed(2);\n  var remainStatus = getWaterfallRemainStatus(dataSum, totalNum);\n  var xAxisParams = {\n    dimension: dimension,\n    rows: rows,\n    remainStatus: remainStatus,\n    totalName: totalName,\n    remainName: remainName,\n    xAxisName: xAxisName,\n    axisVisible: axisVisible\n  };\n  var xAxis = getWaterfallXAxis(xAxisParams);\n  var yAxis = getWaterfallYAxis({ dataType: dataType, yAxisName: yAxisName, axisVisible: axisVisible });\n  var seriesParams = {\n    dataType: dataType,\n    rows: rows,\n    dimension: dimension,\n    metrics: metrics,\n    totalNum: totalNum,\n    remainStatus: remainStatus,\n    dataSum: dataSum\n  };\n  var series = getWaterfallSeries(seriesParams);\n  var options = { tooltip: tooltip, xAxis: xAxis, yAxis: yAxis, series: series };\n  return options;\n};\n\nvar VeWaterfall = {\n  render: function render() {\n    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: \"canvas\", staticClass: \"ve-waterfall\", style: _vm.canvasStyle });\n  },\n  staticRenderFns: [],\n  name: 'VeWaterfall',\n  mixins: [chartMixin],\n  created: function created() {\n    this.chartHandler = waterfall;\n    this.echartsLib = echarts;\n  }\n};\n\nfunction getFunnelTooltip(dataType) {\n  return {\n    trigger: 'item',\n    formatter: function formatter(item) {\n      var tpl = [];\n      tpl.push(itemPoint(item.color));\n      tpl.push(item.name + ': ' + getFormated(item.data.realValue, dataType));\n      return tpl.join('');\n    }\n  };\n}\n\nfunction getFunnelSeries(args) {\n  var dimension = args.dimension,\n      metrics = args.metrics,\n      rows = args.rows,\n      sequence = args.sequence,\n      ascending = args.ascending;\n\n  var series = { type: 'funnel' };\n  rows.sort(function (a, b) {\n    return sequence.indexOf(a[dimension]) - sequence.indexOf(b[dimension]);\n  });\n\n  var falseFunnel = false;\n  rows.some(function (row, index) {\n    if (index && row[metrics] > rows[index - 1][metrics]) {\n      falseFunnel = true;\n      return true;\n    }\n  });\n\n  var step = 100 / rows.length;\n\n  if (falseFunnel) {\n    series.data = rows.slice().reverse().map(function (row, index) {\n      return {\n        name: row[dimension],\n        value: (index + 1) * step,\n        realValue: row[metrics]\n      };\n    });\n  } else {\n    series.data = rows.map(function (row) {\n      return {\n        name: row[dimension],\n        value: row[metrics],\n        realValue: row[metrics]\n      };\n    });\n  }\n\n  if (ascending) series.sort = 'ascending';\n  return series;\n}\n\nvar funnel = function funnel(outerColumns, outerRows, settings, extra) {\n  var columns = outerColumns.slice();\n  var rows = outerRows.slice();\n  var _settings$dataType = settings.dataType,\n      dataType = _settings$dataType === undefined ? 'normal' : _settings$dataType,\n      _settings$dimension = settings.dimension,\n      dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,\n      _settings$sequence = settings.sequence,\n      sequence = _settings$sequence === undefined ? rows.map(function (row) {\n    return row[dimension];\n  }) : _settings$sequence,\n      ascending = settings.ascending;\n  var tooltipVisible = extra.tooltipVisible,\n      legendVisible = extra.legendVisible;\n\n  var metrics = void 0;\n  if (settings.metrics) {\n    metrics = settings.metrics;\n  } else {\n    var metricsTemp = columns.slice();\n    metricsTemp.splice(columns.indexOf(dimension), 1);\n    metrics = metricsTemp[0];\n  }\n\n  var tooltip = tooltipVisible && getFunnelTooltip(dataType);\n  var legend = legendVisible && { data: sequence };\n  var seriesParams = { dimension: dimension, metrics: metrics, rows: rows, sequence: sequence, ascending: ascending };\n  var series = getFunnelSeries(seriesParams);\n  var options = { tooltip: tooltip, legend: legend, series: series };\n  return options;\n};\n\nvar VeFunnel = {\n  render: function render() {\n    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: \"canvas\", staticClass: \"ve-funnel\", style: _vm.canvasStyle });\n  },\n  staticRenderFns: [],\n  name: 'VeFunnel',\n  mixins: [chartMixin],\n  created: function created() {\n    this.chartHandler = funnel;\n    this.echartsLib = echarts;\n  }\n};\n\nfunction getRadarLegend(rows, dimension) {\n  var legendData = rows.map(function (row) {\n    return row[dimension];\n  });\n\n  return { data: legendData };\n}\n\nfunction getRadarTooltip(dataType, radar) {\n  var typeTemp = [];\n  var nameTemp = [];\n  radar.indicator.map(function (item, index) {\n    typeTemp[index] = dataType[item.name];\n    nameTemp[index] = item.name;\n  });\n  return {\n    formatter: function formatter(item) {\n      var tpl = [];\n      tpl.push(itemPoint(item.color));\n      tpl.push(item.seriesName + '<br />');\n      item.data.forEach(function (val, index) {\n        tpl.push(nameTemp[index] + ': ');\n        tpl.push(getFormated(val, typeTemp[index]) + '<br />');\n      });\n      return tpl.join('');\n    }\n  };\n}\n\nfunction getRadarSetting(rows, metrics) {\n  var settingBase = {\n    indicator: [],\n    shape: 'circle',\n    splitNumber: 5\n  };\n  var indicatorTemp = {};\n  rows.forEach(function (items) {\n    metrics.forEach(function (item) {\n      if (!indicatorTemp[item]) {\n        indicatorTemp[item] = [items[item]];\n      } else {\n        indicatorTemp[item].push(items[item]);\n      }\n    });\n  });\n  settingBase.indicator = Object.keys(indicatorTemp).map(function (key) {\n    return {\n      name: key,\n      max: Math.max.apply(null, indicatorTemp[key])\n    };\n  });\n  return settingBase;\n}\n\nfunction getRadarSeries(args) {\n  var rows = args.rows,\n      dimension = args.dimension,\n      metrics = args.metrics,\n      radar = args.radar;\n\n  var radarIndexObj = {};\n  radar.indicator.forEach(function (item, index) {\n    radarIndexObj[item.name] = index;\n  });\n\n  var series = rows.map(function (row) {\n    var seriesBase = {\n      name: row[dimension],\n      type: 'radar',\n      data: []\n    };\n    var dataArr = [];\n    Object.keys(row).forEach(function (key) {\n      if (~metrics.indexOf(key)) dataArr[radarIndexObj[key]] = row[key];\n    });\n    seriesBase.data.push(dataArr);\n    return seriesBase;\n  });\n  return series;\n}\n\nvar radar = function radar(columns, rows, settings, extra) {\n  var _settings$dataType = settings.dataType,\n      dataType = _settings$dataType === undefined ? {} : _settings$dataType,\n      _settings$dimension = settings.dimension,\n      dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension;\n  var tooltipVisible = extra.tooltipVisible,\n      legendVisible = extra.legendVisible;\n\n  var metrics = columns.slice();\n  if (settings.metrics) {\n    metrics = settings.metrics;\n  } else {\n    metrics.splice(columns.indexOf(dimension), 1);\n  }\n  var legend = legendVisible && getRadarLegend(rows, dimension);\n  var radar = getRadarSetting(rows, metrics);\n  var tooltip = tooltipVisible && getRadarTooltip(dataType, radar);\n  var series = getRadarSeries({ rows: rows, dimension: dimension, metrics: metrics, radar: radar });\n  var options = { legend: legend, tooltip: tooltip, radar: radar, series: series };\n  return options;\n};\n\nvar VeRadar = {\n  render: function render() {\n    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: \"canvas\", staticClass: \"ve-radar\", style: _vm.canvasStyle });\n  },\n  staticRenderFns: [],\n  name: 'VeRadar',\n  mixins: [chartMixin],\n  created: function created() {\n    this.chartHandler = radar;\n    this.echartsLib = echarts;\n  }\n};\n\nvar VeChart = {\n  render: function render() {\n    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: \"canvas\", staticClass: \"ve-chart\", style: _vm.canvasStyle });\n  },\n  staticRenderFns: [],\n  name: 'VeChart',\n  mixins: [chartMixin],\n  created: function created() {\n    this.chartLib = {\n      bar: bar,\n      histogram: histogram,\n      line: line,\n      pie: pie,\n      ring: ring,\n      funnel: funnel,\n      radar: radar,\n      waterfall: waterfall\n    };\n    this.chartHandler = this.chartLib[this.settings.type];\n    this.echartsLib = echarts;\n  }\n};\n\nvar components = [VeBar, VeHistogram, VeLine, VePie, VeRing, VeWaterfall, VeFunnel, VeRadar, VeChart];\n\nfunction install(Vue, _) {\n  components.forEach(function (component) {\n    Vue.component(component.name, component);\n  });\n}\n\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue);\n}\n\nvar index = {\n  VeBar: VeBar,\n  VeHistogram: VeHistogram,\n  VeRing: VeRing,\n  VeLine: VeLine,\n  VePie: VePie,\n  VeWaterfall: VeWaterfall,\n  VeFunnel: VeFunnel,\n  VeRadar: VeRadar,\n  VeChart: VeChart,\n  install: install\n};\n\nmodule.exports = index;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3YtY2hhcnRzL2xpYi9pbmRleC5qcz9iNjhhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLCtCQUErQixpRkFBaUY7O0FBRWhIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCO0FBQ2hCLEdBQUc7QUFDSDtBQUNBLGVBQWU7QUFDZixHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLDJEQUEyRCwwQkFBMEIsZ0JBQWdCLGlCQUFpQix1QkFBdUIscUJBQXFCO0FBQ2xLOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQjs7QUFFbE0saUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRTtBQUNyQyxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFELFVBQVU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDLDZCQUE2Qix1RkFBdUY7QUFDcEgsNkJBQTZCLCtFQUErRTtBQUM1Ryw2QkFBNkIsMkZBQTJGO0FBQ3hILHVCQUF1QjtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0QsWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakMsNkJBQTZCLHVGQUF1RjtBQUNwSCw2QkFBNkIsK0VBQStFO0FBQzVHLDZCQUE2QiwyRkFBMkY7QUFDeEgsdUJBQXVCO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsdUNBQXVDO0FBQ2xELGVBQWU7QUFDZjtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksZ0NBQWdDO0FBQzVDLGFBQWEsaUNBQWlDO0FBQzlDLG1CQUFtQixpQkFBaUI7QUFDcEMsa0JBQWtCLGlCQUFpQjtBQUNuQyxhQUFhLGVBQWU7QUFDNUIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsY0FBYztBQUMzQixxQkFBcUIsK0JBQStCO0FBQ3BELG9CQUFvQiwrQkFBK0I7QUFDbkQscUJBQXFCLGVBQWU7QUFDcEMsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0Isd0JBQXdCO0FBQ3hDLGVBQWUsd0JBQXdCO0FBQ3ZDLGNBQWMsZUFBZTtBQUM3QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEIsNEJBQTRCLGtCQUFrQiwrREFBK0Q7QUFDNUosR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEIsNEJBQTRCLGtCQUFrQixxRUFBcUU7QUFDbEssR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUIsZ0JBQWdCLEVBQUU7QUFDNUQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsV0FBVztBQUNqRDs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQSw0QkFBNEIsbUZBQW1GO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCLDRCQUE0QixrQkFBa0IsZ0VBQWdFO0FBQzdKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMEJBQTBCLGtEQUFrRDtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsNkRBQTZEO0FBQzNHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCLDRCQUE0QixrQkFBa0IsK0RBQStEO0FBQzVKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCLDRCQUE0QixrQkFBa0IsZ0VBQWdFO0FBQzdKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFFQUFxRTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCLDRCQUE0QixrQkFBa0IscUVBQXFFO0FBQ2xLLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakMsc0JBQXNCO0FBQ3RCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEIsNEJBQTRCLGtCQUFrQixrRUFBa0U7QUFDL0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtRUFBbUU7QUFDbEcsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEIsNEJBQTRCLGtCQUFrQixpRUFBaUU7QUFDOUosR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEIsNEJBQTRCLGtCQUFrQixpRUFBaUU7QUFDOUosR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBlY2hhcnRzID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2VjaGFydHMvbGliL2VjaGFydHMnKSk7XG5yZXF1aXJlKCdlY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcCcpO1xucmVxdWlyZSgnZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZCcpO1xucmVxdWlyZSgnZWNoYXJ0cy9saWIvY2hhcnQvYmFyJyk7XG5yZXF1aXJlKCdlY2hhcnRzL2xpYi9jaGFydC9saW5lJyk7XG5yZXF1aXJlKCdlY2hhcnRzL2xpYi9jaGFydC9waWUnKTtcbnJlcXVpcmUoJ2VjaGFydHMvbGliL2NoYXJ0L2Z1bm5lbCcpO1xucmVxdWlyZSgnZWNoYXJ0cy9saWIvY2hhcnQvcmFkYXInKTtcblxuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xufVxuXG5lY2hhcnRzLnJlZ2lzdGVyVGhlbWUoJ3ZlLWNoYXJ0Jywge1xuICBjb2xvcjogWycjMTlkNGFlJywgJyM1YWIxZWYnLCAnI2ZhNmU4NicsICcjZmZiOTgwJywgJyMwMDY3YTYnLCAnI2M0YjRlNCcsICcjZDg3YTgwJywgJyM5Y2JiZmYnLCAnI2Q5ZDBjNycsICcjODdhOTk3JywgJyNkNDllYTInLCAnIzViNDk0NycsICcjN2JhM2E4J10sXG4gIGNhdGVnb3J5QXhpczoge1xuICAgIGF4aXNMaW5lOiB7IHNob3c6IGZhbHNlIH0sXG4gICAgYXhpc1RpY2s6IHsgc2hvdzogZmFsc2UgfSxcbiAgICBzcGxpdExpbmU6IHsgc2hvdzogZmFsc2UgfVxuICB9LFxuICB2YWx1ZUF4aXM6IHtcbiAgICBheGlzTGluZTogeyBzaG93OiBmYWxzZSB9XG4gIH0sXG4gIGxpbmU6IHtcbiAgICBzbW9vdGg6IHRydWVcbiAgfSxcbiAgZ3JpZDoge1xuICAgIGNvbnRhaW5MYWJlbDogdHJ1ZSxcbiAgICBsZWZ0OiAxMCxcbiAgICByaWdodDogMTBcbiAgfVxufSk7XG5cbnZhciBpdGVtUG9pbnQgPSBmdW5jdGlvbiBpdGVtUG9pbnQoY29sb3IpIHtcbiAgcmV0dXJuIFsnPHNwYW4gc3R5bGU9XCInLCAnYmFja2dyb3VuZC1jb2xvcjonICsgY29sb3IgKyAnOycsICdkaXNwbGF5OiBpbmxpbmUtYmxvY2s7JywgJ3dpZHRoOiAxMHB4OycsICdoZWlnaHQ6IDEwcHg7JywgJ2JvcmRlci1yYWRpdXM6IDUwJTsnLCAnbWFyZ2luLXJpZ2h0OjJweDsnLCAnXCI+PC9zcGFuPiddLmpvaW4oJycpO1xufTtcblxudmFyIG51bWJlckZvcm1hdCA9IGZ1bmN0aW9uIG51bWJlckZvcm1hdCh2YWwpIHtcbiAgdmFyIGRpZ2l0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMjtcblxuICBpZiAoaXNOYU4oK3ZhbCkpIHJldHVybiB2YWw7XG5cbiAgdmFyIHN5bWJvbE1hcCA9IFt7IHZhbHVlOiAxRTE4LCBzeW1ib2w6ICdFJyB9LCB7IHZhbHVlOiAxRTE1LCBzeW1ib2w6ICdQJyB9LCB7IHZhbHVlOiAxRTEyLCBzeW1ib2w6ICdUJyB9LCB7IHZhbHVlOiAxRTksIHN5bWJvbDogJ0InIH0sIHsgdmFsdWU6IDFFNiwgc3ltYm9sOiAnTScgfSwgeyB2YWx1ZTogMUUzLCBzeW1ib2w6ICdrJyB9XTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbE1hcC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChNYXRoLmFicyh2YWwpID49IHN5bWJvbE1hcFtpXS52YWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWwgLyBzeW1ib2xNYXBbaV0udmFsdWUpLnRvRml4ZWQoZGlnaXRzKSArIHN5bWJvbE1hcFtpXS5zeW1ib2w7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbC50b1N0cmluZygpO1xufTtcblxudmFyIGZvcm1hdFRhdXNlbmRzID0gZnVuY3Rpb24gZm9ybWF0VGF1c2VuZHMobnVtKSB7XG4gIHJldHVybiBTdHJpbmcobnVtKS5yZXBsYWNlKC9eKFxccyt8LSk/XFxkKyg/PS4/XFxkKigkfFxccykpL2csIGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIG0ucmVwbGFjZSgvKD89KD8hXFxiKShcXGR7M30pKyQpL2csICcsJyk7XG4gIH0pO1xufTtcblxudmFyIGdldEZvcm1hdGVkID0gZnVuY3Rpb24gZ2V0Rm9ybWF0ZWQodmFsLCB0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ0tNQic6XG4gICAgICByZXR1cm4gbnVtYmVyRm9ybWF0KHZhbCk7XG4gICAgY2FzZSAncGVyY2VudCc6XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCgodmFsICogMTAwKS50b0ZpeGVkKDIpKSArICclJztcbiAgICBjYXNlICdub3JtYWwnOlxuICAgICAgcmV0dXJuIGZvcm1hdFRhdXNlbmRzKHZhbCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2YWw7XG4gIH1cbn07XG5cblxuXG52YXIgZ2V0U3RhY2tNYXAgPSBmdW5jdGlvbiBnZXRTdGFja01hcChzdGFjaykge1xuICB2YXIgc3RhY2tNYXAgPSB7fTtcbiAgT2JqZWN0LmtleXMoc3RhY2spLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBzdGFja1tpdGVtXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBzdGFja01hcFtuYW1lXSA9IGl0ZW07XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gc3RhY2tNYXA7XG59O1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbmZ1bmN0aW9uIGdldEJhckRpbUF4aXMoYXJncykge1xuICB2YXIgcm93cyA9IGFyZ3Mucm93cyxcbiAgICAgIGRpbUF4aXNOYW1lID0gYXJncy5kaW1BeGlzTmFtZSxcbiAgICAgIGRpbWVuc2lvbiA9IGFyZ3MuZGltZW5zaW9uLFxuICAgICAgYXhpc1Zpc2libGUgPSBhcmdzLmF4aXNWaXNpYmxlO1xuXG4gIHJldHVybiBkaW1lbnNpb24ubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICBuYW1lOiBkaW1BeGlzTmFtZSxcbiAgICAgIG5hbWVMb2NhdGlvbjogJ21pZGRsZScsXG4gICAgICBuYW1lR2FwOiAyMixcbiAgICAgIGRhdGE6IHJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuIHJvd1tpdGVtXTtcbiAgICAgIH0pLFxuICAgICAgYXhpc0xhYmVsOiB7XG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKHYpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHYpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2hvdzogYXhpc1Zpc2libGVcbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QmFyTWVhQXhpcyhhcmdzKSB7XG4gIHZhciBtZWFBeGlzTmFtZSA9IGFyZ3MubWVhQXhpc05hbWUsXG4gICAgICBtZWFBeGlzVHlwZSA9IGFyZ3MubWVhQXhpc1R5cGUsXG4gICAgICBheGlzVmlzaWJsZSA9IGFyZ3MuYXhpc1Zpc2libGU7XG5cbiAgdmFyIG1lYUF4aXNCYXNlID0ge1xuICAgIHR5cGU6ICd2YWx1ZScsXG4gICAgYXhpc1RpY2s6IHtcbiAgICAgIHNob3c6IGZhbHNlXG4gICAgfSxcbiAgICBzaG93OiBheGlzVmlzaWJsZVxuICB9O1xuICB2YXIgbWVhQXhpcyA9IFtdO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICBpZiAobWVhQXhpc1R5cGVbaV0pIHtcbiAgICAgIG1lYUF4aXNbaV0gPSBPYmplY3QuYXNzaWduKHt9LCBtZWFBeGlzQmFzZSwge1xuICAgICAgICBheGlzTGFiZWw6IHtcbiAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRGb3JtYXRlZCh2YWwsIG1lYUF4aXNUeXBlW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZWFBeGlzW2ldID0gT2JqZWN0LmFzc2lnbih7fSwgbWVhQXhpc0Jhc2UpO1xuICAgIH1cbiAgICBtZWFBeGlzW2ldLm5hbWUgPSBtZWFBeGlzTmFtZVtpXSB8fCAnJztcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgIF9sb29wKGkpO1xuICB9XG5cbiAgcmV0dXJuIG1lYUF4aXM7XG59XG5cbmZ1bmN0aW9uIGdldEJhclRvb2x0aXAoYXJncykge1xuICB2YXIgYXhpc1NpdGUgPSBhcmdzLmF4aXNTaXRlLFxuICAgICAgaXNIaXN0b2dyYW0gPSBhcmdzLmlzSGlzdG9ncmFtLFxuICAgICAgbWVhQXhpc1R5cGUgPSBhcmdzLm1lYUF4aXNUeXBlO1xuXG4gIHZhciBzZWNvbmRBeGlzID0gaXNIaXN0b2dyYW0gPyBheGlzU2l0ZS5yaWdodCA6IGF4aXNTaXRlLnRvcDtcbiAgcmV0dXJuIHtcbiAgICB0cmlnZ2VyOiAnYXhpcycsXG4gICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIoaXRlbXMpIHtcbiAgICAgIHZhciB0cGwgPSBbXTtcbiAgICAgIHRwbC5wdXNoKGl0ZW1zWzBdLm5hbWUgKyAnPGJyPicpO1xuICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgc2VyaWVzTmFtZSA9IGl0ZW0uc2VyaWVzTmFtZTtcbiAgICAgICAgdmFyIHR5cGUgPSB+c2Vjb25kQXhpcy5pbmRleE9mKHNlcmllc05hbWUpID8gbWVhQXhpc1R5cGVbMV0gOiBtZWFBeGlzVHlwZVswXTtcbiAgICAgICAgdHBsLnB1c2goaXRlbVBvaW50KGl0ZW0uY29sb3IpKTtcbiAgICAgICAgdHBsLnB1c2goc2VyaWVzTmFtZSArICc6ICcpO1xuICAgICAgICB0cGwucHVzaChnZXRGb3JtYXRlZChpdGVtLnZhbHVlLCB0eXBlKSk7XG4gICAgICAgIHRwbC5wdXNoKCc8YnI+Jyk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRwbC5qb2luKCcnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEJhclNlcmllcyhhcmdzKSB7XG4gIHZhciByb3dzID0gYXJncy5yb3dzLFxuICAgICAgbWV0cmljcyA9IGFyZ3MubWV0cmljcyxcbiAgICAgIHN0YWNrID0gYXJncy5zdGFjayxcbiAgICAgIGF4aXNTaXRlID0gYXJncy5heGlzU2l0ZSxcbiAgICAgIGlzSGlzdG9ncmFtID0gYXJncy5pc0hpc3RvZ3JhbTtcblxuICB2YXIgc2VyaWVzID0gW107XG4gIHZhciBzZXJpZXNUZW1wID0ge307XG4gIHZhciBzZWNvbmRBeGlzID0gaXNIaXN0b2dyYW0gPyBheGlzU2l0ZS5yaWdodCA6IGF4aXNTaXRlLnRvcDtcbiAgdmFyIHNlY29uZERpbUF4aXNJbmRleCA9IGlzSGlzdG9ncmFtID8gJ3lBeGlzSW5kZXgnIDogJ3hBeGlzSW5kZXgnO1xuICB2YXIgc3RhY2tNYXAgPSBzdGFjayAmJiBnZXRTdGFja01hcChzdGFjayk7XG4gIG1ldHJpY3MuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIHNlcmllc1RlbXBbaXRlbV0gPSBbXTtcbiAgfSk7XG4gIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgbWV0cmljcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBzZXJpZXNUZW1wW2l0ZW1dLnB1c2gocm93W2l0ZW1dKTtcbiAgICB9KTtcbiAgfSk7XG4gIHNlcmllcyA9IE9iamVjdC5rZXlzKHNlcmllc1RlbXApLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBzZXJpZXNJdGVtID0gZGVmaW5lUHJvcGVydHkoe1xuICAgICAgbmFtZTogaXRlbSxcbiAgICAgIHR5cGU6ICdiYXInLFxuICAgICAgZGF0YTogc2VyaWVzVGVtcFtpdGVtXVxuICAgIH0sIHNlY29uZERpbUF4aXNJbmRleCwgfnNlY29uZEF4aXMuaW5kZXhPZihpdGVtKSA/ICcxJyA6ICcwJyk7XG5cbiAgICBpZiAoc3RhY2sgJiYgc3RhY2tNYXBbaXRlbV0pIHNlcmllc0l0ZW0uc3RhY2sgPSBzdGFja01hcFtpdGVtXTtcblxuICAgIHJldHVybiBzZXJpZXNJdGVtO1xuICB9KTtcblxuICByZXR1cm4gc2VyaWVzLmxlbmd0aCA/IHNlcmllcyA6IGZhbHNlO1xufVxuXG52YXIgYmFyID0gZnVuY3Rpb24gYmFyKGNvbHVtbnMsIHJvd3MsIHNldHRpbmdzLCBleHRyYSkge1xuICB2YXIgX3NldHRpbmdzJGF4aXNTaXRlID0gc2V0dGluZ3MuYXhpc1NpdGUsXG4gICAgICBheGlzU2l0ZSA9IF9zZXR0aW5ncyRheGlzU2l0ZSA9PT0gdW5kZWZpbmVkID8geyB0b3A6IFtdIH0gOiBfc2V0dGluZ3MkYXhpc1NpdGUsXG4gICAgICBfc2V0dGluZ3MkZGltZW5zaW9uID0gc2V0dGluZ3MuZGltZW5zaW9uLFxuICAgICAgZGltZW5zaW9uID0gX3NldHRpbmdzJGRpbWVuc2lvbiA9PT0gdW5kZWZpbmVkID8gW2NvbHVtbnNbMF1dIDogX3NldHRpbmdzJGRpbWVuc2lvbixcbiAgICAgIF9zZXR0aW5ncyRzdGFjayA9IHNldHRpbmdzLnN0YWNrLFxuICAgICAgc3RhY2sgPSBfc2V0dGluZ3Mkc3RhY2sgPT09IHVuZGVmaW5lZCA/IHt9IDogX3NldHRpbmdzJHN0YWNrLFxuICAgICAgX3NldHRpbmdzJGF4aXNWaXNpYmxlID0gc2V0dGluZ3MuYXhpc1Zpc2libGUsXG4gICAgICBheGlzVmlzaWJsZSA9IF9zZXR0aW5ncyRheGlzVmlzaWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9zZXR0aW5ncyRheGlzVmlzaWJsZTtcbiAgdmFyIHRvb2x0aXBWaXNpYmxlID0gZXh0cmEudG9vbHRpcFZpc2libGUsXG4gICAgICBsZWdlbmRWaXNpYmxlID0gZXh0cmEubGVnZW5kVmlzaWJsZTtcblxuICB2YXIgbWV0cmljcyA9IGNvbHVtbnMuc2xpY2UoKTtcbiAgaWYgKHNldHRpbmdzLm1ldHJpY3MpIHtcbiAgICBtZXRyaWNzID0gc2V0dGluZ3MubWV0cmljcztcbiAgfSBlbHNlIHtcbiAgICBtZXRyaWNzLnNwbGljZShjb2x1bW5zLmluZGV4T2YoZGltZW5zaW9uWzBdKSwgMSk7XG4gIH1cbiAgdmFyIG1lYUF4aXNUeXBlID0gc2V0dGluZ3MueEF4aXNUeXBlIHx8IFsnbm9ybWFsJywgJ25vcm1hbCddO1xuICB2YXIgbWVhQXhpc05hbWUgPSBzZXR0aW5ncy54QXhpc05hbWUgfHwgW107XG4gIHZhciBkaW1BeGlzTmFtZSA9IHNldHRpbmdzLnlBeGlzTmFtZSB8fCAnJztcbiAgdmFyIGlzSGlzdG9ncmFtID0gZmFsc2U7XG5cbiAgdmFyIGxlZ2VuZCA9IGxlZ2VuZFZpc2libGUgJiYgeyBkYXRhOiBtZXRyaWNzIH07XG4gIHZhciB5QXhpcyA9IGdldEJhckRpbUF4aXMoeyByb3dzOiByb3dzLCBkaW1BeGlzTmFtZTogZGltQXhpc05hbWUsIGRpbWVuc2lvbjogZGltZW5zaW9uLCBheGlzVmlzaWJsZTogYXhpc1Zpc2libGUgfSk7XG4gIHZhciB4QXhpcyA9IGdldEJhck1lYUF4aXMoeyBtZWFBeGlzTmFtZTogbWVhQXhpc05hbWUsIG1lYUF4aXNUeXBlOiBtZWFBeGlzVHlwZSwgYXhpc1Zpc2libGU6IGF4aXNWaXNpYmxlIH0pO1xuICB2YXIgc2VyaWVzID0gZ2V0QmFyU2VyaWVzKHsgcm93czogcm93cywgbWV0cmljczogbWV0cmljcywgc3RhY2s6IHN0YWNrLCBheGlzU2l0ZTogYXhpc1NpdGUsIGlzSGlzdG9ncmFtOiBpc0hpc3RvZ3JhbSB9KTtcbiAgdmFyIHRvb2x0aXBQYXJhbXMgPSB7IGF4aXNTaXRlOiBheGlzU2l0ZSwgaXNIaXN0b2dyYW06IGlzSGlzdG9ncmFtLCBtZWFBeGlzVHlwZTogbWVhQXhpc1R5cGUgfTtcbiAgdmFyIHRvb2x0aXAgPSB0b29sdGlwVmlzaWJsZSAmJiBnZXRCYXJUb29sdGlwKHRvb2x0aXBQYXJhbXMpO1xuICB2YXIgb3B0aW9ucyA9IHsgbGVnZW5kOiBsZWdlbmQsIHlBeGlzOiB5QXhpcywgc2VyaWVzOiBzZXJpZXMsIHhBeGlzOiB4QXhpcywgdG9vbHRpcDogdG9vbHRpcCB9O1xuICByZXR1cm4gb3B0aW9ucztcbn07XG5cbnZhciBoaXN0b2dyYW0gPSBmdW5jdGlvbiBoaXN0b2dyYW0oY29sdW1ucywgcm93cywgc2V0dGluZ3MsIHN0YXR1cykge1xuICB2YXIgX3NldHRpbmdzJGF4aXNTaXRlMiA9IHNldHRpbmdzLmF4aXNTaXRlLFxuICAgICAgYXhpc1NpdGUgPSBfc2V0dGluZ3MkYXhpc1NpdGUyID09PSB1bmRlZmluZWQgPyB7IHJpZ2h0OiBbXSB9IDogX3NldHRpbmdzJGF4aXNTaXRlMixcbiAgICAgIF9zZXR0aW5ncyRkaW1lbnNpb24yID0gc2V0dGluZ3MuZGltZW5zaW9uLFxuICAgICAgZGltZW5zaW9uID0gX3NldHRpbmdzJGRpbWVuc2lvbjIgPT09IHVuZGVmaW5lZCA/IFtjb2x1bW5zWzBdXSA6IF9zZXR0aW5ncyRkaW1lbnNpb24yLFxuICAgICAgX3NldHRpbmdzJHN0YWNrMiA9IHNldHRpbmdzLnN0YWNrLFxuICAgICAgc3RhY2sgPSBfc2V0dGluZ3Mkc3RhY2syID09PSB1bmRlZmluZWQgPyB7fSA6IF9zZXR0aW5ncyRzdGFjazIsXG4gICAgICBfc2V0dGluZ3MkYXhpc1Zpc2libGUyID0gc2V0dGluZ3MuYXhpc1Zpc2libGUsXG4gICAgICBheGlzVmlzaWJsZSA9IF9zZXR0aW5ncyRheGlzVmlzaWJsZTIgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfc2V0dGluZ3MkYXhpc1Zpc2libGUyO1xuICB2YXIgdG9vbHRpcFZpc2libGUgPSBzdGF0dXMudG9vbHRpcFZpc2libGUsXG4gICAgICBsZWdlbmRWaXNpYmxlID0gc3RhdHVzLmxlZ2VuZFZpc2libGU7XG5cbiAgdmFyIG1ldHJpY3MgPSBjb2x1bW5zLnNsaWNlKCk7XG4gIGlmIChzZXR0aW5ncy5tZXRyaWNzKSB7XG4gICAgbWV0cmljcyA9IHNldHRpbmdzLm1ldHJpY3M7XG4gIH0gZWxzZSB7XG4gICAgbWV0cmljcy5zcGxpY2UoY29sdW1ucy5pbmRleE9mKGRpbWVuc2lvblswXSksIDEpO1xuICB9XG4gIHZhciBtZWFBeGlzVHlwZSA9IHNldHRpbmdzLnlBeGlzVHlwZSB8fCBbJ25vcm1hbCcsICdub3JtYWwnXTtcbiAgdmFyIG1lYUF4aXNOYW1lID0gc2V0dGluZ3MueUF4aXNOYW1lIHx8IFtdO1xuICB2YXIgZGltQXhpc05hbWUgPSBzZXR0aW5ncy54QXhpc05hbWUgfHwgJyc7XG4gIHZhciBpc0hpc3RvZ3JhbSA9IHRydWU7XG5cbiAgdmFyIGxlZ2VuZCA9IGxlZ2VuZFZpc2libGUgJiYgeyBkYXRhOiBtZXRyaWNzIH07XG4gIHZhciB4QXhpcyA9IGdldEJhckRpbUF4aXMoeyByb3dzOiByb3dzLCBkaW1BeGlzTmFtZTogZGltQXhpc05hbWUsIGRpbWVuc2lvbjogZGltZW5zaW9uLCBheGlzVmlzaWJsZTogYXhpc1Zpc2libGUgfSk7XG4gIHZhciB5QXhpcyA9IGdldEJhck1lYUF4aXMoeyBtZWFBeGlzTmFtZTogbWVhQXhpc05hbWUsIG1lYUF4aXNUeXBlOiBtZWFBeGlzVHlwZSwgYXhpc1Zpc2libGU6IGF4aXNWaXNpYmxlIH0pO1xuICB2YXIgc2VyaWVzID0gZ2V0QmFyU2VyaWVzKHsgcm93czogcm93cywgbWV0cmljczogbWV0cmljcywgc3RhY2s6IHN0YWNrLCBheGlzU2l0ZTogYXhpc1NpdGUsIGlzSGlzdG9ncmFtOiBpc0hpc3RvZ3JhbSB9KTtcbiAgdmFyIHRvb2x0aXBQYXJhbXMgPSB7IGF4aXNTaXRlOiBheGlzU2l0ZSwgaXNIaXN0b2dyYW06IGlzSGlzdG9ncmFtLCBtZWFBeGlzVHlwZTogbWVhQXhpc1R5cGUgfTtcbiAgdmFyIHRvb2x0aXAgPSB0b29sdGlwVmlzaWJsZSAmJiBnZXRCYXJUb29sdGlwKHRvb2x0aXBQYXJhbXMpO1xuICB2YXIgb3B0aW9ucyA9IHsgbGVnZW5kOiBsZWdlbmQsIHlBeGlzOiB5QXhpcywgc2VyaWVzOiBzZXJpZXMsIHhBeGlzOiB4QXhpcywgdG9vbHRpcDogdG9vbHRpcCB9O1xuICByZXR1cm4gb3B0aW9ucztcbn07XG5cbnZhciBjaGFydE1peGluID0ge1xuICBwcm9wczoge1xuICAgIGRhdGE6IHsgdHlwZTogW09iamVjdCwgQXJyYXldLCBkZWZhdWx0OiBudWxsIH0sXG4gICAgc2V0dGluZ3M6IHsgdHlwZTogT2JqZWN0LCBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH0sXG4gICAgd2lkdGg6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnYXV0bycgfSxcbiAgICBoZWlnaHQ6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnNDAwcHgnIH0sXG4gICAgYmVmb3JlQ29uZmlnOiB7IHR5cGU6IEZ1bmN0aW9uIH0sXG4gICAgYWZ0ZXJDb25maWc6IHsgdHlwZTogRnVuY3Rpb24gfSxcbiAgICBldmVudHM6IHsgdHlwZTogT2JqZWN0IH0sXG4gICAgZ3JpZDogeyB0eXBlOiBPYmplY3QgfSxcbiAgICBjb2xvcnM6IHsgdHlwZTogQXJyYXkgfSxcbiAgICB0b29sdGlwVmlzaWJsZTogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiB0cnVlIH0sXG4gICAgbGVnZW5kVmlzaWJsZTogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiB0cnVlIH0sXG4gICAgbGVnZW5kUG9zaXRpb246IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgbWFya0xpbmU6IHsgdHlwZTogT2JqZWN0IH0sXG4gICAgbWFya0FyZWE6IHsgdHlwZTogT2JqZWN0IH0sXG4gICAgbWFya1BvaW50OiB7IHR5cGU6IE9iamVjdCB9LFxuICAgIHZpc3VhbE1hcDogeyB0eXBlOiBbT2JqZWN0LCBBcnJheV0gfSxcbiAgICBkYXRhWm9vbTogeyB0eXBlOiBbT2JqZWN0LCBBcnJheV0gfSxcbiAgICB0b29sYm94OiB7IHR5cGU6IE9iamVjdCB9LFxuICAgIGluaXRPcHRpb25zOiB7IHR5cGU6IE9iamVjdCwgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBkYXRhOiB7XG4gICAgICBkZWVwOiB0cnVlLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcih2KSB7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgdGhpcy5kYXRhSGFuZGxlcih2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXR0aW5nczoge1xuICAgICAgZGVlcDogdHJ1ZSxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIodikge1xuICAgICAgICBpZiAodi50eXBlICYmIHRoaXMuY2hhcnRMaWIpIHRoaXMuY2hhcnRIYW5kbGVyID0gdGhpcy5jaGFydExpYlt2LnR5cGVdO1xuICAgICAgICB0aGlzLmRhdGFIYW5kbGVyKHRoaXMuZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgY2FudmFzU3R5bGU6IGZ1bmN0aW9uIGNhbnZhc1N0eWxlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgZGF0YUhhbmRsZXI6IGZ1bmN0aW9uIGRhdGFIYW5kbGVyKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5jaGFydEhhbmRsZXIpIHJldHVybjtcbiAgICAgIGlmICghZGF0YSB8fCAhQXJyYXkuaXNBcnJheShkYXRhLmNvbHVtbnMpIHx8ICFBcnJheS5pc0FycmF5KGRhdGEucm93cykpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBfZGF0YSA9IGRhdGEsXG4gICAgICAgICAgY29sdW1ucyA9IF9kYXRhLmNvbHVtbnMsXG4gICAgICAgICAgcm93cyA9IF9kYXRhLnJvd3M7XG5cbiAgICAgIHZhciBleHRyYSA9IHtcbiAgICAgICAgdG9vbHRpcFZpc2libGU6IHRoaXMudG9vbHRpcFZpc2libGUsXG4gICAgICAgIGxlZ2VuZFZpc2libGU6IHRoaXMubGVnZW5kVmlzaWJsZVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmJlZm9yZUNvbmZpZykgZGF0YSA9IHRoaXMuYmVmb3JlQ29uZmlnKGRhdGEpO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuY2hhcnRIYW5kbGVyKGNvbHVtbnMsIHJvd3MsIHRoaXMuc2V0dGluZ3MsIGV4dHJhKTtcblxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sb3JzKSBvcHRpb25zLmNvbG9yID0gdGhpcy5jb2xvcnM7XG4gICAgICAgIGlmICh0aGlzLmdyaWQpIG9wdGlvbnMuZ3JpZCA9IHRoaXMuZ3JpZDtcbiAgICAgICAgaWYgKHRoaXMubGVnZW5kUG9zaXRpb24gJiYgb3B0aW9ucy5sZWdlbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmxlZ2VuZFt0aGlzLmxlZ2VuZFBvc2l0aW9uXSA9IDEwO1xuICAgICAgICAgIGlmICh+WydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZih0aGlzLmxlZ2VuZFBvc2l0aW9uKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5sZWdlbmQudG9wID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBvcHRpb25zLmxlZ2VuZC5vcmllbnQgPSAndmVydGljYWwnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhWm9vbSkgb3B0aW9ucy5kYXRhWm9vbSA9IHRoaXMuZGF0YVpvb207XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbE1hcCkgb3B0aW9ucy52aXN1YWxNYXAgPSB0aGlzLnZpc3VhbE1hcDtcbiAgICAgICAgaWYgKHRoaXMudG9vbGJveCkgb3B0aW9ucy50b29sYm94ID0gdGhpcy50b29sYm94O1xuICAgICAgICBpZiAodGhpcy5tYXJrQXJlYSB8fCB0aGlzLm1hcmtMaW5lIHx8IHRoaXMubWFya1BvaW50KSB7XG4gICAgICAgICAgdmFyIG1hcmtzID0ge1xuICAgICAgICAgICAgbWFya0FyZWE6IHRoaXMubWFya0FyZWEsXG4gICAgICAgICAgICBtYXJrTGluZTogdGhpcy5tYXJrTGluZSxcbiAgICAgICAgICAgIG1hcmtQb2ludDogdGhpcy5tYXJrUG9pbnRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBzZXJpZXMgPSBvcHRpb25zLnNlcmllcztcbiAgICAgICAgICBpZiAodGhpcy5nZXRUeXBlKHNlcmllcykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgIHNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgIF90aGlzLmFkZE1hcmsoaXRlbSwgbWFya3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmdldFR5cGUoc2VyaWVzKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWFyayhzZXJpZXMsIG1hcmtzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWZ0ZXJDb25maWcpIG9wdGlvbnMgPSB0aGlzLmFmdGVyQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVjaGFydHMuc2V0T3B0aW9uKG9wdGlvbnMsIHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWRkTWFyazogZnVuY3Rpb24gYWRkTWFyayhzZXJpZXNJdGVtLCBtYXJrcykge1xuICAgICAgT2JqZWN0LmtleXMobWFya3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAobWFya3Nba2V5XSkge1xuICAgICAgICAgIHNlcmllc0l0ZW1ba2V5XSA9IG1hcmtzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24gZ2V0VHlwZSh2KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpO1xuICAgIH0sXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIGlmICh0aGlzLmVjaGFydHMpIHJldHVybjtcbiAgICAgIHRoaXMuZWNoYXJ0cyA9IHRoaXMuZWNoYXJ0c0xpYi5pbml0KHRoaXMuJHJlZnMuY2FudmFzLCAndmUtY2hhcnQnLCB0aGlzLmluaXRPcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLmRhdGEpIHRoaXMuZGF0YUhhbmRsZXIodGhpcy5kYXRhKTtcbiAgICAgIGlmICh0aGlzLmV2ZW50cykgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgfSxcbiAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbiBiaW5kRXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuZXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczIuZWNoYXJ0cy5vbihldmVudCwgX3RoaXMyLmV2ZW50c1tldmVudF0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczMuaW5pdCgpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIF90aGlzMy5lY2hhcnRzLnJlc2l6ZSk7XG4gICAgfSk7XG4gIH0sXG4gIGJlZm9yZURlc3Rvcnk6IGZ1bmN0aW9uIGJlZm9yZURlc3RvcnkoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuZWNoYXJ0cy5yZXNpemUpO1xuICAgIHRoaXMuZWNoYXJ0cy5kaXNwb3NlKCk7XG4gIH1cbn07XG5cbnZhciBWZUJhciA9IHtcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF92bSA9IHRoaXM7dmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaDtyZXR1cm4gX2MoJ2RpdicsIHsgcmVmOiBcImNhbnZhc1wiLCBzdGF0aWNDbGFzczogXCJ2ZS1iYXJcIiwgc3R5bGU6IF92bS5jYW52YXNTdHlsZSB9KTtcbiAgfSxcbiAgc3RhdGljUmVuZGVyRm5zOiBbXSxcbiAgbmFtZTogJ1ZlQmFyJyxcbiAgbWl4aW5zOiBbY2hhcnRNaXhpbl0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgdGhpcy5jaGFydEhhbmRsZXIgPSBiYXI7XG4gICAgdGhpcy5lY2hhcnRzTGliID0gZWNoYXJ0cztcbiAgfVxufTtcblxudmFyIFZlSGlzdG9ncmFtID0ge1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3ZtID0gdGhpczt2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oO3JldHVybiBfYygnZGl2JywgeyByZWY6IFwiY2FudmFzXCIsIHN0YXRpY0NsYXNzOiBcInZlLWhpc3RvZ3JhbVwiLCBzdHlsZTogX3ZtLmNhbnZhc1N0eWxlIH0pO1xuICB9LFxuICBzdGF0aWNSZW5kZXJGbnM6IFtdLFxuICBuYW1lOiAnVmVIaXN0b2dyYW0nLFxuICBtaXhpbnM6IFtjaGFydE1peGluXSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB0aGlzLmNoYXJ0SGFuZGxlciA9IGhpc3RvZ3JhbTtcbiAgICB0aGlzLmVjaGFydHNMaWIgPSBlY2hhcnRzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRMaW5lWEF4aXMoYXJncykge1xuICB2YXIgZGltZW5zaW9uID0gYXJncy5kaW1lbnNpb24sXG4gICAgICByb3dzID0gYXJncy5yb3dzLFxuICAgICAgeEF4aXNOYW1lID0gYXJncy54QXhpc05hbWUsXG4gICAgICBheGlzVmlzaWJsZSA9IGFyZ3MuYXhpc1Zpc2libGU7XG5cbiAgcmV0dXJuIGRpbWVuc2lvbi5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICBuYW1lTG9jYXRpb246ICdtaWRkbGUnLFxuICAgICAgbmFtZUdhcDogMjIsXG4gICAgICBib3VuZGFyeUdhcDogZmFsc2UsXG4gICAgICBuYW1lOiB4QXhpc05hbWVbaW5kZXhdIHx8ICcnLFxuICAgICAgYXhpc1RpY2s6IHsgc2hvdzogdHJ1ZSwgbGluZVN0eWxlOiB7IGNvbG9yOiAnI2VlZScgfSB9LFxuICAgICAgZGF0YTogcm93cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICByZXR1cm4gcm93W2l0ZW1dO1xuICAgICAgfSksXG4gICAgICBheGlzTGFiZWw6IHtcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodikge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzaG93OiBheGlzVmlzaWJsZVxuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRMaW5lU2VyaWVzKGFyZ3MpIHtcbiAgdmFyIHJvd3MgPSBhcmdzLnJvd3MsXG4gICAgICBheGlzU2l0ZSA9IGFyZ3MuYXhpc1NpdGUsXG4gICAgICBtZXRyaWNzID0gYXJncy5tZXRyaWNzLFxuICAgICAgYXJlYSA9IGFyZ3MuYXJlYSxcbiAgICAgIHN0YWNrID0gYXJncy5zdGFjayxcbiAgICAgIG51bGxBZGRaZXJvID0gYXJncy5udWxsQWRkWmVybztcblxuICB2YXIgc2VyaWVzID0gW107XG4gIHZhciBkYXRhVGVtcCA9IHt9O1xuICB2YXIgc3RhY2tNYXAgPSBzdGFjayAmJiBnZXRTdGFja01hcChzdGFjayk7XG4gIG1ldHJpY3MuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGRhdGFUZW1wW2l0ZW1dID0gW107XG4gIH0pO1xuICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgIG1ldHJpY3MuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgIGlmIChyb3dbaXRlbV0gIT0gbnVsbCkge1xuICAgICAgICB2YWx1ZSA9IHJvd1tpdGVtXTtcbiAgICAgIH0gZWxzZSBpZiAobnVsbEFkZFplcm8pIHtcbiAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgfVxuICAgICAgZGF0YVRlbXBbaXRlbV0ucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gIH0pO1xuICBtZXRyaWNzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgc2VyaWVzSXRlbSA9IHtcbiAgICAgIG5hbWU6IGl0ZW0sXG4gICAgICB0eXBlOiAnbGluZScsXG4gICAgICBkYXRhOiBkYXRhVGVtcFtpdGVtXVxuICAgIH07XG5cbiAgICBpZiAoYXJlYSkgc2VyaWVzSXRlbS5hcmVhU3R5bGUgPSB7IG5vcm1hbDoge30gfTtcbiAgICBzZXJpZXNJdGVtLnlBeGlzSW5kZXggPSB+YXhpc1NpdGUucmlnaHQuaW5kZXhPZihpdGVtKSA/IDEgOiAwO1xuXG4gICAgaWYgKHN0YWNrICYmIHN0YWNrTWFwW2l0ZW1dKSBzZXJpZXNJdGVtLnN0YWNrID0gc3RhY2tNYXBbaXRlbV07XG5cbiAgICBzZXJpZXMucHVzaChzZXJpZXNJdGVtKTtcbiAgfSk7XG4gIHJldHVybiBzZXJpZXMubGVuZ3RoID8gc2VyaWVzIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldExpbmVZQXhpcyhhcmdzKSB7XG4gIHZhciB5QXhpc05hbWUgPSBhcmdzLnlBeGlzTmFtZSxcbiAgICAgIHlBeGlzVHlwZSA9IGFyZ3MueUF4aXNUeXBlLFxuICAgICAgYXhpc1Zpc2libGUgPSBhcmdzLmF4aXNWaXNpYmxlLFxuICAgICAgc2NhbGUgPSBhcmdzLnNjYWxlLFxuICAgICAgbWluID0gYXJncy5taW4sXG4gICAgICBtYXggPSBhcmdzLm1heDtcblxuICB2YXIgeUF4aXNCYXNlID0ge1xuICAgIHR5cGU6ICd2YWx1ZScsXG4gICAgYXhpc1RpY2s6IHtcbiAgICAgIHNob3c6IGZhbHNlXG4gICAgfSxcbiAgICBzaG93OiBheGlzVmlzaWJsZVxuICB9O1xuICB2YXIgeUF4aXMgPSBbXTtcblxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgaWYgKHlBeGlzVHlwZVtpXSkge1xuICAgICAgeUF4aXNbaV0gPSBPYmplY3QuYXNzaWduKHt9LCB5QXhpc0Jhc2UsIHtcbiAgICAgICAgYXhpc0xhYmVsOiB7XG4gICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Rm9ybWF0ZWQodmFsLCB5QXhpc1R5cGVbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHlBeGlzW2ldID0gT2JqZWN0LmFzc2lnbih7fSwgeUF4aXNCYXNlKTtcbiAgICB9XG4gICAgeUF4aXNbaV0ubmFtZSA9IHlBeGlzTmFtZVtpXSB8fCAnJztcbiAgICB5QXhpc1tpXS5zY2FsZSA9IHNjYWxlW2ldIHx8IGZhbHNlO1xuICAgIHlBeGlzW2ldLm1pbiA9IG1pbltpXSB8fCBudWxsO1xuICAgIHlBeGlzW2ldLm1heCA9IG1heFtpXSB8fCBudWxsO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgX2xvb3AoaSk7XG4gIH1cbiAgcmV0dXJuIHlBeGlzO1xufVxuXG5mdW5jdGlvbiBnZXRMaW5lVG9vbHRpcChheGlzU2l0ZSwgeUF4aXNUeXBlKSB7XG4gIHJldHVybiB7XG4gICAgdHJpZ2dlcjogJ2F4aXMnLFxuICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKGl0ZW1zKSB7XG4gICAgICB2YXIgdHBsID0gW107XG4gICAgICB0cGwucHVzaChpdGVtc1swXS5uYW1lICsgJzxicj4nKTtcbiAgICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIHNob3dEYXRhID0gdm9pZCAwO1xuICAgICAgICB2YXIgdHlwZSA9IH5heGlzU2l0ZS5yaWdodC5pbmRleE9mKGl0ZW0uc2VyaWVzTmFtZSkgPyB5QXhpc1R5cGVbMV0gOiB5QXhpc1R5cGVbMF07XG4gICAgICAgIHNob3dEYXRhID0gZ2V0Rm9ybWF0ZWQoaXRlbS5kYXRhLCB0eXBlKTtcbiAgICAgICAgdHBsLnB1c2goaXRlbVBvaW50KGl0ZW0uY29sb3IpKTtcbiAgICAgICAgdHBsLnB1c2goaXRlbS5zZXJpZXNOYW1lICsgJzogJyArIHNob3dEYXRhKTtcbiAgICAgICAgdHBsLnB1c2goJzxicj4nKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRwbC5qb2luKCcnKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsaW5lID0gZnVuY3Rpb24gbGluZShjb2x1bW5zLCByb3dzLCBzZXR0aW5ncywgZXh0cmEpIHtcbiAgdmFyIF9zZXR0aW5ncyRheGlzU2l0ZSA9IHNldHRpbmdzLmF4aXNTaXRlLFxuICAgICAgYXhpc1NpdGUgPSBfc2V0dGluZ3MkYXhpc1NpdGUgPT09IHVuZGVmaW5lZCA/IHsgcmlnaHQ6IFtdIH0gOiBfc2V0dGluZ3MkYXhpc1NpdGUsXG4gICAgICBfc2V0dGluZ3MkeUF4aXNUeXBlID0gc2V0dGluZ3MueUF4aXNUeXBlLFxuICAgICAgeUF4aXNUeXBlID0gX3NldHRpbmdzJHlBeGlzVHlwZSA9PT0gdW5kZWZpbmVkID8gWydub3JtYWwnLCAnbm9ybWFsJ10gOiBfc2V0dGluZ3MkeUF4aXNUeXBlLFxuICAgICAgX3NldHRpbmdzJHlBeGlzTmFtZSA9IHNldHRpbmdzLnlBeGlzTmFtZSxcbiAgICAgIHlBeGlzTmFtZSA9IF9zZXR0aW5ncyR5QXhpc05hbWUgPT09IHVuZGVmaW5lZCA/IFtdIDogX3NldHRpbmdzJHlBeGlzTmFtZSxcbiAgICAgIF9zZXR0aW5ncyRkaW1lbnNpb24gPSBzZXR0aW5ncy5kaW1lbnNpb24sXG4gICAgICBkaW1lbnNpb24gPSBfc2V0dGluZ3MkZGltZW5zaW9uID09PSB1bmRlZmluZWQgPyBbY29sdW1uc1swXV0gOiBfc2V0dGluZ3MkZGltZW5zaW9uLFxuICAgICAgX3NldHRpbmdzJHhBeGlzTmFtZSA9IHNldHRpbmdzLnhBeGlzTmFtZSxcbiAgICAgIHhBeGlzTmFtZSA9IF9zZXR0aW5ncyR4QXhpc05hbWUgPT09IHVuZGVmaW5lZCA/IFtdIDogX3NldHRpbmdzJHhBeGlzTmFtZSxcbiAgICAgIF9zZXR0aW5ncyRheGlzVmlzaWJsZSA9IHNldHRpbmdzLmF4aXNWaXNpYmxlLFxuICAgICAgYXhpc1Zpc2libGUgPSBfc2V0dGluZ3MkYXhpc1Zpc2libGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfc2V0dGluZ3MkYXhpc1Zpc2libGUsXG4gICAgICBhcmVhID0gc2V0dGluZ3MuYXJlYSxcbiAgICAgIHN0YWNrID0gc2V0dGluZ3Muc3RhY2ssXG4gICAgICBfc2V0dGluZ3Mkc2NhbGUgPSBzZXR0aW5ncy5zY2FsZSxcbiAgICAgIHNjYWxlID0gX3NldHRpbmdzJHNjYWxlID09PSB1bmRlZmluZWQgPyBbZmFsc2UsIGZhbHNlXSA6IF9zZXR0aW5ncyRzY2FsZSxcbiAgICAgIF9zZXR0aW5ncyRtaW4gPSBzZXR0aW5ncy5taW4sXG4gICAgICBtaW4gPSBfc2V0dGluZ3MkbWluID09PSB1bmRlZmluZWQgPyBbbnVsbCwgbnVsbF0gOiBfc2V0dGluZ3MkbWluLFxuICAgICAgX3NldHRpbmdzJG1heCA9IHNldHRpbmdzLm1heCxcbiAgICAgIG1heCA9IF9zZXR0aW5ncyRtYXggPT09IHVuZGVmaW5lZCA/IFtudWxsLCBudWxsXSA6IF9zZXR0aW5ncyRtYXgsXG4gICAgICBfc2V0dGluZ3MkbnVsbEFkZFplcm8gPSBzZXR0aW5ncy5udWxsQWRkWmVybyxcbiAgICAgIG51bGxBZGRaZXJvID0gX3NldHRpbmdzJG51bGxBZGRaZXJvID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9zZXR0aW5ncyRudWxsQWRkWmVybztcbiAgdmFyIHRvb2x0aXBWaXNpYmxlID0gZXh0cmEudG9vbHRpcFZpc2libGUsXG4gICAgICBsZWdlbmRWaXNpYmxlID0gZXh0cmEubGVnZW5kVmlzaWJsZTtcblxuICB2YXIgbWV0cmljcyA9IGNvbHVtbnMuc2xpY2UoKTtcblxuICBpZiAoc2V0dGluZ3MubWV0cmljcykge1xuICAgIG1ldHJpY3MgPSBzZXR0aW5ncy5tZXRyaWNzO1xuICB9IGVsc2Uge1xuICAgIG1ldHJpY3Muc3BsaWNlKGNvbHVtbnMuaW5kZXhPZihkaW1lbnNpb25bMF0pLCAxKTtcbiAgfVxuXG4gIHZhciBsZWdlbmQgPSBsZWdlbmRWaXNpYmxlICYmIHsgZGF0YTogbWV0cmljcyB9O1xuICB2YXIgdG9vbHRpcCA9IHRvb2x0aXBWaXNpYmxlICYmIGdldExpbmVUb29sdGlwKGF4aXNTaXRlLCB5QXhpc1R5cGUpO1xuICB2YXIgeEF4aXMgPSBnZXRMaW5lWEF4aXMoeyBkaW1lbnNpb246IGRpbWVuc2lvbiwgcm93czogcm93cywgeEF4aXNOYW1lOiB4QXhpc05hbWUsIGF4aXNWaXNpYmxlOiBheGlzVmlzaWJsZSB9KTtcbiAgdmFyIHlBeGlzUGFyYW1zID0ge1xuICAgIHlBeGlzTmFtZTogeUF4aXNOYW1lLFxuICAgIHlBeGlzVHlwZTogeUF4aXNUeXBlLFxuICAgIGF4aXNWaXNpYmxlOiBheGlzVmlzaWJsZSxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXhcbiAgfTtcbiAgdmFyIHlBeGlzID0gZ2V0TGluZVlBeGlzKHlBeGlzUGFyYW1zKTtcbiAgdmFyIHNlcmllc1BhcmFtcyA9IHtcbiAgICByb3dzOiByb3dzLFxuICAgIGF4aXNTaXRlOiBheGlzU2l0ZSxcbiAgICBtZXRyaWNzOiBtZXRyaWNzLFxuICAgIGFyZWE6IGFyZWEsXG4gICAgc3RhY2s6IHN0YWNrLFxuICAgIG51bGxBZGRaZXJvOiBudWxsQWRkWmVyb1xuICB9O1xuICB2YXIgc2VyaWVzID0gZ2V0TGluZVNlcmllcyhzZXJpZXNQYXJhbXMpO1xuICBpZiAoIXhBeGlzIHx8ICFzZXJpZXMpIHJldHVybiBmYWxzZTtcblxuICB2YXIgb3B0aW9ucyA9IHsgbGVnZW5kOiBsZWdlbmQsIHhBeGlzOiB4QXhpcywgc2VyaWVzOiBzZXJpZXMsIHlBeGlzOiB5QXhpcywgdG9vbHRpcDogdG9vbHRpcCB9O1xuICByZXR1cm4gb3B0aW9ucztcbn07XG5cbnZhciBWZUxpbmUgPSB7XG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdm0gPSB0aGlzO3ZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7cmV0dXJuIF9jKCdkaXYnLCB7IHJlZjogXCJjYW52YXNcIiwgc3RhdGljQ2xhc3M6IFwidmUtbGluZVwiLCBzdHlsZTogX3ZtLmNhbnZhc1N0eWxlIH0pO1xuICB9LFxuICBzdGF0aWNSZW5kZXJGbnM6IFtdLFxuICBuYW1lOiAnVmVMaW5lJyxcbiAgbWl4aW5zOiBbY2hhcnRNaXhpbl0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgdGhpcy5jaGFydEhhbmRsZXIgPSBsaW5lO1xuICAgIHRoaXMuZWNoYXJ0c0xpYiA9IGVjaGFydHM7XG4gIH1cbn07XG5cbnZhciBwaWVSYWRpdXMgPSAxMDA7XG52YXIgcmluZ1JhZGl1cyA9IFs4MCwgMTAwXTtcbnZhciBwaWVPZmZzZXRZID0gMjAwO1xuXG5mdW5jdGlvbiBnZXRQaWVTZXJpZXMoYXJncykge1xuICB2YXIgcm93cyA9IGFyZ3Mucm93cyxcbiAgICAgIGRhdGFUeXBlID0gYXJncy5kYXRhVHlwZSxcbiAgICAgIHBlcmNlbnRTaG93ID0gYXJncy5wZXJjZW50U2hvdyxcbiAgICAgIGRpbWVuc2lvbiA9IGFyZ3MuZGltZW5zaW9uLFxuICAgICAgbWV0cmljcyA9IGFyZ3MubWV0cmljcyxcbiAgICAgIHJhZGl1cyA9IGFyZ3MucmFkaXVzLFxuICAgICAgb2Zmc2V0WSA9IGFyZ3Mub2Zmc2V0WSxcbiAgICAgIHNlbGVjdGVkTW9kZSA9IGFyZ3Muc2VsZWN0ZWRNb2RlLFxuICAgICAgaG92ZXJBbmltYXRpb24gPSBhcmdzLmhvdmVyQW5pbWF0aW9uO1xuXG5cbiAgdmFyIHNlcmllcyA9IHtcbiAgICB0eXBlOiAncGllJyxcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBzZWxlY3RlZE1vZGU6IHNlbGVjdGVkTW9kZSxcbiAgICBob3ZlckFuaW1hdGlvbjogaG92ZXJBbmltYXRpb24sXG4gICAgZGF0YTogW10sXG4gICAgY2VudGVyOiBbJzUwJScsIG9mZnNldFldXG4gIH07XG4gIGlmIChwZXJjZW50U2hvdykge1xuICAgIHNlcmllcy5sYWJlbCA9IHtcbiAgICAgIG5vcm1hbDoge1xuICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcihpdGVtKSB7XG4gICAgICAgICAgdmFyIHRwbCA9IFtdO1xuICAgICAgICAgIHRwbC5wdXNoKGl0ZW0ubmFtZSArICc6Jyk7XG4gICAgICAgICAgdHBsLnB1c2goZ2V0Rm9ybWF0ZWQoaXRlbS52YWx1ZSwgZGF0YVR5cGUpKTtcbiAgICAgICAgICB0cGwucHVzaCgnKCcgKyBpdGVtLnBlcmNlbnQgKyAnJSknKTtcbiAgICAgICAgICByZXR1cm4gdHBsLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgc2VyaWVzLmRhdGEgPSByb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHJvd1tkaW1lbnNpb25dLFxuICAgICAgdmFsdWU6IHJvd1ttZXRyaWNzXVxuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiBzZXJpZXM7XG59XG5cbmZ1bmN0aW9uIGdldFBpZUxlZ2VuZChhcmdzKSB7XG4gIHZhciByb3dzID0gYXJncy5yb3dzLFxuICAgICAgZGltZW5zaW9uID0gYXJncy5kaW1lbnNpb24sXG4gICAgICBsZWdlbmRMaW1pdCA9IGFyZ3MubGVnZW5kTGltaXQ7XG5cbiAgdmFyIGxlZ2VuZCA9IHJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICByZXR1cm4gcm93W2RpbWVuc2lvbl07XG4gIH0pO1xuICByZXR1cm4gbGVnZW5kLmxlbmd0aCA/IHsgZGF0YTogbGVnZW5kLCBzaG93OiBsZWdlbmQubGVuZ3RoIDwgbGVnZW5kTGltaXQgfSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRQaWVUb29sdGlwKGRhdGFUeXBlKSB7XG4gIHJldHVybiB7XG4gICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIoaXRlbSkge1xuICAgICAgdmFyIHRwbCA9IFtdO1xuICAgICAgdHBsLnB1c2goaXRlbVBvaW50KGl0ZW0uY29sb3IpKTtcbiAgICAgIHRwbC5wdXNoKGl0ZW0ubmFtZSArICc6Jyk7XG4gICAgICB0cGwucHVzaChnZXRGb3JtYXRlZChpdGVtLnZhbHVlLCBkYXRhVHlwZSkpO1xuICAgICAgdHBsLnB1c2goJygnICsgaXRlbS5wZXJjZW50ICsgJyUpJyk7XG4gICAgICByZXR1cm4gdHBsLmpvaW4oJyAnKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBwaWUgPSBmdW5jdGlvbiBwaWUoY29sdW1ucywgcm93cywgc2V0dGluZ3MsIGV4dHJhLCBpc1JpbmcpIHtcbiAgdmFyIF9zZXR0aW5ncyRkYXRhVHlwZSA9IHNldHRpbmdzLmRhdGFUeXBlLFxuICAgICAgZGF0YVR5cGUgPSBfc2V0dGluZ3MkZGF0YVR5cGUgPT09IHVuZGVmaW5lZCA/ICdub3JtYWwnIDogX3NldHRpbmdzJGRhdGFUeXBlLFxuICAgICAgcGVyY2VudFNob3cgPSBzZXR0aW5ncy5wZXJjZW50U2hvdyxcbiAgICAgIF9zZXR0aW5ncyRkaW1lbnNpb24gPSBzZXR0aW5ncy5kaW1lbnNpb24sXG4gICAgICBkaW1lbnNpb24gPSBfc2V0dGluZ3MkZGltZW5zaW9uID09PSB1bmRlZmluZWQgPyBjb2x1bW5zWzBdIDogX3NldHRpbmdzJGRpbWVuc2lvbixcbiAgICAgIF9zZXR0aW5ncyRtZXRyaWNzID0gc2V0dGluZ3MubWV0cmljcyxcbiAgICAgIG1ldHJpY3MgPSBfc2V0dGluZ3MkbWV0cmljcyA9PT0gdW5kZWZpbmVkID8gY29sdW1uc1sxXSA6IF9zZXR0aW5ncyRtZXRyaWNzLFxuICAgICAgX3NldHRpbmdzJHJhZGl1cyA9IHNldHRpbmdzLnJhZGl1cyxcbiAgICAgIHJhZGl1cyA9IF9zZXR0aW5ncyRyYWRpdXMgPT09IHVuZGVmaW5lZCA/IGlzUmluZyA/IHJpbmdSYWRpdXMgOiBwaWVSYWRpdXMgOiBfc2V0dGluZ3MkcmFkaXVzLFxuICAgICAgX3NldHRpbmdzJG9mZnNldFkgPSBzZXR0aW5ncy5vZmZzZXRZLFxuICAgICAgb2Zmc2V0WSA9IF9zZXR0aW5ncyRvZmZzZXRZID09PSB1bmRlZmluZWQgPyBwaWVPZmZzZXRZIDogX3NldHRpbmdzJG9mZnNldFksXG4gICAgICBfc2V0dGluZ3MkbGVnZW5kTGltaXQgPSBzZXR0aW5ncy5sZWdlbmRMaW1pdCxcbiAgICAgIGxlZ2VuZExpbWl0ID0gX3NldHRpbmdzJGxlZ2VuZExpbWl0ID09PSB1bmRlZmluZWQgPyAzMCA6IF9zZXR0aW5ncyRsZWdlbmRMaW1pdCxcbiAgICAgIF9zZXR0aW5ncyRzZWxlY3RlZE1vZCA9IHNldHRpbmdzLnNlbGVjdGVkTW9kZSxcbiAgICAgIHNlbGVjdGVkTW9kZSA9IF9zZXR0aW5ncyRzZWxlY3RlZE1vZCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfc2V0dGluZ3Mkc2VsZWN0ZWRNb2QsXG4gICAgICBfc2V0dGluZ3MkaG92ZXJBbmltYXQgPSBzZXR0aW5ncy5ob3ZlckFuaW1hdGlvbixcbiAgICAgIGhvdmVyQW5pbWF0aW9uID0gX3NldHRpbmdzJGhvdmVyQW5pbWF0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3NldHRpbmdzJGhvdmVyQW5pbWF0O1xuICB2YXIgdG9vbHRpcFZpc2libGUgPSBleHRyYS50b29sdGlwVmlzaWJsZSxcbiAgICAgIGxlZ2VuZFZpc2libGUgPSBleHRyYS5sZWdlbmRWaXNpYmxlO1xuXG4gIHZhciBzZXJpZXNQYXJhbXMgPSB7XG4gICAgcm93czogcm93cyxcbiAgICBkYXRhVHlwZTogZGF0YVR5cGUsXG4gICAgcGVyY2VudFNob3c6IHBlcmNlbnRTaG93LFxuICAgIGRpbWVuc2lvbjogZGltZW5zaW9uLFxuICAgIG1ldHJpY3M6IG1ldHJpY3MsXG4gICAgcmFkaXVzOiByYWRpdXMsXG4gICAgb2Zmc2V0WTogb2Zmc2V0WSxcbiAgICBzZWxlY3RlZE1vZGU6IHNlbGVjdGVkTW9kZSxcbiAgICBob3ZlckFuaW1hdGlvbjogaG92ZXJBbmltYXRpb25cbiAgfTtcbiAgdmFyIHNlcmllcyA9IGdldFBpZVNlcmllcyhzZXJpZXNQYXJhbXMpO1xuICB2YXIgbGVnZW5kID0gbGVnZW5kVmlzaWJsZSAmJiBnZXRQaWVMZWdlbmQoeyByb3dzOiByb3dzLCBkaW1lbnNpb246IGRpbWVuc2lvbiwgbGVnZW5kTGltaXQ6IGxlZ2VuZExpbWl0IH0pO1xuICB2YXIgdG9vbHRpcCA9IHRvb2x0aXBWaXNpYmxlICYmIGdldFBpZVRvb2x0aXAoZGF0YVR5cGUpO1xuICB2YXIgb3B0aW9ucyA9IHsgc2VyaWVzOiBzZXJpZXMsIGxlZ2VuZDogbGVnZW5kLCB0b29sdGlwOiB0b29sdGlwIH07XG4gIHJldHVybiBvcHRpb25zO1xufTtcblxudmFyIHJpbmcgPSBmdW5jdGlvbiByaW5nKGNvbHVtbnMsIHJvd3MsIHNldHRpbmdzLCBleHRyYSkge1xuICByZXR1cm4gcGllKGNvbHVtbnMsIHJvd3MsIHNldHRpbmdzLCBleHRyYSwgdHJ1ZSk7XG59O1xuXG52YXIgVmVQaWUgPSB7XG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdm0gPSB0aGlzO3ZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7cmV0dXJuIF9jKCdkaXYnLCB7IHJlZjogXCJjYW52YXNcIiwgc3RhdGljQ2xhc3M6IFwidmUtcGllXCIsIHN0eWxlOiBfdm0uY2FudmFzU3R5bGUgfSk7XG4gIH0sXG4gIHN0YXRpY1JlbmRlckZuczogW10sXG4gIG5hbWU6ICdWZVBpZScsXG4gIG1peGluczogW2NoYXJ0TWl4aW5dLFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMuY2hhcnRIYW5kbGVyID0gcGllO1xuICAgIHRoaXMuZWNoYXJ0c0xpYiA9IGVjaGFydHM7XG4gIH1cbn07XG5cbnZhciBWZVJpbmcgPSB7XG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdm0gPSB0aGlzO3ZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7cmV0dXJuIF9jKCdkaXYnLCB7IHJlZjogXCJjYW52YXNcIiwgc3RhdGljQ2xhc3M6IFwidmUtcmluZ1wiLCBzdHlsZTogX3ZtLmNhbnZhc1N0eWxlIH0pO1xuICB9LFxuICBzdGF0aWNSZW5kZXJGbnM6IFtdLFxuICBuYW1lOiAnVmVSaW5nJyxcbiAgbWl4aW5zOiBbY2hhcnRNaXhpbl0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgdGhpcy5jaGFydEhhbmRsZXIgPSByaW5nO1xuICAgIHRoaXMuZWNoYXJ0c0xpYiA9IGVjaGFydHM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFdhdGVyZmFsbFRvb2x0aXAoZGF0YVR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0cmlnZ2VyOiAnYXhpcycsXG4gICAgYXhpc1BvaW50ZXI6IHsgdHlwZTogJ3NoYWRvdycgfSxcbiAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcihpdGVtcykge1xuICAgICAgdmFyIGl0ZW0gPSBpdGVtc1sxXTtcbiAgICAgIHJldHVybiBbaXRlbS5uYW1lICsgJzxici8+JyArIGl0ZW0uc2VyaWVzTmFtZSArICcgOicsICcnICsgZ2V0Rm9ybWF0ZWQoaXRlbS52YWx1ZSwgZGF0YVR5cGUpXS5qb2luKCcnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFdhdGVyZmFsbFhBeGlzKGFyZ3MpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IGFyZ3MuZGltZW5zaW9uLFxuICAgICAgcm93cyA9IGFyZ3Mucm93cyxcbiAgICAgIHJlbWFpblN0YXR1cyA9IGFyZ3MucmVtYWluU3RhdHVzLFxuICAgICAgdG90YWxOYW1lID0gYXJncy50b3RhbE5hbWUsXG4gICAgICByZW1haW5OYW1lID0gYXJncy5yZW1haW5OYW1lLFxuICAgICAgeEF4aXNOYW1lID0gYXJncy54QXhpc05hbWUsXG4gICAgICBheGlzVmlzaWJsZSA9IGFyZ3MuYXhpc1Zpc2libGU7XG5cbiAgdmFyIHhBeGlzRGF0YSA9IFt0b3RhbE5hbWVdLmNvbmNhdChyb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgcmV0dXJuIHJvd1tkaW1lbnNpb25dO1xuICB9KSk7XG4gIGlmIChyZW1haW5TdGF0dXMgPT09ICdoYXZlLXJlbWFpbicpIHtcbiAgICB4QXhpc0RhdGEgPSB4QXhpc0RhdGEuY29uY2F0KFtyZW1haW5OYW1lXSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgbmFtZTogeEF4aXNOYW1lLFxuICAgIHNwbGl0TGluZTogeyBzaG93OiBmYWxzZSB9LFxuICAgIGRhdGE6IHhBeGlzRGF0YSxcbiAgICBzaG93OiBheGlzVmlzaWJsZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRXYXRlcmZhbGxZQXhpcyhhcmdzKSB7XG4gIHZhciBkYXRhVHlwZSA9IGFyZ3MuZGF0YVR5cGUsXG4gICAgICB5QXhpc05hbWUgPSBhcmdzLnlBeGlzTmFtZSxcbiAgICAgIGF4aXNWaXNpYmxlID0gYXJncy5heGlzVmlzaWJsZTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICd2YWx1ZScsXG4gICAgbmFtZTogeUF4aXNOYW1lLFxuICAgIGF4aXNUaWNrOiB7IHNob3c6IGZhbHNlIH0sXG4gICAgYXhpc0xhYmVsOiB7XG4gICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcih2YWwpIHtcbiAgICAgICAgcmV0dXJuIGdldEZvcm1hdGVkKHZhbCwgZGF0YVR5cGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2hvdzogYXhpc1Zpc2libGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0V2F0ZXJmYWxsU2VyaWVzKGFyZ3MpIHtcbiAgdmFyIGRhdGFUeXBlID0gYXJncy5kYXRhVHlwZSxcbiAgICAgIHJvd3MgPSBhcmdzLnJvd3MsXG4gICAgICBtZXRyaWNzID0gYXJncy5tZXRyaWNzLFxuICAgICAgdG90YWxOdW0gPSBhcmdzLnRvdGFsTnVtLFxuICAgICAgcmVtYWluU3RhdHVzID0gYXJncy5yZW1haW5TdGF0dXMsXG4gICAgICBkYXRhU3VtID0gYXJncy5kYXRhU3VtO1xuXG4gIHZhciBzZXJpZXNCYXNlID0geyB0eXBlOiAnYmFyJywgc3RhY2s6ICfmgLvph48nIH07XG4gIHZhciBkYXRhU3VtVGVtcCA9IGRhdGFTdW07XG4gIHZhciB0b3RhbE51bVRlbXAgPSB0b3RhbE51bTtcbiAgdmFyIGFzc2lzdERhdGEgPSB2b2lkIDA7XG4gIHZhciBtYWluRGF0YSA9IHZvaWQgMDtcbiAgdmFyIHJvd0RhdGEgPSByb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgcmV0dXJuIHJvd1ttZXRyaWNzXTtcbiAgfSk7XG5cbiAgaWYgKHJlbWFpblN0YXR1cyA9PT0gJ2hhdmUtcmVtYWluJykge1xuICAgIGFzc2lzdERhdGEgPSBbMF0uY29uY2F0KHJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHRvdGFsTnVtVGVtcCAtPSByb3dbbWV0cmljc107XG4gICAgICByZXR1cm4gdG90YWxOdW1UZW1wO1xuICAgIH0pKS5jb25jYXQoWzBdKTtcbiAgICBtYWluRGF0YSA9IFt0b3RhbE51bV0uY29uY2F0KHJvd0RhdGEpLmNvbmNhdChbdG90YWxOdW0gLSBkYXRhU3VtXSk7XG4gIH0gZWxzZSB7XG4gICAgYXNzaXN0RGF0YSA9IFswXS5jb25jYXQocm93cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgZGF0YVN1bVRlbXAgLT0gcm93W21ldHJpY3NdO1xuICAgICAgcmV0dXJuIGRhdGFTdW1UZW1wO1xuICAgIH0pKTtcbiAgICBtYWluRGF0YSA9IFtkYXRhU3VtXS5jb25jYXQocm93RGF0YSk7XG4gIH1cbiAgdmFyIHNlcmllcyA9IFtdO1xuXG4gIHNlcmllcy5wdXNoKE9iamVjdC5hc3NpZ24oe1xuICAgIG5hbWU6ICfovoXliqknLFxuICAgIGl0ZW1TdHlsZToge1xuICAgICAgbm9ybWFsOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgIGVtcGhhc2lzOiB7IG9wYWNpdHk6IDAgfVxuICAgIH0sXG4gICAgZGF0YTogYXNzaXN0RGF0YVxuICB9LCBzZXJpZXNCYXNlKSk7XG5cbiAgc2VyaWVzLnB1c2goT2JqZWN0LmFzc2lnbih7XG4gICAgbmFtZTogJ+aVsOWAvCcsXG4gICAgbGFiZWw6IHtcbiAgICAgIG5vcm1hbDoge1xuICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Rm9ybWF0ZWQoaXRlbS52YWx1ZSwgZGF0YVR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiBtYWluRGF0YVxuICB9LCBzZXJpZXNCYXNlKSk7XG4gIHJldHVybiBzZXJpZXM7XG59XG5cbmZ1bmN0aW9uIGdldFdhdGVyZmFsbFJlbWFpblN0YXR1cyhkYXRhU3VtLCB0b3RhbE51bSkge1xuICBpZiAoIXRvdGFsTnVtKSByZXR1cm4gJ25vdC10b3RhbCc7XG4gIHJldHVybiB0b3RhbE51bSA+IGRhdGFTdW0gPyAnaGF2ZS1yZW1haW4nIDogJ25vbmUtcmVtYWluJztcbn1cblxudmFyIHdhdGVyZmFsbCA9IGZ1bmN0aW9uIHdhdGVyZmFsbChjb2x1bW5zLCByb3dzLCBzZXR0aW5ncywgZXh0cmEpIHtcbiAgdmFyIF9zZXR0aW5ncyRkYXRhVHlwZSA9IHNldHRpbmdzLmRhdGFUeXBlLFxuICAgICAgZGF0YVR5cGUgPSBfc2V0dGluZ3MkZGF0YVR5cGUgPT09IHVuZGVmaW5lZCA/ICdub3JtYWwnIDogX3NldHRpbmdzJGRhdGFUeXBlLFxuICAgICAgX3NldHRpbmdzJGRpbWVuc2lvbiA9IHNldHRpbmdzLmRpbWVuc2lvbixcbiAgICAgIGRpbWVuc2lvbiA9IF9zZXR0aW5ncyRkaW1lbnNpb24gPT09IHVuZGVmaW5lZCA/IGNvbHVtbnNbMF0gOiBfc2V0dGluZ3MkZGltZW5zaW9uLFxuICAgICAgX3NldHRpbmdzJHRvdGFsTmFtZSA9IHNldHRpbmdzLnRvdGFsTmFtZSxcbiAgICAgIHRvdGFsTmFtZSA9IF9zZXR0aW5ncyR0b3RhbE5hbWUgPT09IHVuZGVmaW5lZCA/ICfmgLvorqEnIDogX3NldHRpbmdzJHRvdGFsTmFtZSxcbiAgICAgIHRvdGFsTnVtID0gc2V0dGluZ3MudG90YWxOdW0sXG4gICAgICBfc2V0dGluZ3MkcmVtYWluTmFtZSA9IHNldHRpbmdzLnJlbWFpbk5hbWUsXG4gICAgICByZW1haW5OYW1lID0gX3NldHRpbmdzJHJlbWFpbk5hbWUgPT09IHVuZGVmaW5lZCA/ICflhbbku5YnIDogX3NldHRpbmdzJHJlbWFpbk5hbWUsXG4gICAgICBfc2V0dGluZ3MkeEF4aXNOYW1lID0gc2V0dGluZ3MueEF4aXNOYW1lLFxuICAgICAgeEF4aXNOYW1lID0gX3NldHRpbmdzJHhBeGlzTmFtZSA9PT0gdW5kZWZpbmVkID8gZGltZW5zaW9uIDogX3NldHRpbmdzJHhBeGlzTmFtZSxcbiAgICAgIF9zZXR0aW5ncyRheGlzVmlzaWJsZSA9IHNldHRpbmdzLmF4aXNWaXNpYmxlLFxuICAgICAgYXhpc1Zpc2libGUgPSBfc2V0dGluZ3MkYXhpc1Zpc2libGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfc2V0dGluZ3MkYXhpc1Zpc2libGU7XG4gIHZhciB0b29sdGlwVmlzaWJsZSA9IGV4dHJhLnRvb2x0aXBWaXNpYmxlO1xuXG4gIHZhciBtZXRyaWNzVGVtcCA9IGNvbHVtbnMuc2xpY2UoKTtcbiAgbWV0cmljc1RlbXAuc3BsaWNlKG1ldHJpY3NUZW1wLmluZGV4T2YoZGltZW5zaW9uKSwgMSk7XG4gIHZhciBtZXRyaWNzID0gbWV0cmljc1RlbXBbMF07XG4gIHZhciB5QXhpc05hbWUgPSBtZXRyaWNzO1xuICB2YXIgdG9vbHRpcCA9IHRvb2x0aXBWaXNpYmxlICYmIGdldFdhdGVyZmFsbFRvb2x0aXAoZGF0YVR5cGUpO1xuICB2YXIgZGF0YVN1bSA9IHJvd3MucmVkdWNlKGZ1bmN0aW9uIChwcmUsIGN1cikge1xuICAgIHJldHVybiBwcmUgKyBOdW1iZXIoY3VyW21ldHJpY3NdKTtcbiAgfSwgMCkudG9GaXhlZCgyKTtcbiAgdmFyIHJlbWFpblN0YXR1cyA9IGdldFdhdGVyZmFsbFJlbWFpblN0YXR1cyhkYXRhU3VtLCB0b3RhbE51bSk7XG4gIHZhciB4QXhpc1BhcmFtcyA9IHtcbiAgICBkaW1lbnNpb246IGRpbWVuc2lvbixcbiAgICByb3dzOiByb3dzLFxuICAgIHJlbWFpblN0YXR1czogcmVtYWluU3RhdHVzLFxuICAgIHRvdGFsTmFtZTogdG90YWxOYW1lLFxuICAgIHJlbWFpbk5hbWU6IHJlbWFpbk5hbWUsXG4gICAgeEF4aXNOYW1lOiB4QXhpc05hbWUsXG4gICAgYXhpc1Zpc2libGU6IGF4aXNWaXNpYmxlXG4gIH07XG4gIHZhciB4QXhpcyA9IGdldFdhdGVyZmFsbFhBeGlzKHhBeGlzUGFyYW1zKTtcbiAgdmFyIHlBeGlzID0gZ2V0V2F0ZXJmYWxsWUF4aXMoeyBkYXRhVHlwZTogZGF0YVR5cGUsIHlBeGlzTmFtZTogeUF4aXNOYW1lLCBheGlzVmlzaWJsZTogYXhpc1Zpc2libGUgfSk7XG4gIHZhciBzZXJpZXNQYXJhbXMgPSB7XG4gICAgZGF0YVR5cGU6IGRhdGFUeXBlLFxuICAgIHJvd3M6IHJvd3MsXG4gICAgZGltZW5zaW9uOiBkaW1lbnNpb24sXG4gICAgbWV0cmljczogbWV0cmljcyxcbiAgICB0b3RhbE51bTogdG90YWxOdW0sXG4gICAgcmVtYWluU3RhdHVzOiByZW1haW5TdGF0dXMsXG4gICAgZGF0YVN1bTogZGF0YVN1bVxuICB9O1xuICB2YXIgc2VyaWVzID0gZ2V0V2F0ZXJmYWxsU2VyaWVzKHNlcmllc1BhcmFtcyk7XG4gIHZhciBvcHRpb25zID0geyB0b29sdGlwOiB0b29sdGlwLCB4QXhpczogeEF4aXMsIHlBeGlzOiB5QXhpcywgc2VyaWVzOiBzZXJpZXMgfTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG52YXIgVmVXYXRlcmZhbGwgPSB7XG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdm0gPSB0aGlzO3ZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7cmV0dXJuIF9jKCdkaXYnLCB7IHJlZjogXCJjYW52YXNcIiwgc3RhdGljQ2xhc3M6IFwidmUtd2F0ZXJmYWxsXCIsIHN0eWxlOiBfdm0uY2FudmFzU3R5bGUgfSk7XG4gIH0sXG4gIHN0YXRpY1JlbmRlckZuczogW10sXG4gIG5hbWU6ICdWZVdhdGVyZmFsbCcsXG4gIG1peGluczogW2NoYXJ0TWl4aW5dLFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMuY2hhcnRIYW5kbGVyID0gd2F0ZXJmYWxsO1xuICAgIHRoaXMuZWNoYXJ0c0xpYiA9IGVjaGFydHM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldEZ1bm5lbFRvb2x0aXAoZGF0YVR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0cmlnZ2VyOiAnaXRlbScsXG4gICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIoaXRlbSkge1xuICAgICAgdmFyIHRwbCA9IFtdO1xuICAgICAgdHBsLnB1c2goaXRlbVBvaW50KGl0ZW0uY29sb3IpKTtcbiAgICAgIHRwbC5wdXNoKGl0ZW0ubmFtZSArICc6ICcgKyBnZXRGb3JtYXRlZChpdGVtLmRhdGEucmVhbFZhbHVlLCBkYXRhVHlwZSkpO1xuICAgICAgcmV0dXJuIHRwbC5qb2luKCcnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEZ1bm5lbFNlcmllcyhhcmdzKSB7XG4gIHZhciBkaW1lbnNpb24gPSBhcmdzLmRpbWVuc2lvbixcbiAgICAgIG1ldHJpY3MgPSBhcmdzLm1ldHJpY3MsXG4gICAgICByb3dzID0gYXJncy5yb3dzLFxuICAgICAgc2VxdWVuY2UgPSBhcmdzLnNlcXVlbmNlLFxuICAgICAgYXNjZW5kaW5nID0gYXJncy5hc2NlbmRpbmc7XG5cbiAgdmFyIHNlcmllcyA9IHsgdHlwZTogJ2Z1bm5lbCcgfTtcbiAgcm93cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIHNlcXVlbmNlLmluZGV4T2YoYVtkaW1lbnNpb25dKSAtIHNlcXVlbmNlLmluZGV4T2YoYltkaW1lbnNpb25dKTtcbiAgfSk7XG5cbiAgdmFyIGZhbHNlRnVubmVsID0gZmFsc2U7XG4gIHJvd3Muc29tZShmdW5jdGlvbiAocm93LCBpbmRleCkge1xuICAgIGlmIChpbmRleCAmJiByb3dbbWV0cmljc10gPiByb3dzW2luZGV4IC0gMV1bbWV0cmljc10pIHtcbiAgICAgIGZhbHNlRnVubmVsID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHN0ZXAgPSAxMDAgLyByb3dzLmxlbmd0aDtcblxuICBpZiAoZmFsc2VGdW5uZWwpIHtcbiAgICBzZXJpZXMuZGF0YSA9IHJvd3Muc2xpY2UoKS5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uIChyb3csIGluZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiByb3dbZGltZW5zaW9uXSxcbiAgICAgICAgdmFsdWU6IChpbmRleCArIDEpICogc3RlcCxcbiAgICAgICAgcmVhbFZhbHVlOiByb3dbbWV0cmljc11cbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc2VyaWVzLmRhdGEgPSByb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiByb3dbZGltZW5zaW9uXSxcbiAgICAgICAgdmFsdWU6IHJvd1ttZXRyaWNzXSxcbiAgICAgICAgcmVhbFZhbHVlOiByb3dbbWV0cmljc11cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBpZiAoYXNjZW5kaW5nKSBzZXJpZXMuc29ydCA9ICdhc2NlbmRpbmcnO1xuICByZXR1cm4gc2VyaWVzO1xufVxuXG52YXIgZnVubmVsID0gZnVuY3Rpb24gZnVubmVsKG91dGVyQ29sdW1ucywgb3V0ZXJSb3dzLCBzZXR0aW5ncywgZXh0cmEpIHtcbiAgdmFyIGNvbHVtbnMgPSBvdXRlckNvbHVtbnMuc2xpY2UoKTtcbiAgdmFyIHJvd3MgPSBvdXRlclJvd3Muc2xpY2UoKTtcbiAgdmFyIF9zZXR0aW5ncyRkYXRhVHlwZSA9IHNldHRpbmdzLmRhdGFUeXBlLFxuICAgICAgZGF0YVR5cGUgPSBfc2V0dGluZ3MkZGF0YVR5cGUgPT09IHVuZGVmaW5lZCA/ICdub3JtYWwnIDogX3NldHRpbmdzJGRhdGFUeXBlLFxuICAgICAgX3NldHRpbmdzJGRpbWVuc2lvbiA9IHNldHRpbmdzLmRpbWVuc2lvbixcbiAgICAgIGRpbWVuc2lvbiA9IF9zZXR0aW5ncyRkaW1lbnNpb24gPT09IHVuZGVmaW5lZCA/IGNvbHVtbnNbMF0gOiBfc2V0dGluZ3MkZGltZW5zaW9uLFxuICAgICAgX3NldHRpbmdzJHNlcXVlbmNlID0gc2V0dGluZ3Muc2VxdWVuY2UsXG4gICAgICBzZXF1ZW5jZSA9IF9zZXR0aW5ncyRzZXF1ZW5jZSA9PT0gdW5kZWZpbmVkID8gcm93cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgIHJldHVybiByb3dbZGltZW5zaW9uXTtcbiAgfSkgOiBfc2V0dGluZ3Mkc2VxdWVuY2UsXG4gICAgICBhc2NlbmRpbmcgPSBzZXR0aW5ncy5hc2NlbmRpbmc7XG4gIHZhciB0b29sdGlwVmlzaWJsZSA9IGV4dHJhLnRvb2x0aXBWaXNpYmxlLFxuICAgICAgbGVnZW5kVmlzaWJsZSA9IGV4dHJhLmxlZ2VuZFZpc2libGU7XG5cbiAgdmFyIG1ldHJpY3MgPSB2b2lkIDA7XG4gIGlmIChzZXR0aW5ncy5tZXRyaWNzKSB7XG4gICAgbWV0cmljcyA9IHNldHRpbmdzLm1ldHJpY3M7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1ldHJpY3NUZW1wID0gY29sdW1ucy5zbGljZSgpO1xuICAgIG1ldHJpY3NUZW1wLnNwbGljZShjb2x1bW5zLmluZGV4T2YoZGltZW5zaW9uKSwgMSk7XG4gICAgbWV0cmljcyA9IG1ldHJpY3NUZW1wWzBdO1xuICB9XG5cbiAgdmFyIHRvb2x0aXAgPSB0b29sdGlwVmlzaWJsZSAmJiBnZXRGdW5uZWxUb29sdGlwKGRhdGFUeXBlKTtcbiAgdmFyIGxlZ2VuZCA9IGxlZ2VuZFZpc2libGUgJiYgeyBkYXRhOiBzZXF1ZW5jZSB9O1xuICB2YXIgc2VyaWVzUGFyYW1zID0geyBkaW1lbnNpb246IGRpbWVuc2lvbiwgbWV0cmljczogbWV0cmljcywgcm93czogcm93cywgc2VxdWVuY2U6IHNlcXVlbmNlLCBhc2NlbmRpbmc6IGFzY2VuZGluZyB9O1xuICB2YXIgc2VyaWVzID0gZ2V0RnVubmVsU2VyaWVzKHNlcmllc1BhcmFtcyk7XG4gIHZhciBvcHRpb25zID0geyB0b29sdGlwOiB0b29sdGlwLCBsZWdlbmQ6IGxlZ2VuZCwgc2VyaWVzOiBzZXJpZXMgfTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG52YXIgVmVGdW5uZWwgPSB7XG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdm0gPSB0aGlzO3ZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7cmV0dXJuIF9jKCdkaXYnLCB7IHJlZjogXCJjYW52YXNcIiwgc3RhdGljQ2xhc3M6IFwidmUtZnVubmVsXCIsIHN0eWxlOiBfdm0uY2FudmFzU3R5bGUgfSk7XG4gIH0sXG4gIHN0YXRpY1JlbmRlckZuczogW10sXG4gIG5hbWU6ICdWZUZ1bm5lbCcsXG4gIG1peGluczogW2NoYXJ0TWl4aW5dLFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMuY2hhcnRIYW5kbGVyID0gZnVubmVsO1xuICAgIHRoaXMuZWNoYXJ0c0xpYiA9IGVjaGFydHM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFJhZGFyTGVnZW5kKHJvd3MsIGRpbWVuc2lvbikge1xuICB2YXIgbGVnZW5kRGF0YSA9IHJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICByZXR1cm4gcm93W2RpbWVuc2lvbl07XG4gIH0pO1xuXG4gIHJldHVybiB7IGRhdGE6IGxlZ2VuZERhdGEgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmFkYXJUb29sdGlwKGRhdGFUeXBlLCByYWRhcikge1xuICB2YXIgdHlwZVRlbXAgPSBbXTtcbiAgdmFyIG5hbWVUZW1wID0gW107XG4gIHJhZGFyLmluZGljYXRvci5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgdHlwZVRlbXBbaW5kZXhdID0gZGF0YVR5cGVbaXRlbS5uYW1lXTtcbiAgICBuYW1lVGVtcFtpbmRleF0gPSBpdGVtLm5hbWU7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKGl0ZW0pIHtcbiAgICAgIHZhciB0cGwgPSBbXTtcbiAgICAgIHRwbC5wdXNoKGl0ZW1Qb2ludChpdGVtLmNvbG9yKSk7XG4gICAgICB0cGwucHVzaChpdGVtLnNlcmllc05hbWUgKyAnPGJyIC8+Jyk7XG4gICAgICBpdGVtLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAodmFsLCBpbmRleCkge1xuICAgICAgICB0cGwucHVzaChuYW1lVGVtcFtpbmRleF0gKyAnOiAnKTtcbiAgICAgICAgdHBsLnB1c2goZ2V0Rm9ybWF0ZWQodmFsLCB0eXBlVGVtcFtpbmRleF0pICsgJzxiciAvPicpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHBsLmpvaW4oJycpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmFkYXJTZXR0aW5nKHJvd3MsIG1ldHJpY3MpIHtcbiAgdmFyIHNldHRpbmdCYXNlID0ge1xuICAgIGluZGljYXRvcjogW10sXG4gICAgc2hhcGU6ICdjaXJjbGUnLFxuICAgIHNwbGl0TnVtYmVyOiA1XG4gIH07XG4gIHZhciBpbmRpY2F0b3JUZW1wID0ge307XG4gIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICBtZXRyaWNzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlmICghaW5kaWNhdG9yVGVtcFtpdGVtXSkge1xuICAgICAgICBpbmRpY2F0b3JUZW1wW2l0ZW1dID0gW2l0ZW1zW2l0ZW1dXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGljYXRvclRlbXBbaXRlbV0ucHVzaChpdGVtc1tpdGVtXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBzZXR0aW5nQmFzZS5pbmRpY2F0b3IgPSBPYmplY3Qua2V5cyhpbmRpY2F0b3JUZW1wKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBrZXksXG4gICAgICBtYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIGluZGljYXRvclRlbXBba2V5XSlcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHNldHRpbmdCYXNlO1xufVxuXG5mdW5jdGlvbiBnZXRSYWRhclNlcmllcyhhcmdzKSB7XG4gIHZhciByb3dzID0gYXJncy5yb3dzLFxuICAgICAgZGltZW5zaW9uID0gYXJncy5kaW1lbnNpb24sXG4gICAgICBtZXRyaWNzID0gYXJncy5tZXRyaWNzLFxuICAgICAgcmFkYXIgPSBhcmdzLnJhZGFyO1xuXG4gIHZhciByYWRhckluZGV4T2JqID0ge307XG4gIHJhZGFyLmluZGljYXRvci5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHJhZGFySW5kZXhPYmpbaXRlbS5uYW1lXSA9IGluZGV4O1xuICB9KTtcblxuICB2YXIgc2VyaWVzID0gcm93cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgIHZhciBzZXJpZXNCYXNlID0ge1xuICAgICAgbmFtZTogcm93W2RpbWVuc2lvbl0sXG4gICAgICB0eXBlOiAncmFkYXInLFxuICAgICAgZGF0YTogW11cbiAgICB9O1xuICAgIHZhciBkYXRhQXJyID0gW107XG4gICAgT2JqZWN0LmtleXMocm93KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICh+bWV0cmljcy5pbmRleE9mKGtleSkpIGRhdGFBcnJbcmFkYXJJbmRleE9ialtrZXldXSA9IHJvd1trZXldO1xuICAgIH0pO1xuICAgIHNlcmllc0Jhc2UuZGF0YS5wdXNoKGRhdGFBcnIpO1xuICAgIHJldHVybiBzZXJpZXNCYXNlO1xuICB9KTtcbiAgcmV0dXJuIHNlcmllcztcbn1cblxudmFyIHJhZGFyID0gZnVuY3Rpb24gcmFkYXIoY29sdW1ucywgcm93cywgc2V0dGluZ3MsIGV4dHJhKSB7XG4gIHZhciBfc2V0dGluZ3MkZGF0YVR5cGUgPSBzZXR0aW5ncy5kYXRhVHlwZSxcbiAgICAgIGRhdGFUeXBlID0gX3NldHRpbmdzJGRhdGFUeXBlID09PSB1bmRlZmluZWQgPyB7fSA6IF9zZXR0aW5ncyRkYXRhVHlwZSxcbiAgICAgIF9zZXR0aW5ncyRkaW1lbnNpb24gPSBzZXR0aW5ncy5kaW1lbnNpb24sXG4gICAgICBkaW1lbnNpb24gPSBfc2V0dGluZ3MkZGltZW5zaW9uID09PSB1bmRlZmluZWQgPyBjb2x1bW5zWzBdIDogX3NldHRpbmdzJGRpbWVuc2lvbjtcbiAgdmFyIHRvb2x0aXBWaXNpYmxlID0gZXh0cmEudG9vbHRpcFZpc2libGUsXG4gICAgICBsZWdlbmRWaXNpYmxlID0gZXh0cmEubGVnZW5kVmlzaWJsZTtcblxuICB2YXIgbWV0cmljcyA9IGNvbHVtbnMuc2xpY2UoKTtcbiAgaWYgKHNldHRpbmdzLm1ldHJpY3MpIHtcbiAgICBtZXRyaWNzID0gc2V0dGluZ3MubWV0cmljcztcbiAgfSBlbHNlIHtcbiAgICBtZXRyaWNzLnNwbGljZShjb2x1bW5zLmluZGV4T2YoZGltZW5zaW9uKSwgMSk7XG4gIH1cbiAgdmFyIGxlZ2VuZCA9IGxlZ2VuZFZpc2libGUgJiYgZ2V0UmFkYXJMZWdlbmQocm93cywgZGltZW5zaW9uKTtcbiAgdmFyIHJhZGFyID0gZ2V0UmFkYXJTZXR0aW5nKHJvd3MsIG1ldHJpY3MpO1xuICB2YXIgdG9vbHRpcCA9IHRvb2x0aXBWaXNpYmxlICYmIGdldFJhZGFyVG9vbHRpcChkYXRhVHlwZSwgcmFkYXIpO1xuICB2YXIgc2VyaWVzID0gZ2V0UmFkYXJTZXJpZXMoeyByb3dzOiByb3dzLCBkaW1lbnNpb246IGRpbWVuc2lvbiwgbWV0cmljczogbWV0cmljcywgcmFkYXI6IHJhZGFyIH0pO1xuICB2YXIgb3B0aW9ucyA9IHsgbGVnZW5kOiBsZWdlbmQsIHRvb2x0aXA6IHRvb2x0aXAsIHJhZGFyOiByYWRhciwgc2VyaWVzOiBzZXJpZXMgfTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG52YXIgVmVSYWRhciA9IHtcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF92bSA9IHRoaXM7dmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaDtyZXR1cm4gX2MoJ2RpdicsIHsgcmVmOiBcImNhbnZhc1wiLCBzdGF0aWNDbGFzczogXCJ2ZS1yYWRhclwiLCBzdHlsZTogX3ZtLmNhbnZhc1N0eWxlIH0pO1xuICB9LFxuICBzdGF0aWNSZW5kZXJGbnM6IFtdLFxuICBuYW1lOiAnVmVSYWRhcicsXG4gIG1peGluczogW2NoYXJ0TWl4aW5dLFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMuY2hhcnRIYW5kbGVyID0gcmFkYXI7XG4gICAgdGhpcy5lY2hhcnRzTGliID0gZWNoYXJ0cztcbiAgfVxufTtcblxudmFyIFZlQ2hhcnQgPSB7XG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdm0gPSB0aGlzO3ZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7cmV0dXJuIF9jKCdkaXYnLCB7IHJlZjogXCJjYW52YXNcIiwgc3RhdGljQ2xhc3M6IFwidmUtY2hhcnRcIiwgc3R5bGU6IF92bS5jYW52YXNTdHlsZSB9KTtcbiAgfSxcbiAgc3RhdGljUmVuZGVyRm5zOiBbXSxcbiAgbmFtZTogJ1ZlQ2hhcnQnLFxuICBtaXhpbnM6IFtjaGFydE1peGluXSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB0aGlzLmNoYXJ0TGliID0ge1xuICAgICAgYmFyOiBiYXIsXG4gICAgICBoaXN0b2dyYW06IGhpc3RvZ3JhbSxcbiAgICAgIGxpbmU6IGxpbmUsXG4gICAgICBwaWU6IHBpZSxcbiAgICAgIHJpbmc6IHJpbmcsXG4gICAgICBmdW5uZWw6IGZ1bm5lbCxcbiAgICAgIHJhZGFyOiByYWRhcixcbiAgICAgIHdhdGVyZmFsbDogd2F0ZXJmYWxsXG4gICAgfTtcbiAgICB0aGlzLmNoYXJ0SGFuZGxlciA9IHRoaXMuY2hhcnRMaWJbdGhpcy5zZXR0aW5ncy50eXBlXTtcbiAgICB0aGlzLmVjaGFydHNMaWIgPSBlY2hhcnRzO1xuICB9XG59O1xuXG52YXIgY29tcG9uZW50cyA9IFtWZUJhciwgVmVIaXN0b2dyYW0sIFZlTGluZSwgVmVQaWUsIFZlUmluZywgVmVXYXRlcmZhbGwsIFZlRnVubmVsLCBWZVJhZGFyLCBWZUNoYXJ0XTtcblxuZnVuY3Rpb24gaW5zdGFsbChWdWUsIF8pIHtcbiAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICBWdWUuY29tcG9uZW50KGNvbXBvbmVudC5uYW1lLCBjb21wb25lbnQpO1xuICB9KTtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgaW5zdGFsbCh3aW5kb3cuVnVlKTtcbn1cblxudmFyIGluZGV4ID0ge1xuICBWZUJhcjogVmVCYXIsXG4gIFZlSGlzdG9ncmFtOiBWZUhpc3RvZ3JhbSxcbiAgVmVSaW5nOiBWZVJpbmcsXG4gIFZlTGluZTogVmVMaW5lLFxuICBWZVBpZTogVmVQaWUsXG4gIFZlV2F0ZXJmYWxsOiBWZVdhdGVyZmFsbCxcbiAgVmVGdW5uZWw6IFZlRnVubmVsLFxuICBWZVJhZGFyOiBWZVJhZGFyLFxuICBWZUNoYXJ0OiBWZUNoYXJ0LFxuICBpbnN0YWxsOiBpbnN0YWxsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluZGV4O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3YtY2hhcnRzL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {// Enable DEV mode when using source code without build. which has no __DEV__ variable\n// In build process 'typeof __DEV__' will be replace with 'boolean'\n// So this code will be removed or disabled anyway after built.\nif (typeof __DEV__ === 'undefined') {\n    // In browser\n    if (typeof window !== 'undefined') {\n        window.__DEV__ = true;\n    }\n    // In node\n    else if (typeof global !== 'undefined') {\n        global.__DEV__ = true;\n    }\n}\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\n/**\n * @module echarts\n */\n\n\n    var env = __webpack_require__(18);\n\n    var GlobalModel = __webpack_require__(19);\n    var ExtensionAPI = __webpack_require__(91);\n    var CoordinateSystemManager = __webpack_require__(92);\n    var OptionManager = __webpack_require__(93);\n\n    var ComponentModel = __webpack_require__(85);\n    var SeriesModel = __webpack_require__(94);\n\n    var ComponentView = __webpack_require__(95);\n    var ChartView = __webpack_require__(96);\n    var graphic = __webpack_require__(34);\n    var modelUtil = __webpack_require__(21);\n    var throttle = __webpack_require__(97);\n\n    var zrender = __webpack_require__(98);\n    var zrUtil = __webpack_require__(20);\n    var colorTool = __webpack_require__(47);\n    var Eventful = __webpack_require__(41);\n    var timsort = __webpack_require__(102);\n\n    var each = zrUtil.each;\n    var parseClassType = ComponentModel.parseClassType;\n\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\n\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    // FIXME\n    // necessary?\n    var PRIORITY_VISUAL_BRUSH = 5000;\n\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flagInMainProcess';\n    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\n    var OPTION_UPDATED = '__optionUpdated';\n    var ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts(dom, theme, opts) {\n        opts = opts || {};\n\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        var zr = this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height\n        });\n\n        /**\n         * Expect 60 pfs.\n         * @type {Function}\n         * @private\n         */\n        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = createExtensionAPI(this);\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n\n        // Init mouse events\n        this._initEvents();\n\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n\n        zr.animation.on('frame', this._onframe, this);\n\n        // ECharts instance can be used as value.\n        zrUtil.setAsPrimitive(this);\n    }\n\n    var echartsProto = ECharts.prototype;\n\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            var silent = this[OPTION_UPDATED].silent;\n\n            this[IN_MAIN_PROCESS] = true;\n\n            updateMethods.prepareAndUpdate.call(this);\n\n            this[IN_MAIN_PROCESS] = false;\n\n            this[OPTION_UPDATED] = false;\n\n            flushPendingActions.call(this, silent);\n\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n\n    /**\n     * Usage:\n     * chart.setOption(option, notMerge, lazyUpdate);\n     * chart.setOption(option, {\n     *     notMerge: ...,\n     *     lazyUpdate: ...,\n     *     silent: ...\n     * });\n     *\n     * @param {Object} option\n     * @param {Object|boolean} [opts] opts or notMerge.\n     * @param {boolean} [opts.notMerge=false]\n     * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n\n        var silent;\n        if (zrUtil.isObject(notMerge)) {\n            lazyUpdate = notMerge.lazyUpdate;\n            silent = notMerge.silent;\n            notMerge = notMerge.notMerge;\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n\n        this._model.setOption(option, optionPreprocessorFuncs);\n\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = {silent: silent};\n            this[IN_MAIN_PROCESS] = false;\n        }\n        else {\n            updateMethods.prepareAndUpdate.call(this);\n            // Ensure zr refresh sychronously, and then pixel in canvas can be\n            // fetched after `setOption`.\n            this._zr.flush();\n\n            this[OPTION_UPDATED] = false;\n            this[IN_MAIN_PROCESS] = false;\n\n            flushPendingActions.call(this, silent);\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getDevicePixelRatio = function () {\n        return this._zr.painter.dpr || window.devicePixelRatio || 1;\n    };\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     * @param {string} [opts.excludeComponents]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({\n                mainType: componentType\n            }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n\n        var url = this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n\n\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = (opts && opts.pixelRatio) || 1;\n\n            zrUtil.each(instances, function (chart, id) {\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(\n                        zrUtil.clone(opts)\n                    );\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            });\n\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                    style: {\n                        x: item.left * dpr - left,\n                        y: item.top * dpr - top,\n                        image: item.dom\n                    }\n                });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        }\n        else {\n            return this.getDataURL(opts);\n        }\n    };\n\n    /**\n     * Convert from logical coordinate system to pixel coordinate system.\n     * See CoordinateSystem#convertToPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId, geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\n    /**\n     * Convert from pixel coordinate system to logical coordinate system.\n     * See CoordinateSystem#convertFromPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\n    function doConvertPixel(methodName, finder, value) {\n        var ecModel = this._model;\n        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n            if (coordSys[methodName]\n                && (result = coordSys[methodName](ecModel, finder, value)) != null\n            ) {\n                return result;\n            }\n        }\n\n        if (__DEV__) {\n            console.warn(\n                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n            );\n        }\n    }\n\n    /**\n     * Is the specified coordinate systems or components contain the given pixel point.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {boolean} result\n     */\n    echartsProto.containPixel = function (finder, value) {\n        var ecModel = this._model;\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        zrUtil.each(finder, function (models, key) {\n            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n                var coordSys = model.coordinateSystem;\n                if (coordSys && coordSys.containPoint) {\n                    result |= !!coordSys.containPoint(value);\n                }\n                else if (key === 'seriesModels') {\n                    var view = this._chartsMap[model.__viewId];\n                    if (view && view.containPoint) {\n                        result |= view.containPoint(value, model);\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.warn(key + ': ' + (view\n                                ? 'The found component do not support containPoint.'\n                                : 'No view mapping to the found component.'\n                            ));\n                        }\n                    }\n                }\n                else {\n                    if (__DEV__) {\n                        console.warn(key + ': containPoint is not supported');\n                    }\n                }\n            }, this);\n        }, this);\n\n        return !!result;\n    };\n\n    /**\n     * Get visual from series or data.\n     * @param {string|Object} finder\n     *        If string, e.g., 'series', means {seriesIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            dataIndex / dataIndexInside\n     *        }\n     *        If dataIndex is not specified, series visual will be fetched,\n     *        but not data item visual.\n     *        If all of seriesIndex, seriesId, seriesName are not specified,\n     *        visual will be fetched from first series.\n     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n     */\n    echartsProto.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n\n        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n        var seriesModel = finder.seriesModel;\n\n        if (__DEV__) {\n            if (!seriesModel) {\n                console.warn('There is no specified seires model');\n            }\n        }\n\n        var data = seriesModel.getData();\n\n        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n            ? finder.dataIndexInside\n            : finder.hasOwnProperty('dataIndex')\n            ? data.indexOfRawIndex(finder.dataIndex)\n            : null;\n\n        return dataIndexInside != null\n            ? data.getItemVisual(dataIndexInside, visualType)\n            : data.getVisual(visualType);\n    };\n\n    /**\n     * Get view of corresponding component model\n     * @param  {module:echarts/model/Component} componentModel\n     * @return {module:echarts/view/Component}\n     */\n    echartsProto.getViewOfComponentModel = function (componentModel) {\n        return this._componentsMap[componentModel.__viewId];\n    };\n\n    /**\n     * Get view of corresponding series model\n     * @param  {module:echarts/model/Series} seriesModel\n     * @return {module:echarts/view/Chart}\n     */\n    echartsProto.getViewOfSeriesModel = function (seriesModel) {\n        return this._chartsMap[seriesModel.__viewId];\n    };\n\n\n    var updateMethods = {\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        update: function (payload) {\n            // console.profile && console.profile('update');\n\n            var ecModel = this._model;\n            var api = this._api;\n            var coordSysMgr = this._coordSysMgr;\n            var zr = this._zr;\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            // Fixme First time update ?\n            ecModel.restoreData();\n\n            // TODO\n            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n            // Create new coordinate system each update\n            // In LineView may save the old coordinate system and use it to get the orignal point\n            coordSysMgr.create(this._model, this._api);\n\n            processData.call(this, ecModel, api);\n\n            stackSeriesData.call(this, ecModel);\n\n            coordSysMgr.update(ecModel, api);\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            doRender.call(this, ecModel, payload);\n\n            // Set background\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n            var painter = zr.painter;\n            // TODO all use clearColor ?\n            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n            }\n            else {\n                // In IE8\n                if (!env.canvasSupported) {\n                    var colorArr = colorTool.parse(backgroundColor);\n                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                    if (colorArr[3] === 0) {\n                        backgroundColor = 'transparent';\n                    }\n                }\n                if (backgroundColor.colorStops || backgroundColor.image) {\n                    // Gradient background\n                    // FIXME Fixed layer？\n                    zr.configLayer(0, {\n                        clearColor: backgroundColor\n                    });\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                    this._dom.style.background = 'transparent';\n                }\n                else {\n                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                        zr.configLayer(0, {\n                            clearColor: null\n                        });\n                    }\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                    this._dom.style.background = backgroundColor;\n                }\n            }\n\n            each(postUpdateFuncs, function (func) {\n                func(ecModel, api);\n            });\n\n            // console.profile && console.profileEnd('update');\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateView: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateVisual: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload, true);\n\n            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateLayout: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            doLayout.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        prepareAndUpdate: function (payload) {\n            var ecModel = this._model;\n\n            prepareView.call(this, 'component', ecModel);\n\n            prepareView.call(this, 'chart', ecModel);\n\n            updateMethods.update.call(this, payload);\n        }\n    };\n\n    /**\n     * @private\n     */\n    function updateDirectly(ecIns, method, payload, mainType, subType) {\n        var ecModel = ecIns._model;\n\n        // broadcast\n        if (!mainType) {\n            each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);\n            return;\n        }\n\n        var query = {};\n        query[mainType + 'Id'] = payload[mainType + 'Id'];\n        query[mainType + 'Index'] = payload[mainType + 'Index'];\n        query[mainType + 'Name'] = payload[mainType + 'Name'];\n\n        var condition = {mainType: mainType, query: query};\n        subType && (condition.subType = subType); // subType may be '' by parseClassType;\n\n        // If dispatchAction before setOption, do nothing.\n        ecModel && ecModel.eachComponent(condition, function (model, index) {\n            callView(ecIns[\n                mainType === 'series' ? '_chartsMap' : '_componentsMap'\n            ][model.__viewId]);\n        }, ecIns);\n\n        function callView(view) {\n            view && view.__alive && view[method] && view[method](\n                view.__model, ecModel, ecIns._api, payload\n            );\n        }\n    }\n\n    /**\n     * Resize the chart\n     * @param {Object} opts\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @param {boolean} [opts.silent=false]\n     */\n    echartsProto.resize = function (opts) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        this._zr.resize(opts);\n\n        var optionChanged = this._model && this._model.resetOption('media');\n        var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n\n        updateMethods[updateMethod].call(this);\n\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n\n        this[IN_MAIN_PROCESS] = false;\n\n        var silent = opts && opts.silent;\n\n        flushPendingActions.call(this, silent);\n\n        triggerUpdatedEvent.call(this, silent);\n    };\n\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (__DEV__) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n\n        zr.add(el);\n    };\n\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n     * @param {boolean} [opt.silent=false] Whether trigger events.\n     * @param {boolean} [opt.flush=undefined]\n     *                  true: Flush immediately, and then pixel in canvas can be fetched\n     *                      immediately. Caution: it might affect performance.\n     *                  false: Not not flush.\n     *                  undefined: Auto decide whether perform flush.\n     */\n    echartsProto.dispatchAction = function (payload, opt) {\n        if (!zrUtil.isObject(opt)) {\n            opt = {silent: !!opt};\n        }\n\n        if (!actions[payload.type]) {\n            return;\n        }\n\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n\n        doDispatchAction.call(this, payload, opt.silent);\n\n        if (opt.flush) {\n            this._zr.flush(true);\n        }\n        else if (opt.flush !== false && env.browser.weChat) {\n            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n            // hang when sliding page (on touch event), which cause that zr does not\n            // refresh util user interaction finished, which is not expected.\n            // But `dispatchAction` may be called too frequently when pan on touch\n            // screen, which impacts performance if do not throttle them.\n            this._throttledZrFlush();\n        }\n\n        flushPendingActions.call(this, opt.silent);\n\n        triggerUpdatedEvent.call(this, opt.silent);\n    };\n\n    function doDispatchAction(payload, silent) {\n        var payloadType = payload.type;\n        var escapeConnect = payload.escapeConnect;\n        var actionWrap = actions[payloadType];\n        var actionInfo = actionWrap.actionInfo;\n\n        var cptType = (actionInfo.update || 'update').split(':');\n        var updateMethod = cptType.pop();\n        cptType = cptType[0] != null && parseClassType(cptType[0]);\n\n        this[IN_MAIN_PROCESS] = true;\n\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n\n        each(payloads, function (batchItem) {\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model, this._api);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            // light update does not perform data process, layout and visual.\n            if (isHighDown) {\n                // method, payload, mainType, subType\n                updateDirectly(this, updateMethod, batchItem, 'series');\n            }\n            else if (cptType) {\n                updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n            }\n        }, this);\n\n        if (updateMethod !== 'none' && !isHighDown && !cptType) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            }\n            else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payloadType,\n                escapeConnect: escapeConnect,\n                batch: eventObjBatch\n            };\n        }\n        else {\n            eventObj = eventObjBatch[0];\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n    }\n\n    function flushPendingActions(silent) {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            doDispatchAction.call(this, payload, silent);\n        }\n    }\n\n    function triggerUpdatedEvent(silent) {\n        !silent && this.trigger('updated');\n    }\n\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, component);\n        }, this);\n\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n\n            updateZ(seriesModel, chart);\n\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Post render\n        each(postUpdateFuncs, function (func) {\n            func(ecModel, api);\n        });\n    }\n\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            }\n            else {\n                model = componentType;\n            }\n\n            // Consider: id same and type changed.\n            var viewId = '_ec_' + model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = parseClassType(model.type);\n                var Clazz = isComponent\n                    ? ComponentView.getClass(classType.main, classType.sub)\n                    : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                }\n                else {\n                    // Error\n                    return;\n                }\n            }\n\n            model.__viewId = view.__id = viewId;\n            view.__alive = true;\n            view.__model = model;\n            view.group.__ecComponentInfo = {\n                mainType: model.mainType,\n                index: model.componentIndex\n            };\n        }, this);\n\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n                view.__id = view.group.__ecComponentInfo = null;\n            }\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                // Avoid conflict with Object.prototype\n                if (stackedDataMap.hasOwnProperty(stack) && previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @param {object} layout\n     * @param {boolean} [excludesLayout]\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload, excludesLayout) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            (!excludesLayout || !visual.isLayout)\n                && visual.func(ecModel, api, payload);\n        });\n    }\n\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, componentView);\n        }, this);\n\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n\n            chartView.group.silent = !!seriesModel.get('silent');\n\n            updateZ(seriesModel, chartView);\n\n            updateProgressiveAndBlend(seriesModel, chartView);\n\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n\n    var MOUSE_EVENT_NAMES = [\n        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n    ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                var params;\n\n                // no e.target when 'globalout'.\n                if (eveName === 'globalout') {\n                    params = {};\n                }\n                else if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                }\n                // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    params = zrUtil.extend({}, el.eventData);\n                }\n\n                if (params) {\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }\n\n            }, this);\n        }, this);\n\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (__DEV__) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n\n        var api = this._api;\n        var ecModel = this._model;\n\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n\n        // Dispose after all views disposed\n        this._zr.dispose();\n\n        delete instances[this.id];\n    };\n\n    zrUtil.mixin(ECharts, Eventful);\n\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ?\n                        Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (__DEV__) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n\n    function createExtensionAPI(ecInstance) {\n        var coordSysMgr = ecInstance._coordSysMgr;\n        return zrUtil.extend(new ExtensionAPI(ecInstance), {\n            // Inject methods\n            getCoordinateSystems: zrUtil.bind(\n                coordSysMgr.getCoordinateSystems, coordSysMgr\n            ),\n            getComponentByElement: function (el) {\n                while (el) {\n                    var modelInfo = el.__ecComponentInfo;\n                    if (modelInfo != null) {\n                        return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);\n                    }\n                    el = el.parent;\n                }\n            }\n        });\n    }\n\n    /**\n     * @type {Object} key: actionType.\n     * @inner\n     */\n    var actions = {};\n\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var postUpdateFuncs = [];\n\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n\n\n    var instances = {};\n    var connectedGroups = {};\n\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n        /**\n         * @type {number}\n         */\n        version: '3.6.2',\n        dependencies: {\n            zrender: '3.5.2'\n        }\n    };\n\n    function enableConnect(chart) {\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    if (event && event.escapeConnect) {\n                        return;\n                    }\n\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n\n                    zrUtil.each(instances, function (otherChart) {\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    });\n\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n    }\n\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n     *                              Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n     *                               Can be 'auto' (the same as null/undefined)\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (__DEV__) {\n            // Check version\n            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n                throw new Error(\n                    'ZRender ' + zrender.version\n                    + ' is too old for ECharts ' + echarts.version\n                    + '. Current version need ZRender '\n                    + echarts.dependencies.zrender + '+'\n                );\n            }\n\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n        }\n\n        var existInstance = echarts.getInstanceByDom(dom);\n        if (existInstance) {\n            if (__DEV__) {\n                console.warn('There is a chart instance already initialized on the dom.');\n            }\n            return existInstance;\n        }\n\n        if (__DEV__) {\n            if (zrUtil.isDom(dom)\n                && dom.nodeName.toUpperCase() !== 'CANVAS'\n                && (\n                    (!dom.clientWidth && (!opts || opts.width == null))\n                    || (!dom.clientHeight && (!opts || opts.height == null))\n                )\n            ) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n\n        if (dom.setAttribute) {\n            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n        }\n        else {\n            dom[DOM_ATTRIBUTE_KEY] = chart.id;\n        }\n\n        enableConnect(chart);\n\n        return chart;\n    };\n\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || ('g_' + groupIdBase++);\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n\n    /**\n     * @DEPRECATED\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n\n    /**\n     * @return {string} groupId\n     */\n    echarts.disconnect = echarts.disConnect;\n\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        else if (!(chart instanceof ECharts)){\n            // Try to treat as dom\n            chart = echarts.getInstanceByDom(chart);\n        }\n        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key;\n        if (dom.getAttribute) {\n            key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        }\n        else {\n            key = dom[DOM_ATTRIBUTE_KEY];\n        }\n        return instances[key];\n    };\n\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n\n    /**\n     * Register postUpdater\n     * @param {Function} postUpdateFunc\n     */\n    echarts.registerPostUpdate = function (postUpdateFunc) {\n        postUpdateFuncs.push(postUpdateFunc);\n    };\n\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo)\n            ? actionInfo.type\n            : ([actionInfo, actionInfo = {\n                event: eventName\n            }][0]);\n\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n\n        // Validate action type and event name.\n        zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n        if (!actions[actionType]) {\n            actions[actionType] = {action: action, actionInfo: actionInfo};\n        }\n        eventActionMap[eventName] = actionType;\n    };\n\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n\n    /**\n     * Get dimensions of specified coordinate system.\n     * @param {string} type\n     * @return {Array.<string|Object>}\n     */\n    echarts.getCoordinateSystemDimensions = function (type) {\n        var coordSysCreator = CoordinateSystemManager.get(type);\n        if (coordSysCreator) {\n            return coordSysCreator.getDimensionsInfo\n                    ? coordSysCreator.getDimensionsInfo()\n                    : coordSysCreator.dimensions.slice();\n        }\n    };\n\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts/*, superClass*/) {\n        // var Clazz = ComponentModel;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts/*, superClass*/) {\n        // var Clazz = ComponentView;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentView.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts/*, superClass*/) {\n        // var Clazz = SeriesModel;\n        // if (superClass) {\n        //     superClass = 'series.' + superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return SeriesModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts/*, superClass*/) {\n        // var Clazz = ChartView;\n        // if (superClass) {\n        //     superClass = superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ChartView.getClass(classType.main, true);\n        // }\n        return ChartView.extend(opts);\n    };\n\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, __webpack_require__(110));\n    echarts.registerPreprocessor(__webpack_require__(111));\n    echarts.registerLoading('default', __webpack_require__(113));\n\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n\n\n    // --------\n    // Exports\n    // --------\n    echarts.zrender = zrender;\n\n    echarts.List = __webpack_require__(114);\n    echarts.Model = __webpack_require__(28);\n\n    echarts.Axis = __webpack_require__(116);\n\n    echarts.graphic = __webpack_require__(34);\n    echarts.number = __webpack_require__(23);\n    echarts.format = __webpack_require__(22);\n    echarts.throttle = throttle.throttle;\n    echarts.matrix = __webpack_require__(27);\n    echarts.vector = __webpack_require__(26);\n    echarts.color = __webpack_require__(47);\n\n    echarts.util = {};\n    each([\n            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n            'extend', 'defaults', 'clone', 'merge'\n        ],\n        function (name) {\n            echarts.util[name] = zrUtil[name];\n        }\n    );\n\n    echarts.helper = __webpack_require__(124);\n\n\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n\n    module.exports = echarts;\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2VjaGFydHMuanM/NjhhMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBLGdCQUFnQjtBQUNoQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3Qiw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3Qiw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZ0RBQWdELGVBQWU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQsMEJBQTBCOztBQUVuRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QixpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0MsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwyREFBMkQ7QUFDMUUsZUFBZSx3REFBd0Q7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSwyREFBMkQ7QUFDMUUsZUFBZSx3REFBd0Q7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isc0NBQXNDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQiw2Q0FBNkM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThELE1BQU07QUFDcEUsaURBQWlELE1BQU07QUFDdkQ7QUFDQSxZQUFZLDZEQUE2RDtBQUN6RSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbmFibGUgREVWIG1vZGUgd2hlbiB1c2luZyBzb3VyY2UgY29kZSB3aXRob3V0IGJ1aWxkLiB3aGljaCBoYXMgbm8gX19ERVZfXyB2YXJpYWJsZVxuLy8gSW4gYnVpbGQgcHJvY2VzcyAndHlwZW9mIF9fREVWX18nIHdpbGwgYmUgcmVwbGFjZSB3aXRoICdib29sZWFuJ1xuLy8gU28gdGhpcyBjb2RlIHdpbGwgYmUgcmVtb3ZlZCBvciBkaXNhYmxlZCBhbnl3YXkgYWZ0ZXIgYnVpbHQuXG5pZiAodHlwZW9mIF9fREVWX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gSW4gYnJvd3NlclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3aW5kb3cuX19ERVZfXyA9IHRydWU7XG4gICAgfVxuICAgIC8vIEluIG5vZGVcbiAgICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBnbG9iYWwuX19ERVZfXyA9IHRydWU7XG4gICAgfVxufVxuXG4vKiFcbiAqIEVDaGFydHMsIGEgamF2YXNjcmlwdCBpbnRlcmFjdGl2ZSBjaGFydCBsaWJyYXJ5LlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgQmFpZHUgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZWNvbWZlL2VjaGFydHMvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcbiAqL1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0c1xuICovXG5cblxuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2VudicpO1xuXG4gICAgdmFyIEdsb2JhbE1vZGVsID0gcmVxdWlyZSgnLi9tb2RlbC9HbG9iYWwnKTtcbiAgICB2YXIgRXh0ZW5zaW9uQVBJID0gcmVxdWlyZSgnLi9FeHRlbnNpb25BUEknKTtcbiAgICB2YXIgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIgPSByZXF1aXJlKCcuL0Nvb3JkaW5hdGVTeXN0ZW0nKTtcbiAgICB2YXIgT3B0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vbW9kZWwvT3B0aW9uTWFuYWdlcicpO1xuXG4gICAgdmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZSgnLi9tb2RlbC9Db21wb25lbnQnKTtcbiAgICB2YXIgU2VyaWVzTW9kZWwgPSByZXF1aXJlKCcuL21vZGVsL1NlcmllcycpO1xuXG4gICAgdmFyIENvbXBvbmVudFZpZXcgPSByZXF1aXJlKCcuL3ZpZXcvQ29tcG9uZW50Jyk7XG4gICAgdmFyIENoYXJ0VmlldyA9IHJlcXVpcmUoJy4vdmlldy9DaGFydCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIHRocm90dGxlID0gcmVxdWlyZSgnLi91dGlsL3Rocm90dGxlJyk7XG5cbiAgICB2YXIgenJlbmRlciA9IHJlcXVpcmUoJ3pyZW5kZXInKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGNvbG9yVG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvY29sb3InKTtcbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bCcpO1xuICAgIHZhciB0aW1zb3J0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS90aW1zb3J0Jyk7XG5cbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciBwYXJzZUNsYXNzVHlwZSA9IENvbXBvbmVudE1vZGVsLnBhcnNlQ2xhc3NUeXBlO1xuXG4gICAgdmFyIFBSSU9SSVRZX1BST0NFU1NPUl9GSUxURVIgPSAxMDAwO1xuICAgIHZhciBQUklPUklUWV9QUk9DRVNTT1JfU1RBVElTVElDID0gNTAwMDtcblxuXG4gICAgdmFyIFBSSU9SSVRZX1ZJU1VBTF9MQVlPVVQgPSAxMDAwO1xuICAgIHZhciBQUklPUklUWV9WSVNVQUxfR0xPQkFMID0gMjAwMDtcbiAgICB2YXIgUFJJT1JJVFlfVklTVUFMX0NIQVJUID0gMzAwMDtcbiAgICB2YXIgUFJJT1JJVFlfVklTVUFMX0NPTVBPTkVOVCA9IDQwMDA7XG4gICAgLy8gRklYTUVcbiAgICAvLyBuZWNlc3Nhcnk/XG4gICAgdmFyIFBSSU9SSVRZX1ZJU1VBTF9CUlVTSCA9IDUwMDA7XG5cbiAgICAvLyBNYWluIHByb2Nlc3MgaGF2ZSB0aHJlZSBlbnRyaWVzOiBgc2V0T3B0aW9uYCwgYGRpc3BhdGNoQWN0aW9uYCBhbmQgYHJlc2l6ZWAsXG4gICAgLy8gd2hlcmUgdGhleSBtdXN0IG5vdCBiZSBpbnZva2VkIG5lc3RlZGx5LCBleGNlcHQgdGhlIG9ubHkgY2FzZTogaW52b2tlXG4gICAgLy8gZGlzcGF0Y2hBY3Rpb24gd2l0aCB1cGRhdGVNZXRob2QgXCJub25lXCIgaW4gbWFpbiBwcm9jZXNzLlxuICAgIC8vIFRoaXMgZmxhZyBpcyB1c2VkIHRvIGNhcnJ5IG91dCB0aGlzIHJ1bGUuXG4gICAgLy8gQWxsIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZCBvdXQgc2lkZSBtYWluIHByb2Nlc3MgKGkuZS4gd2hlbiAhdGhpc1tJTl9NQUlOX1BST0NFU1NdKS5cbiAgICB2YXIgSU5fTUFJTl9QUk9DRVNTID0gJ19fZmxhZ0luTWFpblByb2Nlc3MnO1xuICAgIHZhciBIQVNfR1JBRElFTlRfT1JfUEFUVEVSTl9CRyA9ICdfX2hhc0dyYWRpZW50T3JQYXR0ZXJuQmcnO1xuICAgIHZhciBPUFRJT05fVVBEQVRFRCA9ICdfX29wdGlvblVwZGF0ZWQnO1xuICAgIHZhciBBQ1RJT05fUkVHID0gL15bYS16QS1aMC05X10rJC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBFdmVudCBuYW1lIGlzIGFsbCBsb3dlcmNhc2VcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZSAmJiBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIEV2ZW50ZnVsLnByb3RvdHlwZVttZXRob2RdLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyLCBjb250ZXh0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIGVjaGFydHN+TWVzc2FnZUNlbnRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VDZW50ZXIoKSB7XG4gICAgICAgIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIE1lc3NhZ2VDZW50ZXIucHJvdG90eXBlLm9uID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvbicpO1xuICAgIE1lc3NhZ2VDZW50ZXIucHJvdG90eXBlLm9mZiA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb2ZmJyk7XG4gICAgTWVzc2FnZUNlbnRlci5wcm90b3R5cGUub25lID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvbmUnKTtcbiAgICB6clV0aWwubWl4aW4oTWVzc2FnZUNlbnRlciwgRXZlbnRmdWwpO1xuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBlY2hhcnRzfkVDaGFydHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFQ2hhcnRzKGRvbSwgdGhlbWUsIG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgLy8gR2V0IHRoZW1lIGJ5IG5hbWVcbiAgICAgICAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoZW1lID0gdGhlbWVTdG9yYWdlW3RoZW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyb3VwIGlkXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyb3VwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0hUTUxEb21FbGVtZW50fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZG9tID0gZG9tO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgenIgPSB0aGlzLl96ciA9IHpyZW5kZXIuaW5pdChkb20sIHtcbiAgICAgICAgICAgIHJlbmRlcmVyOiBvcHRzLnJlbmRlcmVyIHx8ICdjYW52YXMnLFxuICAgICAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogb3B0cy5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICAgICAgd2lkdGg6IG9wdHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IG9wdHMuaGVpZ2h0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBlY3QgNjAgcGZzLlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90aHJvdHRsZWRackZsdXNoID0gdGhyb3R0bGUudGhyb3R0bGUoenJVdGlsLmJpbmQoenIuZmx1c2gsIHpyKSwgMTcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGhlbWUgPSB6clV0aWwuY2xvbmUodGhlbWUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY2hhcnRzVmlld3MgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6ZWNoYXJ0cy92aWV3L0NoYXJ0Pn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NoYXJ0c01hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50Pn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHNWaWV3cyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50Pn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHNNYXAgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL0Nvb3JkaW5hdGVTeXN0ZW19XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb29yZFN5c01nciA9IG5ldyBDb29yZGluYXRlU3lzdGVtTWFuYWdlcigpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYXBpID0gY3JlYXRlRXh0ZW5zaW9uQVBJKHRoaXMpO1xuXG4gICAgICAgIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0c35NZXNzYWdlQ2VudGVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWVzc2FnZUNlbnRlciA9IG5ldyBNZXNzYWdlQ2VudGVyKCk7XG5cbiAgICAgICAgLy8gSW5pdCBtb3VzZSBldmVudHNcbiAgICAgICAgdGhpcy5faW5pdEV2ZW50cygpO1xuXG4gICAgICAgIC8vIEluIGNhc2Ugc29tZSBwZW9wbGUgd3JpdGUgYHdpbmRvdy5vbnJlc2l6ZSA9IGNoYXJ0LnJlc2l6ZWBcbiAgICAgICAgdGhpcy5yZXNpemUgPSB6clV0aWwuYmluZCh0aGlzLnJlc2l6ZSwgdGhpcyk7XG5cbiAgICAgICAgLy8gQ2FuJ3QgZGlzcGF0Y2ggYWN0aW9uIGR1cmluZyByZW5kZXJpbmcgcHJvY2VkdXJlXG4gICAgICAgIHRoaXMuX3BlbmRpbmdBY3Rpb25zID0gW107XG4gICAgICAgIC8vIFNvcnQgb24gZGVtYW5kXG4gICAgICAgIGZ1bmN0aW9uIHByaW9yaXR5U29ydEZ1bmMoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpbyAtIGIucHJpbztcbiAgICAgICAgfVxuICAgICAgICB0aW1zb3J0KHZpc3VhbEZ1bmNzLCBwcmlvcml0eVNvcnRGdW5jKTtcbiAgICAgICAgdGltc29ydChkYXRhUHJvY2Vzc29yRnVuY3MsIHByaW9yaXR5U29ydEZ1bmMpO1xuXG4gICAgICAgIHpyLmFuaW1hdGlvbi5vbignZnJhbWUnLCB0aGlzLl9vbmZyYW1lLCB0aGlzKTtcblxuICAgICAgICAvLyBFQ2hhcnRzIGluc3RhbmNlIGNhbiBiZSB1c2VkIGFzIHZhbHVlLlxuICAgICAgICB6clV0aWwuc2V0QXNQcmltaXRpdmUodGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIGVjaGFydHNQcm90byA9IEVDaGFydHMucHJvdG90eXBlO1xuXG4gICAgZWNoYXJ0c1Byb3RvLl9vbmZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBMYXp5IHVwZGF0ZVxuICAgICAgICBpZiAodGhpc1tPUFRJT05fVVBEQVRFRF0pIHtcbiAgICAgICAgICAgIHZhciBzaWxlbnQgPSB0aGlzW09QVElPTl9VUERBVEVEXS5zaWxlbnQ7XG5cbiAgICAgICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IHRydWU7XG5cbiAgICAgICAgICAgIHVwZGF0ZU1ldGhvZHMucHJlcGFyZUFuZFVwZGF0ZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSBmYWxzZTtcblxuICAgICAgICAgICAgdGhpc1tPUFRJT05fVVBEQVRFRF0gPSBmYWxzZTtcblxuICAgICAgICAgICAgZmx1c2hQZW5kaW5nQWN0aW9ucy5jYWxsKHRoaXMsIHNpbGVudCk7XG5cbiAgICAgICAgICAgIHRyaWdnZXJVcGRhdGVkRXZlbnQuY2FsbCh0aGlzLCBzaWxlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtIVE1MRG9tRWxlbWVudH1cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZ2V0RG9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG9tO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlcn5aUmVuZGVyfVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXRaciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2FnZTpcbiAgICAgKiBjaGFydC5zZXRPcHRpb24ob3B0aW9uLCBub3RNZXJnZSwgbGF6eVVwZGF0ZSk7XG4gICAgICogY2hhcnQuc2V0T3B0aW9uKG9wdGlvbiwge1xuICAgICAqICAgICBub3RNZXJnZTogLi4uLFxuICAgICAqICAgICBsYXp5VXBkYXRlOiAuLi4sXG4gICAgICogICAgIHNpbGVudDogLi4uXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbn0gW29wdHNdIG9wdHMgb3Igbm90TWVyZ2UuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5ub3RNZXJnZT1mYWxzZV1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmxhenlVcGRhdGU9ZmFsc2VdIFVzZWZ1bCB3aGVuIHNldE9wdGlvbiBmcmVxdWVudGx5LlxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5zZXRPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uLCBub3RNZXJnZSwgbGF6eVVwZGF0ZSkge1xuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgenJVdGlsLmFzc2VydCghdGhpc1tJTl9NQUlOX1BST0NFU1NdLCAnYHNldE9wdGlvbmAgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZHVyaW5nIG1haW4gcHJvY2Vzcy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWxlbnQ7XG4gICAgICAgIGlmICh6clV0aWwuaXNPYmplY3Qobm90TWVyZ2UpKSB7XG4gICAgICAgICAgICBsYXp5VXBkYXRlID0gbm90TWVyZ2UubGF6eVVwZGF0ZTtcbiAgICAgICAgICAgIHNpbGVudCA9IG5vdE1lcmdlLnNpbGVudDtcbiAgICAgICAgICAgIG5vdE1lcmdlID0gbm90TWVyZ2Uubm90TWVyZ2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSB0cnVlO1xuXG4gICAgICAgIGlmICghdGhpcy5fbW9kZWwgfHwgbm90TWVyZ2UpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25NYW5hZ2VyID0gbmV3IE9wdGlvbk1hbmFnZXIodGhpcy5fYXBpKTtcbiAgICAgICAgICAgIHZhciB0aGVtZSA9IHRoaXMuX3RoZW1lO1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbCA9IG5ldyBHbG9iYWxNb2RlbChudWxsLCBudWxsLCB0aGVtZSwgb3B0aW9uTWFuYWdlcik7XG4gICAgICAgICAgICBlY01vZGVsLmluaXQobnVsbCwgbnVsbCwgdGhlbWUsIG9wdGlvbk1hbmFnZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW9kZWwuc2V0T3B0aW9uKG9wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MpO1xuXG4gICAgICAgIGlmIChsYXp5VXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzW09QVElPTl9VUERBVEVEXSA9IHtzaWxlbnQ6IHNpbGVudH07XG4gICAgICAgICAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZU1ldGhvZHMucHJlcGFyZUFuZFVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgLy8gRW5zdXJlIHpyIHJlZnJlc2ggc3ljaHJvbm91c2x5LCBhbmQgdGhlbiBwaXhlbCBpbiBjYW52YXMgY2FuIGJlXG4gICAgICAgICAgICAvLyBmZXRjaGVkIGFmdGVyIGBzZXRPcHRpb25gLlxuICAgICAgICAgICAgdGhpcy5fenIuZmx1c2goKTtcblxuICAgICAgICAgICAgdGhpc1tPUFRJT05fVVBEQVRFRF0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmbHVzaFBlbmRpbmdBY3Rpb25zLmNhbGwodGhpcywgc2lsZW50KTtcbiAgICAgICAgICAgIHRyaWdnZXJVcGRhdGVkRXZlbnQuY2FsbCh0aGlzLCBzaWxlbnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBERVBSRUNBVEVEXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLnNldFRoZW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmxvZygnRUNoYXJ0cyNzZXRUaGVtZSgpIGlzIERFUFJFQ0FURUQgaW4gRUNoYXJ0cyAzLjAnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXRNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGVsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldE9wdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGVsICYmIHRoaXMuX21vZGVsLmdldE9wdGlvbigpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fenIuZ2V0V2lkdGgoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96ci5nZXRIZWlnaHQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXREZXZpY2VQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fenIucGFpbnRlci5kcHIgfHwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhbnZhcyB3aGljaCBoYXMgYWxsIHRoaW5nIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXRSZW5kZXJlZENhbnZhcyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIGlmICghZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBvcHRzLnBpeGVsUmF0aW8gPSBvcHRzLnBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgb3B0cy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRzLmJhY2tncm91bmRDb2xvclxuICAgICAgICAgICAgfHwgdGhpcy5fbW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgdmFyIHpyID0gdGhpcy5fenI7XG4gICAgICAgIHZhciBsaXN0ID0genIuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpO1xuICAgICAgICAvLyBTdG9wIGFuaW1hdGlvbnNcbiAgICAgICAgenJVdGlsLmVhY2gobGlzdCwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBlbC5zdG9wQW5pbWF0aW9uKHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHpyLnBhaW50ZXIuZ2V0UmVuZGVyZWRDYW52YXMob3B0cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMudHlwZT0ncG5nJ11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucGl4ZWxSYXRpbz0xXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYWNrZ3JvdW5kQ29sb3JdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmV4Y2x1ZGVDb21wb25lbnRzXVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXREYXRhVVJMID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIHZhciBleGNsdWRlQ29tcG9uZW50cyA9IG9wdHMuZXhjbHVkZUNvbXBvbmVudHM7XG4gICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgICAgIHZhciBleGNsdWRlc0NvbXBvbmVudFZpZXdzID0gW107XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBlYWNoKGV4Y2x1ZGVDb21wb25lbnRzLCBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgICAgICAgICAgICBtYWluVHlwZTogY29tcG9uZW50VHlwZVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gc2VsZi5fY29tcG9uZW50c01hcFtjb21wb25lbnQuX192aWV3SWRdO1xuICAgICAgICAgICAgICAgIGlmICghdmlldy5ncm91cC5pZ25vcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZXNDb21wb25lbnRWaWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3Lmdyb3VwLmlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB1cmwgPSB0aGlzLmdldFJlbmRlcmVkQ2FudmFzKG9wdHMpLnRvRGF0YVVSTChcbiAgICAgICAgICAgICdpbWFnZS8nICsgKG9wdHMgJiYgb3B0cy50eXBlIHx8ICdwbmcnKVxuICAgICAgICApO1xuXG4gICAgICAgIGVhY2goZXhjbHVkZXNDb21wb25lbnRWaWV3cywgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgICAgIHZpZXcuZ3JvdXAuaWdub3JlID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50eXBlPSdwbmcnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5waXhlbFJhdGlvPTFdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZ2V0Q29ubmVjdGVkRGF0YVVSTCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIGlmICghZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncm91cElkID0gdGhpcy5ncm91cDtcbiAgICAgICAgdmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbiAgICAgICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICAgICAgdmFyIE1BWF9OVU1CRVIgPSBJbmZpbml0eTtcbiAgICAgICAgaWYgKGNvbm5lY3RlZEdyb3Vwc1tncm91cElkXSkge1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBNQVhfTlVNQkVSO1xuICAgICAgICAgICAgdmFyIHRvcCA9IE1BWF9OVU1CRVI7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSAtTUFYX05VTUJFUjtcbiAgICAgICAgICAgIHZhciBib3R0b20gPSAtTUFYX05VTUJFUjtcbiAgICAgICAgICAgIHZhciBjYW52YXNMaXN0ID0gW107XG4gICAgICAgICAgICB2YXIgZHByID0gKG9wdHMgJiYgb3B0cy5waXhlbFJhdGlvKSB8fCAxO1xuXG4gICAgICAgICAgICB6clV0aWwuZWFjaChpbnN0YW5jZXMsIGZ1bmN0aW9uIChjaGFydCwgaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuZ3JvdXAgPT09IGdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGNoYXJ0LmdldFJlbmRlcmVkQ2FudmFzKFxuICAgICAgICAgICAgICAgICAgICAgICAgenJVdGlsLmNsb25lKG9wdHMpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBjaGFydC5nZXREb20oKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IG1hdGhNaW4oYm91bmRpbmdSZWN0LmxlZnQsIGxlZnQpO1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSBtYXRoTWluKGJvdW5kaW5nUmVjdC50b3AsIHRvcCk7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gbWF0aE1heChib3VuZGluZ1JlY3QucmlnaHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tID0gbWF0aE1heChib3VuZGluZ1JlY3QuYm90dG9tLCBib3R0b20pO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tOiBjYW52YXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBib3VuZGluZ1JlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogYm91bmRpbmdSZWN0LnRvcFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGVmdCAqPSBkcHI7XG4gICAgICAgICAgICB0b3AgKj0gZHByO1xuICAgICAgICAgICAgcmlnaHQgKj0gZHByO1xuICAgICAgICAgICAgYm90dG9tICo9IGRwcjtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Q2FudmFzID0genJVdGlsLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgICAgICAgdGFyZ2V0Q2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0YXJnZXRDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHpyID0genJlbmRlci5pbml0KHRhcmdldENhbnZhcyk7XG5cbiAgICAgICAgICAgIGVhY2goY2FudmFzTGlzdCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogaXRlbS5sZWZ0ICogZHByIC0gbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGl0ZW0udG9wICogZHByIC0gdG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGl0ZW0uZG9tXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB6ci5hZGQoaW1nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgenIucmVmcmVzaEltbWVkaWF0ZWx5KCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRDYW52YXMudG9EYXRhVVJMKCdpbWFnZS8nICsgKG9wdHMgJiYgb3B0cy50eXBlIHx8ICdwbmcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhVVJMKG9wdHMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgZnJvbSBsb2dpY2FsIGNvb3JkaW5hdGUgc3lzdGVtIHRvIHBpeGVsIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIFNlZSBDb29yZGluYXRlU3lzdGVtI2NvbnZlcnRUb1BpeGVsLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZmluZGVyXG4gICAgICogICAgICAgIElmIHN0cmluZywgZS5nLiwgJ2dlbycsIG1lYW5zIHtnZW9JbmRleDogMH0uXG4gICAgICogICAgICAgIElmIE9iamVjdCwgY291bGQgY29udGFpbiBzb21lIG9mIHRoZXNlIHByb3BlcnRpZXMgYmVsb3c6XG4gICAgICogICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgIHNlcmllc0luZGV4IC8gc2VyaWVzSWQgLyBzZXJpZXNOYW1lLFxuICAgICAqICAgICAgICAgICAgZ2VvSW5kZXggLyBnZW9JZCwgZ2VvTmFtZSxcbiAgICAgKiAgICAgICAgICAgIGJtYXBJbmRleCAvIGJtYXBJZCAvIGJtYXBOYW1lLFxuICAgICAqICAgICAgICAgICAgeEF4aXNJbmRleCAvIHhBeGlzSWQgLyB4QXhpc05hbWUsXG4gICAgICogICAgICAgICAgICB5QXhpc0luZGV4IC8geUF4aXNJZCAvIHlBeGlzTmFtZSxcbiAgICAgKiAgICAgICAgICAgIGdyaWRJbmRleCAvIGdyaWRJZCAvIGdyaWROYW1lLFxuICAgICAqICAgICAgICAgICAgLi4uIChjYW4gYmUgZXh0ZW5kZWQpXG4gICAgICogICAgICAgIH1cbiAgICAgKiBAcGFyYW0ge0FycmF5fG51bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtBcnJheXxudW1iZXJ9IHJlc3VsdFxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5jb252ZXJ0VG9QaXhlbCA9IHpyVXRpbC5jdXJyeShkb0NvbnZlcnRQaXhlbCwgJ2NvbnZlcnRUb1BpeGVsJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGZyb20gcGl4ZWwgY29vcmRpbmF0ZSBzeXN0ZW0gdG8gbG9naWNhbCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBTZWUgQ29vcmRpbmF0ZVN5c3RlbSNjb252ZXJ0RnJvbVBpeGVsLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZmluZGVyXG4gICAgICogICAgICAgIElmIHN0cmluZywgZS5nLiwgJ2dlbycsIG1lYW5zIHtnZW9JbmRleDogMH0uXG4gICAgICogICAgICAgIElmIE9iamVjdCwgY291bGQgY29udGFpbiBzb21lIG9mIHRoZXNlIHByb3BlcnRpZXMgYmVsb3c6XG4gICAgICogICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgIHNlcmllc0luZGV4IC8gc2VyaWVzSWQgLyBzZXJpZXNOYW1lLFxuICAgICAqICAgICAgICAgICAgZ2VvSW5kZXggLyBnZW9JZCAvIGdlb05hbWUsXG4gICAgICogICAgICAgICAgICBibWFwSW5kZXggLyBibWFwSWQgLyBibWFwTmFtZSxcbiAgICAgKiAgICAgICAgICAgIHhBeGlzSW5kZXggLyB4QXhpc0lkIC8geEF4aXNOYW1lLFxuICAgICAqICAgICAgICAgICAgeUF4aXNJbmRleCAvIHlBeGlzSWQgLyB5QXhpc05hbWVcbiAgICAgKiAgICAgICAgICAgIGdyaWRJbmRleCAvIGdyaWRJZCAvIGdyaWROYW1lLFxuICAgICAqICAgICAgICAgICAgLi4uIChjYW4gYmUgZXh0ZW5kZWQpXG4gICAgICogICAgICAgIH1cbiAgICAgKiBAcGFyYW0ge0FycmF5fG51bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtBcnJheXxudW1iZXJ9IHJlc3VsdFxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5jb252ZXJ0RnJvbVBpeGVsID0genJVdGlsLmN1cnJ5KGRvQ29udmVydFBpeGVsLCAnY29udmVydEZyb21QaXhlbCcpO1xuXG4gICAgZnVuY3Rpb24gZG9Db252ZXJ0UGl4ZWwobWV0aG9kTmFtZSwgZmluZGVyLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICAgICAgICB2YXIgY29vcmRTeXNMaXN0ID0gdGhpcy5fY29vcmRTeXNNZ3IuZ2V0Q29vcmRpbmF0ZVN5c3RlbXMoKTtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBmaW5kZXIgPSBtb2RlbFV0aWwucGFyc2VGaW5kZXIoZWNNb2RlbCwgZmluZGVyKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkU3lzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gY29vcmRTeXNMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGNvb3JkU3lzW21ldGhvZE5hbWVdXG4gICAgICAgICAgICAgICAgJiYgKHJlc3VsdCA9IGNvb3JkU3lzW21ldGhvZE5hbWVdKGVjTW9kZWwsIGZpbmRlciwgdmFsdWUpKSAhPSBudWxsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAnTm8gY29vcmRpbmF0ZSBzeXN0ZW0gdGhhdCBzdXBwb3J0cyAnICsgbWV0aG9kTmFtZSArICcgZm91bmQgYnkgdGhlIGdpdmVuIGZpbmRlci4nXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXMgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlIHN5c3RlbXMgb3IgY29tcG9uZW50cyBjb250YWluIHRoZSBnaXZlbiBwaXhlbCBwb2ludC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGZpbmRlclxuICAgICAqICAgICAgICBJZiBzdHJpbmcsIGUuZy4sICdnZW8nLCBtZWFucyB7Z2VvSW5kZXg6IDB9LlxuICAgICAqICAgICAgICBJZiBPYmplY3QsIGNvdWxkIGNvbnRhaW4gc29tZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGJlbG93OlxuICAgICAqICAgICAgICB7XG4gICAgICogICAgICAgICAgICBzZXJpZXNJbmRleCAvIHNlcmllc0lkIC8gc2VyaWVzTmFtZSxcbiAgICAgKiAgICAgICAgICAgIGdlb0luZGV4IC8gZ2VvSWQgLyBnZW9OYW1lLFxuICAgICAqICAgICAgICAgICAgYm1hcEluZGV4IC8gYm1hcElkIC8gYm1hcE5hbWUsXG4gICAgICogICAgICAgICAgICB4QXhpc0luZGV4IC8geEF4aXNJZCAvIHhBeGlzTmFtZSxcbiAgICAgKiAgICAgICAgICAgIHlBeGlzSW5kZXggLyB5QXhpc0lkIC8geUF4aXNOYW1lLFxuICAgICAqICAgICAgICAgICAgZ3JpZEluZGV4IC8gZ3JpZElkIC8gZ3JpZE5hbWUsXG4gICAgICogICAgICAgICAgICAuLi4gKGNhbiBiZSBleHRlbmRlZClcbiAgICAgKiAgICAgICAgfVxuICAgICAqIEBwYXJhbSB7QXJyYXl8bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHJlc3VsdFxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5jb250YWluUGl4ZWwgPSBmdW5jdGlvbiAoZmluZGVyLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIGZpbmRlciA9IG1vZGVsVXRpbC5wYXJzZUZpbmRlcihlY01vZGVsLCBmaW5kZXIpO1xuXG4gICAgICAgIHpyVXRpbC5lYWNoKGZpbmRlciwgZnVuY3Rpb24gKG1vZGVscywga2V5KSB7XG4gICAgICAgICAgICBrZXkuaW5kZXhPZignTW9kZWxzJykgPj0gMCAmJiB6clV0aWwuZWFjaChtb2RlbHMsIGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IG1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICAgICAgaWYgKGNvb3JkU3lzICYmIGNvb3JkU3lzLmNvbnRhaW5Qb2ludCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgfD0gISFjb29yZFN5cy5jb250YWluUG9pbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzZXJpZXNNb2RlbHMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5fY2hhcnRzTWFwW21vZGVsLl9fdmlld0lkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXcgJiYgdmlldy5jb250YWluUG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCB8PSB2aWV3LmNvbnRhaW5Qb2ludCh2YWx1ZSwgbW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oa2V5ICsgJzogJyArICh2aWV3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ1RoZSBmb3VuZCBjb21wb25lbnQgZG8gbm90IHN1cHBvcnQgY29udGFpblBvaW50LidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnTm8gdmlldyBtYXBwaW5nIHRvIHRoZSBmb3VuZCBjb21wb25lbnQuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGtleSArICc6IGNvbnRhaW5Qb2ludCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmlzdWFsIGZyb20gc2VyaWVzIG9yIGRhdGEuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBmaW5kZXJcbiAgICAgKiAgICAgICAgSWYgc3RyaW5nLCBlLmcuLCAnc2VyaWVzJywgbWVhbnMge3Nlcmllc0luZGV4OiAwfS5cbiAgICAgKiAgICAgICAgSWYgT2JqZWN0LCBjb3VsZCBjb250YWluIHNvbWUgb2YgdGhlc2UgcHJvcGVydGllcyBiZWxvdzpcbiAgICAgKiAgICAgICAge1xuICAgICAqICAgICAgICAgICAgc2VyaWVzSW5kZXggLyBzZXJpZXNJZCAvIHNlcmllc05hbWUsXG4gICAgICogICAgICAgICAgICBkYXRhSW5kZXggLyBkYXRhSW5kZXhJbnNpZGVcbiAgICAgKiAgICAgICAgfVxuICAgICAqICAgICAgICBJZiBkYXRhSW5kZXggaXMgbm90IHNwZWNpZmllZCwgc2VyaWVzIHZpc3VhbCB3aWxsIGJlIGZldGNoZWQsXG4gICAgICogICAgICAgIGJ1dCBub3QgZGF0YSBpdGVtIHZpc3VhbC5cbiAgICAgKiAgICAgICAgSWYgYWxsIG9mIHNlcmllc0luZGV4LCBzZXJpZXNJZCwgc2VyaWVzTmFtZSBhcmUgbm90IHNwZWNpZmllZCxcbiAgICAgKiAgICAgICAgdmlzdWFsIHdpbGwgYmUgZmV0Y2hlZCBmcm9tIGZpcnN0IHNlcmllcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzdWFsVHlwZSAnY29sb3InLCAnc3ltYm9sJywgJ3N5bWJvbFNpemUnXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldFZpc3VhbCA9IGZ1bmN0aW9uIChmaW5kZXIsIHZpc3VhbFR5cGUpIHtcbiAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcblxuICAgICAgICBmaW5kZXIgPSBtb2RlbFV0aWwucGFyc2VGaW5kZXIoZWNNb2RlbCwgZmluZGVyLCB7ZGVmYXVsdE1haW5UeXBlOiAnc2VyaWVzJ30pO1xuXG4gICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGZpbmRlci5zZXJpZXNNb2RlbDtcblxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgaWYgKCFzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlcmUgaXMgbm8gc3BlY2lmaWVkIHNlaXJlcyBtb2RlbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG5cbiAgICAgICAgdmFyIGRhdGFJbmRleEluc2lkZSA9IGZpbmRlci5oYXNPd25Qcm9wZXJ0eSgnZGF0YUluZGV4SW5zaWRlJylcbiAgICAgICAgICAgID8gZmluZGVyLmRhdGFJbmRleEluc2lkZVxuICAgICAgICAgICAgOiBmaW5kZXIuaGFzT3duUHJvcGVydHkoJ2RhdGFJbmRleCcpXG4gICAgICAgICAgICA/IGRhdGEuaW5kZXhPZlJhd0luZGV4KGZpbmRlci5kYXRhSW5kZXgpXG4gICAgICAgICAgICA6IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIGRhdGFJbmRleEluc2lkZSAhPSBudWxsXG4gICAgICAgICAgICA/IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXhJbnNpZGUsIHZpc3VhbFR5cGUpXG4gICAgICAgICAgICA6IGRhdGEuZ2V0VmlzdWFsKHZpc3VhbFR5cGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmlldyBvZiBjb3JyZXNwb25kaW5nIGNvbXBvbmVudCBtb2RlbFxuICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gY29tcG9uZW50TW9kZWxcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy92aWV3L0NvbXBvbmVudH1cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZ2V0Vmlld09mQ29tcG9uZW50TW9kZWwgPSBmdW5jdGlvbiAoY29tcG9uZW50TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNNYXBbY29tcG9uZW50TW9kZWwuX192aWV3SWRdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmlldyBvZiBjb3JyZXNwb25kaW5nIHNlcmllcyBtb2RlbFxuICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy92aWV3L0NoYXJ0fVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXRWaWV3T2ZTZXJpZXNNb2RlbCA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhcnRzTWFwW3Nlcmllc01vZGVsLl9fdmlld0lkXTtcbiAgICB9O1xuXG5cbiAgICB2YXIgdXBkYXRlTWV0aG9kcyA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUucHJvZmlsZSAmJiBjb25zb2xlLnByb2ZpbGUoJ3VwZGF0ZScpO1xuXG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuX2FwaTtcbiAgICAgICAgICAgIHZhciBjb29yZFN5c01nciA9IHRoaXMuX2Nvb3JkU3lzTWdyO1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fenI7XG4gICAgICAgICAgICAvLyB1cGRhdGUgYmVmb3JlIHNldE9wdGlvblxuICAgICAgICAgICAgaWYgKCFlY01vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXhtZSBGaXJzdCB0aW1lIHVwZGF0ZSA/XG4gICAgICAgICAgICBlY01vZGVsLnJlc3RvcmVEYXRhKCk7XG5cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIC8vIFNhdmUgdG90YWwgZWNNb2RlbCBoZXJlIGZvciB1bmRvL3JlZG8gKGFmdGVyIHJlc3RvcmluZyBkYXRhIGFuZCBiZWZvcmUgcHJvY2Vzc2luZyBkYXRhKS5cbiAgICAgICAgICAgIC8vIFVuZG8gKHJlc3RvcmF0aW9uIG9mIHRvdGFsIGVjTW9kZWwpIGNhbiBiZSBjYXJyaWVkIG91dCBpbiAnYWN0aW9uJyBvciBvdXRzaWRlIEFQSSBjYWxsLlxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgbmV3IGNvb3JkaW5hdGUgc3lzdGVtIGVhY2ggdXBkYXRlXG4gICAgICAgICAgICAvLyBJbiBMaW5lVmlldyBtYXkgc2F2ZSB0aGUgb2xkIGNvb3JkaW5hdGUgc3lzdGVtIGFuZCB1c2UgaXQgdG8gZ2V0IHRoZSBvcmlnbmFsIHBvaW50XG4gICAgICAgICAgICBjb29yZFN5c01nci5jcmVhdGUodGhpcy5fbW9kZWwsIHRoaXMuX2FwaSk7XG5cbiAgICAgICAgICAgIHByb2Nlc3NEYXRhLmNhbGwodGhpcywgZWNNb2RlbCwgYXBpKTtcblxuICAgICAgICAgICAgc3RhY2tTZXJpZXNEYXRhLmNhbGwodGhpcywgZWNNb2RlbCk7XG5cbiAgICAgICAgICAgIGNvb3JkU3lzTWdyLnVwZGF0ZShlY01vZGVsLCBhcGkpO1xuXG4gICAgICAgICAgICBkb1Zpc3VhbEVuY29kaW5nLmNhbGwodGhpcywgZWNNb2RlbCwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIGRvUmVuZGVyLmNhbGwodGhpcywgZWNNb2RlbCwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIC8vIFNldCBiYWNrZ3JvdW5kXG4gICAgICAgICAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gZWNNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpIHx8ICd0cmFuc3BhcmVudCc7XG5cbiAgICAgICAgICAgIHZhciBwYWludGVyID0genIucGFpbnRlcjtcbiAgICAgICAgICAgIC8vIFRPRE8gYWxsIHVzZSBjbGVhckNvbG9yID9cbiAgICAgICAgICAgIGlmIChwYWludGVyLmlzU2luZ2xlQ2FudmFzICYmIHBhaW50ZXIuaXNTaW5nbGVDYW52YXMoKSkge1xuICAgICAgICAgICAgICAgIHpyLmNvbmZpZ0xheWVyKDAsIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvcjogYmFja2dyb3VuZENvbG9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBJRThcbiAgICAgICAgICAgICAgICBpZiAoIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yQXJyID0gY29sb3JUb29sLnBhcnNlKGJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IGNvbG9yVG9vbC5zdHJpbmdpZnkoY29sb3JBcnIsICdyZ2InKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yQXJyWzNdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IuY29sb3JTdG9wcyB8fCBiYWNrZ3JvdW5kQ29sb3IuaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR3JhZGllbnQgYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBGaXhlZCBsYXllcu+8n1xuICAgICAgICAgICAgICAgICAgICB6ci5jb25maWdMYXllcigwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yOiBiYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbSEFTX0dSQURJRU5UX09SX1BBVFRFUk5fQkddID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb20uc3R5bGUuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1tIQVNfR1JBRElFTlRfT1JfUEFUVEVSTl9CR10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpyLmNvbmZpZ0xheWVyKDAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzW0hBU19HUkFESUVOVF9PUl9QQVRURVJOX0JHXSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvbS5zdHlsZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWFjaChwb3N0VXBkYXRlRnVuY3MsIGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgZnVuYyhlY01vZGVsLCBhcGkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUucHJvZmlsZSAmJiBjb25zb2xlLnByb2ZpbGVFbmQoJ3VwZGF0ZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlVmlldzogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBiZWZvcmUgc2V0T3B0aW9uXG4gICAgICAgICAgICBpZiAoIWVjTW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXREYXRhKCkuY2xlYXJBbGxWaXN1YWwoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkb1Zpc3VhbEVuY29kaW5nLmNhbGwodGhpcywgZWNNb2RlbCwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIGludm9rZVVwZGF0ZU1ldGhvZC5jYWxsKHRoaXMsICd1cGRhdGVWaWV3JywgZWNNb2RlbCwgcGF5bG9hZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVWaXN1YWw6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgYmVmb3JlIHNldE9wdGlvblxuICAgICAgICAgICAgaWYgKCFlY01vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmNsZWFyQWxsVmlzdWFsKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZG9WaXN1YWxFbmNvZGluZy5jYWxsKHRoaXMsIGVjTW9kZWwsIHBheWxvYWQsIHRydWUpO1xuXG4gICAgICAgICAgICBpbnZva2VVcGRhdGVNZXRob2QuY2FsbCh0aGlzLCAndXBkYXRlVmlzdWFsJywgZWNNb2RlbCwgcGF5bG9hZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgYmVmb3JlIHNldE9wdGlvblxuICAgICAgICAgICAgaWYgKCFlY01vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkb0xheW91dC5jYWxsKHRoaXMsIGVjTW9kZWwsIHBheWxvYWQpO1xuXG4gICAgICAgICAgICBpbnZva2VVcGRhdGVNZXRob2QuY2FsbCh0aGlzLCAndXBkYXRlTGF5b3V0JywgZWNNb2RlbCwgcGF5bG9hZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBwcmVwYXJlQW5kVXBkYXRlOiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcblxuICAgICAgICAgICAgcHJlcGFyZVZpZXcuY2FsbCh0aGlzLCAnY29tcG9uZW50JywgZWNNb2RlbCk7XG5cbiAgICAgICAgICAgIHByZXBhcmVWaWV3LmNhbGwodGhpcywgJ2NoYXJ0JywgZWNNb2RlbCk7XG5cbiAgICAgICAgICAgIHVwZGF0ZU1ldGhvZHMudXBkYXRlLmNhbGwodGhpcywgcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVEaXJlY3RseShlY0lucywgbWV0aG9kLCBwYXlsb2FkLCBtYWluVHlwZSwgc3ViVHlwZSkge1xuICAgICAgICB2YXIgZWNNb2RlbCA9IGVjSW5zLl9tb2RlbDtcblxuICAgICAgICAvLyBicm9hZGNhc3RcbiAgICAgICAgaWYgKCFtYWluVHlwZSkge1xuICAgICAgICAgICAgZWFjaChlY0lucy5fY29tcG9uZW50c1ZpZXdzLmNvbmNhdChlY0lucy5fY2hhcnRzVmlld3MpLCBjYWxsVmlldyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcXVlcnkgPSB7fTtcbiAgICAgICAgcXVlcnlbbWFpblR5cGUgKyAnSWQnXSA9IHBheWxvYWRbbWFpblR5cGUgKyAnSWQnXTtcbiAgICAgICAgcXVlcnlbbWFpblR5cGUgKyAnSW5kZXgnXSA9IHBheWxvYWRbbWFpblR5cGUgKyAnSW5kZXgnXTtcbiAgICAgICAgcXVlcnlbbWFpblR5cGUgKyAnTmFtZSddID0gcGF5bG9hZFttYWluVHlwZSArICdOYW1lJ107XG5cbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHttYWluVHlwZTogbWFpblR5cGUsIHF1ZXJ5OiBxdWVyeX07XG4gICAgICAgIHN1YlR5cGUgJiYgKGNvbmRpdGlvbi5zdWJUeXBlID0gc3ViVHlwZSk7IC8vIHN1YlR5cGUgbWF5IGJlICcnIGJ5IHBhcnNlQ2xhc3NUeXBlO1xuXG4gICAgICAgIC8vIElmIGRpc3BhdGNoQWN0aW9uIGJlZm9yZSBzZXRPcHRpb24sIGRvIG5vdGhpbmcuXG4gICAgICAgIGVjTW9kZWwgJiYgZWNNb2RlbC5lYWNoQ29tcG9uZW50KGNvbmRpdGlvbiwgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkge1xuICAgICAgICAgICAgY2FsbFZpZXcoZWNJbnNbXG4gICAgICAgICAgICAgICAgbWFpblR5cGUgPT09ICdzZXJpZXMnID8gJ19jaGFydHNNYXAnIDogJ19jb21wb25lbnRzTWFwJ1xuICAgICAgICAgICAgXVttb2RlbC5fX3ZpZXdJZF0pO1xuICAgICAgICB9LCBlY0lucyk7XG5cbiAgICAgICAgZnVuY3Rpb24gY2FsbFZpZXcodmlldykge1xuICAgICAgICAgICAgdmlldyAmJiB2aWV3Ll9fYWxpdmUgJiYgdmlld1ttZXRob2RdICYmIHZpZXdbbWV0aG9kXShcbiAgICAgICAgICAgICAgICB2aWV3Ll9fbW9kZWwsIGVjTW9kZWwsIGVjSW5zLl9hcGksIHBheWxvYWRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgdGhlIGNoYXJ0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMud2lkdGhdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2lsZW50PWZhbHNlXVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5yZXNpemUgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgenJVdGlsLmFzc2VydCghdGhpc1tJTl9NQUlOX1BST0NFU1NdLCAnYHJlc2l6ZWAgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZHVyaW5nIG1haW4gcHJvY2Vzcy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fenIucmVzaXplKG9wdHMpO1xuXG4gICAgICAgIHZhciBvcHRpb25DaGFuZ2VkID0gdGhpcy5fbW9kZWwgJiYgdGhpcy5fbW9kZWwucmVzZXRPcHRpb24oJ21lZGlhJyk7XG4gICAgICAgIHZhciB1cGRhdGVNZXRob2QgPSBvcHRpb25DaGFuZ2VkID8gJ3ByZXBhcmVBbmRVcGRhdGUnIDogJ3VwZGF0ZSc7XG5cbiAgICAgICAgdXBkYXRlTWV0aG9kc1t1cGRhdGVNZXRob2RdLmNhbGwodGhpcyk7XG5cbiAgICAgICAgLy8gUmVzaXplIGxvYWRpbmcgZWZmZWN0XG4gICAgICAgIHRoaXMuX2xvYWRpbmdGWCAmJiB0aGlzLl9sb2FkaW5nRlgucmVzaXplKCk7XG5cbiAgICAgICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIHNpbGVudCA9IG9wdHMgJiYgb3B0cy5zaWxlbnQ7XG5cbiAgICAgICAgZmx1c2hQZW5kaW5nQWN0aW9ucy5jYWxsKHRoaXMsIHNpbGVudCk7XG5cbiAgICAgICAgdHJpZ2dlclVwZGF0ZWRFdmVudC5jYWxsKHRoaXMsIHNpbGVudCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNob3cgbG9hZGluZyBlZmZlY3RcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IFtuYW1lPSdkZWZhdWx0J11cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtjZmddXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLnNob3dMb2FkaW5nID0gZnVuY3Rpb24gKG5hbWUsIGNmZykge1xuICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjZmcgPSBuYW1lO1xuICAgICAgICAgICAgbmFtZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBuYW1lIHx8ICdkZWZhdWx0JztcblxuICAgICAgICB0aGlzLmhpZGVMb2FkaW5nKCk7XG4gICAgICAgIGlmICghbG9hZGluZ0VmZmVjdHNbbmFtZV0pIHtcbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdMb2FkaW5nIGVmZmVjdHMgJyArIG5hbWUgKyAnIG5vdCBleGlzdHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsID0gbG9hZGluZ0VmZmVjdHNbbmFtZV0odGhpcy5fYXBpLCBjZmcpO1xuICAgICAgICB2YXIgenIgPSB0aGlzLl96cjtcbiAgICAgICAgdGhpcy5fbG9hZGluZ0ZYID0gZWw7XG5cbiAgICAgICAgenIuYWRkKGVsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGlkZSBsb2FkaW5nIGVmZmVjdFxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5oaWRlTG9hZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbG9hZGluZ0ZYICYmIHRoaXMuX3pyLnJlbW92ZSh0aGlzLl9sb2FkaW5nRlgpO1xuICAgICAgICB0aGlzLl9sb2FkaW5nRlggPSBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRPYmpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLm1ha2VBY3Rpb25Gcm9tRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRPYmopIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSB6clV0aWwuZXh0ZW5kKHt9LCBldmVudE9iaik7XG4gICAgICAgIHBheWxvYWQudHlwZSA9IGV2ZW50QWN0aW9uTWFwW2V2ZW50T2JqLnR5cGVdO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHB1YmlsY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXlsb2FkLnR5cGVdIEFjdGlvbiB0eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbn0gW29wdF0gSWYgcGFzcyBib29sZWFuLCBtZWFucyBvcHQuc2lsZW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0LnNpbGVudD1mYWxzZV0gV2hldGhlciB0cmlnZ2VyIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQuZmx1c2g9dW5kZWZpbmVkXVxuICAgICAqICAgICAgICAgICAgICAgICAgdHJ1ZTogRmx1c2ggaW1tZWRpYXRlbHksIGFuZCB0aGVuIHBpeGVsIGluIGNhbnZhcyBjYW4gYmUgZmV0Y2hlZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5LiBDYXV0aW9uOiBpdCBtaWdodCBhZmZlY3QgcGVyZm9ybWFuY2UuXG4gICAgICogICAgICAgICAgICAgICAgICBmYWxzZTogTm90IG5vdCBmbHVzaC5cbiAgICAgKiAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDogQXV0byBkZWNpZGUgd2hldGhlciBwZXJmb3JtIGZsdXNoLlxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5kaXNwYXRjaEFjdGlvbiA9IGZ1bmN0aW9uIChwYXlsb2FkLCBvcHQpIHtcbiAgICAgICAgaWYgKCF6clV0aWwuaXNPYmplY3Qob3B0KSkge1xuICAgICAgICAgICAgb3B0ID0ge3NpbGVudDogISFvcHR9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhY3Rpb25zW3BheWxvYWQudHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1heSBkaXNwYXRjaEFjdGlvbiBpbiByZW5kZXJpbmcgcHJvY2VkdXJlXG4gICAgICAgIGlmICh0aGlzW0lOX01BSU5fUFJPQ0VTU10pIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdBY3Rpb25zLnB1c2gocGF5bG9hZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkb0Rpc3BhdGNoQWN0aW9uLmNhbGwodGhpcywgcGF5bG9hZCwgb3B0LnNpbGVudCk7XG5cbiAgICAgICAgaWYgKG9wdC5mbHVzaCkge1xuICAgICAgICAgICAgdGhpcy5fenIuZmx1c2godHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0LmZsdXNoICE9PSBmYWxzZSAmJiBlbnYuYnJvd3Nlci53ZUNoYXQpIHtcbiAgICAgICAgICAgIC8vIEluIFdlQ2hhdCBlbWJlZGVkIGJyb3dzZXIsIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGFuZCBgc2V0SW50ZXJ2YWxgXG4gICAgICAgICAgICAvLyBoYW5nIHdoZW4gc2xpZGluZyBwYWdlIChvbiB0b3VjaCBldmVudCksIHdoaWNoIGNhdXNlIHRoYXQgenIgZG9lcyBub3RcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdXRpbCB1c2VyIGludGVyYWN0aW9uIGZpbmlzaGVkLCB3aGljaCBpcyBub3QgZXhwZWN0ZWQuXG4gICAgICAgICAgICAvLyBCdXQgYGRpc3BhdGNoQWN0aW9uYCBtYXkgYmUgY2FsbGVkIHRvbyBmcmVxdWVudGx5IHdoZW4gcGFuIG9uIHRvdWNoXG4gICAgICAgICAgICAvLyBzY3JlZW4sIHdoaWNoIGltcGFjdHMgcGVyZm9ybWFuY2UgaWYgZG8gbm90IHRocm90dGxlIHRoZW0uXG4gICAgICAgICAgICB0aGlzLl90aHJvdHRsZWRackZsdXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmbHVzaFBlbmRpbmdBY3Rpb25zLmNhbGwodGhpcywgb3B0LnNpbGVudCk7XG5cbiAgICAgICAgdHJpZ2dlclVwZGF0ZWRFdmVudC5jYWxsKHRoaXMsIG9wdC5zaWxlbnQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkb0Rpc3BhdGNoQWN0aW9uKHBheWxvYWQsIHNpbGVudCkge1xuICAgICAgICB2YXIgcGF5bG9hZFR5cGUgPSBwYXlsb2FkLnR5cGU7XG4gICAgICAgIHZhciBlc2NhcGVDb25uZWN0ID0gcGF5bG9hZC5lc2NhcGVDb25uZWN0O1xuICAgICAgICB2YXIgYWN0aW9uV3JhcCA9IGFjdGlvbnNbcGF5bG9hZFR5cGVdO1xuICAgICAgICB2YXIgYWN0aW9uSW5mbyA9IGFjdGlvbldyYXAuYWN0aW9uSW5mbztcblxuICAgICAgICB2YXIgY3B0VHlwZSA9IChhY3Rpb25JbmZvLnVwZGF0ZSB8fCAndXBkYXRlJykuc3BsaXQoJzonKTtcbiAgICAgICAgdmFyIHVwZGF0ZU1ldGhvZCA9IGNwdFR5cGUucG9wKCk7XG4gICAgICAgIGNwdFR5cGUgPSBjcHRUeXBlWzBdICE9IG51bGwgJiYgcGFyc2VDbGFzc1R5cGUoY3B0VHlwZVswXSk7XG5cbiAgICAgICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgcGF5bG9hZHMgPSBbcGF5bG9hZF07XG4gICAgICAgIHZhciBiYXRjaGVkID0gZmFsc2U7XG4gICAgICAgIC8vIEJhdGNoIGFjdGlvblxuICAgICAgICBpZiAocGF5bG9hZC5iYXRjaCkge1xuICAgICAgICAgICAgYmF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICBwYXlsb2FkcyA9IHpyVXRpbC5tYXAocGF5bG9hZC5iYXRjaCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtID0genJVdGlsLmRlZmF1bHRzKHpyVXRpbC5leHRlbmQoe30sIGl0ZW0pLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBpdGVtLmJhdGNoID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2ZW50T2JqQmF0Y2ggPSBbXTtcbiAgICAgICAgdmFyIGV2ZW50T2JqO1xuICAgICAgICB2YXIgaXNIaWdoRG93biA9IHBheWxvYWRUeXBlID09PSAnaGlnaGxpZ2h0JyB8fCBwYXlsb2FkVHlwZSA9PT0gJ2Rvd25wbGF5JztcblxuICAgICAgICBlYWNoKHBheWxvYWRzLCBmdW5jdGlvbiAoYmF0Y2hJdGVtKSB7XG4gICAgICAgICAgICAvLyBBY3Rpb24gY2FuIHNwZWNpZnkgdGhlIGV2ZW50IGJ5IHJldHVybiBpdC5cbiAgICAgICAgICAgIGV2ZW50T2JqID0gYWN0aW9uV3JhcC5hY3Rpb24oYmF0Y2hJdGVtLCB0aGlzLl9tb2RlbCwgdGhpcy5fYXBpKTtcbiAgICAgICAgICAgIC8vIEVtaXQgZXZlbnQgb3V0c2lkZVxuICAgICAgICAgICAgZXZlbnRPYmogPSBldmVudE9iaiB8fCB6clV0aWwuZXh0ZW5kKHt9LCBiYXRjaEl0ZW0pO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0eXBlIHRvIGV2ZW50VHlwZVxuICAgICAgICAgICAgZXZlbnRPYmoudHlwZSA9IGFjdGlvbkluZm8uZXZlbnQgfHwgZXZlbnRPYmoudHlwZTtcbiAgICAgICAgICAgIGV2ZW50T2JqQmF0Y2gucHVzaChldmVudE9iaik7XG5cbiAgICAgICAgICAgIC8vIGxpZ2h0IHVwZGF0ZSBkb2VzIG5vdCBwZXJmb3JtIGRhdGEgcHJvY2VzcywgbGF5b3V0IGFuZCB2aXN1YWwuXG4gICAgICAgICAgICBpZiAoaXNIaWdoRG93bikge1xuICAgICAgICAgICAgICAgIC8vIG1ldGhvZCwgcGF5bG9hZCwgbWFpblR5cGUsIHN1YlR5cGVcbiAgICAgICAgICAgICAgICB1cGRhdGVEaXJlY3RseSh0aGlzLCB1cGRhdGVNZXRob2QsIGJhdGNoSXRlbSwgJ3NlcmllcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3B0VHlwZSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZURpcmVjdGx5KHRoaXMsIHVwZGF0ZU1ldGhvZCwgYmF0Y2hJdGVtLCBjcHRUeXBlLm1haW4sIGNwdFR5cGUuc3ViKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZU1ldGhvZCAhPT0gJ25vbmUnICYmICFpc0hpZ2hEb3duICYmICFjcHRUeXBlKSB7XG4gICAgICAgICAgICAvLyBTdGlsbCBkaXJ0eVxuICAgICAgICAgICAgaWYgKHRoaXNbT1BUSU9OX1VQREFURURdKSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgUGFzcyBwYXlsb2FkID9cbiAgICAgICAgICAgICAgICB1cGRhdGVNZXRob2RzLnByZXBhcmVBbmRVcGRhdGUuY2FsbCh0aGlzLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB0aGlzW09QVElPTl9VUERBVEVEXSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlTWV0aG9kc1t1cGRhdGVNZXRob2RdLmNhbGwodGhpcywgcGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb2xsb3cgdGhlIHJ1bGUgb2YgYWN0aW9uIGJhdGNoXG4gICAgICAgIGlmIChiYXRjaGVkKSB7XG4gICAgICAgICAgICBldmVudE9iaiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhY3Rpb25JbmZvLmV2ZW50IHx8IHBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgIGVzY2FwZUNvbm5lY3Q6IGVzY2FwZUNvbm5lY3QsXG4gICAgICAgICAgICAgICAgYmF0Y2g6IGV2ZW50T2JqQmF0Y2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBldmVudE9iaiA9IGV2ZW50T2JqQmF0Y2hbMF07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSBmYWxzZTtcblxuICAgICAgICAhc2lsZW50ICYmIHRoaXMuX21lc3NhZ2VDZW50ZXIudHJpZ2dlcihldmVudE9iai50eXBlLCBldmVudE9iaik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmx1c2hQZW5kaW5nQWN0aW9ucyhzaWxlbnQpIHtcbiAgICAgICAgdmFyIHBlbmRpbmdBY3Rpb25zID0gdGhpcy5fcGVuZGluZ0FjdGlvbnM7XG4gICAgICAgIHdoaWxlIChwZW5kaW5nQWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gcGVuZGluZ0FjdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgICAgIGRvRGlzcGF0Y2hBY3Rpb24uY2FsbCh0aGlzLCBwYXlsb2FkLCBzaWxlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpZ2dlclVwZGF0ZWRFdmVudChzaWxlbnQpIHtcbiAgICAgICAgIXNpbGVudCAmJiB0aGlzLnRyaWdnZXIoJ3VwZGF0ZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBldmVudFxuICAgICAqIEBtZXRob2RcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8ub24gPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29uJyk7XG4gICAgZWNoYXJ0c1Byb3RvLm9mZiA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb2ZmJyk7XG4gICAgZWNoYXJ0c1Byb3RvLm9uZSA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb25lJyk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52b2tlVXBkYXRlTWV0aG9kKG1ldGhvZE5hbWUsIGVjTW9kZWwsIHBheWxvYWQpIHtcbiAgICAgICAgdmFyIGFwaSA9IHRoaXMuX2FwaTtcblxuICAgICAgICAvLyBVcGRhdGUgYWxsIGNvbXBvbmVudHNcbiAgICAgICAgZWFjaCh0aGlzLl9jb21wb25lbnRzVmlld3MsIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRNb2RlbCA9IGNvbXBvbmVudC5fX21vZGVsO1xuICAgICAgICAgICAgY29tcG9uZW50W21ldGhvZE5hbWVdKGNvbXBvbmVudE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuXG4gICAgICAgICAgICB1cGRhdGVaKGNvbXBvbmVudE1vZGVsLCBjb21wb25lbnQpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAvLyBVcGF0ZSBhbGwgY2hhcnRzXG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGlkeCkge1xuICAgICAgICAgICAgdmFyIGNoYXJ0ID0gdGhpcy5fY2hhcnRzTWFwW3Nlcmllc01vZGVsLl9fdmlld0lkXTtcbiAgICAgICAgICAgIGNoYXJ0W21ldGhvZE5hbWVdKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuXG4gICAgICAgICAgICB1cGRhdGVaKHNlcmllc01vZGVsLCBjaGFydCk7XG5cbiAgICAgICAgICAgIHVwZGF0ZVByb2dyZXNzaXZlQW5kQmxlbmQoc2VyaWVzTW9kZWwsIGNoYXJ0KTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLy8gSWYgdXNlIGhvdmVyIGxheWVyXG4gICAgICAgIHVwZGF0ZUhvdmVyTGF5ZXJTdGF0dXModGhpcy5fenIsIGVjTW9kZWwpO1xuXG4gICAgICAgIC8vIFBvc3QgcmVuZGVyXG4gICAgICAgIGVhY2gocG9zdFVwZGF0ZUZ1bmNzLCBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgZnVuYyhlY01vZGVsLCBhcGkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHZpZXcgaW5zdGFuY2VzIG9mIGNoYXJ0cyBhbmQgY29tcG9uZW50c1xuICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJlcGFyZVZpZXcodHlwZSwgZWNNb2RlbCkge1xuICAgICAgICB2YXIgaXNDb21wb25lbnQgPSB0eXBlID09PSAnY29tcG9uZW50JztcbiAgICAgICAgdmFyIHZpZXdMaXN0ID0gaXNDb21wb25lbnQgPyB0aGlzLl9jb21wb25lbnRzVmlld3MgOiB0aGlzLl9jaGFydHNWaWV3cztcbiAgICAgICAgdmFyIHZpZXdNYXAgPSBpc0NvbXBvbmVudCA/IHRoaXMuX2NvbXBvbmVudHNNYXAgOiB0aGlzLl9jaGFydHNNYXA7XG4gICAgICAgIHZhciB6ciA9IHRoaXMuX3pyO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlld0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZpZXdMaXN0W2ldLl9fYWxpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVjTW9kZWxbaXNDb21wb25lbnQgPyAnZWFjaENvbXBvbmVudCcgOiAnZWFjaFNlcmllcyddKGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBtb2RlbCkge1xuICAgICAgICAgICAgaWYgKGlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudFR5cGUgPT09ICdzZXJpZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGNvbXBvbmVudFR5cGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnNpZGVyOiBpZCBzYW1lIGFuZCB0eXBlIGNoYW5nZWQuXG4gICAgICAgICAgICB2YXIgdmlld0lkID0gJ19lY18nICsgbW9kZWwuaWQgKyAnXycgKyBtb2RlbC50eXBlO1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB2aWV3TWFwW3ZpZXdJZF07XG4gICAgICAgICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUobW9kZWwudHlwZSk7XG4gICAgICAgICAgICAgICAgdmFyIENsYXp6ID0gaXNDb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgPyBDb21wb25lbnRWaWV3LmdldENsYXNzKGNsYXNzVHlwZS5tYWluLCBjbGFzc1R5cGUuc3ViKVxuICAgICAgICAgICAgICAgICAgICA6IENoYXJ0Vmlldy5nZXRDbGFzcyhjbGFzc1R5cGUuc3ViKTtcbiAgICAgICAgICAgICAgICBpZiAoQ2xhenopIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldyA9IG5ldyBDbGF6eigpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmluaXQoZWNNb2RlbCwgdGhpcy5fYXBpKTtcbiAgICAgICAgICAgICAgICAgICAgdmlld01hcFt2aWV3SWRdID0gdmlldztcbiAgICAgICAgICAgICAgICAgICAgdmlld0xpc3QucHVzaCh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgenIuYWRkKHZpZXcuZ3JvdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbW9kZWwuX192aWV3SWQgPSB2aWV3Ll9faWQgPSB2aWV3SWQ7XG4gICAgICAgICAgICB2aWV3Ll9fYWxpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdmlldy5fX21vZGVsID0gbW9kZWw7XG4gICAgICAgICAgICB2aWV3Lmdyb3VwLl9fZWNDb21wb25lbnRJbmZvID0ge1xuICAgICAgICAgICAgICAgIG1haW5UeXBlOiBtb2RlbC5tYWluVHlwZSxcbiAgICAgICAgICAgICAgICBpbmRleDogbW9kZWwuY29tcG9uZW50SW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlld0xpc3QubGVuZ3RoOykge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB2aWV3TGlzdFtpXTtcbiAgICAgICAgICAgIGlmICghdmlldy5fX2FsaXZlKSB7XG4gICAgICAgICAgICAgICAgenIucmVtb3ZlKHZpZXcuZ3JvdXApO1xuICAgICAgICAgICAgICAgIHZpZXcuZGlzcG9zZShlY01vZGVsLCB0aGlzLl9hcGkpO1xuICAgICAgICAgICAgICAgIHZpZXdMaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdmlld01hcFt2aWV3Ll9faWRdO1xuICAgICAgICAgICAgICAgIHZpZXcuX19pZCA9IHZpZXcuZ3JvdXAuX19lY0NvbXBvbmVudEluZm8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2Vzc29yIGRhdGEgaW4gZWFjaCBzZXJpZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzRGF0YShlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgZWFjaChkYXRhUHJvY2Vzc29yRnVuY3MsIGZ1bmN0aW9uIChwcm9jZXNzKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmZ1bmMoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja1Nlcmllc0RhdGEoZWNNb2RlbCkge1xuICAgICAgICB2YXIgc3RhY2tlZERhdGFNYXAgPSB7fTtcbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IHNlcmllcy5nZXQoJ3N0YWNrJyk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllcy5nZXREYXRhKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2sgJiYgZGF0YS50eXBlID09PSAnbGlzdCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNTdGFjayA9IHN0YWNrZWREYXRhTWFwW3N0YWNrXTtcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGVcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2tlZERhdGFNYXAuaGFzT3duUHJvcGVydHkoc3RhY2spICYmIHByZXZpb3VzU3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zdGFja2VkT24gPSBwcmV2aW91c1N0YWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFja2VkRGF0YU1hcFtzdGFja10gPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMYXlvdXQgYmVmb3JlIGVhY2ggY2hhcnQgcmVuZGVyIHRoZXJlIHNlcmllcywgc3BlY2lhbCB2aXN1YWwgZW5jb2Rpbmcgc3RhZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0xheW91dChlY01vZGVsLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICAgIGVhY2godmlzdWFsRnVuY3MsIGZ1bmN0aW9uICh2aXN1YWwpIHtcbiAgICAgICAgICAgIGlmICh2aXN1YWwuaXNMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICB2aXN1YWwuZnVuYyhlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgdmlzdWFsIGluZm9tYXRpb24gZnJvbSBkYXRhIGFmdGVyIGRhdGEgcHJvY2Vzc2luZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbGF5b3V0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZXhjbHVkZXNMYXlvdXRdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb1Zpc3VhbEVuY29kaW5nKGVjTW9kZWwsIHBheWxvYWQsIGV4Y2x1ZGVzTGF5b3V0KSB7XG4gICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICAgIGVjTW9kZWwuY2xlYXJDb2xvclBhbGV0dGUoKTtcbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgc2VyaWVzTW9kZWwuY2xlYXJDb2xvclBhbGV0dGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2godmlzdWFsRnVuY3MsIGZ1bmN0aW9uICh2aXN1YWwpIHtcbiAgICAgICAgICAgICghZXhjbHVkZXNMYXlvdXQgfHwgIXZpc3VhbC5pc0xheW91dClcbiAgICAgICAgICAgICAgICAmJiB2aXN1YWwuZnVuYyhlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZWFjaCBjaGFydCBhbmQgY29tcG9uZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb1JlbmRlcihlY01vZGVsLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICAgIC8vIFJlbmRlciBhbGwgY29tcG9uZW50c1xuICAgICAgICBlYWNoKHRoaXMuX2NvbXBvbmVudHNWaWV3cywgZnVuY3Rpb24gKGNvbXBvbmVudFZpZXcpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRNb2RlbCA9IGNvbXBvbmVudFZpZXcuX19tb2RlbDtcbiAgICAgICAgICAgIGNvbXBvbmVudFZpZXcucmVuZGVyKGNvbXBvbmVudE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuXG4gICAgICAgICAgICB1cGRhdGVaKGNvbXBvbmVudE1vZGVsLCBjb21wb25lbnRWaWV3KTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgZWFjaCh0aGlzLl9jaGFydHNWaWV3cywgZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgICAgICAgICBjaGFydC5fX2FsaXZlID0gZmFsc2U7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIFJlbmRlciBhbGwgY2hhcnRzXG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGlkeCkge1xuICAgICAgICAgICAgdmFyIGNoYXJ0VmlldyA9IHRoaXMuX2NoYXJ0c01hcFtzZXJpZXNNb2RlbC5fX3ZpZXdJZF07XG4gICAgICAgICAgICBjaGFydFZpZXcuX19hbGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBjaGFydFZpZXcucmVuZGVyKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuXG4gICAgICAgICAgICBjaGFydFZpZXcuZ3JvdXAuc2lsZW50ID0gISFzZXJpZXNNb2RlbC5nZXQoJ3NpbGVudCcpO1xuXG4gICAgICAgICAgICB1cGRhdGVaKHNlcmllc01vZGVsLCBjaGFydFZpZXcpO1xuXG4gICAgICAgICAgICB1cGRhdGVQcm9ncmVzc2l2ZUFuZEJsZW5kKHNlcmllc01vZGVsLCBjaGFydFZpZXcpO1xuXG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIElmIHVzZSBob3ZlciBsYXllclxuICAgICAgICB1cGRhdGVIb3ZlckxheWVyU3RhdHVzKHRoaXMuX3pyLCBlY01vZGVsKTtcblxuICAgICAgICAvLyBSZW1vdmUgZ3JvdXBzIG9mIHVucmVuZGVyZWQgY2hhcnRzXG4gICAgICAgIGVhY2godGhpcy5fY2hhcnRzVmlld3MsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgICAgICAgaWYgKCFjaGFydC5fX2FsaXZlKSB7XG4gICAgICAgICAgICAgICAgY2hhcnQucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFtcbiAgICAgICAgJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLFxuICAgICAgICAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnZ2xvYmFsb3V0JywgJ2NvbnRleHRtZW51J1xuICAgIF07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uX2luaXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uIChldmVOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl96ci5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5nZXRNb2RlbCgpO1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXM7XG5cbiAgICAgICAgICAgICAgICAvLyBubyBlLnRhcmdldCB3aGVuICdnbG9iYWxvdXQnLlxuICAgICAgICAgICAgICAgIGlmIChldmVOYW1lID09PSAnZ2xvYmFsb3V0Jykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZWwgJiYgZWwuZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFNb2RlbCA9IGVsLmRhdGFNb2RlbCB8fCBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoZWwuc2VyaWVzSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBkYXRhTW9kZWwgJiYgZGF0YU1vZGVsLmdldERhdGFQYXJhbXMoZWwuZGF0YUluZGV4LCBlbC5kYXRhVHlwZSkgfHwge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIGN1c3RvbSBldmVudERhdGEgb2YgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsICYmIGVsLmV2ZW50RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB6clV0aWwuZXh0ZW5kKHt9LCBlbC5ldmVudERhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBldmVOYW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoZXZlTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBlYWNoKGV2ZW50QWN0aW9uTWFwLCBmdW5jdGlvbiAoYWN0aW9uVHlwZSwgZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlQ2VudGVyLm9uKGV2ZW50VHlwZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50VHlwZSwgZXZlbnQpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5pc0Rpc3Bvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcG9zZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbih7IHNlcmllczogW10gfSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignSW5zdGFuY2UgJyArIHRoaXMuaWQgKyAnIGhhcyBiZWVuIGRpc3Bvc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlO1xuXG4gICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG5cbiAgICAgICAgZWFjaCh0aGlzLl9jb21wb25lbnRzVmlld3MsIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5kaXNwb3NlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoKHRoaXMuX2NoYXJ0c1ZpZXdzLCBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICAgICAgICAgIGNoYXJ0LmRpc3Bvc2UoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRGlzcG9zZSBhZnRlciBhbGwgdmlld3MgZGlzcG9zZWRcbiAgICAgICAgdGhpcy5fenIuZGlzcG9zZSgpO1xuXG4gICAgICAgIGRlbGV0ZSBpbnN0YW5jZXNbdGhpcy5pZF07XG4gICAgfTtcblxuICAgIHpyVXRpbC5taXhpbihFQ2hhcnRzLCBFdmVudGZ1bCk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVIb3ZlckxheWVyU3RhdHVzKHpyLCBlY01vZGVsKSB7XG4gICAgICAgIHZhciBzdG9yYWdlID0genIuc3RvcmFnZTtcbiAgICAgICAgdmFyIGVsQ291bnQgPSAwO1xuICAgICAgICBzdG9yYWdlLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKCFlbC5pc0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgZWxDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVsQ291bnQgPiBlY01vZGVsLmdldCgnaG92ZXJMYXllclRocmVzaG9sZCcpICYmICFlbnYubm9kZSkge1xuICAgICAgICAgICAgc3RvcmFnZS50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVsLmlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgZWwudXNlSG92ZXJMYXllciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY2hhcnQgcHJvZ3Jlc3NpdmUgYW5kIGJsZW5kLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gbW9kZWxcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50fG1vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnR9IHZpZXdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVQcm9ncmVzc2l2ZUFuZEJsZW5kKHNlcmllc01vZGVsLCBjaGFydFZpZXcpIHtcbiAgICAgICAgLy8gUHJvZ3Jlc3NpdmUgY29uZmlndXJhdGlvblxuICAgICAgICB2YXIgZWxDb3VudCA9IDA7XG4gICAgICAgIGNoYXJ0Vmlldy5ncm91cC50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbC50eXBlICE9PSAnZ3JvdXAnICYmICFlbC5pZ25vcmUpIHtcbiAgICAgICAgICAgICAgICBlbENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZnJhbWVEcmF3TnVtID0gK3Nlcmllc01vZGVsLmdldCgncHJvZ3Jlc3NpdmUnKTtcbiAgICAgICAgdmFyIG5lZWRQcm9ncmVzc2l2ZSA9IGVsQ291bnQgPiBzZXJpZXNNb2RlbC5nZXQoJ3Byb2dyZXNzaXZlVGhyZXNob2xkJykgJiYgZnJhbWVEcmF3TnVtICYmICFlbnYubm9kZTtcbiAgICAgICAgaWYgKG5lZWRQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgICAgY2hhcnRWaWV3Lmdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIG1hcmtlciBhbmQgb3RoZXIgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5wcm9ncmVzc2l2ZSA9IG5lZWRQcm9ncmVzc2l2ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGVsQ291bnQrKyAvIGZyYW1lRHJhd051bSkgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3RvcEFuaW1hdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmxlbmQgY29uZmlncmF0aW9uXG4gICAgICAgIHZhciBibGVuZE1vZGUgPSBzZXJpZXNNb2RlbC5nZXQoJ2JsZW5kTW9kZScpIHx8IG51bGw7XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoIWVudi5jYW52YXNTdXBwb3J0ZWQgJiYgYmxlbmRNb2RlICYmIGJsZW5kTW9kZSAhPT0gJ3NvdXJjZS1vdmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignT25seSBjYW52YXMgc3VwcG9ydCBibGVuZE1vZGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGFydFZpZXcuZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSBtYXJrZXIgYW5kIG90aGVyIGNvbXBvbmVudHNcbiAgICAgICAgICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgICAgICAgICAgIGVsLnNldFN0eWxlKCdibGVuZCcsIGJsZW5kTW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gbW9kZWxcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50fG1vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnR9IHZpZXdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVaKG1vZGVsLCB2aWV3KSB7XG4gICAgICAgIHZhciB6ID0gbW9kZWwuZ2V0KCd6Jyk7XG4gICAgICAgIHZhciB6bGV2ZWwgPSBtb2RlbC5nZXQoJ3psZXZlbCcpO1xuICAgICAgICAvLyBTZXQgeiBhbmQgemxldmVsXG4gICAgICAgIHZpZXcuZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgICAgIHogIT0gbnVsbCAmJiAoZWwueiA9IHopO1xuICAgICAgICAgICAgICAgIHpsZXZlbCAhPSBudWxsICYmIChlbC56bGV2ZWwgPSB6bGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFeHRlbnNpb25BUEkoZWNJbnN0YW5jZSkge1xuICAgICAgICB2YXIgY29vcmRTeXNNZ3IgPSBlY0luc3RhbmNlLl9jb29yZFN5c01ncjtcbiAgICAgICAgcmV0dXJuIHpyVXRpbC5leHRlbmQobmV3IEV4dGVuc2lvbkFQSShlY0luc3RhbmNlKSwge1xuICAgICAgICAgICAgLy8gSW5qZWN0IG1ldGhvZHNcbiAgICAgICAgICAgIGdldENvb3JkaW5hdGVTeXN0ZW1zOiB6clV0aWwuYmluZChcbiAgICAgICAgICAgICAgICBjb29yZFN5c01nci5nZXRDb29yZGluYXRlU3lzdGVtcywgY29vcmRTeXNNZ3JcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBnZXRDb21wb25lbnRCeUVsZW1lbnQ6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZWxJbmZvID0gZWwuX19lY0NvbXBvbmVudEluZm87XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbEluZm8gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVjSW5zdGFuY2UuX21vZGVsLmdldENvbXBvbmVudChtb2RlbEluZm8ubWFpblR5cGUsIG1vZGVsSW5mby5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0fSBrZXk6IGFjdGlvblR5cGUuXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIGFjdGlvbnMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIE1hcCBldmVudFR5cGUgdG8gYWN0aW9uVHlwZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIGV2ZW50QWN0aW9uTWFwID0ge307XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIHByb2Nlc3NvciBmdW5jdGlvbnMgb2YgZWFjaCBzdGFnZVxuICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0LjxzdHJpbmcsIEZ1bmN0aW9uPj59XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIGRhdGFQcm9jZXNzb3JGdW5jcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5LjxGdW5jdGlvbj59XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXkuPEZ1bmN0aW9uPn1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgcG9zdFVwZGF0ZUZ1bmNzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBWaXN1YWwgZW5jb2RpbmcgZnVuY3Rpb25zIG9mIGVhY2ggc3RhZ2VcbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdC48c3RyaW5nLCBGdW5jdGlvbj4+fVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciB2aXN1YWxGdW5jcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIFRoZW1lIHN0b3JhZ2VcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxrZXksIE9iamVjdD59XG4gICAgICovXG4gICAgdmFyIHRoZW1lU3RvcmFnZSA9IHt9O1xuICAgIC8qKlxuICAgICAqIExvYWRpbmcgZWZmZWN0c1xuICAgICAqL1xuICAgIHZhciBsb2FkaW5nRWZmZWN0cyA9IHt9O1xuXG5cbiAgICB2YXIgaW5zdGFuY2VzID0ge307XG4gICAgdmFyIGNvbm5lY3RlZEdyb3VwcyA9IHt9O1xuXG4gICAgdmFyIGlkQmFzZSA9IG5ldyBEYXRlKCkgLSAwO1xuICAgIHZhciBncm91cElkQmFzZSA9IG5ldyBEYXRlKCkgLSAwO1xuICAgIHZhciBET01fQVRUUklCVVRFX0tFWSA9ICdfZWNoYXJ0c19pbnN0YW5jZV8nO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzXG4gICAgICovXG4gICAgdmFyIGVjaGFydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmVyc2lvbjogJzMuNi4yJyxcbiAgICAgICAgZGVwZW5kZW5jaWVzOiB7XG4gICAgICAgICAgICB6cmVuZGVyOiAnMy41LjInXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZW5hYmxlQ29ubmVjdChjaGFydCkge1xuICAgICAgICB2YXIgU1RBVFVTX1BFTkRJTkcgPSAwO1xuICAgICAgICB2YXIgU1RBVFVTX1VQREFUSU5HID0gMTtcbiAgICAgICAgdmFyIFNUQVRVU19VUERBVEVEID0gMjtcbiAgICAgICAgdmFyIFNUQVRVU19LRVkgPSAnX19jb25uZWN0VXBkYXRlU3RhdHVzJztcblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDb25uZWN0ZWRDaGFydHNTdGF0dXMoY2hhcnRzLCBzdGF0dXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyQ2hhcnQgPSBjaGFydHNbaV07XG4gICAgICAgICAgICAgICAgb3RoZXJDaGFydFtTVEFUVVNfS0VZXSA9IHN0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHpyVXRpbC5lYWNoKGV2ZW50QWN0aW9uTWFwLCBmdW5jdGlvbiAoYWN0aW9uVHlwZSwgZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICBjaGFydC5fbWVzc2FnZUNlbnRlci5vbihldmVudFR5cGUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0ZWRHcm91cHNbY2hhcnQuZ3JvdXBdICYmIGNoYXJ0W1NUQVRVU19LRVldICE9PSBTVEFUVVNfUEVORElORykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQuZXNjYXBlQ29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGNoYXJ0Lm1ha2VBY3Rpb25Gcm9tRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJDaGFydHMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChpbnN0YW5jZXMsIGZ1bmN0aW9uIChvdGhlckNoYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJDaGFydCAhPT0gY2hhcnQgJiYgb3RoZXJDaGFydC5ncm91cCA9PT0gY2hhcnQuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlckNoYXJ0cy5wdXNoKG90aGVyQ2hhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb25uZWN0ZWRDaGFydHNTdGF0dXMob3RoZXJDaGFydHMsIFNUQVRVU19QRU5ESU5HKTtcbiAgICAgICAgICAgICAgICAgICAgZWFjaChvdGhlckNoYXJ0cywgZnVuY3Rpb24gKG90aGVyQ2hhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckNoYXJ0W1NUQVRVU19LRVldICE9PSBTVEFUVVNfVVBEQVRJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlckNoYXJ0LmRpc3BhdGNoQWN0aW9uKGFjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb25uZWN0ZWRDaGFydHNTdGF0dXMob3RoZXJDaGFydHMsIFNUQVRVU19VUERBVEVEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRG9tRWxlbWVudH0gZG9tXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFt0aGVtZV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXSBVc2Ugd2luZG93LmRldmljZVBpeGVsUmF0aW8gYnkgZGVmYXVsdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcl0gQ3VycmVudGx5IG9ubHkgJ2NhbnZhcycgaXMgc3VwcG9ydGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy53aWR0aF0gVXNlIGNsaWVudFdpZHRoIG9mIHRoZSBpbnB1dCBgZG9tYCBieSBkZWZhdWx0LlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmhlaWdodF0gVXNlIGNsaWVudEhlaWdodCBvZiB0aGUgaW5wdXQgYGRvbWAgYnkgZGVmYXVsdC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgKi9cbiAgICBlY2hhcnRzLmluaXQgPSBmdW5jdGlvbiAoZG9tLCB0aGVtZSwgb3B0cykge1xuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgdmVyc2lvblxuICAgICAgICAgICAgaWYgKCh6cmVuZGVyLnZlcnNpb24ucmVwbGFjZSgnLicsICcnKSAtIDApIDwgKGVjaGFydHMuZGVwZW5kZW5jaWVzLnpyZW5kZXIucmVwbGFjZSgnLicsICcnKSAtIDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnWlJlbmRlciAnICsgenJlbmRlci52ZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgICsgJyBpcyB0b28gb2xkIGZvciBFQ2hhcnRzICcgKyBlY2hhcnRzLnZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgKyAnLiBDdXJyZW50IHZlcnNpb24gbmVlZCBaUmVuZGVyICdcbiAgICAgICAgICAgICAgICAgICAgKyBlY2hhcnRzLmRlcGVuZGVuY2llcy56cmVuZGVyICsgJysnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFkb20pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luaXRpYWxpemUgZmFpbGVkOiBpbnZhbGlkIGRvbS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleGlzdEluc3RhbmNlID0gZWNoYXJ0cy5nZXRJbnN0YW5jZUJ5RG9tKGRvbSk7XG4gICAgICAgIGlmIChleGlzdEluc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlcmUgaXMgYSBjaGFydCBpbnN0YW5jZSBhbHJlYWR5IGluaXRpYWxpemVkIG9uIHRoZSBkb20uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RJbnN0YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoenJVdGlsLmlzRG9tKGRvbSlcbiAgICAgICAgICAgICAgICAmJiBkb20ubm9kZU5hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0NBTlZBUydcbiAgICAgICAgICAgICAgICAmJiAoXG4gICAgICAgICAgICAgICAgICAgICghZG9tLmNsaWVudFdpZHRoICYmICghb3B0cyB8fCBvcHRzLndpZHRoID09IG51bGwpKVxuICAgICAgICAgICAgICAgICAgICB8fCAoIWRvbS5jbGllbnRIZWlnaHQgJiYgKCFvcHRzIHx8IG9wdHMuaGVpZ2h0ID09IG51bGwpKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQ2FuXFwndCBnZXQgZG9tIHdpZHRoIG9yIGhlaWdodCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYXJ0ID0gbmV3IEVDaGFydHMoZG9tLCB0aGVtZSwgb3B0cyk7XG4gICAgICAgIGNoYXJ0LmlkID0gJ2VjXycgKyBpZEJhc2UrKztcbiAgICAgICAgaW5zdGFuY2VzW2NoYXJ0LmlkXSA9IGNoYXJ0O1xuXG4gICAgICAgIGlmIChkb20uc2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKERPTV9BVFRSSUJVVEVfS0VZLCBjaGFydC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb21bRE9NX0FUVFJJQlVURV9LRVldID0gY2hhcnQuaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBlbmFibGVDb25uZWN0KGNoYXJ0KTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xBcnJheS48bW9kdWxlOmVjaGFydHN+RUNoYXJ0cz59IGdyb3VwSWRcbiAgICAgKi9cbiAgICBlY2hhcnRzLmNvbm5lY3QgPSBmdW5jdGlvbiAoZ3JvdXBJZCkge1xuICAgICAgICAvLyBJcyBhcnJheSBvZiBjaGFydHNcbiAgICAgICAgaWYgKHpyVXRpbC5pc0FycmF5KGdyb3VwSWQpKSB7XG4gICAgICAgICAgICB2YXIgY2hhcnRzID0gZ3JvdXBJZDtcbiAgICAgICAgICAgIGdyb3VwSWQgPSBudWxsO1xuICAgICAgICAgICAgLy8gSWYgYW55IGNoYXJ0IGhhcyBncm91cFxuICAgICAgICAgICAgenJVdGlsLmVhY2goY2hhcnRzLCBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBncm91cElkID0gY2hhcnQuZ3JvdXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cElkID0gZ3JvdXBJZCB8fCAoJ2dfJyArIGdyb3VwSWRCYXNlKyspO1xuICAgICAgICAgICAgenJVdGlsLmVhY2goY2hhcnRzLCBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICAgICAgICAgICAgICBjaGFydC5ncm91cCA9IGdyb3VwSWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0ZWRHcm91cHNbZ3JvdXBJZF0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZ3JvdXBJZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQERFUFJFQ0FURURcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IGdyb3VwSWRcbiAgICAgKi9cbiAgICBlY2hhcnRzLmRpc0Nvbm5lY3QgPSBmdW5jdGlvbiAoZ3JvdXBJZCkge1xuICAgICAgICBjb25uZWN0ZWRHcm91cHNbZ3JvdXBJZF0gPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBncm91cElkXG4gICAgICovXG4gICAgZWNoYXJ0cy5kaXNjb25uZWN0ID0gZWNoYXJ0cy5kaXNDb25uZWN0O1xuXG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBhIGNoYXJ0IGluc3RhbmNlXG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHN+RUNoYXJ0c3xIVE1MRG9tRWxlbWVudHxzdHJpbmd9IGNoYXJ0XG4gICAgICovXG4gICAgZWNoYXJ0cy5kaXNwb3NlID0gZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaGFydCA9IGluc3RhbmNlc1tjaGFydF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShjaGFydCBpbnN0YW5jZW9mIEVDaGFydHMpKXtcbiAgICAgICAgICAgIC8vIFRyeSB0byB0cmVhdCBhcyBkb21cbiAgICAgICAgICAgIGNoYXJ0ID0gZWNoYXJ0cy5nZXRJbnN0YW5jZUJ5RG9tKGNoYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGNoYXJ0IGluc3RhbmNlb2YgRUNoYXJ0cykgJiYgIWNoYXJ0LmlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgY2hhcnQuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge0hUTUxEb21FbGVtZW50fSBkb21cbiAgICAgKiBAcmV0dXJuIHtlY2hhcnRzfkVDaGFydHN9XG4gICAgICovXG4gICAgZWNoYXJ0cy5nZXRJbnN0YW5jZUJ5RG9tID0gZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBpZiAoZG9tLmdldEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAga2V5ID0gZG9tLmdldEF0dHJpYnV0ZShET01fQVRUUklCVVRFX0tFWSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBkb21bRE9NX0FUVFJJQlVURV9LRVldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZXNba2V5XTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm4ge2VjaGFydHN+RUNoYXJ0c31cbiAgICAgKi9cbiAgICBlY2hhcnRzLmdldEluc3RhbmNlQnlJZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlc1trZXldO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciB0aGVtZVxuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJUaGVtZSA9IGZ1bmN0aW9uIChuYW1lLCB0aGVtZSkge1xuICAgICAgICB0aGVtZVN0b3JhZ2VbbmFtZV0gPSB0aGVtZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgb3B0aW9uIHByZXByb2Nlc3NvclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZXByb2Nlc3NvckZ1bmNcbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yID0gZnVuY3Rpb24gKHByZXByb2Nlc3NvckZ1bmMpIHtcbiAgICAgICAgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MucHVzaChwcmVwcm9jZXNzb3JGdW5jKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT0xMDAwXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByb2Nlc3NvckZ1bmNcbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJvY2Vzc29yID0gZnVuY3Rpb24gKHByaW9yaXR5LCBwcm9jZXNzb3JGdW5jKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJpb3JpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHByb2Nlc3NvckZ1bmMgPSBwcmlvcml0eTtcbiAgICAgICAgICAgIHByaW9yaXR5ID0gUFJJT1JJVFlfUFJPQ0VTU09SX0ZJTFRFUjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHByaW9yaXR5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rb3duIHByb2Nlc3NvciBwcmlvcml0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRhdGFQcm9jZXNzb3JGdW5jcy5wdXNoKHtcbiAgICAgICAgICAgIHByaW86IHByaW9yaXR5LFxuICAgICAgICAgICAgZnVuYzogcHJvY2Vzc29yRnVuY1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgcG9zdFVwZGF0ZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb3N0VXBkYXRlRnVuY1xuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJQb3N0VXBkYXRlID0gZnVuY3Rpb24gKHBvc3RVcGRhdGVGdW5jKSB7XG4gICAgICAgIHBvc3RVcGRhdGVGdW5jcy5wdXNoKHBvc3RVcGRhdGVGdW5jKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNhZ2U6XG4gICAgICogcmVnaXN0ZXJBY3Rpb24oJ3NvbWVBY3Rpb24nLCAnc29tZUV2ZW50JywgZnVuY3Rpb24gKCkgeyAuLi4gfSk7XG4gICAgICogcmVnaXN0ZXJBY3Rpb24oJ3NvbWVBY3Rpb24nLCBmdW5jdGlvbiAoKSB7IC4uLiB9KTtcbiAgICAgKiByZWdpc3RlckFjdGlvbihcbiAgICAgKiAgICAge3R5cGU6ICdzb21lQWN0aW9uJywgZXZlbnQ6ICdzb21lRXZlbnQnLCB1cGRhdGU6ICd1cGRhdGVWaWV3J30sXG4gICAgICogICAgIGZ1bmN0aW9uICgpIHsgLi4uIH1cbiAgICAgKiApO1xuICAgICAqXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfE9iamVjdCl9IGFjdGlvbkluZm9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uSW5mby50eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFthY3Rpb25JbmZvLmV2ZW50XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYWN0aW9uSW5mby51cGRhdGVdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtldmVudE5hbWVdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlckFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb25JbmZvLCBldmVudE5hbWUsIGFjdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYWN0aW9uID0gZXZlbnROYW1lO1xuICAgICAgICAgICAgZXZlbnROYW1lID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFjdGlvblR5cGUgPSB6clV0aWwuaXNPYmplY3QoYWN0aW9uSW5mbylcbiAgICAgICAgICAgID8gYWN0aW9uSW5mby50eXBlXG4gICAgICAgICAgICA6IChbYWN0aW9uSW5mbywgYWN0aW9uSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnROYW1lXG4gICAgICAgICAgICB9XVswXSk7XG5cbiAgICAgICAgLy8gRXZlbnQgbmFtZSBpcyBhbGwgbG93ZXJjYXNlXG4gICAgICAgIGFjdGlvbkluZm8uZXZlbnQgPSAoYWN0aW9uSW5mby5ldmVudCB8fCBhY3Rpb25UeXBlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBldmVudE5hbWUgPSBhY3Rpb25JbmZvLmV2ZW50O1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIGFjdGlvbiB0eXBlIGFuZCBldmVudCBuYW1lLlxuICAgICAgICB6clV0aWwuYXNzZXJ0KEFDVElPTl9SRUcudGVzdChhY3Rpb25UeXBlKSAmJiBBQ1RJT05fUkVHLnRlc3QoZXZlbnROYW1lKSk7XG5cbiAgICAgICAgaWYgKCFhY3Rpb25zW2FjdGlvblR5cGVdKSB7XG4gICAgICAgICAgICBhY3Rpb25zW2FjdGlvblR5cGVdID0ge2FjdGlvbjogYWN0aW9uLCBhY3Rpb25JbmZvOiBhY3Rpb25JbmZvfTtcbiAgICAgICAgfVxuICAgICAgICBldmVudEFjdGlvbk1hcFtldmVudE5hbWVdID0gYWN0aW9uVHlwZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0geyp9IENvb3JkaW5hdGVTeXN0ZW1cbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyQ29vcmRpbmF0ZVN5c3RlbSA9IGZ1bmN0aW9uICh0eXBlLCBDb29yZGluYXRlU3lzdGVtKSB7XG4gICAgICAgIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLnJlZ2lzdGVyKHR5cGUsIENvb3JkaW5hdGVTeXN0ZW0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGltZW5zaW9ucyBvZiBzcGVjaWZpZWQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nfE9iamVjdD59XG4gICAgICovXG4gICAgZWNoYXJ0cy5nZXRDb29yZGluYXRlU3lzdGVtRGltZW5zaW9ucyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBjb29yZFN5c0NyZWF0b3IgPSBDb29yZGluYXRlU3lzdGVtTWFuYWdlci5nZXQodHlwZSk7XG4gICAgICAgIGlmIChjb29yZFN5c0NyZWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjb29yZFN5c0NyZWF0b3IuZ2V0RGltZW5zaW9uc0luZm9cbiAgICAgICAgICAgICAgICAgICAgPyBjb29yZFN5c0NyZWF0b3IuZ2V0RGltZW5zaW9uc0luZm8oKVxuICAgICAgICAgICAgICAgICAgICA6IGNvb3JkU3lzQ3JlYXRvci5kaW1lbnNpb25zLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTGF5b3V0IGlzIGEgc3BlY2lhbCBzdGFnZSBvZiB2aXN1YWwgZW5jb2RpbmdcbiAgICAgKiBNb3N0IHZpc3VhbCBlbmNvZGluZyBsaWtlIGNvbG9yIGFyZSBjb21tb24gZm9yIGRpZmZlcmVudCBjaGFydFxuICAgICAqIEJ1dCBlYWNoIGNoYXJ0IGhhcyBpdCdzIG93biBsYXlvdXQgYWxnb3JpdGhtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PTEwMDBdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGF5b3V0RnVuY1xuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJMYXlvdXQgPSBmdW5jdGlvbiAocHJpb3JpdHksIGxheW91dEZ1bmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbGF5b3V0RnVuYyA9IHByaW9yaXR5O1xuICAgICAgICAgICAgcHJpb3JpdHkgPSBQUklPUklUWV9WSVNVQUxfTEFZT1VUO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4ocHJpb3JpdHkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtvd24gbGF5b3V0IHByaW9yaXR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlzdWFsRnVuY3MucHVzaCh7XG4gICAgICAgICAgICBwcmlvOiBwcmlvcml0eSxcbiAgICAgICAgICAgIGZ1bmM6IGxheW91dEZ1bmMsXG4gICAgICAgICAgICBpc0xheW91dDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT0zMDAwXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHZpc3VhbEZ1bmNcbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyVmlzdWFsID0gZnVuY3Rpb24gKHByaW9yaXR5LCB2aXN1YWxGdW5jKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJpb3JpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZpc3VhbEZ1bmMgPSBwcmlvcml0eTtcbiAgICAgICAgICAgIHByaW9yaXR5ID0gUFJJT1JJVFlfVklTVUFMX0NIQVJUO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4ocHJpb3JpdHkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtvd24gdmlzdWFsIHByaW9yaXR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlzdWFsRnVuY3MucHVzaCh7XG4gICAgICAgICAgICBwcmlvOiBwcmlvcml0eSxcbiAgICAgICAgICAgIGZ1bmM6IHZpc3VhbEZ1bmNcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlckxvYWRpbmcgPSBmdW5jdGlvbiAobmFtZSwgbG9hZGluZ0Z4KSB7XG4gICAgICAgIGxvYWRpbmdFZmZlY3RzW25hbWVdID0gbG9hZGluZ0Z4O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3VwZXJDbGFzc11cbiAgICAgKi9cbiAgICBlY2hhcnRzLmV4dGVuZENvbXBvbmVudE1vZGVsID0gZnVuY3Rpb24gKG9wdHMvKiwgc3VwZXJDbGFzcyovKSB7XG4gICAgICAgIC8vIHZhciBDbGF6eiA9IENvbXBvbmVudE1vZGVsO1xuICAgICAgICAvLyBpZiAoc3VwZXJDbGFzcykge1xuICAgICAgICAvLyAgICAgdmFyIGNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlKHN1cGVyQ2xhc3MpO1xuICAgICAgICAvLyAgICAgQ2xhenogPSBDb21wb25lbnRNb2RlbC5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgY2xhc3NUeXBlLnN1YiwgdHJ1ZSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIENvbXBvbmVudE1vZGVsLmV4dGVuZChvcHRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N1cGVyQ2xhc3NdXG4gICAgICovXG4gICAgZWNoYXJ0cy5leHRlbmRDb21wb25lbnRWaWV3ID0gZnVuY3Rpb24gKG9wdHMvKiwgc3VwZXJDbGFzcyovKSB7XG4gICAgICAgIC8vIHZhciBDbGF6eiA9IENvbXBvbmVudFZpZXc7XG4gICAgICAgIC8vIGlmIChzdXBlckNsYXNzKSB7XG4gICAgICAgIC8vICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUoc3VwZXJDbGFzcyk7XG4gICAgICAgIC8vICAgICBDbGF6eiA9IENvbXBvbmVudFZpZXcuZ2V0Q2xhc3MoY2xhc3NUeXBlLm1haW4sIGNsYXNzVHlwZS5zdWIsIHRydWUpO1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiBDb21wb25lbnRWaWV3LmV4dGVuZChvcHRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N1cGVyQ2xhc3NdXG4gICAgICovXG4gICAgZWNoYXJ0cy5leHRlbmRTZXJpZXNNb2RlbCA9IGZ1bmN0aW9uIChvcHRzLyosIHN1cGVyQ2xhc3MqLykge1xuICAgICAgICAvLyB2YXIgQ2xhenogPSBTZXJpZXNNb2RlbDtcbiAgICAgICAgLy8gaWYgKHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgLy8gICAgIHN1cGVyQ2xhc3MgPSAnc2VyaWVzLicgKyBzdXBlckNsYXNzLnJlcGxhY2UoJ3Nlcmllcy4nLCAnJyk7XG4gICAgICAgIC8vICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUoc3VwZXJDbGFzcyk7XG4gICAgICAgIC8vICAgICBDbGF6eiA9IENvbXBvbmVudE1vZGVsLmdldENsYXNzKGNsYXNzVHlwZS5tYWluLCBjbGFzc1R5cGUuc3ViLCB0cnVlKTtcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gU2VyaWVzTW9kZWwuZXh0ZW5kKG9wdHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3VwZXJDbGFzc11cbiAgICAgKi9cbiAgICBlY2hhcnRzLmV4dGVuZENoYXJ0VmlldyA9IGZ1bmN0aW9uIChvcHRzLyosIHN1cGVyQ2xhc3MqLykge1xuICAgICAgICAvLyB2YXIgQ2xhenogPSBDaGFydFZpZXc7XG4gICAgICAgIC8vIGlmIChzdXBlckNsYXNzKSB7XG4gICAgICAgIC8vICAgICBzdXBlckNsYXNzID0gc3VwZXJDbGFzcy5yZXBsYWNlKCdzZXJpZXMuJywgJycpO1xuICAgICAgICAvLyAgICAgdmFyIGNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlKHN1cGVyQ2xhc3MpO1xuICAgICAgICAvLyAgICAgQ2xhenogPSBDaGFydFZpZXcuZ2V0Q2xhc3MoY2xhc3NUeXBlLm1haW4sIHRydWUpO1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiBDaGFydFZpZXcuZXh0ZW5kKG9wdHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBaUmVuZGVyIG5lZWQgYSBjYW52YXMgY29udGV4dCB0byBkbyBtZWFzdXJlVGV4dC5cbiAgICAgKiBCdXQgaW4gbm9kZSBlbnZpcm9ubWVudCBjYW52YXMgbWF5IGJlIGNyZWF0ZWQgYnkgbm9kZS1jYW52YXMuXG4gICAgICogU28gd2UgbmVlZCB0byBzcGVjaWZ5IGhvdyB0byBjcmVhdGUgYSBjYW52YXMgaW5zdGVhZCBvZiB1c2luZyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAqXG4gICAgICogQmUgY2FyZWZ1bCBvZiB1c2luZyBpdCBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNyZWF0b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICB2YXIgQ2FudmFzID0gcmVxdWlyZSgnY2FudmFzJyk7XG4gICAgICogICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnZWNoYXJ0cycpO1xuICAgICAqICAgICBlY2hhcnRzLnNldENhbnZhc0NyZWF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAqICAgICAgICAgLy8gU21hbGwgc2l6ZSBpcyBlbm91Z2guXG4gICAgICogICAgICAgICByZXR1cm4gbmV3IENhbnZhcygzMiwgMzIpO1xuICAgICAqICAgICB9KTtcbiAgICAgKi9cbiAgICBlY2hhcnRzLnNldENhbnZhc0NyZWF0b3IgPSBmdW5jdGlvbiAoY3JlYXRvcikge1xuICAgICAgICB6clV0aWwuY3JlYXRlQ2FudmFzID0gY3JlYXRvcjtcbiAgICB9O1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlclZpc3VhbChQUklPUklUWV9WSVNVQUxfR0xPQkFMLCByZXF1aXJlKCcuL3Zpc3VhbC9zZXJpZXNDb2xvcicpKTtcbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKHJlcXVpcmUoJy4vcHJlcHJvY2Vzc29yL2JhY2t3YXJkQ29tcGF0JykpO1xuICAgIGVjaGFydHMucmVnaXN0ZXJMb2FkaW5nKCdkZWZhdWx0JywgcmVxdWlyZSgnLi9sb2FkaW5nL2RlZmF1bHQnKSk7XG5cbiAgICAvLyBEZWZhdWx0IGFjdGlvblxuICAgIGVjaGFydHMucmVnaXN0ZXJBY3Rpb24oe1xuICAgICAgICB0eXBlOiAnaGlnaGxpZ2h0JyxcbiAgICAgICAgZXZlbnQ6ICdoaWdobGlnaHQnLFxuICAgICAgICB1cGRhdGU6ICdoaWdobGlnaHQnXG4gICAgfSwgenJVdGlsLm5vb3ApO1xuICAgIGVjaGFydHMucmVnaXN0ZXJBY3Rpb24oe1xuICAgICAgICB0eXBlOiAnZG93bnBsYXknLFxuICAgICAgICBldmVudDogJ2Rvd25wbGF5JyxcbiAgICAgICAgdXBkYXRlOiAnZG93bnBsYXknXG4gICAgfSwgenJVdGlsLm5vb3ApO1xuXG5cbiAgICAvLyAtLS0tLS0tLVxuICAgIC8vIEV4cG9ydHNcbiAgICAvLyAtLS0tLS0tLVxuICAgIGVjaGFydHMuenJlbmRlciA9IHpyZW5kZXI7XG5cbiAgICBlY2hhcnRzLkxpc3QgPSByZXF1aXJlKCcuL2RhdGEvTGlzdCcpO1xuICAgIGVjaGFydHMuTW9kZWwgPSByZXF1aXJlKCcuL21vZGVsL01vZGVsJyk7XG5cbiAgICBlY2hhcnRzLkF4aXMgPSByZXF1aXJlKCcuL2Nvb3JkL0F4aXMnKTtcblxuICAgIGVjaGFydHMuZ3JhcGhpYyA9IHJlcXVpcmUoJy4vdXRpbC9ncmFwaGljJyk7XG4gICAgZWNoYXJ0cy5udW1iZXIgPSByZXF1aXJlKCcuL3V0aWwvbnVtYmVyJyk7XG4gICAgZWNoYXJ0cy5mb3JtYXQgPSByZXF1aXJlKCcuL3V0aWwvZm9ybWF0Jyk7XG4gICAgZWNoYXJ0cy50aHJvdHRsZSA9IHRocm90dGxlLnRocm90dGxlO1xuICAgIGVjaGFydHMubWF0cml4ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9tYXRyaXgnKTtcbiAgICBlY2hhcnRzLnZlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XG4gICAgZWNoYXJ0cy5jb2xvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvY29sb3InKTtcblxuICAgIGVjaGFydHMudXRpbCA9IHt9O1xuICAgIGVhY2goW1xuICAgICAgICAgICAgJ21hcCcsICdlYWNoJywgJ2ZpbHRlcicsICdpbmRleE9mJywgJ2luaGVyaXRzJywgJ3JlZHVjZScsICdmaWx0ZXInLFxuICAgICAgICAgICAgJ2JpbmQnLCAnY3VycnknLCAnaXNBcnJheScsICdpc1N0cmluZycsICdpc09iamVjdCcsICdpc0Z1bmN0aW9uJyxcbiAgICAgICAgICAgICdleHRlbmQnLCAnZGVmYXVsdHMnLCAnY2xvbmUnLCAnbWVyZ2UnXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBlY2hhcnRzLnV0aWxbbmFtZV0gPSB6clV0aWxbbmFtZV07XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZWNoYXJ0cy5oZWxwZXIgPSByZXF1aXJlKCcuL2hlbHBlcicpO1xuXG5cbiAgICAvLyBQUklPUklUWVxuICAgIGVjaGFydHMuUFJJT1JJVFkgPSB7XG4gICAgICAgIFBST0NFU1NPUjoge1xuICAgICAgICAgICAgRklMVEVSOiBQUklPUklUWV9QUk9DRVNTT1JfRklMVEVSLFxuICAgICAgICAgICAgU1RBVElTVElDOiBQUklPUklUWV9QUk9DRVNTT1JfU1RBVElTVElDXG4gICAgICAgIH0sXG4gICAgICAgIFZJU1VBTDoge1xuICAgICAgICAgICAgTEFZT1VUOiBQUklPUklUWV9WSVNVQUxfTEFZT1VULFxuICAgICAgICAgICAgR0xPQkFMOiBQUklPUklUWV9WSVNVQUxfR0xPQkFMLFxuICAgICAgICAgICAgQ0hBUlQ6IFBSSU9SSVRZX1ZJU1VBTF9DSEFSVCxcbiAgICAgICAgICAgIENPTVBPTkVOVDogUFJJT1JJVFlfVklTVUFMX0NPTVBPTkVOVCxcbiAgICAgICAgICAgIEJSVVNIOiBQUklPUklUWV9WSVNVQUxfQlJVU0hcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVjaGFydHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvZWNoYXJ0cy5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports){eval("/**\n * echarts设备环境识别\n *\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // 原生canvas支持，改极端点了\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n                // events currently. So we dont use that on other browsers unless tested sufficiently.\n                // Although IE 10 supports pointer event, it use old style and is different from the\n                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n                && (browser.edge || (browser.ie && browser.version >= 11))\n        };\n    }\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZW52LmpzPzljY2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxJQUFJO0FBQ3BELDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLDhDQUE4Qzs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGVjaGFydHPorr7lpIfnjq/looPor4bliKtcbiAqXG4gKiBAZGVzYyBlY2hhcnRz5Z+65LqOQ2FudmFz77yM57qvSmF2YXNjcmlwdOWbvuihqOW6k++8jOaPkOS+m+ebtOingu+8jOeUn+WKqO+8jOWPr+S6pOS6ku+8jOWPr+S4quaAp+WMluWumuWItueahOaVsOaNrue7n+iuoeWbvuihqOOAglxuICogQGF1dGhvciBmaXJlZGVbZmlyZWRlQGZpcmVkZS51c11cbiAqIEBkZXNjIHRoYW5rcyB6ZXB0by5cbiAqL1xuXG4gICAgdmFyIGVudiA9IHt9O1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBJbiBub2RlXG4gICAgICAgIGVudiA9IHtcbiAgICAgICAgICAgIGJyb3dzZXI6IHt9LFxuICAgICAgICAgICAgb3M6IHt9LFxuICAgICAgICAgICAgbm9kZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIEFzc3VtZSBjYW52YXMgaXMgc3VwcG9ydGVkXG4gICAgICAgICAgICBjYW52YXNTdXBwb3J0ZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVudiA9IGRldGVjdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVudjtcblxuICAgIC8vIFplcHRvLmpzXG4gICAgLy8gKGMpIDIwMTAtMjAxMyBUaG9tYXMgRnVjaHNcbiAgICAvLyBaZXB0by5qcyBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuICAgIGZ1bmN0aW9uIGRldGVjdCh1YSkge1xuICAgICAgICB2YXIgb3MgPSB7fTtcbiAgICAgICAgdmFyIGJyb3dzZXIgPSB7fTtcbiAgICAgICAgLy8gdmFyIHdlYmtpdCA9IHVhLm1hdGNoKC9XZWJba0tdaXRbXFwvXXswLDF9KFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBhbmRyb2lkID0gdWEubWF0Y2goLyhBbmRyb2lkKTs/W1xcc1xcL10rKFtcXGQuXSspPy8pO1xuICAgICAgICAvLyB2YXIgaXBhZCA9IHVhLm1hdGNoKC8oaVBhZCkuKk9TXFxzKFtcXGRfXSspLyk7XG4gICAgICAgIC8vIHZhciBpcG9kID0gdWEubWF0Y2goLyhpUG9kKSguKk9TXFxzKFtcXGRfXSspKT8vKTtcbiAgICAgICAgLy8gdmFyIGlwaG9uZSA9ICFpcGFkICYmIHVhLm1hdGNoKC8oaVBob25lXFxzT1MpXFxzKFtcXGRfXSspLyk7XG4gICAgICAgIC8vIHZhciB3ZWJvcyA9IHVhLm1hdGNoKC8od2ViT1N8aHB3T1MpW1xcc1xcL10oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIHRvdWNocGFkID0gd2Vib3MgJiYgdWEubWF0Y2goL1RvdWNoUGFkLyk7XG4gICAgICAgIC8vIHZhciBraW5kbGUgPSB1YS5tYXRjaCgvS2luZGxlXFwvKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBzaWxrID0gdWEubWF0Y2goL1NpbGtcXC8oW1xcZC5fXSspLyk7XG4gICAgICAgIC8vIHZhciBibGFja2JlcnJ5ID0gdWEubWF0Y2goLyhCbGFja0JlcnJ5KS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgYmIxMCA9IHVhLm1hdGNoKC8oQkIxMCkuKlZlcnNpb25cXC8oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIHJpbXRhYmxldG9zID0gdWEubWF0Y2goLyhSSU1cXHNUYWJsZXRcXHNPUylcXHMoW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIHBsYXlib29rID0gdWEubWF0Y2goL1BsYXlCb29rLyk7XG4gICAgICAgIC8vIHZhciBjaHJvbWUgPSB1YS5tYXRjaCgvQ2hyb21lXFwvKFtcXGQuXSspLykgfHwgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLyk7XG4gICAgICAgIHZhciBmaXJlZm94ID0gdWEubWF0Y2goL0ZpcmVmb3hcXC8oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIHNhZmFyaSA9IHdlYmtpdCAmJiB1YS5tYXRjaCgvTW9iaWxlXFwvLykgJiYgIWNocm9tZTtcbiAgICAgICAgLy8gdmFyIHdlYnZpZXcgPSB1YS5tYXRjaCgvKGlQaG9uZXxpUG9kfGlQYWQpLipBcHBsZVdlYktpdCg/IS4qU2FmYXJpKS8pICYmICFjaHJvbWU7XG4gICAgICAgIHZhciBpZSA9IHVhLm1hdGNoKC9NU0lFXFxzKFtcXGQuXSspLylcbiAgICAgICAgICAgIC8vIElFIDExIFRyaWRlbnQvNy4wOyBydjoxMS4wXG4gICAgICAgICAgICB8fCB1YS5tYXRjaCgvVHJpZGVudFxcLy4rP3J2OigoW1xcZC5dKykpLyk7XG4gICAgICAgIHZhciBlZGdlID0gdWEubWF0Y2goL0VkZ2VcXC8oW1xcZC5dKykvKTsgLy8gSUUgMTIgYW5kIDEyK1xuXG4gICAgICAgIHZhciB3ZUNoYXQgPSAoL21pY3JvbWVzc2VuZ2VyL2kpLnRlc3QodWEpO1xuXG4gICAgICAgIC8vIFRvZG86IGNsZWFuIHRoaXMgdXAgd2l0aCBhIGJldHRlciBPUy9icm93c2VyIHNlcGVyYXRpb246XG4gICAgICAgIC8vIC0gZGlzY2VybiAobW9yZSkgYmV0d2VlbiBtdWx0aXBsZSBicm93c2VycyBvbiBhbmRyb2lkXG4gICAgICAgIC8vIC0gZGVjaWRlIGlmIGtpbmRsZSBmaXJlIGluIHNpbGsgbW9kZSBpcyBhbmRyb2lkIG9yIG5vdFxuICAgICAgICAvLyAtIEZpcmVmb3ggb24gQW5kcm9pZCBkb2Vzbid0IHNwZWNpZnkgdGhlIEFuZHJvaWQgdmVyc2lvblxuICAgICAgICAvLyAtIHBvc3NpYmx5IGRldmlkZSBpbiBvcywgZGV2aWNlIGFuZCBicm93c2VyIGhhc2hlc1xuXG4gICAgICAgIC8vIGlmIChicm93c2VyLndlYmtpdCA9ICEhd2Via2l0KSBicm93c2VyLnZlcnNpb24gPSB3ZWJraXRbMV07XG5cbiAgICAgICAgLy8gaWYgKGFuZHJvaWQpIG9zLmFuZHJvaWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gYW5kcm9pZFsyXTtcbiAgICAgICAgLy8gaWYgKGlwaG9uZSAmJiAhaXBvZCkgb3MuaW9zID0gb3MuaXBob25lID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwaG9uZVsyXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gICAgICAgIC8vIGlmIChpcGFkKSBvcy5pb3MgPSBvcy5pcGFkID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwYWRbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAgICAgICAvLyBpZiAoaXBvZCkgb3MuaW9zID0gb3MuaXBvZCA9IHRydWUsIG9zLnZlcnNpb24gPSBpcG9kWzNdID8gaXBvZFszXS5yZXBsYWNlKC9fL2csICcuJykgOiBudWxsO1xuICAgICAgICAvLyBpZiAod2Vib3MpIG9zLndlYm9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHdlYm9zWzJdO1xuICAgICAgICAvLyBpZiAodG91Y2hwYWQpIG9zLnRvdWNocGFkID0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgKGJsYWNrYmVycnkpIG9zLmJsYWNrYmVycnkgPSB0cnVlLCBvcy52ZXJzaW9uID0gYmxhY2tiZXJyeVsyXTtcbiAgICAgICAgLy8gaWYgKGJiMTApIG9zLmJiMTAgPSB0cnVlLCBvcy52ZXJzaW9uID0gYmIxMFsyXTtcbiAgICAgICAgLy8gaWYgKHJpbXRhYmxldG9zKSBvcy5yaW10YWJsZXRvcyA9IHRydWUsIG9zLnZlcnNpb24gPSByaW10YWJsZXRvc1syXTtcbiAgICAgICAgLy8gaWYgKHBsYXlib29rKSBicm93c2VyLnBsYXlib29rID0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgKGtpbmRsZSkgb3Mua2luZGxlID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGtpbmRsZVsxXTtcbiAgICAgICAgLy8gaWYgKHNpbGspIGJyb3dzZXIuc2lsayA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IHNpbGtbMV07XG4gICAgICAgIC8vIGlmICghc2lsayAmJiBvcy5hbmRyb2lkICYmIHVhLm1hdGNoKC9LaW5kbGUgRmlyZS8pKSBicm93c2VyLnNpbGsgPSB0cnVlO1xuICAgICAgICAvLyBpZiAoY2hyb21lKSBicm93c2VyLmNocm9tZSA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IGNocm9tZVsxXTtcbiAgICAgICAgaWYgKGZpcmVmb3gpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuZmlyZWZveCA9IHRydWU7XG4gICAgICAgICAgICBicm93c2VyLnZlcnNpb24gPSBmaXJlZm94WzFdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIChzYWZhcmkgJiYgKHVhLm1hdGNoKC9TYWZhcmkvKSB8fCAhIW9zLmlvcykpIGJyb3dzZXIuc2FmYXJpID0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgKHdlYnZpZXcpIGJyb3dzZXIud2VidmlldyA9IHRydWU7XG5cbiAgICAgICAgaWYgKGllKSB7XG4gICAgICAgICAgICBicm93c2VyLmllID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyb3dzZXIudmVyc2lvbiA9IGllWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVkZ2UpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuZWRnZSA9IHRydWU7XG4gICAgICAgICAgICBicm93c2VyLnZlcnNpb24gPSBlZGdlWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSXQgaXMgZGlmZmljdWx0IHRvIGRldGVjdCBXZUNoYXQgaW4gV2luIFBob25lIHByZWNpc2VseSwgYmVjYXVzZSB1YSBjYW5cbiAgICAgICAgLy8gbm90IGJlIHNldCBvbiB3aW4gcGhvbmUuIFNvIHdlIGRvIG5vdCBjb25zaWRlciBXaW4gUGhvbmUuXG4gICAgICAgIGlmICh3ZUNoYXQpIHtcbiAgICAgICAgICAgIGJyb3dzZXIud2VDaGF0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9zLnRhYmxldCA9ICEhKGlwYWQgfHwgcGxheWJvb2sgfHwgKGFuZHJvaWQgJiYgIXVhLm1hdGNoKC9Nb2JpbGUvKSkgfHxcbiAgICAgICAgLy8gICAgIChmaXJlZm94ICYmIHVhLm1hdGNoKC9UYWJsZXQvKSkgfHwgKGllICYmICF1YS5tYXRjaCgvUGhvbmUvKSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpO1xuICAgICAgICAvLyBvcy5waG9uZSAgPSAhISghb3MudGFibGV0ICYmICFvcy5pcG9kICYmIChhbmRyb2lkIHx8IGlwaG9uZSB8fCB3ZWJvcyB8fFxuICAgICAgICAvLyAgICAgKGNocm9tZSAmJiB1YS5tYXRjaCgvQW5kcm9pZC8pKSB8fCAoY2hyb21lICYmIHVhLm1hdGNoKC9DcmlPU1xcLyhbXFxkLl0rKS8pKSB8fFxuICAgICAgICAvLyAgICAgKGZpcmVmb3ggJiYgdWEubWF0Y2goL01vYmlsZS8pKSB8fCAoaWUgJiYgdWEubWF0Y2goL1RvdWNoLykpKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJyb3dzZXI6IGJyb3dzZXIsXG4gICAgICAgICAgICBvczogb3MsXG4gICAgICAgICAgICBub2RlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIOWOn+eUn2NhbnZhc+aUr+aMge+8jOaUueaegeerr+eCueS6hlxuICAgICAgICAgICAgLy8gY2FudmFzU3VwcG9ydGVkIDogIShicm93c2VyLmllICYmIHBhcnNlRmxvYXQoYnJvd3Nlci52ZXJzaW9uKSA8IDkpXG4gICAgICAgICAgICBjYW52YXNTdXBwb3J0ZWQgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0ID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgLy8gQHNlZSA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80ODE3MDI5L3doYXRzLXRoZS1iZXN0LXdheS10by1kZXRlY3QtYS10b3VjaC1zY3JlZW4tZGV2aWNlLXVzaW5nLWphdmFzY3JpcHQ+XG4gICAgICAgICAgICAvLyB3b3JrcyBvbiBtb3N0IGJyb3dzZXJzXG4gICAgICAgICAgICAvLyBJRTEwLzExIGRvZXMgbm90IHN1cHBvcnQgdG91Y2ggZXZlbnQsIGFuZCBNUyBFZGdlIHN1cHBvcnRzIHRoZW0gYnV0IG5vdCBieVxuICAgICAgICAgICAgLy8gZGVmYXVsdCwgc28gd2UgZG9udCBjaGVjayBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgZm9yIHRoZW0gaGVyZS5cbiAgICAgICAgICAgIHRvdWNoRXZlbnRzU3VwcG9ydGVkOiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgIWJyb3dzZXIuaWUgJiYgIWJyb3dzZXIuZWRnZSxcbiAgICAgICAgICAgIC8vIDxodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1wb2ludGVyJTIwZXZlbnQ+LlxuICAgICAgICAgICAgcG9pbnRlckV2ZW50c1N1cHBvcnRlZDogJ29ucG9pbnRlcmRvd24nIGluIHdpbmRvd1xuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggc3VwcG9ydHMgcG9pbnRlciBidXQgbm90IGJ5IGRlZmF1bHQsIG9ubHkgTVMgYnJvd3NlcnMgYXJlIHJlbGlhYmxlIG9uIHBvaW50ZXJcbiAgICAgICAgICAgICAgICAvLyBldmVudHMgY3VycmVudGx5LiBTbyB3ZSBkb250IHVzZSB0aGF0IG9uIG90aGVyIGJyb3dzZXJzIHVubGVzcyB0ZXN0ZWQgc3VmZmljaWVudGx5LlxuICAgICAgICAgICAgICAgIC8vIEFsdGhvdWdoIElFIDEwIHN1cHBvcnRzIHBvaW50ZXIgZXZlbnQsIGl0IHVzZSBvbGQgc3R5bGUgYW5kIGlzIGRpZmZlcmVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkLiBTbyB3ZSBleGNsdWRlIHRoYXQuIChJRSAxMCBpcyBoYXJkbHkgdXNlZCBvbiB0b3VjaCBkZXZpY2UpXG4gICAgICAgICAgICAgICAgJiYgKGJyb3dzZXIuZWRnZSB8fCAoYnJvd3Nlci5pZSAmJiBicm93c2VyLnZlcnNpb24gPj0gMTEpKVxuICAgICAgICB9O1xuICAgIH1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL2Vudi5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n\n    /**\n     * Caution: If the mechanism should be changed some day, these cases\n     * should be considered:\n     *\n     * (1) In `merge option` mode, if using the same option to call `setOption`\n     * many times, the result should be the same (try our best to ensure that).\n     * (2) In `merge option` mode, if a component has no id/name specified, it\n     * will be merged by index, and the result sequence of the components is\n     * consistent to the original sequence.\n     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n     * `mergeOption` in module:echarts/model/OptionManager.\n     */\n\n    var zrUtil = __webpack_require__(20);\n    var modelUtil = __webpack_require__(21);\n    var Model = __webpack_require__(28);\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n\n    var ComponentModel = __webpack_require__(85);\n\n    var globalDefault = __webpack_require__(89);\n\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n\n        constructor: GlobalModel,\n\n        init: function (option, parentModel, theme, optionManager) {\n            theme = theme || {};\n\n            this.option = null; // Mark as not initialized.\n\n            /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n            this._theme = new Model(theme);\n\n            /**\n             * @type {module:echarts/model/OptionManager}\n             */\n            this._optionManager = optionManager;\n        },\n\n        setOption: function (option, optionPreprocessorFuncs) {\n            zrUtil.assert(\n                !(OPTION_INNER_KEY in option),\n                'please use chart.getOption()'\n            );\n\n            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n            this.resetOption(null);\n        },\n\n        /**\n         * @param {string} type null/undefined: reset all.\n         *                      'recreate': force recreate all.\n         *                      'timeline': only reset timeline option\n         *                      'media': only reset media query option\n         * @return {boolean} Whether option changed.\n         */\n        resetOption: function (type) {\n            var optionChanged = false;\n            var optionManager = this._optionManager;\n\n            if (!type || type === 'recreate') {\n                var baseOption = optionManager.mountOption(type === 'recreate');\n\n                if (!this.option || type === 'recreate') {\n                    initBase.call(this, baseOption);\n                }\n                else {\n                    this.restoreData();\n                    this.mergeOption(baseOption);\n                }\n                optionChanged = true;\n            }\n\n            if (type === 'timeline' || type === 'media') {\n                this.restoreData();\n            }\n\n            if (!type || type === 'recreate' || type === 'timeline') {\n                var timelineOption = optionManager.getTimelineOption(this);\n                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n            }\n\n            if (!type || type === 'recreate' || type === 'media') {\n                var mediaOptions = optionManager.getMediaOption(this, this._api);\n                if (mediaOptions.length) {\n                    each(mediaOptions, function (mediaOption) {\n                        this.mergeOption(mediaOption, optionChanged = true);\n                    }, this);\n                }\n            }\n\n            return optionChanged;\n        },\n\n        /**\n         * @protected\n         */\n        mergeOption: function (newOption) {\n            var option = this.option;\n            var componentsMap = this._componentsMap;\n            var newCptTypes = [];\n\n            // 如果不存在对应的 component model 则直接 merge\n            each(newOption, function (componentOption, mainType) {\n                if (componentOption == null) {\n                    return;\n                }\n\n                if (!ComponentModel.hasClass(mainType)) {\n                    option[mainType] = option[mainType] == null\n                        ? zrUtil.clone(componentOption)\n                        : zrUtil.merge(option[mainType], componentOption, true);\n                }\n                else {\n                    newCptTypes.push(mainType);\n                }\n            });\n\n            // FIXME OPTION 同步是否要改回原来的\n            ComponentModel.topologicalTravel(\n                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n            );\n\n            this._seriesIndices = this._seriesIndices || [];\n\n            function visitComponent(mainType, dependencies) {\n                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\n                var mapResult = modelUtil.mappingToExists(\n                    componentsMap.get(mainType), newCptOptionList\n                );\n\n                modelUtil.makeIdAndName(mapResult);\n\n                // Set mainType and complete subType.\n                each(mapResult, function (item, index) {\n                    var opt = item.option;\n                    if (isObject(opt)) {\n                        item.keyInfo.mainType = mainType;\n                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n                    }\n                });\n\n                var dependentModels = getComponentsByTypes(\n                    componentsMap, dependencies\n                );\n\n                option[mainType] = [];\n                componentsMap.set(mainType, []);\n\n                each(mapResult, function (resultItem, index) {\n                    var componentModel = resultItem.exist;\n                    var newCptOption = resultItem.option;\n\n                    zrUtil.assert(\n                        isObject(newCptOption) || componentModel,\n                        'Empty component definition'\n                    );\n\n                    // Consider where is no new option and should be merged using {},\n                    // see removeEdgeAndAdd in topologicalTravel and\n                    // ComponentModel.getAllClassMainTypes.\n                    if (!newCptOption) {\n                        componentModel.mergeOption({}, this);\n                        componentModel.optionUpdated({}, false);\n                    }\n                    else {\n                        var ComponentModelClass = ComponentModel.getClass(\n                            mainType, resultItem.keyInfo.subType, true\n                        );\n\n                        if (componentModel && componentModel instanceof ComponentModelClass) {\n                            componentModel.name = resultItem.keyInfo.name;\n                            componentModel.mergeOption(newCptOption, this);\n                            componentModel.optionUpdated(newCptOption, false);\n                        }\n                        else {\n                            // PENDING Global as parent ?\n                            var extraOpt = zrUtil.extend(\n                                {\n                                    dependentModels: dependentModels,\n                                    componentIndex: index\n                                },\n                                resultItem.keyInfo\n                            );\n                            componentModel = new ComponentModelClass(\n                                newCptOption, this, this, extraOpt\n                            );\n                            zrUtil.extend(componentModel, extraOpt);\n                            componentModel.init(newCptOption, this, this, extraOpt);\n                            // Call optionUpdated after init.\n                            // newCptOption has been used as componentModel.option\n                            // and may be merged with theme and default, so pass null\n                            // to avoid confusion.\n                            componentModel.optionUpdated(null, true);\n                        }\n                    }\n\n                    componentsMap.get(mainType)[index] = componentModel;\n                    option[mainType][index] = componentModel.option;\n                }, this);\n\n                // Backup series for filtering.\n                if (mainType === 'series') {\n                    this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n                }\n            }\n        },\n\n        /**\n         * Get option for output (cloned option and inner info removed)\n         * @public\n         * @return {Object}\n         */\n        getOption: function () {\n            var option = zrUtil.clone(this.option);\n\n            each(option, function (opts, mainType) {\n                if (ComponentModel.hasClass(mainType)) {\n                    var opts = modelUtil.normalizeToArray(opts);\n                    for (var i = opts.length - 1; i >= 0; i--) {\n                        // Remove options with inner id.\n                        if (modelUtil.isIdInner(opts[i])) {\n                            opts.splice(i, 1);\n                        }\n                    }\n                    option[mainType] = opts;\n                }\n            });\n\n            delete option[OPTION_INNER_KEY];\n\n            return option;\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        getTheme: function () {\n            return this._theme;\n        },\n\n        /**\n         * @param {string} mainType\n         * @param {number} [idx=0]\n         * @return {module:echarts/model/Component}\n         */\n        getComponent: function (mainType, idx) {\n            var list = this._componentsMap.get(mainType);\n            if (list) {\n                return list[idx || 0];\n            }\n        },\n\n        /**\n         * If none of index and id and name used, return all components with mainType.\n         * @param {Object} condition\n         * @param {string} condition.mainType\n         * @param {string} [condition.subType] If ignore, only query by mainType\n         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        queryComponents: function (condition) {\n            var mainType = condition.mainType;\n            if (!mainType) {\n                return [];\n            }\n\n            var index = condition.index;\n            var id = condition.id;\n            var name = condition.name;\n\n            var cpts = this._componentsMap.get(mainType);\n\n            if (!cpts || !cpts.length) {\n                return [];\n            }\n\n            var result;\n\n            if (index != null) {\n                if (!isArray(index)) {\n                    index = [index];\n                }\n                result = filter(map(index, function (idx) {\n                    return cpts[idx];\n                }), function (val) {\n                    return !!val;\n                });\n            }\n            else if (id != null) {\n                var isIdArray = isArray(id);\n                result = filter(cpts, function (cpt) {\n                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n                        || (!isIdArray && cpt.id === id);\n                });\n            }\n            else if (name != null) {\n                var isNameArray = isArray(name);\n                result = filter(cpts, function (cpt) {\n                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n                        || (!isNameArray && cpt.name === name);\n                });\n            }\n            else {\n                // Return all components with mainType\n                result = cpts.slice();\n            }\n\n            return filterBySubType(result, condition);\n        },\n\n        /**\n         * The interface is different from queryComponents,\n         * which is convenient for inner usage.\n         *\n         * @usage\n         * var result = findComponents(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series'},\n         *     function (model, index) {...}\n         * );\n         * // result like [component0, componnet1, ...]\n         *\n         * @param {Object} condition\n         * @param {string} condition.mainType Mandatory.\n         * @param {string} [condition.subType] Optional.\n         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n         *        where xxx is mainType.\n         *        If query attribute is null/undefined or has no index/id/name,\n         *        do not filtering by query conditions, which is convenient for\n         *        no-payload situations or when target of action is global.\n         * @param {Function} [condition.filter] parameter: component, return boolean.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        findComponents: function (condition) {\n            var query = condition.query;\n            var mainType = condition.mainType;\n\n            var queryCond = getQueryCond(query);\n            var result = queryCond\n                ? this.queryComponents(queryCond)\n                : this._componentsMap.get(mainType);\n\n            return doFilter(filterBySubType(result, condition));\n\n            function getQueryCond(q) {\n                var indexAttr = mainType + 'Index';\n                var idAttr = mainType + 'Id';\n                var nameAttr = mainType + 'Name';\n                return q && (\n                        q[indexAttr] != null\n                        || q[idAttr] != null\n                        || q[nameAttr] != null\n                    )\n                    ? {\n                        mainType: mainType,\n                        // subType will be filtered finally.\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    }\n                    : null;\n            }\n\n            function doFilter(res) {\n                return condition.filter\n                     ? filter(res, condition.filter)\n                     : res;\n            }\n        },\n\n        /**\n         * @usage\n         * eachComponent('legend', function (legendModel, index) {\n         *     ...\n         * });\n         * eachComponent(function (componentType, model, index) {\n         *     // componentType does not include subType\n         *     // (componentType is 'xxx' but not 'xxx.aa')\n         * });\n         * eachComponent(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n         *     function (model, index) {...}\n         * );\n         * eachComponent(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n         *     function (model, index) {...}\n         * );\n         *\n         * @param {string|Object=} mainType When mainType is object, the definition\n         *                                  is the same as the method 'findComponents'.\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachComponent: function (mainType, cb, context) {\n            var componentsMap = this._componentsMap;\n\n            if (typeof mainType === 'function') {\n                context = cb;\n                cb = mainType;\n                componentsMap.each(function (components, componentType) {\n                    each(components, function (component, index) {\n                        cb.call(context, componentType, component, index);\n                    });\n                });\n            }\n            else if (zrUtil.isString(mainType)) {\n                each(componentsMap.get(mainType), cb, context);\n            }\n            else if (isObject(mainType)) {\n                var queryResult = this.findComponents(mainType);\n                each(queryResult, cb, context);\n            }\n        },\n\n        /**\n         * @param {string} name\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByName: function (name) {\n            var series = this._componentsMap.get('series');\n            return filter(series, function (oneSeries) {\n                return oneSeries.name === name;\n            });\n        },\n\n        /**\n         * @param {number} seriesIndex\n         * @return {module:echarts/model/Series}\n         */\n        getSeriesByIndex: function (seriesIndex) {\n            return this._componentsMap.get('series')[seriesIndex];\n        },\n\n        /**\n         * @param {string} subType\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByType: function (subType) {\n            var series = this._componentsMap.get('series');\n            return filter(series, function (oneSeries) {\n                return oneSeries.subType === subType;\n            });\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeries: function () {\n            return this._componentsMap.get('series').slice();\n        },\n\n        /**\n         * After filtering, series may be different\n         * frome raw series.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.get('series')[rawSeriesIndex];\n                cb.call(context, series, rawSeriesIndex);\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeries: function (cb, context) {\n            each(this._componentsMap.get('series'), cb, context);\n        },\n\n        /**\n         * After filtering, series may be different.\n         * frome raw series.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeriesByType: function (subType, cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.get('series')[rawSeriesIndex];\n                if (series.subType === subType) {\n                    cb.call(context, series, rawSeriesIndex);\n                }\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered of given type.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeriesByType: function (subType, cb, context) {\n            return each(this.getSeriesByType(subType), cb, context);\n        },\n\n        /**\n         * @param {module:echarts/model/Series} seriesModel\n         */\n        isSeriesFiltered: function (seriesModel) {\n            assertSeriesInitialized(this);\n            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getCurrentSeriesIndices: function () {\n            return (this._seriesIndices || []).slice();\n        },\n\n        /**\n         * @param {Function} cb\n         * @param {*} context\n         */\n        filterSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            var filteredSeries = filter(\n                this._componentsMap.get('series'), cb, context\n            );\n            this._seriesIndices = createSeriesIndices(filteredSeries);\n        },\n\n        restoreData: function () {\n            var componentsMap = this._componentsMap;\n\n            this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n\n            var componentTypes = [];\n            componentsMap.each(function (components, componentType) {\n                componentTypes.push(componentType);\n            });\n\n            ComponentModel.topologicalTravel(\n                componentTypes,\n                ComponentModel.getAllClassMainTypes(),\n                function (componentType, dependencies) {\n                    each(componentsMap.get(componentType), function (component) {\n                        component.restoreData();\n                    });\n                }\n            );\n        }\n\n    });\n\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        zrUtil.each(theme, function (themeItem, name) {\n            // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n            if (!ComponentModel.hasClass(name)) {\n                if (typeof themeItem === 'object') {\n                    option[name] = !option[name]\n                        ? zrUtil.clone(themeItem)\n                        : zrUtil.merge(option[name], themeItem, false);\n                }\n                else {\n                    if (option[name] == null) {\n                        option[name] = themeItem;\n                    }\n                }\n            }\n        });\n    }\n\n    function initBase(baseOption) {\n        baseOption = baseOption;\n\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n\n        /**\n         * Init with series: [], in case of calling findSeries method\n         * before series initialized.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = zrUtil.createHashMap({series: []});\n\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n\n        mergeTheme(baseOption, this._theme.option);\n\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n\n        this.mergeOption(baseOption);\n    }\n\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap.get(type) || []).slice();\n        });\n\n        return ret;\n    }\n\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type\n            ? newCptOption.type\n            : existComponent\n            ? existComponent.subType\n            // Use determineSubType only when there is no existComponent.\n            : ComponentModel.determineSubType(mainType, newCptOption);\n\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType')\n            ? filter(components, function (cpt) {\n                return cpt.subType === condition.subType;\n            })\n            : components;\n    }\n\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (__DEV__) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Option should contains series.');\n            }\n        }\n    }\n\n    zrUtil.mixin(GlobalModel, __webpack_require__(90));\n\n    module.exports = GlobalModel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL21vZGVsL0dsb2JhbC5qcz9iOWQzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLHNCQUFzQjtBQUN6QyxtQkFBbUIsc0JBQXNCO0FBQ3pDLG1CQUFtQixzQkFBc0I7QUFDekMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBNEM7QUFDNUQ7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPLHlCQUF5Qix5QkFBeUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLGdCQUFnQiw4QkFBOEIsbUJBQW1CO0FBQ2pFLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsZ0JBQWdCLDRDQUE0QyxtQkFBbUI7QUFDL0Usd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsRUFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxvREFBb0QsV0FBVzs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDLGdCQUFnQixPQUFPLE9BQU8sT0FBTyxlQUFlLGVBQWU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVDaGFydHMgZ2xvYmFsIG1vZGVsXG4gKlxuICogQG1vZHVsZSB7ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gKi9cblxuXG5cbiAgICAvKipcbiAgICAgKiBDYXV0aW9uOiBJZiB0aGUgbWVjaGFuaXNtIHNob3VsZCBiZSBjaGFuZ2VkIHNvbWUgZGF5LCB0aGVzZSBjYXNlc1xuICAgICAqIHNob3VsZCBiZSBjb25zaWRlcmVkOlxuICAgICAqXG4gICAgICogKDEpIEluIGBtZXJnZSBvcHRpb25gIG1vZGUsIGlmIHVzaW5nIHRoZSBzYW1lIG9wdGlvbiB0byBjYWxsIGBzZXRPcHRpb25gXG4gICAgICogbWFueSB0aW1lcywgdGhlIHJlc3VsdCBzaG91bGQgYmUgdGhlIHNhbWUgKHRyeSBvdXIgYmVzdCB0byBlbnN1cmUgdGhhdCkuXG4gICAgICogKDIpIEluIGBtZXJnZSBvcHRpb25gIG1vZGUsIGlmIGEgY29tcG9uZW50IGhhcyBubyBpZC9uYW1lIHNwZWNpZmllZCwgaXRcbiAgICAgKiB3aWxsIGJlIG1lcmdlZCBieSBpbmRleCwgYW5kIHRoZSByZXN1bHQgc2VxdWVuY2Ugb2YgdGhlIGNvbXBvbmVudHMgaXNcbiAgICAgKiBjb25zaXN0ZW50IHRvIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZS5cbiAgICAgKiAoMykgYHJlc2V0YCBmZWF0dXJlIChpbiB0b29sYm94KS4gRmluZCBkZXRhaWxlZCBpbmZvIGluIGNvbW1lbnRzIGFib3V0XG4gICAgICogYG1lcmdlT3B0aW9uYCBpbiBtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9PcHRpb25NYW5hZ2VyLlxuICAgICAqL1xuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG4gICAgdmFyIGZpbHRlciA9IHpyVXRpbC5maWx0ZXI7XG4gICAgdmFyIG1hcCA9IHpyVXRpbC5tYXA7XG4gICAgdmFyIGlzQXJyYXkgPSB6clV0aWwuaXNBcnJheTtcbiAgICB2YXIgaW5kZXhPZiA9IHpyVXRpbC5pbmRleE9mO1xuICAgIHZhciBpc09iamVjdCA9IHpyVXRpbC5pc09iamVjdDtcblxuICAgIHZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50Jyk7XG5cbiAgICB2YXIgZ2xvYmFsRGVmYXVsdCA9IHJlcXVpcmUoJy4vZ2xvYmFsRGVmYXVsdCcpO1xuXG4gICAgdmFyIE9QVElPTl9JTk5FUl9LRVkgPSAnXFwwX2VjX2lubmVyJztcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBwYXJlbnRNb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aGVtZVxuICAgICAqL1xuICAgIHZhciBHbG9iYWxNb2RlbCA9IE1vZGVsLmV4dGVuZCh7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEdsb2JhbE1vZGVsLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCB0aGVtZSwgb3B0aW9uTWFuYWdlcikge1xuICAgICAgICAgICAgdGhlbWUgPSB0aGVtZSB8fCB7fTtcblxuICAgICAgICAgICAgdGhpcy5vcHRpb24gPSBudWxsOyAvLyBNYXJrIGFzIG5vdCBpbml0aWFsaXplZC5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl90aGVtZSA9IG5ldyBNb2RlbCh0aGVtZSk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL09wdGlvbk1hbmFnZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX29wdGlvbk1hbmFnZXIgPSBvcHRpb25NYW5hZ2VyO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldE9wdGlvbjogZnVuY3Rpb24gKG9wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MpIHtcbiAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoXG4gICAgICAgICAgICAgICAgIShPUFRJT05fSU5ORVJfS0VZIGluIG9wdGlvbiksXG4gICAgICAgICAgICAgICAgJ3BsZWFzZSB1c2UgY2hhcnQuZ2V0T3B0aW9uKCknXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25NYW5hZ2VyLnNldE9wdGlvbihvcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzKTtcblxuICAgICAgICAgICAgdGhpcy5yZXNldE9wdGlvbihudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgbnVsbC91bmRlZmluZWQ6IHJlc2V0IGFsbC5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgJ3JlY3JlYXRlJzogZm9yY2UgcmVjcmVhdGUgYWxsLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAndGltZWxpbmUnOiBvbmx5IHJlc2V0IHRpbWVsaW5lIG9wdGlvblxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAnbWVkaWEnOiBvbmx5IHJlc2V0IG1lZGlhIHF1ZXJ5IG9wdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9wdGlvbiBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVzZXRPcHRpb246IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIG9wdGlvbk1hbmFnZXIgPSB0aGlzLl9vcHRpb25NYW5hZ2VyO1xuXG4gICAgICAgICAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3JlY3JlYXRlJykge1xuICAgICAgICAgICAgICAgIHZhciBiYXNlT3B0aW9uID0gb3B0aW9uTWFuYWdlci5tb3VudE9wdGlvbih0eXBlID09PSAncmVjcmVhdGUnKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb24gfHwgdHlwZSA9PT0gJ3JlY3JlYXRlJykge1xuICAgICAgICAgICAgICAgICAgICBpbml0QmFzZS5jYWxsKHRoaXMsIGJhc2VPcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlT3B0aW9uKGJhc2VPcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICd0aW1lbGluZScgfHwgdHlwZSA9PT0gJ21lZGlhJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZURhdGEoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICdyZWNyZWF0ZScgfHwgdHlwZSA9PT0gJ3RpbWVsaW5lJykge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZU9wdGlvbiA9IG9wdGlvbk1hbmFnZXIuZ2V0VGltZWxpbmVPcHRpb24odGhpcyk7XG4gICAgICAgICAgICAgICAgdGltZWxpbmVPcHRpb24gJiYgKHRoaXMubWVyZ2VPcHRpb24odGltZWxpbmVPcHRpb24pLCBvcHRpb25DaGFuZ2VkID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAncmVjcmVhdGUnIHx8IHR5cGUgPT09ICdtZWRpYScpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVkaWFPcHRpb25zID0gb3B0aW9uTWFuYWdlci5nZXRNZWRpYU9wdGlvbih0aGlzLCB0aGlzLl9hcGkpO1xuICAgICAgICAgICAgICAgIGlmIChtZWRpYU9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVhY2gobWVkaWFPcHRpb25zLCBmdW5jdGlvbiAobWVkaWFPcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VPcHRpb24obWVkaWFPcHRpb24sIG9wdGlvbkNoYW5nZWQgPSB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uQ2hhbmdlZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdPcHRpb24pIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRzTWFwID0gdGhpcy5fY29tcG9uZW50c01hcDtcbiAgICAgICAgICAgIHZhciBuZXdDcHRUeXBlcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyDlpoLmnpzkuI3lrZjlnKjlr7nlupTnmoQgY29tcG9uZW50IG1vZGVsIOWImeebtOaOpSBtZXJnZVxuICAgICAgICAgICAgZWFjaChuZXdPcHRpb24sIGZ1bmN0aW9uIChjb21wb25lbnRPcHRpb24sIG1haW5UeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudE9wdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIUNvbXBvbmVudE1vZGVsLmhhc0NsYXNzKG1haW5UeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25bbWFpblR5cGVdID0gb3B0aW9uW21haW5UeXBlXSA9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHpyVXRpbC5jbG9uZShjb21wb25lbnRPcHRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHpyVXRpbC5tZXJnZShvcHRpb25bbWFpblR5cGVdLCBjb21wb25lbnRPcHRpb24sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q3B0VHlwZXMucHVzaChtYWluVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FIE9QVElPTiDlkIzmraXmmK/lkKbopoHmlLnlm57ljp/mnaXnmoRcbiAgICAgICAgICAgIENvbXBvbmVudE1vZGVsLnRvcG9sb2dpY2FsVHJhdmVsKFxuICAgICAgICAgICAgICAgIG5ld0NwdFR5cGVzLCBDb21wb25lbnRNb2RlbC5nZXRBbGxDbGFzc01haW5UeXBlcygpLCB2aXNpdENvbXBvbmVudCwgdGhpc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5fc2VyaWVzSW5kaWNlcyA9IHRoaXMuX3Nlcmllc0luZGljZXMgfHwgW107XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHZpc2l0Q29tcG9uZW50KG1haW5UeXBlLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q3B0T3B0aW9uTGlzdCA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KG5ld09wdGlvblttYWluVHlwZV0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1hcFJlc3VsdCA9IG1vZGVsVXRpbC5tYXBwaW5nVG9FeGlzdHMoXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKSwgbmV3Q3B0T3B0aW9uTGlzdFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBtb2RlbFV0aWwubWFrZUlkQW5kTmFtZShtYXBSZXN1bHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0IG1haW5UeXBlIGFuZCBjb21wbGV0ZSBzdWJUeXBlLlxuICAgICAgICAgICAgICAgIGVhY2gobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdCA9IGl0ZW0ub3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5rZXlJbmZvLm1haW5UeXBlID0gbWFpblR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmtleUluZm8uc3ViVHlwZSA9IGRldGVybWluZVN1YlR5cGUobWFpblR5cGUsIG9wdCwgaXRlbS5leGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBkZXBlbmRlbnRNb2RlbHMgPSBnZXRDb21wb25lbnRzQnlUeXBlcyhcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50c01hcCwgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvblttYWluVHlwZV0gPSBbXTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzTWFwLnNldChtYWluVHlwZSwgW10pO1xuXG4gICAgICAgICAgICAgICAgZWFjaChtYXBSZXN1bHQsIGZ1bmN0aW9uIChyZXN1bHRJdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50TW9kZWwgPSByZXN1bHRJdGVtLmV4aXN0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q3B0T3B0aW9uID0gcmVzdWx0SXRlbS5vcHRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgenJVdGlsLmFzc2VydChcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0KG5ld0NwdE9wdGlvbikgfHwgY29tcG9uZW50TW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRW1wdHkgY29tcG9uZW50IGRlZmluaXRpb24nXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgd2hlcmUgaXMgbm8gbmV3IG9wdGlvbiBhbmQgc2hvdWxkIGJlIG1lcmdlZCB1c2luZyB7fSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VlIHJlbW92ZUVkZ2VBbmRBZGQgaW4gdG9wb2xvZ2ljYWxUcmF2ZWwgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXBvbmVudE1vZGVsLmdldEFsbENsYXNzTWFpblR5cGVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld0NwdE9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwubWVyZ2VPcHRpb24oe30sIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwub3B0aW9uVXBkYXRlZCh7fSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIENvbXBvbmVudE1vZGVsQ2xhc3MgPSBDb21wb25lbnRNb2RlbC5nZXRDbGFzcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluVHlwZSwgcmVzdWx0SXRlbS5rZXlJbmZvLnN1YlR5cGUsIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRNb2RlbCAmJiBjb21wb25lbnRNb2RlbCBpbnN0YW5jZW9mIENvbXBvbmVudE1vZGVsQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5uYW1lID0gcmVzdWx0SXRlbS5rZXlJbmZvLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwubWVyZ2VPcHRpb24obmV3Q3B0T3B0aW9uLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5vcHRpb25VcGRhdGVkKG5ld0NwdE9wdGlvbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUEVORElORyBHbG9iYWwgYXMgcGFyZW50ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXh0cmFPcHQgPSB6clV0aWwuZXh0ZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbnRNb2RlbHM6IGRlcGVuZGVudE1vZGVscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRJdGVtLmtleUluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsID0gbmV3IENvbXBvbmVudE1vZGVsQ2xhc3MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NwdE9wdGlvbiwgdGhpcywgdGhpcywgZXh0cmFPcHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpyVXRpbC5leHRlbmQoY29tcG9uZW50TW9kZWwsIGV4dHJhT3B0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5pbml0KG5ld0NwdE9wdGlvbiwgdGhpcywgdGhpcywgZXh0cmFPcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgb3B0aW9uVXBkYXRlZCBhZnRlciBpbml0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ld0NwdE9wdGlvbiBoYXMgYmVlbiB1c2VkIGFzIGNvbXBvbmVudE1vZGVsLm9wdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBtYXkgYmUgbWVyZ2VkIHdpdGggdGhlbWUgYW5kIGRlZmF1bHQsIHNvIHBhc3MgbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIGNvbmZ1c2lvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5vcHRpb25VcGRhdGVkKG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50c01hcC5nZXQobWFpblR5cGUpW2luZGV4XSA9IGNvbXBvbmVudE1vZGVsO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25bbWFpblR5cGVdW2luZGV4XSA9IGNvbXBvbmVudE1vZGVsLm9wdGlvbjtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAgIC8vIEJhY2t1cCBzZXJpZXMgZm9yIGZpbHRlcmluZy5cbiAgICAgICAgICAgICAgICBpZiAobWFpblR5cGUgPT09ICdzZXJpZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nlcmllc0luZGljZXMgPSBjcmVhdGVTZXJpZXNJbmRpY2VzKGNvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgb3B0aW9uIGZvciBvdXRwdXQgKGNsb25lZCBvcHRpb24gYW5kIGlubmVyIGluZm8gcmVtb3ZlZClcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRPcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB6clV0aWwuY2xvbmUodGhpcy5vcHRpb24pO1xuXG4gICAgICAgICAgICBlYWNoKG9wdGlvbiwgZnVuY3Rpb24gKG9wdHMsIG1haW5UeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKENvbXBvbmVudE1vZGVsLmhhc0NsYXNzKG1haW5UeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gb3B0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9wdGlvbnMgd2l0aCBpbm5lciBpZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbFV0aWwuaXNJZElubmVyKG9wdHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uW21haW5UeXBlXSA9IG9wdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25bT1BUSU9OX0lOTkVSX0tFWV07XG5cbiAgICAgICAgICAgIHJldHVybiBvcHRpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGhlbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aGVtZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG1haW5UeXBlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaWR4PTBdXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH1cbiAgICAgICAgICovXG4gICAgICAgIGdldENvbXBvbmVudDogZnVuY3Rpb24gKG1haW5UeXBlLCBpZHgpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQobWFpblR5cGUpO1xuICAgICAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdFtpZHggfHwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG5vbmUgb2YgaW5kZXggYW5kIGlkIGFuZCBuYW1lIHVzZWQsIHJldHVybiBhbGwgY29tcG9uZW50cyB3aXRoIG1haW5UeXBlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZGl0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb25kaXRpb24ubWFpblR5cGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25kaXRpb24uc3ViVHlwZV0gSWYgaWdub3JlLCBvbmx5IHF1ZXJ5IGJ5IG1haW5UeXBlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBbY29uZGl0aW9uLmluZGV4XSBFaXRoZXIgaW5wdXQgaW5kZXggb3IgaWQgb3IgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtjb25kaXRpb24uaWRdIEVpdGhlciBpbnB1dCBpbmRleCBvciBpZCBvciBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2NvbmRpdGlvbi5uYW1lXSBFaXRoZXIgaW5wdXQgaW5kZXggb3IgaWQgb3IgbmFtZS5cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudD59XG4gICAgICAgICAqL1xuICAgICAgICBxdWVyeUNvbXBvbmVudHM6IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBtYWluVHlwZSA9IGNvbmRpdGlvbi5tYWluVHlwZTtcbiAgICAgICAgICAgIGlmICghbWFpblR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmRleCA9IGNvbmRpdGlvbi5pbmRleDtcbiAgICAgICAgICAgIHZhciBpZCA9IGNvbmRpdGlvbi5pZDtcbiAgICAgICAgICAgIHZhciBuYW1lID0gY29uZGl0aW9uLm5hbWU7XG5cbiAgICAgICAgICAgIHZhciBjcHRzID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQobWFpblR5cGUpO1xuXG4gICAgICAgICAgICBpZiAoIWNwdHMgfHwgIWNwdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBbaW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmaWx0ZXIobWFwKGluZGV4LCBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcHRzW2lkeF07XG4gICAgICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdmFsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBpc0lkQXJyYXkgPSBpc0FycmF5KGlkKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmaWx0ZXIoY3B0cywgZnVuY3Rpb24gKGNwdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGlzSWRBcnJheSAmJiBpbmRleE9mKGlkLCBjcHQuaWQpID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAoIWlzSWRBcnJheSAmJiBjcHQuaWQgPT09IGlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBpc05hbWVBcnJheSA9IGlzQXJyYXkobmFtZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlsdGVyKGNwdHMsIGZ1bmN0aW9uIChjcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpc05hbWVBcnJheSAmJiBpbmRleE9mKG5hbWUsIGNwdC5uYW1lKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKCFpc05hbWVBcnJheSAmJiBjcHQubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYWxsIGNvbXBvbmVudHMgd2l0aCBtYWluVHlwZVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNwdHMuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckJ5U3ViVHlwZShyZXN1bHQsIGNvbmRpdGlvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbnRlcmZhY2UgaXMgZGlmZmVyZW50IGZyb20gcXVlcnlDb21wb25lbnRzLFxuICAgICAgICAgKiB3aGljaCBpcyBjb252ZW5pZW50IGZvciBpbm5lciB1c2FnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHVzYWdlXG4gICAgICAgICAqIHZhciByZXN1bHQgPSBmaW5kQ29tcG9uZW50cyhcbiAgICAgICAgICogICAgIHttYWluVHlwZTogJ2RhdGFab29tJywgcXVlcnk6IHtkYXRhWm9vbUlkOiAnYWJjJ319XG4gICAgICAgICAqICk7XG4gICAgICAgICAqIHZhciByZXN1bHQgPSBmaW5kQ29tcG9uZW50cyhcbiAgICAgICAgICogICAgIHttYWluVHlwZTogJ3NlcmllcycsIHN1YlR5cGU6ICdwaWUnLCBxdWVyeToge3Nlcmllc05hbWU6ICd1aW8nfX1cbiAgICAgICAgICogKTtcbiAgICAgICAgICogdmFyIHJlc3VsdCA9IGZpbmRDb21wb25lbnRzKFxuICAgICAgICAgKiAgICAge21haW5UeXBlOiAnc2VyaWVzJ30sXG4gICAgICAgICAqICAgICBmdW5jdGlvbiAobW9kZWwsIGluZGV4KSB7Li4ufVxuICAgICAgICAgKiApO1xuICAgICAgICAgKiAvLyByZXN1bHQgbGlrZSBbY29tcG9uZW50MCwgY29tcG9ubmV0MSwgLi4uXVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZGl0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb25kaXRpb24ubWFpblR5cGUgTWFuZGF0b3J5LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmRpdGlvbi5zdWJUeXBlXSBPcHRpb25hbC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25kaXRpb24ucXVlcnldIGxpa2Uge3h4eEluZGV4LCB4eHhJZCwgeHh4TmFtZX0sXG4gICAgICAgICAqICAgICAgICB3aGVyZSB4eHggaXMgbWFpblR5cGUuXG4gICAgICAgICAqICAgICAgICBJZiBxdWVyeSBhdHRyaWJ1dGUgaXMgbnVsbC91bmRlZmluZWQgb3IgaGFzIG5vIGluZGV4L2lkL25hbWUsXG4gICAgICAgICAqICAgICAgICBkbyBub3QgZmlsdGVyaW5nIGJ5IHF1ZXJ5IGNvbmRpdGlvbnMsIHdoaWNoIGlzIGNvbnZlbmllbnQgZm9yXG4gICAgICAgICAqICAgICAgICBuby1wYXlsb2FkIHNpdHVhdGlvbnMgb3Igd2hlbiB0YXJnZXQgb2YgYWN0aW9uIGlzIGdsb2JhbC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmRpdGlvbi5maWx0ZXJdIHBhcmFtZXRlcjogY29tcG9uZW50LCByZXR1cm4gYm9vbGVhbi5cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudD59XG4gICAgICAgICAqL1xuICAgICAgICBmaW5kQ29tcG9uZW50czogZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gY29uZGl0aW9uLnF1ZXJ5O1xuICAgICAgICAgICAgdmFyIG1haW5UeXBlID0gY29uZGl0aW9uLm1haW5UeXBlO1xuXG4gICAgICAgICAgICB2YXIgcXVlcnlDb25kID0gZ2V0UXVlcnlDb25kKHF1ZXJ5KTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBxdWVyeUNvbmRcbiAgICAgICAgICAgICAgICA/IHRoaXMucXVlcnlDb21wb25lbnRzKHF1ZXJ5Q29uZClcbiAgICAgICAgICAgICAgICA6IHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGRvRmlsdGVyKGZpbHRlckJ5U3ViVHlwZShyZXN1bHQsIGNvbmRpdGlvbikpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRRdWVyeUNvbmQocSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleEF0dHIgPSBtYWluVHlwZSArICdJbmRleCc7XG4gICAgICAgICAgICAgICAgdmFyIGlkQXR0ciA9IG1haW5UeXBlICsgJ0lkJztcbiAgICAgICAgICAgICAgICB2YXIgbmFtZUF0dHIgPSBtYWluVHlwZSArICdOYW1lJztcbiAgICAgICAgICAgICAgICByZXR1cm4gcSAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBxW2luZGV4QXR0cl0gIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgcVtpZEF0dHJdICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IHFbbmFtZUF0dHJdICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5UeXBlOiBtYWluVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1YlR5cGUgd2lsbCBiZSBmaWx0ZXJlZCBmaW5hbGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHFbaW5kZXhBdHRyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBxW2lkQXR0cl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBxW25hbWVBdHRyXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZG9GaWx0ZXIocmVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbi5maWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgID8gZmlsdGVyKHJlcywgY29uZGl0aW9uLmZpbHRlcilcbiAgICAgICAgICAgICAgICAgICAgIDogcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdXNhZ2VcbiAgICAgICAgICogZWFjaENvbXBvbmVudCgnbGVnZW5kJywgZnVuY3Rpb24gKGxlZ2VuZE1vZGVsLCBpbmRleCkge1xuICAgICAgICAgKiAgICAgLi4uXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBlYWNoQ29tcG9uZW50KGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBtb2RlbCwgaW5kZXgpIHtcbiAgICAgICAgICogICAgIC8vIGNvbXBvbmVudFR5cGUgZG9lcyBub3QgaW5jbHVkZSBzdWJUeXBlXG4gICAgICAgICAqICAgICAvLyAoY29tcG9uZW50VHlwZSBpcyAneHh4JyBidXQgbm90ICd4eHguYWEnKVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogZWFjaENvbXBvbmVudChcbiAgICAgICAgICogICAgIHttYWluVHlwZTogJ2RhdGFab29tJywgcXVlcnk6IHtkYXRhWm9vbUlkOiAnYWJjJ319LFxuICAgICAgICAgKiAgICAgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkgey4uLn1cbiAgICAgICAgICogKTtcbiAgICAgICAgICogZWFjaENvbXBvbmVudChcbiAgICAgICAgICogICAgIHttYWluVHlwZTogJ3NlcmllcycsIHN1YlR5cGU6ICdwaWUnLCBxdWVyeToge3Nlcmllc05hbWU6ICd1aW8nfX0sXG4gICAgICAgICAqICAgICBmdW5jdGlvbiAobW9kZWwsIGluZGV4KSB7Li4ufVxuICAgICAgICAgKiApO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3Q9fSBtYWluVHlwZSBXaGVuIG1haW5UeXBlIGlzIG9iamVjdCwgdGhlIGRlZmluaXRpb25cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdGhlIHNhbWUgYXMgdGhlIG1ldGhvZCAnZmluZENvbXBvbmVudHMnLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGVhY2hDb21wb25lbnQ6IGZ1bmN0aW9uIChtYWluVHlwZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRzTWFwID0gdGhpcy5fY29tcG9uZW50c01hcDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtYWluVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjYjtcbiAgICAgICAgICAgICAgICBjYiA9IG1haW5UeXBlO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNNYXAuZWFjaChmdW5jdGlvbiAoY29tcG9uZW50cywgY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBlYWNoKGNvbXBvbmVudHMsIGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGNvbXBvbmVudFR5cGUsIGNvbXBvbmVudCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHpyVXRpbC5pc1N0cmluZyhtYWluVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBlYWNoKGNvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKSwgY2IsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QobWFpblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5UmVzdWx0ID0gdGhpcy5maW5kQ29tcG9uZW50cyhtYWluVHlwZSk7XG4gICAgICAgICAgICAgICAgZWFjaChxdWVyeVJlc3VsdCwgY2IsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFNlcmllc0J5TmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzZXJpZXMgPSB0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJyk7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyKHNlcmllcywgZnVuY3Rpb24gKG9uZVNlcmllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbmVTZXJpZXMubmFtZSA9PT0gbmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2VyaWVzSW5kZXhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VyaWVzQnlJbmRleDogZnVuY3Rpb24gKHNlcmllc0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpW3Nlcmllc0luZGV4XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN1YlR5cGVcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZXJpZXNCeVR5cGU6IGZ1bmN0aW9uIChzdWJUeXBlKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcihzZXJpZXMsIGZ1bmN0aW9uIChvbmVTZXJpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25lU2VyaWVzLnN1YlR5cGUgPT09IHN1YlR5cGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZXJpZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJykuc2xpY2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWZ0ZXIgZmlsdGVyaW5nLCBzZXJpZXMgbWF5IGJlIGRpZmZlcmVudFxuICAgICAgICAgKiBmcm9tZSByYXcgc2VyaWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGVhY2hTZXJpZXM6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgYXNzZXJ0U2VyaWVzSW5pdGlhbGl6ZWQodGhpcyk7XG4gICAgICAgICAgICBlYWNoKHRoaXMuX3Nlcmllc0luZGljZXMsIGZ1bmN0aW9uIChyYXdTZXJpZXNJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXMgPSB0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJylbcmF3U2VyaWVzSW5kZXhdO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgc2VyaWVzLCByYXdTZXJpZXNJbmRleCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXRlcmF0ZSByYXcgc2VyaWVzIGJlZm9yZSBmaWx0ZXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBlYWNoUmF3U2VyaWVzOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGVhY2godGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpLCBjYiwgY29udGV4dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFmdGVyIGZpbHRlcmluZywgc2VyaWVzIG1heSBiZSBkaWZmZXJlbnQuXG4gICAgICAgICAqIGZyb21lIHJhdyBzZXJpZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJtYSB7c3RyaW5nfSBzdWJUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaFNlcmllc0J5VHlwZTogZnVuY3Rpb24gKHN1YlR5cGUsIGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICAgICAgICAgIGVhY2godGhpcy5fc2VyaWVzSW5kaWNlcywgZnVuY3Rpb24gKHJhd1Nlcmllc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcmllcyA9IHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKVtyYXdTZXJpZXNJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHNlcmllcy5zdWJUeXBlID09PSBzdWJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgc2VyaWVzLCByYXdTZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgcmF3IHNlcmllcyBiZWZvcmUgZmlsdGVyZWQgb2YgZ2l2ZW4gdHlwZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcm1hIHtzdHJpbmd9IHN1YlR5cGVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBlYWNoUmF3U2VyaWVzQnlUeXBlOiBmdW5jdGlvbiAoc3ViVHlwZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBlYWNoKHRoaXMuZ2V0U2VyaWVzQnlUeXBlKHN1YlR5cGUpLCBjYiwgY29udGV4dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgICAgICAgKi9cbiAgICAgICAgaXNTZXJpZXNGaWx0ZXJlZDogZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB6clV0aWwuaW5kZXhPZih0aGlzLl9zZXJpZXNJbmRpY2VzLCBzZXJpZXNNb2RlbC5jb21wb25lbnRJbmRleCkgPCAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEN1cnJlbnRTZXJpZXNJbmRpY2VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX3Nlcmllc0luZGljZXMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyU2VyaWVzOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGFzc2VydFNlcmllc0luaXRpYWxpemVkKHRoaXMpO1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkU2VyaWVzID0gZmlsdGVyKFxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKSwgY2IsIGNvbnRleHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9zZXJpZXNJbmRpY2VzID0gY3JlYXRlU2VyaWVzSW5kaWNlcyhmaWx0ZXJlZFNlcmllcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzdG9yZURhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRzTWFwID0gdGhpcy5fY29tcG9uZW50c01hcDtcblxuICAgICAgICAgICAgdGhpcy5fc2VyaWVzSW5kaWNlcyA9IGNyZWF0ZVNlcmllc0luZGljZXMoY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpKTtcblxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudFR5cGVzID0gW107XG4gICAgICAgICAgICBjb21wb25lbnRzTWFwLmVhY2goZnVuY3Rpb24gKGNvbXBvbmVudHMsIGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRUeXBlcy5wdXNoKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIENvbXBvbmVudE1vZGVsLnRvcG9sb2dpY2FsVHJhdmVsKFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGVzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudE1vZGVsLmdldEFsbENsYXNzTWFpblR5cGVzKCksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUsIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgICAgICBlYWNoKGNvbXBvbmVudHNNYXAuZ2V0KGNvbXBvbmVudFR5cGUpLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQucmVzdG9yZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZVRoZW1lKG9wdGlvbiwgdGhlbWUpIHtcbiAgICAgICAgenJVdGlsLmVhY2godGhlbWUsIGZ1bmN0aW9uICh0aGVtZUl0ZW0sIG5hbWUpIHtcbiAgICAgICAgICAgIC8vIOWmguaenOaciSBjb21wb25lbnQgbW9kZWwg5YiZ5oqK5YW35L2T55qEIG1lcmdlIOmAu+i+keS6pOe7meivpSBtb2RlbCDlpITnkIZcbiAgICAgICAgICAgIGlmICghQ29tcG9uZW50TW9kZWwuaGFzQ2xhc3MobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoZW1lSXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uW25hbWVdID0gIW9wdGlvbltuYW1lXVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB6clV0aWwuY2xvbmUodGhlbWVJdGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB6clV0aWwubWVyZ2Uob3B0aW9uW25hbWVdLCB0aGVtZUl0ZW0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25bbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uW25hbWVdID0gdGhlbWVJdGVtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0QmFzZShiYXNlT3B0aW9uKSB7XG4gICAgICAgIGJhc2VPcHRpb24gPSBiYXNlT3B0aW9uO1xuXG4gICAgICAgIC8vIFVzaW5nIE9QVElPTl9JTk5FUl9LRVkgdG8gbWFyayB0aGF0IHRoaXMgb3B0aW9uIGNhbiBub3QgYmUgdXNlZCBvdXRzaWRlLFxuICAgICAgICAvLyBpLmUuIGBjaGFydC5zZXRPcHRpb24oY2hhcnQuZ2V0TW9kZWwoKS5vcHRpb24pO2AgaXMgZm9yYmlkZW4uXG4gICAgICAgIHRoaXMub3B0aW9uID0ge307XG4gICAgICAgIHRoaXMub3B0aW9uW09QVElPTl9JTk5FUl9LRVldID0gMTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdCB3aXRoIHNlcmllczogW10sIGluIGNhc2Ugb2YgY2FsbGluZyBmaW5kU2VyaWVzIG1ldGhvZFxuICAgICAgICAgKiBiZWZvcmUgc2VyaWVzIGluaXRpYWxpemVkLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIEFycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD4+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29tcG9uZW50c01hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKHtzZXJpZXM6IFtdfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcHBpbmcgYmV0d2VlbiBmaWx0ZXJlZCBzZXJpZXMgbGlzdCBhbmQgcmF3IHNlcmllcyBsaXN0LlxuICAgICAgICAgKiBrZXk6IGZpbHRlcmVkIHNlcmllcyBpbmRpY2VzLCB2YWx1ZTogcmF3IHNlcmllcyBpbmRpY2VzLlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51Ym1lcj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zZXJpZXNJbmRpY2VzID0gbnVsbDtcblxuICAgICAgICBtZXJnZVRoZW1lKGJhc2VPcHRpb24sIHRoaXMuX3RoZW1lLm9wdGlvbik7XG5cbiAgICAgICAgLy8gVE9ETyBOZWVkcyBjbG9uZSB3aGVuIG1lcmdpbmcgdG8gdGhlIHVuZXhpc3RlZCBwcm9wZXJ0eVxuICAgICAgICB6clV0aWwubWVyZ2UoYmFzZU9wdGlvbiwgZ2xvYmFsRGVmYXVsdCwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMubWVyZ2VPcHRpb24oYmFzZU9wdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPnxzdHJpbmd9IHR5cGVzIG1vZGVsIHR5cGVzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBrZXk6IHtzdHJpbmd9IHR5cGUsIHZhbHVlOiB7QXJyYXkuPE9iamVjdD59IG1vZGVsc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudHNCeVR5cGVzKGNvbXBvbmVudHNNYXAsIHR5cGVzKSB7XG4gICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkodHlwZXMpKSB7XG4gICAgICAgICAgICB0eXBlcyA9IHR5cGVzID8gW3R5cGVzXSA6IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgICBlYWNoKHR5cGVzLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0W3R5cGVdID0gKGNvbXBvbmVudHNNYXAuZ2V0KHR5cGUpIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRldGVybWluZVN1YlR5cGUobWFpblR5cGUsIG5ld0NwdE9wdGlvbiwgZXhpc3RDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIHN1YlR5cGUgPSBuZXdDcHRPcHRpb24udHlwZVxuICAgICAgICAgICAgPyBuZXdDcHRPcHRpb24udHlwZVxuICAgICAgICAgICAgOiBleGlzdENvbXBvbmVudFxuICAgICAgICAgICAgPyBleGlzdENvbXBvbmVudC5zdWJUeXBlXG4gICAgICAgICAgICAvLyBVc2UgZGV0ZXJtaW5lU3ViVHlwZSBvbmx5IHdoZW4gdGhlcmUgaXMgbm8gZXhpc3RDb21wb25lbnQuXG4gICAgICAgICAgICA6IENvbXBvbmVudE1vZGVsLmRldGVybWluZVN1YlR5cGUobWFpblR5cGUsIG5ld0NwdE9wdGlvbik7XG5cbiAgICAgICAgLy8gdG9vbHRpcCwgbWFya2xpbmUsIG1hcmtwb2ludCBtYXkgYWx3YXlzIGhhcyBubyBzdWJUeXBlXG4gICAgICAgIHJldHVybiBzdWJUeXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVNlcmllc0luZGljZXMoc2VyaWVzTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiBtYXAoc2VyaWVzTW9kZWxzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzLmNvbXBvbmVudEluZGV4O1xuICAgICAgICB9KSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXJCeVN1YlR5cGUoY29tcG9uZW50cywgY29uZGl0aW9uKSB7XG4gICAgICAgIC8vIFVzaW5nIGhhc093blByb3BlcnR5IGZvciByZXN0cmljdC4gQ29uc2lkZXJcbiAgICAgICAgLy8gc3ViVHlwZSBpcyB1bmRlZmluZWQgaW4gdXNlciBwYXlsb2FkLlxuICAgICAgICByZXR1cm4gY29uZGl0aW9uLmhhc093blByb3BlcnR5KCdzdWJUeXBlJylcbiAgICAgICAgICAgID8gZmlsdGVyKGNvbXBvbmVudHMsIGZ1bmN0aW9uIChjcHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3B0LnN1YlR5cGUgPT09IGNvbmRpdGlvbi5zdWJUeXBlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogY29tcG9uZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlcnRTZXJpZXNJbml0aWFsaXplZChlY01vZGVsKSB7XG4gICAgICAgIC8vIENvbXBvbmVudHMgdGhhdCB1c2UgX3Nlcmllc0luZGljZXMgc2hvdWxkIGRlcGVuZHMgb24gc2VyaWVzIGNvbXBvbmVudCxcbiAgICAgICAgLy8gd2hpY2ggbWFrZSBzdXJlIHRoYXQgdGhlaXIgaW5pdGlhbGl6YXRpb24gaXMgYWZ0ZXIgc2VyaWVzLlxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgaWYgKCFlY01vZGVsLl9zZXJpZXNJbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gc2hvdWxkIGNvbnRhaW5zIHNlcmllcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHpyVXRpbC5taXhpbihHbG9iYWxNb2RlbCwgcmVxdWlyZSgnLi9taXhpbi9jb2xvclBhbGV0dGUnKSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdsb2JhbE1vZGVsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL21vZGVsL0dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports){eval("/**\n * @module zrender/core/util\n */\n\n\n    // 用于处理merge时无法遍历Date等对象的问题\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuiltInObject(sourceProp)\n                    && !isBuiltInObject(targetProp)\n                    && !isPrimitive(sourceProp)\n                    && !isPrimitive(targetProp)\n                ) {\n                    // 如果需要递归覆盖，就递归调用merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * 查询数组中元素的index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * 构造类继承关系\n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz 源类\n     * @param {Function} baseClazz 基类\n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * Consider typed array.\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * 数组或对象遍历\n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * 数组映射\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * 数组过滤\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * 数组项查找\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuiltInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * Whether is exactly NaN. Notice isNaN('a') returns true.\n     * @param {*} value\n     * @return {boolean}\n     */\n    function eqNaN(value) {\n        return value !== value;\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var primitiveKey = '__ec_primitive__';\n    /**\n     * Set an object as primitive to be ignored traversing children in clone or merge\n     */\n    function setAsPrimitive(obj) {\n        obj[primitiveKey] = true;\n    }\n\n    function isPrimitive(obj) {\n        return obj[primitiveKey];\n    }\n\n    /**\n     * @constructor\n     * @param {Object} obj Only apply `ownProperty`.\n     */\n    function HashMap(obj) {\n        obj && each(obj, function (value, key) {\n            this.set(key, value);\n        }, this);\n    }\n\n    // Add prefix to avoid conflict with Object.prototype.\n    var HASH_MAP_PREFIX = '_ec_';\n    var HASH_MAP_PREFIX_LENGTH = 4;\n\n    HashMap.prototype = {\n        constructor: HashMap,\n        // Do not provide `has` method to avoid defining what is `has`.\n        // (We usually treat `null` and `undefined` as the same, different\n        // from ES6 Map).\n        get: function (key) {\n            return this[HASH_MAP_PREFIX + key];\n        },\n        set: function (key, value) {\n            this[HASH_MAP_PREFIX + key] = value;\n            // Comparing with invocation chaining, `return value` is more commonly\n            // used in this case: `var someVal = map.set('a', genVal());`\n            return value;\n        },\n        // Although util.each can be performed on this hashMap directly, user\n        // should not use the exposed keys, who are prefixed.\n        each: function (cb, context) {\n            context !== void 0 && (cb = bind(cb, context));\n            for (var prefixedKey in this) {\n                this.hasOwnProperty(prefixedKey)\n                    && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n            }\n        },\n        // Do not use this method if performance sensitive.\n        removeKey: function (key) {\n            delete this[key];\n        }\n    };\n\n    function createHashMap(obj) {\n        return new HashMap(obj);\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuiltInObject: isBuiltInObject,\n        isDom: isDom,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        assert: assert,\n        setAsPrimitive: setAsPrimitive,\n        createHashMap: createHashMap,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcz8xMGY0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQixFQUFFO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsU0FBUztBQUN4QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS91dGlsXG4gKi9cblxuXG4gICAgLy8g55So5LqO5aSE55CGbWVyZ2Xml7bml6Dms5XpgY3ljoZEYXRl562J5a+56LGh55qE6Zeu6aKYXG4gICAgdmFyIEJVSUxUSU5fT0JKRUNUID0ge1xuICAgICAgICAnW29iamVjdCBGdW5jdGlvbl0nOiAxLFxuICAgICAgICAnW29iamVjdCBSZWdFeHBdJzogMSxcbiAgICAgICAgJ1tvYmplY3QgRGF0ZV0nOiAxLFxuICAgICAgICAnW29iamVjdCBFcnJvcl0nOiAxLFxuICAgICAgICAnW29iamVjdCBDYW52YXNHcmFkaWVudF0nOiAxLFxuICAgICAgICAnW29iamVjdCBDYW52YXNQYXR0ZXJuXSc6IDEsXG4gICAgICAgIC8vIEZvciBub2RlLWNhbnZhc1xuICAgICAgICAnW29iamVjdCBJbWFnZV0nOiAxLFxuICAgICAgICAnW29iamVjdCBDYW52YXNdJzogMVxuICAgIH07XG5cbiAgICB2YXIgVFlQRURfQVJSQVkgPSB7XG4gICAgICAgICdbb2JqZWN0IEludDhBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBVaW50OEFycmF5XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJzogMSxcbiAgICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJzogMSxcbiAgICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJzogMSxcbiAgICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc6IDFcbiAgICB9O1xuXG4gICAgdmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuICAgIHZhciBuYXRpdmVGb3JFYWNoID0gYXJyYXlQcm90by5mb3JFYWNoO1xuICAgIHZhciBuYXRpdmVGaWx0ZXIgPSBhcnJheVByb3RvLmZpbHRlcjtcbiAgICB2YXIgbmF0aXZlU2xpY2UgPSBhcnJheVByb3RvLnNsaWNlO1xuICAgIHZhciBuYXRpdmVNYXAgPSBhcnJheVByb3RvLm1hcDtcbiAgICB2YXIgbmF0aXZlUmVkdWNlID0gYXJyYXlQcm90by5yZWR1Y2U7XG5cbiAgICAvKipcbiAgICAgKiBUaG9zZSBkYXRhIHR5cGVzIGNhbiBiZSBjbG9uZWQ6XG4gICAgICogICAgIFBsYWluIG9iamVjdCwgQXJyYXksIFR5cGVkQXJyYXksIG51bWJlciwgc3RyaW5nLCBudWxsLCB1bmRlZmluZWQuXG4gICAgICogVGhvc2UgZGF0YSB0eXBlcyB3aWxsIGJlIGFzc2dpbmVkIHVzaW5nIHRoZSBvcmdpbmFsIGRhdGE6XG4gICAgICogICAgIEJVSUxUSU5fT0JKRUNUXG4gICAgICogSW5zdGFuY2Ugb2YgdXNlciBkZWZpbmVkIGNsYXNzIHdpbGwgYmUgY2xvbmVkIHRvIGEgcGxhaW4gb2JqZWN0LCB3aXRob3V0XG4gICAgICogcHJvcGVydGllcyBpbiBwcm90b3R5cGUuXG4gICAgICogT3RoZXIgZGF0YSB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkIChub3Qgc3VyZSB3aGF0IHdpbGwgaGFwcGVuKS5cbiAgICAgKlxuICAgICAqIENhdXRpb246IGRvIG5vdCBzdXBwb3J0IGNsb25lIERhdGUsIGZvciBwZXJmb3JtYW5jZSBjb25zaWRlcmF0aW9uLlxuICAgICAqIChUaGVyZSBtaWdodCBiZSBhIGxhcmdlIG51bWJlciBvZiBkYXRlIGluIGBzZXJpZXMuZGF0YWApLlxuICAgICAqIFNvIGRhdGUgc2hvdWxkIG5vdCBiZSBtb2RpZmllZCBpbiBhbmQgb3V0IG9mIGVjaGFydHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVxuICAgICAqIEByZXR1cm4geyp9IG5ld1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlID09IG51bGwgfHwgdHlwZW9mIHNvdXJjZSAhPSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBzb3VyY2U7XG4gICAgICAgIHZhciB0eXBlU3RyID0gb2JqVG9TdHJpbmcuY2FsbChzb3VyY2UpO1xuXG4gICAgICAgIGlmICh0eXBlU3RyID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBjbG9uZShzb3VyY2VbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFRZUEVEX0FSUkFZW3R5cGVTdHJdKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzb3VyY2UuY29uc3RydWN0b3IuZnJvbShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFCVUlMVElOX09CSkVDVFt0eXBlU3RyXSAmJiAhaXNQcmltaXRpdmUoc291cmNlKSAmJiAhaXNEb20oc291cmNlKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gY2xvbmUoc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG92ZXJ3cml0ZSkge1xuICAgICAgICAvLyBXZSBzaG91bGQgZXNjYXBzZSB0aGF0IHNvdXJjZSBpcyBzdHJpbmdcbiAgICAgICAgLy8gYW5kIGVudGVyIGZvciAuLi4gaW4gLi4uXG4gICAgICAgIGlmICghaXNPYmplY3Qoc291cmNlKSB8fCAhaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG92ZXJ3cml0ZSA/IGNsb25lKHNvdXJjZSkgOiB0YXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0UHJvcCA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VQcm9wID0gc291cmNlW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgaXNPYmplY3QodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzQXJyYXkoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzQXJyYXkodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzRG9tKHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0RvbSh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNCdWlsdEluT2JqZWN0KHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0J1aWx0SW5PYmplY3QodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzUHJpbWl0aXZlKHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc1ByaW1pdGl2ZSh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzpnIDopoHpgJLlvZLopobnm5bvvIzlsLHpgJLlvZLosIPnlKhtZXJnZVxuICAgICAgICAgICAgICAgICAgICBtZXJnZSh0YXJnZXRQcm9wLCBzb3VyY2VQcm9wLCBvdmVyd3JpdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvdmVyd3JpdGUgfHwgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlkKbliJnlj6rlpITnkIZvdmVyd3JpdGXkuLp0cnVl77yM5oiW6ICF5Zyo55uu5qCH5a+56LGh5Lit5rKh5pyJ5q2k5bGe5oCn55qE5oOF5Ya1XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEXvvIzlnKggdGFyZ2V0W2tleV0g5LiN5a2Y5Zyo55qE5pe25YCZ5Lmf5piv55u05o6l6KaG55uWXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gY2xvbmUoc291cmNlW2tleV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0QW5kU291cmNlcyBUaGUgZmlyc3QgaXRlbSBpcyB0YXJnZXQsIGFuZCB0aGUgcmVzdHMgYXJlIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdXG4gICAgICogQHJldHVybiB7Kn0gdGFyZ2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VBbGwodGFyZ2V0QW5kU291cmNlcywgb3ZlcndyaXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXRBbmRTb3VyY2VzWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGFyZ2V0QW5kU291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gbWVyZ2UocmVzdWx0LCB0YXJnZXRBbmRTb3VyY2VzW2ldLCBvdmVyd3JpdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlbn0gW292ZXJsYXk9ZmFsc2VdXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRzKHRhcmdldCwgc291cmNlLCBvdmVybGF5KSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KVxuICAgICAgICAgICAgICAgICYmIChvdmVybGF5ID8gc291cmNlW2tleV0gIT0gbnVsbCA6IHRhcmdldFtrZXldID09IG51bGwpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FudmFzKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfVxuICAgIC8vIEZJWE1FXG4gICAgdmFyIF9jdHg7XG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgICAgICAgaWYgKCFfY3R4KSB7XG4gICAgICAgICAgICAvLyBVc2UgdXRpbC5jcmVhdGVDYW52YXMgaW5zdGVhZCBvZiBjcmVhdGVDYW52YXNcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgY3JlYXRlQ2FudmFzIG1heSBiZSBvdmVyd3JpdHRlbiBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRcbiAgICAgICAgICAgIF9jdHggPSB1dGlsLmNyZWF0ZUNhbnZhcygpLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9jdHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5p+l6K+i5pWw57uE5Lit5YWD57Sg55qEaW5kZXhcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgICBpZiAoYXJyYXkuaW5kZXhPZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmnoTpgKDnsbvnu6fmib/lhbPns7tcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGF6eiDmupDnsbtcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlQ2xhenog5Z+657G7XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5oZXJpdHMoY2xhenosIGJhc2VDbGF6eikge1xuICAgICAgICB2YXIgY2xhenpQcm90b3R5cGUgPSBjbGF6ei5wcm90b3R5cGU7XG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxuICAgICAgICBGLnByb3RvdHlwZSA9IGJhc2VDbGF6ei5wcm90b3R5cGU7XG4gICAgICAgIGNsYXp6LnByb3RvdHlwZSA9IG5ldyBGKCk7XG5cbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBjbGF6elByb3RvdHlwZSkge1xuICAgICAgICAgICAgY2xhenoucHJvdG90eXBlW3Byb3BdID0gY2xhenpQcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgICAgY2xhenoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2xheno7XG4gICAgICAgIGNsYXp6LnN1cGVyQ2xhc3MgPSBiYXNlQ2xheno7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gc29yY2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJsYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbih0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICAgICAgICB0YXJnZXQgPSAncHJvdG90eXBlJyBpbiB0YXJnZXQgPyB0YXJnZXQucHJvdG90eXBlIDogdGFyZ2V0O1xuICAgICAgICBzb3VyY2UgPSAncHJvdG90eXBlJyBpbiBzb3VyY2UgPyBzb3VyY2UucHJvdG90eXBlIDogc291cmNlO1xuXG4gICAgICAgIGRlZmF1bHRzKHRhcmdldCwgc291cmNlLCBvdmVybGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zaWRlciB0eXBlZCBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZShkYXRhKSB7XG4gICAgICAgIGlmICghIGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIGRhdGEubGVuZ3RoID09ICdudW1iZXInO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaVsOe7hOaIluWvueixoemBjeWOhlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVhY2gob2JqLCBjYiwgY29udGV4dCkge1xuICAgICAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5mb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgICAgICAgICBvYmouZm9yRWFjaChjYiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaVsOe7hOaYoOWwhFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoubWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5tYXAoY2IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW21lbW9dXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2Uob2JqLCBjYiwgbWVtbywgY29udGV4dCkge1xuICAgICAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5yZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnJlZHVjZShjYiwgbWVtbywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWVtbyA9IGNiLmNhbGwoY29udGV4dCwgbWVtbywgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4Tov4fmu6RcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLmZpbHRlciAmJiBvYmouZmlsdGVyID09PSBuYXRpdmVGaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouZmlsdGVyKGNiLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5pWw57uE6aG55p+l5om+XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmpbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmQoZnVuYywgY29udGV4dCkge1xuICAgICAgICB2YXIgYXJncyA9IG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYykge1xuICAgICAgICB2YXIgYXJncyA9IG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8ICghIXZhbHVlICYmIHR5cGUgPT0gJ29iamVjdCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0J1aWx0SW5PYmplY3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhQlVJTFRJTl9PQkpFQ1Rbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RvbSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgJiYgdHlwZW9mIHZhbHVlLm5vZGVUeXBlID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgJiYgdHlwZW9mIHZhbHVlLm93bmVyRG9jdW1lbnQgPT09ICdvYmplY3QnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXMgZXhhY3RseSBOYU4uIE5vdGljZSBpc05hTignYScpIHJldHVybnMgdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcU5hTih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHZhbHVlMSBpcyBub3QgbnVsbCwgdGhlbiByZXR1cm4gdmFsdWUxLCBvdGhlcndpc2UganVkZ2V0IHJlc3Qgb2YgdmFsdWVzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcmV0dXJuIHsqfSBGaW5hbCB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldHJpZXZlKHZhbHVlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEluZGV4XG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpY2UoKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbi5jYWxsLmFwcGx5KG5hdGl2ZVNsaWNlLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmRpdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByaW1pdGl2ZUtleSA9ICdfX2VjX3ByaW1pdGl2ZV9fJztcbiAgICAvKipcbiAgICAgKiBTZXQgYW4gb2JqZWN0IGFzIHByaW1pdGl2ZSB0byBiZSBpZ25vcmVkIHRyYXZlcnNpbmcgY2hpbGRyZW4gaW4gY2xvbmUgb3IgbWVyZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRBc1ByaW1pdGl2ZShvYmopIHtcbiAgICAgICAgb2JqW3ByaW1pdGl2ZUtleV0gPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqW3ByaW1pdGl2ZUtleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBPbmx5IGFwcGx5IGBvd25Qcm9wZXJ0eWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSGFzaE1hcChvYmopIHtcbiAgICAgICAgb2JqICYmIGVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIC8vIEFkZCBwcmVmaXggdG8gYXZvaWQgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlLlxuICAgIHZhciBIQVNIX01BUF9QUkVGSVggPSAnX2VjXyc7XG4gICAgdmFyIEhBU0hfTUFQX1BSRUZJWF9MRU5HVEggPSA0O1xuXG4gICAgSGFzaE1hcC5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBIYXNoTWFwLFxuICAgICAgICAvLyBEbyBub3QgcHJvdmlkZSBgaGFzYCBtZXRob2QgdG8gYXZvaWQgZGVmaW5pbmcgd2hhdCBpcyBgaGFzYC5cbiAgICAgICAgLy8gKFdlIHVzdWFsbHkgdHJlYXQgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcyB0aGUgc2FtZSwgZGlmZmVyZW50XG4gICAgICAgIC8vIGZyb20gRVM2IE1hcCkuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbSEFTSF9NQVBfUFJFRklYICsga2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpc1tIQVNIX01BUF9QUkVGSVggKyBrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAvLyBDb21wYXJpbmcgd2l0aCBpbnZvY2F0aW9uIGNoYWluaW5nLCBgcmV0dXJuIHZhbHVlYCBpcyBtb3JlIGNvbW1vbmx5XG4gICAgICAgICAgICAvLyB1c2VkIGluIHRoaXMgY2FzZTogYHZhciBzb21lVmFsID0gbWFwLnNldCgnYScsIGdlblZhbCgpKTtgXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFsdGhvdWdoIHV0aWwuZWFjaCBjYW4gYmUgcGVyZm9ybWVkIG9uIHRoaXMgaGFzaE1hcCBkaXJlY3RseSwgdXNlclxuICAgICAgICAvLyBzaG91bGQgbm90IHVzZSB0aGUgZXhwb3NlZCBrZXlzLCB3aG8gYXJlIHByZWZpeGVkLlxuICAgICAgICBlYWNoOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQgIT09IHZvaWQgMCAmJiAoY2IgPSBiaW5kKGNiLCBjb250ZXh0KSk7XG4gICAgICAgICAgICBmb3IgKHZhciBwcmVmaXhlZEtleSBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNPd25Qcm9wZXJ0eShwcmVmaXhlZEtleSlcbiAgICAgICAgICAgICAgICAgICAgJiYgY2IodGhpc1twcmVmaXhlZEtleV0sIHByZWZpeGVkS2V5LnNsaWNlKEhBU0hfTUFQX1BSRUZJWF9MRU5HVEgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBpZiBwZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gICAgICAgIHJlbW92ZUtleTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVIYXNoTWFwKG9iaikge1xuICAgICAgICByZXR1cm4gbmV3IEhhc2hNYXAob2JqKTtcbiAgICB9XG5cbiAgICB2YXIgdXRpbCA9IHtcbiAgICAgICAgaW5oZXJpdHM6IGluaGVyaXRzLFxuICAgICAgICBtaXhpbjogbWl4aW4sXG4gICAgICAgIGNsb25lOiBjbG9uZSxcbiAgICAgICAgbWVyZ2U6IG1lcmdlLFxuICAgICAgICBtZXJnZUFsbDogbWVyZ2VBbGwsXG4gICAgICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgICAgIGdldENvbnRleHQ6IGdldENvbnRleHQsXG4gICAgICAgIGNyZWF0ZUNhbnZhczogY3JlYXRlQ2FudmFzLFxuICAgICAgICBpbmRleE9mOiBpbmRleE9mLFxuICAgICAgICBzbGljZTogc2xpY2UsXG4gICAgICAgIGZpbmQ6IGZpbmQsXG4gICAgICAgIGlzQXJyYXlMaWtlOiBpc0FycmF5TGlrZSxcbiAgICAgICAgZWFjaDogZWFjaCxcbiAgICAgICAgbWFwOiBtYXAsXG4gICAgICAgIHJlZHVjZTogcmVkdWNlLFxuICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgYmluZDogYmluZCxcbiAgICAgICAgY3Vycnk6IGN1cnJ5LFxuICAgICAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgICAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgICAgIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgICAgICAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgICAgICAgaXNCdWlsdEluT2JqZWN0OiBpc0J1aWx0SW5PYmplY3QsXG4gICAgICAgIGlzRG9tOiBpc0RvbSxcbiAgICAgICAgZXFOYU46IGVxTmFOLFxuICAgICAgICByZXRyaWV2ZTogcmV0cmlldmUsXG4gICAgICAgIGFzc2VydDogYXNzZXJ0LFxuICAgICAgICBzZXRBc1ByaW1pdGl2ZTogc2V0QXNQcmltaXRpdmUsXG4gICAgICAgIGNyZWF0ZUhhc2hNYXA6IGNyZWF0ZUhhc2hNYXAsXG4gICAgICAgIG5vb3A6IGZ1bmN0aW9uICgpIHt9XG4gICAgfTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHV0aWw7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("\n\n    var formatUtil = __webpack_require__(22);\n    var nubmerUtil = __webpack_require__(23);\n    var Model = __webpack_require__(28);\n    var zrUtil = __webpack_require__(20);\n    var each = zrUtil.each;\n    var isObject = zrUtil.isObject;\n\n    var modelUtil = {};\n\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array\n            ? value\n            : value == null\n            ? []\n            : [value];\n    };\n\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n     modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n\n            // Default emphasis option from normal\n            each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n\n    modelUtil.LABEL_OPTIONS = ['position', 'offset', 'show', 'textStyle', 'distance', 'formatter'];\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return isObject(dataItem)\n            && !(dataItem instanceof Array);\n            // // markLine data can be array\n            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n\n        if (dimType === 'time'\n            // spead up when using timestamp\n            && typeof value !== 'number'\n            && value != null\n            && value !== '-'\n        ) {\n            value = +nubmerUtil.parseDate(value);\n        }\n\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return (value == null || value === '')\n            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n    };\n\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        /**\n         * Get params for formatter\n         * @param {number} dataIndex\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n            var color = data.getItemVisual(dataIndex, 'color');\n\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: this.seriesIndex,\n                seriesId: this.id,\n                seriesName: this.name,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: color,\n                marker: formatUtil.getTooltipMarker(color),\n\n                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n                $vars: ['seriesName', 'name', 'value']\n            };\n        },\n\n        /**\n         * Format label\n         * @param {number} dataIndex\n         * @param {string} [status='normal'] 'normal' or 'emphasis'\n         * @param {string} [dataType]\n         * @param {number} [dimIndex]\n         * @param {string} [labelProp='label']\n         * @return {string}\n         */\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && (params.value instanceof Array)) {\n                params.value = params.value[dimIndex];\n            }\n\n            var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);\n\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            }\n            else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n\n        /**\n         * Get raw value in option\n         * @param {number} idx\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return (isObject(dataItem) && !(dataItem instanceof Array))\n                    ? dataItem.value : dataItem;\n            }\n        },\n\n        /**\n         * Should be implemented.\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         * @return {string} tooltip string\n         */\n        formatTooltip: zrUtil.noop\n    };\n\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          index of which is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n\n        var result = zrUtil.map(exists || [], function (obj, index) {\n            return {exist: obj};\n        });\n\n        // Mapping by id or name if specified.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option // Consider name: two map to one.\n                    && cptOption.id != null\n                    && result[i].exist.id === cptOption.id + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option // Consider name: two map to one.\n                    // Can not match when both ids exist but different.\n                    && (exist.id == null || cptOption.id == null)\n                    && cptOption.name != null\n                    && !modelUtil.isIdInner(cptOption)\n                    && !modelUtil.isIdInner(exist)\n                    && exist.name === cptOption.name + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n\n        // Otherwise mapping by index.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option\n                    // Existing model that already has id should be able to\n                    // mapped to (because after mapping performed model may\n                    // be assigned with a id, whish should not affect next\n                    // mapping), except those has inner id.\n                    && !modelUtil.isIdInner(exist)\n                    // Caution:\n                    // Do not overwrite id. But name can be overwritten,\n                    // because axis use name as 'show label text'.\n                    // 'exist' always has id and name and we dont\n                    // need to check it.\n                    && cptOption.id == null\n                ) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n\n            if (i >= result.length) {\n                result.push({option: cptOption});\n            }\n        });\n\n        return result;\n    };\n\n    /**\n     * Make id and name for mapping result (result of mappingToExists)\n     * into `keyInfo` field.\n     *\n     * @public\n     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     * @return {Array.<Object>} The input.\n     */\n    modelUtil.makeIdAndName = function (mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n\n        // Ensure that each id is distinct.\n        var idMap = zrUtil.createHashMap();\n\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && idMap.set(existCpt.id, item);\n        });\n\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n\n            zrUtil.assert(\n                !opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item,\n                'id duplicates: ' + (opt && opt.id)\n            );\n\n            opt && opt.id != null && idMap.set(opt.id, item);\n            !item.keyInfo && (item.keyInfo = {});\n        });\n\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n\n            if (!isObject(opt)) {\n                return;\n            }\n\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null\n                ? opt.name + ''\n                : existCpt\n                ? existCpt.name\n                : '\\0-'; // name may be displayed on screen, so use '-'.\n\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            }\n            else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            }\n            else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n                }\n                while (idMap.get(keyInfo.id));\n            }\n\n            idMap.set(keyInfo.id, item);\n        });\n    };\n\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return isObject(cptOption)\n            && cptOption.id\n            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n    };\n\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n\n        return [mapToArray(mapA), mapToArray(mapB)];\n\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    }\n                    else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    }\n                    else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                    }\n                }\n            }\n            return result;\n        }\n    };\n\n    /**\n     * @param {module:echarts/data/List} data\n     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n     *                         each of which can be Array or primary type.\n     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n     */\n    modelUtil.queryDataIndex = function (data, payload) {\n        if (payload.dataIndexInside != null) {\n            return payload.dataIndexInside;\n        }\n        else if (payload.dataIndex != null) {\n            return zrUtil.isArray(payload.dataIndex)\n                ? zrUtil.map(payload.dataIndex, function (value) {\n                    return data.indexOfRawIndex(value);\n                })\n                : data.indexOfRawIndex(payload.dataIndex);\n        }\n        else if (payload.name != null) {\n            return zrUtil.isArray(payload.name)\n                ? zrUtil.map(payload.name, function (value) {\n                    return data.indexOfName(value);\n                })\n                : data.indexOfName(payload.name);\n        }\n    };\n\n    /**\n     * Enable property storage to any host object.\n     * Notice: Serialization is not supported.\n     *\n     * For example:\n     * var get = modelUitl.makeGetter();\n     *\n     * function some(hostObj) {\n     *      get(hostObj)._someProperty = 1212;\n     *      ...\n     * }\n     *\n     * @return {Function}\n     */\n    modelUtil.makeGetter = (function () {\n        var index = 0;\n        return function () {\n            var key = '\\0__ec_prop_getter_' + index++;\n            return function (hostObj) {\n                return hostObj[key] || (hostObj[key] = {});\n            };\n        };\n    })();\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex, seriesId, seriesName,\n     *            geoIndex, geoId, geoName,\n     *            bmapIndex, bmapId, bmapName,\n     *            xAxisIndex, xAxisId, xAxisName,\n     *            yAxisIndex, yAxisId, yAxisName,\n     *            gridIndex, gridId, gridName,\n     *            ... (can be extended)\n     *        }\n     *        Each properties can be number|string|Array.<number>|Array.<string>\n     *        For example, a finder could be\n     *        {\n     *            seriesIndex: 3,\n     *            geoId: ['aa', 'cc'],\n     *            gridName: ['xx', 'rr']\n     *        }\n     *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)\n     *        If nothing or null/undefined specified, return nothing.\n     * @param {Object} [opt]\n     * @param {string} [opt.defaultMainType]\n     * @param {Array.<string>} [opt.includeMainTypes]\n     * @return {Object} result like:\n     *        {\n     *            seriesModels: [seriesModel1, seriesModel2],\n     *            seriesModel: seriesModel1, // The first model\n     *            geoModels: [geoModel1, geoModel2],\n     *            geoModel: geoModel1, // The first model\n     *            ...\n     *        }\n     */\n    modelUtil.parseFinder = function (ecModel, finder, opt) {\n        if (zrUtil.isString(finder)) {\n            var obj = {};\n            obj[finder + 'Index'] = 0;\n            finder = obj;\n        }\n\n        var defaultMainType = opt && opt.defaultMainType;\n        if (defaultMainType\n            && !has(finder, defaultMainType + 'Index')\n            && !has(finder, defaultMainType + 'Id')\n            && !has(finder, defaultMainType + 'Name')\n        ) {\n            finder[defaultMainType + 'Index'] = 0;\n        }\n\n        var result = {};\n\n        each(finder, function (value, key) {\n            var value = finder[key];\n\n            // Exclude 'dataIndex' and other illgal keys.\n            if (key === 'dataIndex' || key === 'dataIndexInside') {\n                result[key] = value;\n                return;\n            }\n\n            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n            var mainType = parsedKey[1];\n            var queryType = (parsedKey[2] || '').toLowerCase();\n\n            if (!mainType\n                || !queryType\n                || value == null\n                || (queryType === 'index' && value === 'none')\n                || (opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0)\n            ) {\n                return;\n            }\n\n            var queryParam = {mainType: mainType};\n            if (queryType !== 'index' || value !== 'all') {\n                queryParam[queryType] = value;\n            }\n\n            var models = ecModel.queryComponents(queryParam);\n            result[mainType + 'Models'] = models;\n            result[mainType + 'Model'] = models[0];\n        });\n\n        return result;\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string|number} dataDim\n     * @return {string}\n     */\n    modelUtil.dataDimToCoordDim = function (data, dataDim) {\n        var dimensions = data.dimensions;\n        dataDim = data.getDimension(dataDim);\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimItem = data.getDimensionInfo(dimensions[i]);\n            if (dimItem.name === dataDim) {\n                return dimItem.coordDim;\n            }\n        }\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string} coordDim\n     * @return {Array.<string>} data dimensions on the coordDim.\n     */\n    modelUtil.coordDimToDataDim = function (data, coordDim) {\n        var dataDim = [];\n        each(data.dimensions, function (dimName) {\n            var dimItem = data.getDimensionInfo(dimName);\n            if (dimItem.coordDim === coordDim) {\n                dataDim[dimItem.coordDimIndex] = dimItem.name;\n            }\n        });\n        return dataDim;\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string} otherDim Can be `otherDims`\n     *                        like 'label' or 'tooltip'.\n     * @return {Array.<string>} data dimensions on the otherDim.\n     */\n    modelUtil.otherDimToDataDim = function (data, otherDim) {\n        var dataDim = [];\n        each(data.dimensions, function (dimName) {\n            var dimItem = data.getDimensionInfo(dimName);\n            var otherDims = dimItem.otherDims;\n            var dimIndex = otherDims[otherDim];\n            if (dimIndex != null && dimIndex !== false) {\n                dataDim[dimIndex] = dimItem.name;\n            }\n        });\n        return dataDim;\n    };\n\n    function has(obj, prop) {\n        return obj && obj.hasOwnProperty(prop);\n    }\n\n    module.exports = modelUtil;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3V0aWwvbW9kZWwuanM/ZTJiZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLEVBQUU7QUFDbEIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlDQUFpQyxXQUFXLGVBQWUsZUFBZTtBQUMxRTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLFdBQVcsZUFBZSxlQUFlO0FBQzFFO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QyxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQXNEO0FBQ3JFLGVBQWUsc0JBQXNCO0FBQ3JDLGdCQUFnQixlQUFlLGdCQUFnQix3QkFBd0IsSUFBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZSxnQkFBZ0Isd0JBQXdCLElBQUk7QUFDMUU7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixVQUFVLEdBQUcsVUFBVSxHQUFHLEdBQUc7QUFDNUQsOEJBQThCLEdBQUcsR0FBRyxVQUFVLEdBQUcsVUFBVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZSxnQkFBZ0IsbUNBQW1DO0FBQ2pGLGVBQWUsZUFBZSxnQkFBZ0IsbUNBQW1DO0FBQ2pGLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQsVUFBVTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsb0NBQW9DO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsY0FBYztBQUM3Qiw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsZUFBZSx5QkFBeUI7QUFDeEMsZUFBZSxjQUFjO0FBQzdCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsZUFBZSx5QkFBeUI7QUFDeEMsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcbiAgICB2YXIgbnVibWVyVXRpbCA9IHJlcXVpcmUoJy4vbnVtYmVyJyk7XG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWwvTW9kZWwnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbiAgICB2YXIgaXNPYmplY3QgPSB6clV0aWwuaXNPYmplY3Q7XG5cbiAgICB2YXIgbW9kZWxVdGlsID0ge307XG5cbiAgICAvKipcbiAgICAgKiBJZiB2YWx1ZSBpcyBub3QgYXJyYXksIHRoZW4gdHJhbnNsYXRlIGl0IHRvIGFycmF5LlxuICAgICAqIEBwYXJhbSAgeyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7QXJyYXl9IFt2YWx1ZV0gb3IgdmFsdWVcbiAgICAgKi9cbiAgICBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgOiB2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICA6IFt2YWx1ZV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN5bmMgZGVmYXVsdCBvcHRpb24gYmV0d2VlbiBub3JtYWwgYW5kIGVtcGhhc2lzIGxpa2UgYHBvc2l0aW9uYCBhbmQgYHNob3dgXG4gICAgICogSW4gY2FzZSBzb21lIG9uZSB3aWxsIHdyaXRlIGNvZGUgbGlrZVxuICAgICAqICAgICBsYWJlbDoge1xuICAgICAqICAgICAgICAgbm9ybWFsOiB7XG4gICAgICogICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICogICAgICAgICAgICAgcG9zaXRpb246ICdvdXRzaWRlJyxcbiAgICAgKiAgICAgICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgZm9udFNpemU6IDE4XG4gICAgICogICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgIGVtcGhhc2lzOiB7XG4gICAgICogICAgICAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHN1Yk9wdHNcbiAgICAgKi9cbiAgICAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyA9IGZ1bmN0aW9uIChvcHQsIHN1Yk9wdHMpIHtcbiAgICAgICAgaWYgKG9wdCkge1xuICAgICAgICAgICAgdmFyIGVtcGhhc2lzT3B0ID0gb3B0LmVtcGhhc2lzID0gb3B0LmVtcGhhc2lzIHx8IHt9O1xuICAgICAgICAgICAgdmFyIG5vcm1hbE9wdCA9IG9wdC5ub3JtYWwgPSBvcHQubm9ybWFsIHx8IHt9O1xuXG4gICAgICAgICAgICAvLyBEZWZhdWx0IGVtcGhhc2lzIG9wdGlvbiBmcm9tIG5vcm1hbFxuICAgICAgICAgICAgZWFjaChzdWJPcHRzLCBmdW5jdGlvbiAoc3ViT3B0TmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB6clV0aWwucmV0cmlldmUoZW1waGFzaXNPcHRbc3ViT3B0TmFtZV0sIG5vcm1hbE9wdFtzdWJPcHROYW1lXSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtcGhhc2lzT3B0W3N1Yk9wdE5hbWVdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZGVsVXRpbC5MQUJFTF9PUFRJT05TID0gWydwb3NpdGlvbicsICdvZmZzZXQnLCAnc2hvdycsICd0ZXh0U3R5bGUnLCAnZGlzdGFuY2UnLCAnZm9ybWF0dGVyJ107XG5cbiAgICAvKipcbiAgICAgKiBkYXRhIGNvdWxkIGJlIFsxMiwgMjMyMywge3ZhbHVlOiAyMjN9LCBbMTIyMSwgMjNdLCB7dmFsdWU6IFsyLCAyM119XVxuICAgICAqIFRoaXMgaGVscGVyIG1ldGhvZCByZXRpZXZlcyB2YWx1ZSBmcm9tIGRhdGEuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfERhdGV8QXJyYXl8T2JqZWN0fSBkYXRhSXRlbVxuICAgICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd8RGF0ZXxBcnJheS48bnVtYmVyfHN0cmluZ3xEYXRlPn1cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwuZ2V0RGF0YUl0ZW1WYWx1ZSA9IGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgICAvLyBQZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gICAgICAgIHJldHVybiBkYXRhSXRlbSAmJiAoZGF0YUl0ZW0udmFsdWUgPT0gbnVsbCA/IGRhdGFJdGVtIDogZGF0YUl0ZW0udmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkYXRhIGNvdWxkIGJlIFsxMiwgMjMyMywge3ZhbHVlOiAyMjN9LCBbMTIyMSwgMjNdLCB7dmFsdWU6IFsyLCAyM119XVxuICAgICAqIFRoaXMgaGVscGVyIG1ldGhvZCBkZXRlcm1pbmUgaWYgZGF0YUl0ZW0gaGFzIGV4dHJhIG9wdGlvbiBiZXNpZGVzIHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfERhdGV8QXJyYXl8T2JqZWN0fSBkYXRhSXRlbVxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5pc0RhdGFJdGVtT3B0aW9uID0gZnVuY3Rpb24gKGRhdGFJdGVtKSB7XG4gICAgICAgIHJldHVybiBpc09iamVjdChkYXRhSXRlbSlcbiAgICAgICAgICAgICYmICEoZGF0YUl0ZW0gaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICAgICAgICAvLyAvLyBtYXJrTGluZSBkYXRhIGNhbiBiZSBhcnJheVxuICAgICAgICAgICAgLy8gJiYgIShkYXRhSXRlbVswXSAmJiBpc09iamVjdChkYXRhSXRlbVswXSkgJiYgIShkYXRhSXRlbVswXSBpbnN0YW5jZW9mIEFycmF5KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaGVscGVyIG1ldGhvZCBjb252ZXJ0IHZhbHVlIGluIGRhdGEuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfERhdGV9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbZGltSW5mb10gSWYgc3RyaW5nIChsaWtlICd4JyksIGRpbVR5cGUgZGVmYXVsdHMgJ251bWJlcicuXG4gICAgICovXG4gICAgbW9kZWxVdGlsLmNvbnZlckRhdGFWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGltSW5mbykge1xuICAgICAgICAvLyBQZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gICAgICAgIHZhciBkaW1UeXBlID0gZGltSW5mbyAmJiBkaW1JbmZvLnR5cGU7XG4gICAgICAgIGlmIChkaW1UeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaW1UeXBlID09PSAndGltZSdcbiAgICAgICAgICAgIC8vIHNwZWFkIHVwIHdoZW4gdXNpbmcgdGltZXN0YW1wXG4gICAgICAgICAgICAmJiB0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInXG4gICAgICAgICAgICAmJiB2YWx1ZSAhPSBudWxsXG4gICAgICAgICAgICAmJiB2YWx1ZSAhPT0gJy0nXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFsdWUgPSArbnVibWVyVXRpbC5wYXJzZURhdGUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGltVHlwZSBkZWZhdWx0cyAnbnVtYmVyJy5cbiAgICAgICAgLy8gSWYgZGltVHlwZSBpcyBub3Qgb3JkaW5hbCBhbmQgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQgb3IgTmFOIG9yICctJyxcbiAgICAgICAgLy8gcGFyc2UgdG8gTmFOLlxuICAgICAgICByZXR1cm4gKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09ICcnKVxuICAgICAgICAgICAgPyBOYU4gOiArdmFsdWU7IC8vIElmIHN0cmluZyAobGlrZSAnLScpLCB1c2luZyAnKycgcGFyc2UgdG8gTmFOXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG1vZGVsIHByb3h5IHRvIGJlIHVzZWQgaW4gdG9vbHRpcCBmb3IgZWRnZSBkYXRhLCBtYXJrTGluZSBkYXRhLCBtYXJrUG9pbnQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdC5zZXJpZXNJbmRleF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdC5uYW1lXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0Lm1haW5UeXBlXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0LnN1YlR5cGVdXG4gICAgICovXG4gICAgbW9kZWxVdGlsLmNyZWF0ZURhdGFGb3JtYXRNb2RlbCA9IGZ1bmN0aW9uIChkYXRhLCBvcHQpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKCk7XG4gICAgICAgIHpyVXRpbC5taXhpbihtb2RlbCwgbW9kZWxVdGlsLmRhdGFGb3JtYXRNaXhpbik7XG4gICAgICAgIG1vZGVsLnNlcmllc0luZGV4ID0gb3B0LnNlcmllc0luZGV4O1xuICAgICAgICBtb2RlbC5uYW1lID0gb3B0Lm5hbWUgfHwgJyc7XG4gICAgICAgIG1vZGVsLm1haW5UeXBlID0gb3B0Lm1haW5UeXBlO1xuICAgICAgICBtb2RlbC5zdWJUeXBlID0gb3B0LnN1YlR5cGU7XG5cbiAgICAgICAgbW9kZWwuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgfTtcblxuICAgIC8vIFBFTkRJTkcgQSBsaXR0bGUgdWdseVxuICAgIG1vZGVsVXRpbC5kYXRhRm9ybWF0TWl4aW4gPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcGFyYW1zIGZvciBmb3JtYXR0ZXJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGFUeXBlXVxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXREYXRhUGFyYW1zOiBmdW5jdGlvbiAoZGF0YUluZGV4LCBkYXRhVHlwZSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZGF0YVR5cGUpO1xuICAgICAgICAgICAgdmFyIHJhd1ZhbHVlID0gdGhpcy5nZXRSYXdWYWx1ZShkYXRhSW5kZXgsIGRhdGFUeXBlKTtcbiAgICAgICAgICAgIHZhciByYXdEYXRhSW5kZXggPSBkYXRhLmdldFJhd0luZGV4KGRhdGFJbmRleCk7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGRhdGEuZ2V0TmFtZShkYXRhSW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgdmFyIGl0ZW1PcHQgPSBkYXRhLmdldFJhd0RhdGFJdGVtKGRhdGFJbmRleCk7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBkYXRhLmdldEl0ZW1WaXN1YWwoZGF0YUluZGV4LCAnY29sb3InKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRUeXBlOiB0aGlzLm1haW5UeXBlLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFN1YlR5cGU6IHRoaXMuc3ViVHlwZSxcbiAgICAgICAgICAgICAgICBzZXJpZXNUeXBlOiB0aGlzLm1haW5UeXBlID09PSAnc2VyaWVzJyA/IHRoaXMuc3ViVHlwZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHRoaXMuc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgc2VyaWVzTmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgZGF0YUluZGV4OiByYXdEYXRhSW5kZXgsXG4gICAgICAgICAgICAgICAgZGF0YTogaXRlbU9wdCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogZGF0YVR5cGUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJhd1ZhbHVlLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICBtYXJrZXI6IGZvcm1hdFV0aWwuZ2V0VG9vbHRpcE1hcmtlcihjb2xvciksXG5cbiAgICAgICAgICAgICAgICAvLyBQYXJhbSBuYW1lIGxpc3QgZm9yIG1hcHBpbmcgYGFgLCBgYmAsIGBjYCwgYGRgLCBgZWBcbiAgICAgICAgICAgICAgICAkdmFyczogWydzZXJpZXNOYW1lJywgJ25hbWUnLCAndmFsdWUnXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybWF0IGxhYmVsXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdGF0dXM9J25vcm1hbCddICdub3JtYWwnIG9yICdlbXBoYXNpcydcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtkYXRhVHlwZV1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtkaW1JbmRleF1cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYWJlbFByb3A9J2xhYmVsJ11cbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Rm9ybWF0dGVkTGFiZWw6IGZ1bmN0aW9uIChkYXRhSW5kZXgsIHN0YXR1cywgZGF0YVR5cGUsIGRpbUluZGV4LCBsYWJlbFByb3ApIHtcbiAgICAgICAgICAgIHN0YXR1cyA9IHN0YXR1cyB8fCAnbm9ybWFsJztcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKGRhdGFUeXBlKTtcbiAgICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChkYXRhSW5kZXgpO1xuXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5nZXREYXRhUGFyYW1zKGRhdGFJbmRleCwgZGF0YVR5cGUpO1xuICAgICAgICAgICAgaWYgKGRpbUluZGV4ICE9IG51bGwgJiYgKHBhcmFtcy52YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy52YWx1ZSA9IHBhcmFtcy52YWx1ZVtkaW1JbmRleF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZXIgPSBpdGVtTW9kZWwuZ2V0KFtsYWJlbFByb3AgfHwgJ2xhYmVsJywgc3RhdHVzLCAnZm9ybWF0dGVyJ10pO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlcihwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0VXRpbC5mb3JtYXRUcGwoZm9ybWF0dGVyLCBwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcmF3IHZhbHVlIGluIG9wdGlvblxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YVR5cGVdXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFJhd1ZhbHVlOiBmdW5jdGlvbiAoaWR4LCBkYXRhVHlwZSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZGF0YVR5cGUpO1xuICAgICAgICAgICAgdmFyIGRhdGFJdGVtID0gZGF0YS5nZXRSYXdEYXRhSXRlbShpZHgpO1xuICAgICAgICAgICAgaWYgKGRhdGFJdGVtICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGlzT2JqZWN0KGRhdGFJdGVtKSAmJiAhKGRhdGFJdGVtIGluc3RhbmNlb2YgQXJyYXkpKVxuICAgICAgICAgICAgICAgICAgICA/IGRhdGFJdGVtLnZhbHVlIDogZGF0YUl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3VsZCBiZSBpbXBsZW1lbnRlZC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttdWx0aXBsZVNlcmllcz1mYWxzZV1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhVHlwZV1cbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSB0b29sdGlwIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZm9ybWF0VG9vbHRpcDogenJVdGlsLm5vb3BcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWFwcGluZyB0byBleGlzdHMgZm9yIG1lcmdlLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD58QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudD59IGV4aXN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5LjxPYmplY3Q+fSBuZXdDcHRPcHRpb25zXG4gICAgICogQHJldHVybiB7QXJyYXkuPE9iamVjdD59IFJlc3VsdCwgbGlrZSBbe2V4aXN0OiAuLi4sIG9wdGlvbjogLi4ufSwge31dLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCBvZiB3aGljaCBpcyB0aGUgc2FtZSBhcyBleGlzdHMuXG4gICAgICovXG4gICAgbW9kZWxVdGlsLm1hcHBpbmdUb0V4aXN0cyA9IGZ1bmN0aW9uIChleGlzdHMsIG5ld0NwdE9wdGlvbnMpIHtcbiAgICAgICAgLy8gTWFwcGluZyBieSB0aGUgb3JkZXIgYnkgb3JpZ2luYWwgb3B0aW9uIChidXQgbm90IG9yZGVyIG9mXG4gICAgICAgIC8vIG5ldyBvcHRpb24pIGluIG1lcmdlIG1vZGUuIEJlY2F1c2Ugd2Ugc2hvdWxkIGVuc3VyZVxuICAgICAgICAvLyBzb21lIHNwZWNpZmllZCBpbmRleCAobGlrZSB4QXhpc0luZGV4KSBpcyBjb25zaXN0ZW50IHdpdGhcbiAgICAgICAgLy8gb3JpZ2luYWwgb3B0aW9uLCB3aGljaCBpcyBlYXN5IHRvIHVuZGVyc3RhbmQsIGVzcGF0aWFsbHkgaW5cbiAgICAgICAgLy8gbWVkaWEgcXVlcnkuIEFuZCBpbiBtb3N0IGNhc2UsIG1lcmdlIG9wdGlvbiBpcyB1c2VkIHRvXG4gICAgICAgIC8vIHVwZGF0ZSBwYXJ0aWFsIG9wdGlvbiBidXQgbm90IGJlIGV4cGVjdGVkIHRvIGNoYW5nZSBvcmRlci5cbiAgICAgICAgbmV3Q3B0T3B0aW9ucyA9IChuZXdDcHRPcHRpb25zIHx8IFtdKS5zbGljZSgpO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB6clV0aWwubWFwKGV4aXN0cyB8fCBbXSwgZnVuY3Rpb24gKG9iaiwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB7ZXhpc3Q6IG9ian07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE1hcHBpbmcgYnkgaWQgb3IgbmFtZSBpZiBzcGVjaWZpZWQuXG4gICAgICAgIGVhY2gobmV3Q3B0T3B0aW9ucywgZnVuY3Rpb24gKGNwdE9wdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghaXNPYmplY3QoY3B0T3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWQgaGFzIGhpZ2hlc3QgcHJpb3JpdHkuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0W2ldLm9wdGlvbiAvLyBDb25zaWRlciBuYW1lOiB0d28gbWFwIHRvIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgJiYgY3B0T3B0aW9uLmlkICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgJiYgcmVzdWx0W2ldLmV4aXN0LmlkID09PSBjcHRPcHRpb24uaWQgKyAnJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0ub3B0aW9uID0gY3B0T3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICBuZXdDcHRPcHRpb25zW2luZGV4XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0ID0gcmVzdWx0W2ldLmV4aXN0O1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0W2ldLm9wdGlvbiAvLyBDb25zaWRlciBuYW1lOiB0d28gbWFwIHRvIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuIG5vdCBtYXRjaCB3aGVuIGJvdGggaWRzIGV4aXN0IGJ1dCBkaWZmZXJlbnQuXG4gICAgICAgICAgICAgICAgICAgICYmIChleGlzdC5pZCA9PSBudWxsIHx8IGNwdE9wdGlvbi5pZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAmJiBjcHRPcHRpb24ubmFtZSAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICYmICFtb2RlbFV0aWwuaXNJZElubmVyKGNwdE9wdGlvbilcbiAgICAgICAgICAgICAgICAgICAgJiYgIW1vZGVsVXRpbC5pc0lkSW5uZXIoZXhpc3QpXG4gICAgICAgICAgICAgICAgICAgICYmIGV4aXN0Lm5hbWUgPT09IGNwdE9wdGlvbi5uYW1lICsgJydcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldLm9wdGlvbiA9IGNwdE9wdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q3B0T3B0aW9uc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBPdGhlcndpc2UgbWFwcGluZyBieSBpbmRleC5cbiAgICAgICAgZWFjaChuZXdDcHRPcHRpb25zLCBmdW5jdGlvbiAoY3B0T3B0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCFpc09iamVjdChjcHRPcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBleGlzdCA9IHJlc3VsdFtpXS5leGlzdDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdFtpXS5vcHRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhpc3RpbmcgbW9kZWwgdGhhdCBhbHJlYWR5IGhhcyBpZCBzaG91bGQgYmUgYWJsZSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXBwZWQgdG8gKGJlY2F1c2UgYWZ0ZXIgbWFwcGluZyBwZXJmb3JtZWQgbW9kZWwgbWF5XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIGFzc2lnbmVkIHdpdGggYSBpZCwgd2hpc2ggc2hvdWxkIG5vdCBhZmZlY3QgbmV4dFxuICAgICAgICAgICAgICAgICAgICAvLyBtYXBwaW5nKSwgZXhjZXB0IHRob3NlIGhhcyBpbm5lciBpZC5cbiAgICAgICAgICAgICAgICAgICAgJiYgIW1vZGVsVXRpbC5pc0lkSW5uZXIoZXhpc3QpXG4gICAgICAgICAgICAgICAgICAgIC8vIENhdXRpb246XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBvdmVyd3JpdGUgaWQuIEJ1dCBuYW1lIGNhbiBiZSBvdmVyd3JpdHRlbixcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBheGlzIHVzZSBuYW1lIGFzICdzaG93IGxhYmVsIHRleHQnLlxuICAgICAgICAgICAgICAgICAgICAvLyAnZXhpc3QnIGFsd2F5cyBoYXMgaWQgYW5kIG5hbWUgYW5kIHdlIGRvbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjaGVjayBpdC5cbiAgICAgICAgICAgICAgICAgICAgJiYgY3B0T3B0aW9uLmlkID09IG51bGxcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldLm9wdGlvbiA9IGNwdE9wdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA+PSByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe29wdGlvbjogY3B0T3B0aW9ufSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1ha2UgaWQgYW5kIG5hbWUgZm9yIG1hcHBpbmcgcmVzdWx0IChyZXN1bHQgb2YgbWFwcGluZ1RvRXhpc3RzKVxuICAgICAqIGludG8gYGtleUluZm9gIGZpZWxkLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFJlc3VsdCwgbGlrZSBbe2V4aXN0OiAuLi4sIG9wdGlvbjogLi4ufSwge31dLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBvcmRlciBpcyB0aGUgc2FtZSBhcyBleGlzdHMuXG4gICAgICogQHJldHVybiB7QXJyYXkuPE9iamVjdD59IFRoZSBpbnB1dC5cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwubWFrZUlkQW5kTmFtZSA9IGZ1bmN0aW9uIChtYXBSZXN1bHQpIHtcbiAgICAgICAgLy8gV2UgdXNlIHRoaXMgaWQgdG8gaGFzaCBjb21wb25lbnQgbW9kZWxzIGFuZCB2aWV3IGluc3RhbmNlc1xuICAgICAgICAvLyBpbiBlY2hhcnRzLiBpZCBjYW4gYmUgc3BlY2lmaWVkIGJ5IHVzZXIsIG9yIGF1dG8gZ2VuZXJhdGVkLlxuXG4gICAgICAgIC8vIFRoZSBpZCBnZW5lcmF0aW9uIHJ1bGUgZW5zdXJlcyBuZXcgdmlldyBpbnN0YW5jZSBhcmUgYWJsZVxuICAgICAgICAvLyB0byBtYXBwZWQgdG8gb2xkIGluc3RhbmNlIHdoZW4gc2V0T3B0aW9uIGFyZSBjYWxsZWQgaW5cbiAgICAgICAgLy8gbm8tbWVyZ2UgbW9kZS4gU28gd2UgZ2VuZXJhdGUgbW9kZWwgaWQgYnkgbmFtZSBhbmQgcGx1c1xuICAgICAgICAvLyB0eXBlIGluIHZpZXcgaWQuXG5cbiAgICAgICAgLy8gbmFtZSBjYW4gYmUgZHVwbGljYXRlZCBhbW9uZyBjb21wb25lbnRzLCB3aGljaCBpcyBjb252ZW5pZW50XG4gICAgICAgIC8vIHRvIHNwZWNpZnkgbXVsdGkgY29tcG9uZW50cyAobGlrZSBzZXJpZXMpIGJ5IG9uZSBuYW1lLlxuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IGVhY2ggaWQgaXMgZGlzdGluY3QuXG4gICAgICAgIHZhciBpZE1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG5cbiAgICAgICAgZWFjaChtYXBSZXN1bHQsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGV4aXN0Q3B0ID0gaXRlbS5leGlzdDtcbiAgICAgICAgICAgIGV4aXN0Q3B0ICYmIGlkTWFwLnNldChleGlzdENwdC5pZCwgaXRlbSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVhY2gobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBvcHQgPSBpdGVtLm9wdGlvbjtcblxuICAgICAgICAgICAgenJVdGlsLmFzc2VydChcbiAgICAgICAgICAgICAgICAhb3B0IHx8IG9wdC5pZCA9PSBudWxsIHx8ICFpZE1hcC5nZXQob3B0LmlkKSB8fCBpZE1hcC5nZXQob3B0LmlkKSA9PT0gaXRlbSxcbiAgICAgICAgICAgICAgICAnaWQgZHVwbGljYXRlczogJyArIChvcHQgJiYgb3B0LmlkKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgb3B0ICYmIG9wdC5pZCAhPSBudWxsICYmIGlkTWFwLnNldChvcHQuaWQsIGl0ZW0pO1xuICAgICAgICAgICAgIWl0ZW0ua2V5SW5mbyAmJiAoaXRlbS5rZXlJbmZvID0ge30pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBNYWtlIG5hbWUgYW5kIGlkLlxuICAgICAgICBlYWNoKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RDcHQgPSBpdGVtLmV4aXN0O1xuICAgICAgICAgICAgdmFyIG9wdCA9IGl0ZW0ub3B0aW9uO1xuICAgICAgICAgICAgdmFyIGtleUluZm8gPSBpdGVtLmtleUluZm87XG5cbiAgICAgICAgICAgIGlmICghaXNPYmplY3Qob3B0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbmFtZSBjYW4gYmUgb3ZlcndpdHRlbi4gQ29uc2lkZXIgY2FzZTogYXhpcy5uYW1lID0gJzIwa20nLlxuICAgICAgICAgICAgLy8gQnV0IGlkIGdlbmVyYXRlZCBieSBuYW1lIHdpbGwgbm90IGJlIGNoYW5nZWQsIHdoaWNoIGFmZmVjdFxuICAgICAgICAgICAgLy8gb25seSBpbiB0aGF0IGNhc2U6IHNldE9wdGlvbiB3aXRoICdub3QgbWVyZ2UgbW9kZScgYW5kIHZpZXdcbiAgICAgICAgICAgIC8vIGluc3RhbmNlIHdpbGwgYmUgcmVjcmVhdGVkLCB3aGljaCBjYW4gYmUgYWNjZXB0ZWQuXG4gICAgICAgICAgICBrZXlJbmZvLm5hbWUgPSBvcHQubmFtZSAhPSBudWxsXG4gICAgICAgICAgICAgICAgPyBvcHQubmFtZSArICcnXG4gICAgICAgICAgICAgICAgOiBleGlzdENwdFxuICAgICAgICAgICAgICAgID8gZXhpc3RDcHQubmFtZVxuICAgICAgICAgICAgICAgIDogJ1xcMC0nOyAvLyBuYW1lIG1heSBiZSBkaXNwbGF5ZWQgb24gc2NyZWVuLCBzbyB1c2UgJy0nLlxuXG4gICAgICAgICAgICBpZiAoZXhpc3RDcHQpIHtcbiAgICAgICAgICAgICAgICBrZXlJbmZvLmlkID0gZXhpc3RDcHQuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHQuaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGtleUluZm8uaWQgPSBvcHQuaWQgKyAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIHRoaXMgc2l0dWF0b2luOlxuICAgICAgICAgICAgICAgIC8vICBvcHRpb25BOiBbe25hbWU6ICdhJ30sIHtuYW1lOiAnYSd9LCB7Li59XVxuICAgICAgICAgICAgICAgIC8vICBvcHRpb25CIFt7Li59LCB7bmFtZTogJ2EnfSwge25hbWU6ICdhJ31dXG4gICAgICAgICAgICAgICAgLy8gU2VyaWVzIHdpdGggdGhlIHNhbWUgbmFtZSBiZXR3ZWVuIG9wdGlvbkEgYW5kIG9wdGlvbkJcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgbWFwcGVkLlxuICAgICAgICAgICAgICAgIHZhciBpZE51bSA9IDA7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBrZXlJbmZvLmlkID0gJ1xcMCcgKyBrZXlJbmZvLm5hbWUgKyAnXFwwJyArIGlkTnVtKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChpZE1hcC5nZXQoa2V5SW5mby5pZCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZE1hcC5zZXQoa2V5SW5mby5pZCwgaXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNwdE9wdGlvblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgbW9kZWxVdGlsLmlzSWRJbm5lciA9IGZ1bmN0aW9uIChjcHRPcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGNwdE9wdGlvbilcbiAgICAgICAgICAgICYmIGNwdE9wdGlvbi5pZFxuICAgICAgICAgICAgJiYgKGNwdE9wdGlvbi5pZCArICcnKS5pbmRleE9mKCdcXDBfZWNfXFwwJykgPT09IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIGZvciByZW1vdmluZyBkdXBsaWNhdGUgaXRlbXMgYmV0d2VlbiBiYXRjaEEgYW5kIGJhdGNoQixcbiAgICAgKiBhbmQgaW4gdGhlbXNlbHZlcywgYW5kIGNhdGVnb3JpemUgYnkgc2VyaWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gYmF0Y2hBIExpa2U6IFt7c2VyaWVzSWQ6IDIsIGRhdGFJbmRleDogWzMyLCA0LCA1XX0sIC4uLl1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBiYXRjaEIgTGlrZTogW3tzZXJpZXNJZDogMiwgZGF0YUluZGV4OiBbMzIsIDQsIDVdfSwgLi4uXVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48T2JqZWN0PiwgQXJyYXkuPE9iamVjdD4+fSByZXN1bHQ6IFtyZXN1bHRCYXRjaEEsIHJlc3VsdEJhdGNoQl1cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwuY29tcHJlc3NCYXRjaGVzID0gZnVuY3Rpb24gKGJhdGNoQSwgYmF0Y2hCKSB7XG4gICAgICAgIHZhciBtYXBBID0ge307XG4gICAgICAgIHZhciBtYXBCID0ge307XG5cbiAgICAgICAgbWFrZU1hcChiYXRjaEEgfHwgW10sIG1hcEEpO1xuICAgICAgICBtYWtlTWFwKGJhdGNoQiB8fCBbXSwgbWFwQiwgbWFwQSk7XG5cbiAgICAgICAgcmV0dXJuIFttYXBUb0FycmF5KG1hcEEpLCBtYXBUb0FycmF5KG1hcEIpXTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlTWFwKHNvdXJjZUJhdGNoLCBtYXAsIG90aGVyTWFwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlQmF0Y2gubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzSWQgPSBzb3VyY2VCYXRjaFtpXS5zZXJpZXNJZDtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YUluZGljZXMgPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShzb3VyY2VCYXRjaFtpXS5kYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciBvdGhlckRhdGFJbmRpY2VzID0gb3RoZXJNYXAgJiYgb3RoZXJNYXBbc2VyaWVzSWRdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbmogPSBkYXRhSW5kaWNlcy5sZW5ndGg7IGogPCBsZW5qOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGRhdGFJbmRpY2VzW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckRhdGFJbmRpY2VzICYmIG90aGVyRGF0YUluZGljZXNbZGF0YUluZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJEYXRhSW5kaWNlc1tkYXRhSW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChtYXBbc2VyaWVzSWRdIHx8IChtYXBbc2VyaWVzSWRdID0ge30pKVtkYXRhSW5kZXhdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwLCBpc0RhdGEpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShpKSAmJiBtYXBbaV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgraSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUluZGljZXMgPSBtYXBUb0FycmF5KG1hcFtpXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSW5kaWNlcy5sZW5ndGggJiYgcmVzdWx0LnB1c2goe3Nlcmllc0lkOiBpLCBkYXRhSW5kZXg6IGRhdGFJbmRpY2VzfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgQ29udGFpbnMgZGF0YUluZGV4IChtZWFucyByYXdJbmRleCkgLyBkYXRhSW5kZXhJbnNpZGUgLyBuYW1lXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgZWFjaCBvZiB3aGljaCBjYW4gYmUgQXJyYXkgb3IgcHJpbWFyeSB0eXBlLlxuICAgICAqIEByZXR1cm4ge251bWJlcnxBcnJheS48bnVtYmVyPn0gZGF0YUluZGV4IElmIG5vdCBmb3VuZCwgcmV0dXJuIHVuZGVmaW5lZC9udWxsLlxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleCA9IGZ1bmN0aW9uIChkYXRhLCBwYXlsb2FkKSB7XG4gICAgICAgIGlmIChwYXlsb2FkLmRhdGFJbmRleEluc2lkZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZC5kYXRhSW5kZXhJbnNpZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGF5bG9hZC5kYXRhSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5pc0FycmF5KHBheWxvYWQuZGF0YUluZGV4KVxuICAgICAgICAgICAgICAgID8genJVdGlsLm1hcChwYXlsb2FkLmRhdGFJbmRleCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmluZGV4T2ZSYXdJbmRleCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IGRhdGEuaW5kZXhPZlJhd0luZGV4KHBheWxvYWQuZGF0YUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXlsb2FkLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5pc0FycmF5KHBheWxvYWQubmFtZSlcbiAgICAgICAgICAgICAgICA/IHpyVXRpbC5tYXAocGF5bG9hZC5uYW1lLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuaW5kZXhPZk5hbWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBkYXRhLmluZGV4T2ZOYW1lKHBheWxvYWQubmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHByb3BlcnR5IHN0b3JhZ2UgdG8gYW55IGhvc3Qgb2JqZWN0LlxuICAgICAqIE5vdGljZTogU2VyaWFsaXphdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGU6XG4gICAgICogdmFyIGdldCA9IG1vZGVsVWl0bC5tYWtlR2V0dGVyKCk7XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzb21lKGhvc3RPYmopIHtcbiAgICAgKiAgICAgIGdldChob3N0T2JqKS5fc29tZVByb3BlcnR5ID0gMTIxMjtcbiAgICAgKiAgICAgIC4uLlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5tYWtlR2V0dGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSAnXFwwX19lY19wcm9wX2dldHRlcl8nICsgaW5kZXgrKztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaG9zdE9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3N0T2JqW2tleV0gfHwgKGhvc3RPYmpba2V5XSA9IHt9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBmaW5kZXJcbiAgICAgKiAgICAgICAgSWYgc3RyaW5nLCBlLmcuLCAnZ2VvJywgbWVhbnMge2dlb0luZGV4OiAwfS5cbiAgICAgKiAgICAgICAgSWYgT2JqZWN0LCBjb3VsZCBjb250YWluIHNvbWUgb2YgdGhlc2UgcHJvcGVydGllcyBiZWxvdzpcbiAgICAgKiAgICAgICAge1xuICAgICAqICAgICAgICAgICAgc2VyaWVzSW5kZXgsIHNlcmllc0lkLCBzZXJpZXNOYW1lLFxuICAgICAqICAgICAgICAgICAgZ2VvSW5kZXgsIGdlb0lkLCBnZW9OYW1lLFxuICAgICAqICAgICAgICAgICAgYm1hcEluZGV4LCBibWFwSWQsIGJtYXBOYW1lLFxuICAgICAqICAgICAgICAgICAgeEF4aXNJbmRleCwgeEF4aXNJZCwgeEF4aXNOYW1lLFxuICAgICAqICAgICAgICAgICAgeUF4aXNJbmRleCwgeUF4aXNJZCwgeUF4aXNOYW1lLFxuICAgICAqICAgICAgICAgICAgZ3JpZEluZGV4LCBncmlkSWQsIGdyaWROYW1lLFxuICAgICAqICAgICAgICAgICAgLi4uIChjYW4gYmUgZXh0ZW5kZWQpXG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgICAgRWFjaCBwcm9wZXJ0aWVzIGNhbiBiZSBudW1iZXJ8c3RyaW5nfEFycmF5LjxudW1iZXI+fEFycmF5LjxzdHJpbmc+XG4gICAgICogICAgICAgIEZvciBleGFtcGxlLCBhIGZpbmRlciBjb3VsZCBiZVxuICAgICAqICAgICAgICB7XG4gICAgICogICAgICAgICAgICBzZXJpZXNJbmRleDogMyxcbiAgICAgKiAgICAgICAgICAgIGdlb0lkOiBbJ2FhJywgJ2NjJ10sXG4gICAgICogICAgICAgICAgICBncmlkTmFtZTogWyd4eCcsICdyciddXG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgICAgeHh4SW5kZXggY2FuIGJlIHNldCBhcyAnYWxsJyAobWVhbnMgYWxsIHh4eCkgb3IgJ25vbmUnIChtZWFucyBub3Qgc3BlY2lmeSlcbiAgICAgKiAgICAgICAgSWYgbm90aGluZyBvciBudWxsL3VuZGVmaW5lZCBzcGVjaWZpZWQsIHJldHVybiBub3RoaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LmRlZmF1bHRNYWluVHlwZV1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbb3B0LmluY2x1ZGVNYWluVHlwZXNdXG4gICAgICogQHJldHVybiB7T2JqZWN0fSByZXN1bHQgbGlrZTpcbiAgICAgKiAgICAgICAge1xuICAgICAqICAgICAgICAgICAgc2VyaWVzTW9kZWxzOiBbc2VyaWVzTW9kZWwxLCBzZXJpZXNNb2RlbDJdLFxuICAgICAqICAgICAgICAgICAgc2VyaWVzTW9kZWw6IHNlcmllc01vZGVsMSwgLy8gVGhlIGZpcnN0IG1vZGVsXG4gICAgICogICAgICAgICAgICBnZW9Nb2RlbHM6IFtnZW9Nb2RlbDEsIGdlb01vZGVsMl0sXG4gICAgICogICAgICAgICAgICBnZW9Nb2RlbDogZ2VvTW9kZWwxLCAvLyBUaGUgZmlyc3QgbW9kZWxcbiAgICAgKiAgICAgICAgICAgIC4uLlxuICAgICAqICAgICAgICB9XG4gICAgICovXG4gICAgbW9kZWxVdGlsLnBhcnNlRmluZGVyID0gZnVuY3Rpb24gKGVjTW9kZWwsIGZpbmRlciwgb3B0KSB7XG4gICAgICAgIGlmICh6clV0aWwuaXNTdHJpbmcoZmluZGVyKSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICAgICAgb2JqW2ZpbmRlciArICdJbmRleCddID0gMDtcbiAgICAgICAgICAgIGZpbmRlciA9IG9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWZhdWx0TWFpblR5cGUgPSBvcHQgJiYgb3B0LmRlZmF1bHRNYWluVHlwZTtcbiAgICAgICAgaWYgKGRlZmF1bHRNYWluVHlwZVxuICAgICAgICAgICAgJiYgIWhhcyhmaW5kZXIsIGRlZmF1bHRNYWluVHlwZSArICdJbmRleCcpXG4gICAgICAgICAgICAmJiAhaGFzKGZpbmRlciwgZGVmYXVsdE1haW5UeXBlICsgJ0lkJylcbiAgICAgICAgICAgICYmICFoYXMoZmluZGVyLCBkZWZhdWx0TWFpblR5cGUgKyAnTmFtZScpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZmluZGVyW2RlZmF1bHRNYWluVHlwZSArICdJbmRleCddID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICBlYWNoKGZpbmRlciwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGZpbmRlcltrZXldO1xuXG4gICAgICAgICAgICAvLyBFeGNsdWRlICdkYXRhSW5kZXgnIGFuZCBvdGhlciBpbGxnYWwga2V5cy5cbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdkYXRhSW5kZXgnIHx8IGtleSA9PT0gJ2RhdGFJbmRleEluc2lkZScpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcnNlZEtleSA9IGtleS5tYXRjaCgvXihcXHcrKShJbmRleHxJZHxOYW1lKSQvKSB8fCBbXTtcbiAgICAgICAgICAgIHZhciBtYWluVHlwZSA9IHBhcnNlZEtleVsxXTtcbiAgICAgICAgICAgIHZhciBxdWVyeVR5cGUgPSAocGFyc2VkS2V5WzJdIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoIW1haW5UeXBlXG4gICAgICAgICAgICAgICAgfHwgIXF1ZXJ5VHlwZVxuICAgICAgICAgICAgICAgIHx8IHZhbHVlID09IG51bGxcbiAgICAgICAgICAgICAgICB8fCAocXVlcnlUeXBlID09PSAnaW5kZXgnICYmIHZhbHVlID09PSAnbm9uZScpXG4gICAgICAgICAgICAgICAgfHwgKG9wdCAmJiBvcHQuaW5jbHVkZU1haW5UeXBlcyAmJiB6clV0aWwuaW5kZXhPZihvcHQuaW5jbHVkZU1haW5UeXBlcywgbWFpblR5cGUpIDwgMClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHF1ZXJ5UGFyYW0gPSB7bWFpblR5cGU6IG1haW5UeXBlfTtcbiAgICAgICAgICAgIGlmIChxdWVyeVR5cGUgIT09ICdpbmRleCcgfHwgdmFsdWUgIT09ICdhbGwnKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbVtxdWVyeVR5cGVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtb2RlbHMgPSBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyhxdWVyeVBhcmFtKTtcbiAgICAgICAgICAgIHJlc3VsdFttYWluVHlwZSArICdNb2RlbHMnXSA9IG1vZGVscztcbiAgICAgICAgICAgIHJlc3VsdFttYWluVHlwZSArICdNb2RlbCddID0gbW9kZWxzWzBdO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnN9XG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRhdGFEaW1cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgbW9kZWxVdGlsLmRhdGFEaW1Ub0Nvb3JkRGltID0gZnVuY3Rpb24gKGRhdGEsIGRhdGFEaW0pIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBkYXRhLmRpbWVuc2lvbnM7XG4gICAgICAgIGRhdGFEaW0gPSBkYXRhLmdldERpbWVuc2lvbihkYXRhRGltKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGltSXRlbSA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1lbnNpb25zW2ldKTtcbiAgICAgICAgICAgIGlmIChkaW1JdGVtLm5hbWUgPT09IGRhdGFEaW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGltSXRlbS5jb29yZERpbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnN9XG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29vcmREaW1cbiAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gZGF0YSBkaW1lbnNpb25zIG9uIHRoZSBjb29yZERpbS5cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwuY29vcmREaW1Ub0RhdGFEaW0gPSBmdW5jdGlvbiAoZGF0YSwgY29vcmREaW0pIHtcbiAgICAgICAgdmFyIGRhdGFEaW0gPSBbXTtcbiAgICAgICAgZWFjaChkYXRhLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkaW1OYW1lKSB7XG4gICAgICAgICAgICB2YXIgZGltSXRlbSA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1OYW1lKTtcbiAgICAgICAgICAgIGlmIChkaW1JdGVtLmNvb3JkRGltID09PSBjb29yZERpbSkge1xuICAgICAgICAgICAgICAgIGRhdGFEaW1bZGltSXRlbS5jb29yZERpbUluZGV4XSA9IGRpbUl0ZW0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhRGltO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnN9XG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3RoZXJEaW0gQ2FuIGJlIGBvdGhlckRpbXNgXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBsaWtlICdsYWJlbCcgb3IgJ3Rvb2x0aXAnLlxuICAgICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBkYXRhIGRpbWVuc2lvbnMgb24gdGhlIG90aGVyRGltLlxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5vdGhlckRpbVRvRGF0YURpbSA9IGZ1bmN0aW9uIChkYXRhLCBvdGhlckRpbSkge1xuICAgICAgICB2YXIgZGF0YURpbSA9IFtdO1xuICAgICAgICBlYWNoKGRhdGEuZGltZW5zaW9ucywgZnVuY3Rpb24gKGRpbU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBkaW1JdGVtID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRpbU5hbWUpO1xuICAgICAgICAgICAgdmFyIG90aGVyRGltcyA9IGRpbUl0ZW0ub3RoZXJEaW1zO1xuICAgICAgICAgICAgdmFyIGRpbUluZGV4ID0gb3RoZXJEaW1zW290aGVyRGltXTtcbiAgICAgICAgICAgIGlmIChkaW1JbmRleCAhPSBudWxsICYmIGRpbUluZGV4ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGRhdGFEaW1bZGltSW5kZXhdID0gZGltSXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGFEaW07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGhhcyhvYmosIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmouaGFzT3duUHJvcGVydHkocHJvcCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtb2RlbFV0aWw7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi91dGlsL21vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n    var numberUtil = __webpack_require__(23);\n    var textContain = __webpack_require__(24);\n\n    var formatUtil = {};\n\n    /**\n     * 每三位默认加,格式化\n     * @param {string|number} x\n     * @return {string}\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n               + (x.length > 1 ? ('.' + x[1]) : '');\n    };\n\n    /**\n     * @param {string} str\n     * @param {boolean} [upperCaseFirst=false]\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str, upperCaseFirst) {\n        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n            return group1.toUpperCase();\n        });\n\n        if (upperCaseFirst && str) {\n            str = str.charAt(0).toUpperCase() + str.slice(1);\n        }\n\n        return str;\n    };\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        else if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    };\n\n    var encodeHTML = formatUtil.encodeHTML = function (source) {\n        return String(source)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    };\n\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    /**\n     * Template formatter\n     * @param {string} tpl\n     * @param {Array.<Object>|Object} paramsList\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList, encode) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            var val = wrapVar(alias, 0);\n            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                var val = paramsList[seriesIdx][$vars[k]];\n                tpl = tpl.replace(\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                    encode ? encodeHTML(val) : val\n                );\n            }\n        }\n\n        return tpl;\n    };\n\n    /**\n     * simple Template formatter\n     *\n     * @param {string} tpl\n     * @param {Object} param\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTplSimple = function (tpl, param, encode) {\n        zrUtil.each(param, function (value, key) {\n            tpl = tpl.replace(\n                '{' + key + '}',\n                encode ? encodeHTML(value) : value\n            );\n        });\n        return tpl;\n    };\n\n    /**\n     * @param {string} color\n     * @param {string} [extraCssText]\n     * @return {string}\n     */\n    formatUtil.getTooltipMarker = function (color, extraCssText) {\n        return color\n            ? '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:'\n                + formatUtil.encodeHTML(color) + ';' + (extraCssText || '') + '\"></span>'\n            : '';\n    };\n\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? ('0' + str) : str;\n    };\n\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @param {boolean} [isUTC=false] Default in local time.\n     *           see `module:echarts/scale/Time`\n     *           and `module:echarts/util/number#parseDate`.\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value, isUTC) {\n        if (tpl === 'week'\n            || tpl === 'month'\n            || tpl === 'quarter'\n            || tpl === 'half-year'\n            || tpl === 'year'\n        ) {\n            tpl = 'MM-dd\\nyyyy';\n        }\n\n        var date = numberUtil.parseDate(value);\n        var utc = isUTC ? 'UTC' : '';\n        var y = date['get' + utc + 'FullYear']();\n        var M = date['get' + utc + 'Month']() + 1;\n        var d = date['get' + utc + 'Date']();\n        var h = date['get' + utc + 'Hours']();\n        var m = date['get' + utc + 'Minutes']();\n        var s = date['get' + utc + 'Seconds']();\n\n        tpl = tpl.replace('MM', s2d(M))\n            .toLowerCase()\n            .replace('yyyy', y)\n            .replace('yy', y % 100)\n            .replace('dd', s2d(d))\n            .replace('d', d)\n            .replace('hh', s2d(h))\n            .replace('h', h)\n            .replace('mm', s2d(m))\n            .replace('m', m)\n            .replace('ss', s2d(s))\n            .replace('s', s);\n\n        return tpl;\n    };\n\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n\n    formatUtil.truncateText = textContain.truncateText;\n\n    module.exports = formatUtil;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3V0aWwvZm9ybWF0LmpzPzdmNzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUksVUFBVSxFQUFFO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQzs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQix1REFBdUQ7QUFDeEU7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3RELDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFLHNDQUFzQyxVQUFVLFdBQVc7QUFDM0QsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4vbnVtYmVyJyk7XG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29udGFpbi90ZXh0Jyk7XG5cbiAgICB2YXIgZm9ybWF0VXRpbCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICog5q+P5LiJ5L2N6buY6K6k5YqgLOagvOW8j+WMllxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0geFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBmb3JtYXRVdGlsLmFkZENvbW1hcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmIChpc05hTih4KSkge1xuICAgICAgICAgICAgcmV0dXJuICctJztcbiAgICAgICAgfVxuICAgICAgICB4ID0gKHggKyAnJykuc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIHhbMF0ucmVwbGFjZSgvKFxcZHsxLDN9KSg/PSg/OlxcZHszfSkrKD8hXFxkKSkvZywnJDEsJylcbiAgICAgICAgICAgICAgICsgKHgubGVuZ3RoID4gMSA/ICgnLicgKyB4WzFdKSA6ICcnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwcGVyQ2FzZUZpcnN0PWZhbHNlXVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAgICovXG4gICAgZm9ybWF0VXRpbC50b0NhbWVsQ2FzZSA9IGZ1bmN0aW9uIChzdHIsIHVwcGVyQ2FzZUZpcnN0KSB7XG4gICAgICAgIHN0ciA9IChzdHIgfHwgJycpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLSguKS9nLCBmdW5jdGlvbihtYXRjaCwgZ3JvdXAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAxLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh1cHBlckNhc2VGaXJzdCAmJiBzdHIpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBjc3MgbGlrZWQgYXJyYXkgY29uZmlndXJhdGlvblxuICAgICAqIGUuZy5cbiAgICAgKiAgMyA9PiBbMywgMywgMywgM11cbiAgICAgKiAgWzQsIDJdID0+IFs0LCAyLCA0LCAyXVxuICAgICAqICBbNCwgMywgMl0gPT4gWzQsIDMsIDIsIDNdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IHZhbFxuICAgICAqL1xuICAgIGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xuICAgICAgICBpZiAodHlwZW9mICh2YWwpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIFt2YWwsIHZhbCwgdmFsLCB2YWxdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgICAgICAgLy8gdmVydGljYWwgfCBob3Jpem9udGFsXG4gICAgICAgICAgICByZXR1cm4gW3ZhbFswXSwgdmFsWzFdLCB2YWxbMF0sIHZhbFsxXV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID09PSAzKSB7XG4gICAgICAgICAgICAvLyB0b3AgfCBob3Jpem9udGFsIHwgYm90dG9tXG4gICAgICAgICAgICByZXR1cm4gW3ZhbFswXSwgdmFsWzFdLCB2YWxbMl0sIHZhbFsxXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgdmFyIGVuY29kZUhUTUwgPSBmb3JtYXRVdGlsLmVuY29kZUhUTUwgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoc291cmNlKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpO1xuICAgIH07XG5cbiAgICB2YXIgVFBMX1ZBUl9BTElBUyA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZyddO1xuXG4gICAgdmFyIHdyYXBWYXIgPSBmdW5jdGlvbiAodmFyTmFtZSwgc2VyaWVzSWR4KSB7XG4gICAgICAgIHJldHVybiAneycgKyB2YXJOYW1lICsgKHNlcmllc0lkeCA9PSBudWxsID8gJycgOiBzZXJpZXNJZHgpICsgJ30nO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZW1wbGF0ZSBmb3JtYXR0ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHBsXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0PnxPYmplY3R9IHBhcmFtc0xpc3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmNvZGU9ZmFsc2VdXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1hdFV0aWwuZm9ybWF0VHBsID0gZnVuY3Rpb24gKHRwbCwgcGFyYW1zTGlzdCwgZW5jb2RlKSB7XG4gICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkocGFyYW1zTGlzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtc0xpc3QgPSBbcGFyYW1zTGlzdF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlcmllc0xlbiA9IHBhcmFtc0xpc3QubGVuZ3RoO1xuICAgICAgICBpZiAoIXNlcmllc0xlbikge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyICR2YXJzID0gcGFyYW1zTGlzdFswXS4kdmFycyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAkdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGFsaWFzID0gVFBMX1ZBUl9BTElBU1tpXTtcbiAgICAgICAgICAgIHZhciB2YWwgPSB3cmFwVmFyKGFsaWFzLCAwKTtcbiAgICAgICAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKHdyYXBWYXIoYWxpYXMpLCBlbmNvZGUgPyBlbmNvZGVIVE1MKHZhbCkgOiB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHNlcmllc0lkeCA9IDA7IHNlcmllc0lkeCA8IHNlcmllc0xlbjsgc2VyaWVzSWR4KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgJHZhcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gcGFyYW1zTGlzdFtzZXJpZXNJZHhdWyR2YXJzW2tdXTtcbiAgICAgICAgICAgICAgICB0cGwgPSB0cGwucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgd3JhcFZhcihUUExfVkFSX0FMSUFTW2tdLCBzZXJpZXNJZHgpLFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGUgPyBlbmNvZGVIVE1MKHZhbCkgOiB2YWxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRwbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2ltcGxlIFRlbXBsYXRlIGZvcm1hdHRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRwbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuY29kZT1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZm9ybWF0VXRpbC5mb3JtYXRUcGxTaW1wbGUgPSBmdW5jdGlvbiAodHBsLCBwYXJhbSwgZW5jb2RlKSB7XG4gICAgICAgIHpyVXRpbC5lYWNoKHBhcmFtLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgdHBsID0gdHBsLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgJ3snICsga2V5ICsgJ30nLFxuICAgICAgICAgICAgICAgIGVuY29kZSA/IGVuY29kZUhUTUwodmFsdWUpIDogdmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHBsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4dHJhQ3NzVGV4dF1cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZm9ybWF0VXRpbC5nZXRUb29sdGlwTWFya2VyID0gZnVuY3Rpb24gKGNvbG9yLCBleHRyYUNzc1RleHQpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yXG4gICAgICAgICAgICA/ICc8c3BhbiBzdHlsZT1cImRpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1yaWdodDo1cHg7J1xuICAgICAgICAgICAgICAgICsgJ2JvcmRlci1yYWRpdXM6MTBweDt3aWR0aDo5cHg7aGVpZ2h0OjlweDtiYWNrZ3JvdW5kLWNvbG9yOidcbiAgICAgICAgICAgICAgICArIGZvcm1hdFV0aWwuZW5jb2RlSFRNTChjb2xvcikgKyAnOycgKyAoZXh0cmFDc3NUZXh0IHx8ICcnKSArICdcIj48L3NwYW4+J1xuICAgICAgICAgICAgOiAnJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgczJkID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyIDwgMTAgPyAoJzAnICsgc3RyKSA6IHN0cjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSVNPIERhdGUgZm9ybWF0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRwbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzVVRDPWZhbHNlXSBEZWZhdWx0IGluIGxvY2FsIHRpbWUuXG4gICAgICogICAgICAgICAgIHNlZSBgbW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZWBcbiAgICAgKiAgICAgICAgICAgYW5kIGBtb2R1bGU6ZWNoYXJ0cy91dGlsL251bWJlciNwYXJzZURhdGVgLlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZvcm1hdFV0aWwuZm9ybWF0VGltZSA9IGZ1bmN0aW9uICh0cGwsIHZhbHVlLCBpc1VUQykge1xuICAgICAgICBpZiAodHBsID09PSAnd2VlaydcbiAgICAgICAgICAgIHx8IHRwbCA9PT0gJ21vbnRoJ1xuICAgICAgICAgICAgfHwgdHBsID09PSAncXVhcnRlcidcbiAgICAgICAgICAgIHx8IHRwbCA9PT0gJ2hhbGYteWVhcidcbiAgICAgICAgICAgIHx8IHRwbCA9PT0gJ3llYXInXG4gICAgICAgICkge1xuICAgICAgICAgICAgdHBsID0gJ01NLWRkXFxueXl5eSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0ZSA9IG51bWJlclV0aWwucGFyc2VEYXRlKHZhbHVlKTtcbiAgICAgICAgdmFyIHV0YyA9IGlzVVRDID8gJ1VUQycgOiAnJztcbiAgICAgICAgdmFyIHkgPSBkYXRlWydnZXQnICsgdXRjICsgJ0Z1bGxZZWFyJ10oKTtcbiAgICAgICAgdmFyIE0gPSBkYXRlWydnZXQnICsgdXRjICsgJ01vbnRoJ10oKSArIDE7XG4gICAgICAgIHZhciBkID0gZGF0ZVsnZ2V0JyArIHV0YyArICdEYXRlJ10oKTtcbiAgICAgICAgdmFyIGggPSBkYXRlWydnZXQnICsgdXRjICsgJ0hvdXJzJ10oKTtcbiAgICAgICAgdmFyIG0gPSBkYXRlWydnZXQnICsgdXRjICsgJ01pbnV0ZXMnXSgpO1xuICAgICAgICB2YXIgcyA9IGRhdGVbJ2dldCcgKyB1dGMgKyAnU2Vjb25kcyddKCk7XG5cbiAgICAgICAgdHBsID0gdHBsLnJlcGxhY2UoJ01NJywgczJkKE0pKVxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIC5yZXBsYWNlKCd5eXl5JywgeSlcbiAgICAgICAgICAgIC5yZXBsYWNlKCd5eScsIHkgJSAxMDApXG4gICAgICAgICAgICAucmVwbGFjZSgnZGQnLCBzMmQoZCkpXG4gICAgICAgICAgICAucmVwbGFjZSgnZCcsIGQpXG4gICAgICAgICAgICAucmVwbGFjZSgnaGgnLCBzMmQoaCkpXG4gICAgICAgICAgICAucmVwbGFjZSgnaCcsIGgpXG4gICAgICAgICAgICAucmVwbGFjZSgnbW0nLCBzMmQobSkpXG4gICAgICAgICAgICAucmVwbGFjZSgnbScsIG0pXG4gICAgICAgICAgICAucmVwbGFjZSgnc3MnLCBzMmQocykpXG4gICAgICAgICAgICAucmVwbGFjZSgncycsIHMpO1xuXG4gICAgICAgIHJldHVybiB0cGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhcGl0YWwgZmlyc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1hdFV0aWwuY2FwaXRhbEZpcnN0ID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyID8gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cigxKSA6IHN0cjtcbiAgICB9O1xuXG4gICAgZm9ybWF0VXRpbC50cnVuY2F0ZVRleHQgPSB0ZXh0Q29udGFpbi50cnVuY2F0ZVRleHQ7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZvcm1hdFV0aWw7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi91dGlsL2Zvcm1hdC5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("/**\n * 数值处理模块\n * @module echarts/util/number\n */\n\n\n\n    var zrUtil = __webpack_require__(20);\n\n    var number = {};\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n\n        if (subDomain === 0) {\n            return subRange === 0\n                ? range[0]\n                : (range[0] + range[1]) / 2;\n        }\n\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                }\n                else if (val >= domain[1]) {\n                    return range[1];\n                }\n            }\n            else {\n                if (val >= domain[0]) {\n                    return range[0];\n                }\n                else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        }\n        else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function(percent, all) {\n        switch (percent) {\n            case 'center':\n            case 'middle':\n                percent = '50%';\n                break;\n            case 'left':\n            case 'top':\n                percent = '0%';\n                break;\n            case 'right':\n            case 'bottom':\n                percent = '100%';\n                break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n\n            return parseFloat(percent);\n        }\n\n        return percent == null ? NaN : +percent;\n    };\n\n    /**\n     * (1) Fix rounding error of float numbers.\n     * (2) Support return string to avoid scientific notation like '3.5e-7'.\n     *\n     * @param {number} x\n     * @param {number} [precision]\n     * @param {boolean} [returnStr]\n     * @return {number|string}\n     */\n    number.round = function (x, precision, returnStr) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // Avoid range error\n        precision = Math.min(Math.max(0, precision), 20);\n        x = (+x).toFixed(precision);\n        return returnStr ? x : +x;\n    };\n\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n\n    /**\n     * @param {string|number} val\n     * @return {number}\n     */\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n\n        // Consider scientific notation: '3.4e-12' '3.4e+12'\n        var eIndex = str.indexOf('e');\n        if (eIndex > 0) {\n            var precision = +str.slice(eIndex + 1);\n            return precision < 0 ? -precision : 0;\n        }\n        else {\n            var dotIndex = str.indexOf('.');\n            return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n        }\n    };\n\n    /**\n     * Minimal dicernible data precisioin according to a single pixel.\n     *\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number} precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        // toFixed() digits argument must be between 0 and 20.\n        var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n        return !isFinite(precision) ? 20 : precision;\n    };\n\n    /**\n     * Get a data of given precision, assuring the sum of percentages\n     * in valueList is 1.\n     * The largest remainer method is used.\n     * https://en.wikipedia.org/wiki/Largest_remainder_method\n     *\n     * @param {Array.<number>} valueList a list of all data\n     * @param {number} idx index of the data to be processed in valueList\n     * @param {number} precision integer number showing digits of precision\n     * @return {number} percent ranging from 0 to 100\n     */\n    number.getPercentWithPrecision = function (valueList, idx, precision) {\n        if (!valueList[idx]) {\n            return 0;\n        }\n\n        var sum = zrUtil.reduce(valueList, function (acc, val) {\n            return acc + (isNaN(val) ? 0 : val);\n        }, 0);\n        if (sum === 0) {\n            return 0;\n        }\n\n        var digits = Math.pow(10, precision);\n        var votesPerQuota = zrUtil.map(valueList, function (val) {\n            return (isNaN(val) ? 0 : val) / sum * digits * 100;\n        });\n        var targetSeats = digits * 100;\n\n        var seats = zrUtil.map(votesPerQuota, function (votes) {\n            // Assign automatic seats.\n            return Math.floor(votes);\n        });\n        var currentSum = zrUtil.reduce(seats, function (acc, val) {\n            return acc + val;\n        }, 0);\n\n        var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {\n            return votes - seats[idx];\n        });\n\n        // Has remainding votes.\n        while (currentSum < targetSeats) {\n            // Find next largest remainder.\n            var max = Number.NEGATIVE_INFINITY;\n            var maxId = null;\n            for (var i = 0, len = remainder.length; i < len; ++i) {\n                if (remainder[i] > max) {\n                    max = remainder[i];\n                    maxId = i;\n                }\n            }\n\n            // Add a vote to max remainder.\n            ++seats[maxId];\n            remainder[maxId] = 0;\n            ++currentSum;\n        }\n\n        return seats[idx] / digits;\n    };\n\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n\n    var TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d\\d)(?::(\\d\\d)(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line\n\n    /**\n     * @return {number} in minutes\n     */\n    number.getTimezoneOffset = function () {\n        return (new Date()).getTimezoneOffset();\n    };\n\n    /**\n     * @param {string|Date|number} value These values can be accepted:\n     *   + An instance of Date, represent a time in its own time zone.\n     *   + Or string in a subset of ISO 8601, only including:\n     *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',\n     *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',\n     *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',\n     *     all of which will be treated as local time if time zone is not specified\n     *     (see <https://momentjs.com/>).\n     *   + Or other string format, including (all of which will be treated as loacal time):\n     *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',\n     *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'\n     *   + a timestamp, which represent a time in UTC.\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            // Different browsers parse date in different way, so we parse it manually.\n            // Some other issues:\n            // new Date('1970-01-01') is UTC,\n            // new Date('1970/01/01') and new Date('1970-1-01') is local.\n            // See issue #3623\n            var match = TIME_REG.exec(value);\n\n            if (!match) {\n                // return Invalid Date.\n                return new Date(NaN);\n            }\n\n            var timezoneOffset = number.getTimezoneOffset();\n            var timeOffset = !match[8]\n                ? 0\n                : match[8].toUpperCase() === 'Z'\n                ? timezoneOffset\n                : +match[8].slice(0, 3) * 60 + timezoneOffset;\n\n            // match[n] can only be string or undefined.\n            // But take care of '12' + 1 => '121'.\n            return new Date(\n                +match[1],\n                +(match[2] || 1) - 1,\n                +match[3] || 1,\n                +match[4] || 0,\n                +(match[5] || 0) - timeOffset,\n                +match[6] || 0,\n                +match[7] || 0\n            );\n        }\n        else if (value == null) {\n            return new Date(NaN);\n        }\n\n        return new Date(Math.round(value));\n    };\n\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     *\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, quantityExponent(val));\n    };\n\n    function quantityExponent(val) {\n        return Math.floor(Math.log(val) / Math.LN10);\n    }\n\n    /**\n     * find a “nice” number approximately equal to x. Round the number if round = true,\n     * take ceiling if round = false. The primary observation is that the “nicest”\n     * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     *\n     * See \"Nice Numbers for Graph Labels\" of Graphic Gems.\n     *\n     * @param  {number} val Non-negative value.\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exponent = quantityExponent(val);\n        var exp10 = Math.pow(10, exponent);\n        var f = val / exp10; // 1 <= f < 10\n        var nf;\n        if (round) {\n            if (f < 1.5) { nf = 1; }\n            else if (f < 2.5) { nf = 2; }\n            else if (f < 4) { nf = 3; }\n            else if (f < 7) { nf = 5; }\n            else { nf = 10; }\n        }\n        else {\n            if (f < 1) { nf = 1; }\n            else if (f < 2) { nf = 2; }\n            else if (f < 3) { nf = 3; }\n            else if (f < 5) { nf = 5; }\n            else { nf = 10; }\n        }\n        val = nf * exp10;\n\n        // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).\n        // 20 is the uppper bound of toFixed.\n        return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n    };\n\n    /**\n     * Order intervals asc, and split them when overlap.\n     * expect(numberUtil.reformIntervals([\n     *     {interval: [18, 62], close: [1, 1]},\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [1, 1]},\n     *     {interval: [62, 150], close: [1, 1]},\n     *     {interval: [106, 150], close: [1, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ])).toEqual([\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [0, 1]},\n     *     {interval: [18, 62], close: [0, 1]},\n     *     {interval: [62, 150], close: [0, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ]);\n     * @param {Array.<Object>} list, where `close` mean open or close\n     *        of the interval, and Infinity can be used.\n     * @return {Array.<Object>} The origin list, which has been reformed.\n     */\n    number.reformIntervals = function (list) {\n        list.sort(function (a, b) {\n            return littleThan(a, b, 0) ? -1 : 1;\n        });\n\n        var curr = -Infinity;\n        var currClose = 1;\n        for (var i = 0; i < list.length;) {\n            var interval = list[i].interval;\n            var close = list[i].close;\n\n            for (var lg = 0; lg < 2; lg++) {\n                if (interval[lg] <= curr) {\n                    interval[lg] = curr;\n                    close[lg] = !lg ? 1 - currClose : 1;\n                }\n                curr = interval[lg];\n                currClose = close[lg];\n            }\n\n            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n                list.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n\n        return list;\n\n        function littleThan(a, b, lg) {\n            return a.interval[lg] < b.interval[lg]\n                || (\n                    a.interval[lg] === b.interval[lg]\n                    && (\n                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n                        || (!lg && littleThan(a, b, 1))\n                    )\n                );\n        }\n    };\n\n    /**\n     * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n     * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n     * subtraction forces infinities to NaN\n     *\n     * @param {*} v\n     * @return {boolean}\n     */\n    number.isNumeric = function (v) {\n        return v - parseFloat(v) >= 0;\n    };\n\n    module.exports = number;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3V0aWwvbnVtYmVyLmpzPzQzZTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QyxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixFQUFFLGFBQWEsSUFBSSxhQUFhLElBQUksWUFBWSxJQUFJLHVFQUF1RTs7QUFFdko7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDLCtCQUErQixRQUFRO0FBQ3ZDLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRO0FBQ3JDLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQyw2QkFBNkIsUUFBUTtBQUNyQyw2QkFBNkIsUUFBUTtBQUNyQyw2QkFBNkIsUUFBUTtBQUNyQyxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0NBQWtDO0FBQzlDLFlBQVksMENBQTBDO0FBQ3RELFlBQVksb0NBQW9DO0FBQ2hELFlBQVksbUNBQW1DO0FBQy9DLFlBQVksbUNBQW1DO0FBQy9DLFlBQVksb0NBQW9DO0FBQ2hELFlBQVk7QUFDWjtBQUNBLFlBQVksMENBQTBDO0FBQ3RELFlBQVksb0NBQW9DO0FBQ2hELFlBQVksbUNBQW1DO0FBQy9DLFlBQVksa0NBQWtDO0FBQzlDLFlBQVksbUNBQW1DO0FBQy9DLFlBQVk7QUFDWjtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBOztBQUVBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIOaVsOWAvOWkhOeQhuaooeWdl1xuICogQG1vZHVsZSBlY2hhcnRzL3V0aWwvbnVtYmVyXG4gKi9cblxuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgbnVtYmVyID0ge307XG5cbiAgICB2YXIgUkFESUFOX0VQU0lMT04gPSAxZS00O1xuXG4gICAgZnVuY3Rpb24gX3RyaW0oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGluZWFyIG1hcHBpbmcgYSB2YWx1ZSBmcm9tIGRvbWFpbiB0byByYW5nZVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZWNoYXJ0cy91dGlsL251bWJlclxuICAgICAqIEBwYXJhbSAgeyhudW1iZXJ8QXJyYXkuPG51bWJlcj4pfSB2YWxcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gZG9tYWluIERvbWFpbiBleHRlbnQgZG9tYWluWzBdIGNhbiBiZSBiaWdnZXIgdGhhbiBkb21haW5bMV1cbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcmFuZ2UgIFJhbmdlIGV4dGVudCByYW5nZVswXSBjYW4gYmUgYmlnZ2VyIHRoYW4gcmFuZ2VbMV1cbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcFxuICAgICAqIEByZXR1cm4geyhudW1iZXJ8QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgbnVtYmVyLmxpbmVhck1hcCA9IGZ1bmN0aW9uICh2YWwsIGRvbWFpbiwgcmFuZ2UsIGNsYW1wKSB7XG4gICAgICAgIHZhciBzdWJEb21haW4gPSBkb21haW5bMV0gLSBkb21haW5bMF07XG4gICAgICAgIHZhciBzdWJSYW5nZSA9IHJhbmdlWzFdIC0gcmFuZ2VbMF07XG5cbiAgICAgICAgaWYgKHN1YkRvbWFpbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1YlJhbmdlID09PSAwXG4gICAgICAgICAgICAgICAgPyByYW5nZVswXVxuICAgICAgICAgICAgICAgIDogKHJhbmdlWzBdICsgcmFuZ2VbMV0pIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF2b2lkIGFjY3VyYWN5IHByb2JsZW0gaW4gZWRnZSwgc3VjaCBhc1xuICAgICAgICAvLyAxNDYuMzkgLSA2Mi44MyA9PT0gODMuNTU5OTk5OTk5OTk5OTkuXG4gICAgICAgIC8vIFNlZSBlY2hhcnRzL3Rlc3QvdXQvc3BlYy91dGlsL251bWJlci5qcyNsaW5lYXJNYXAjYWNjdXJhY3lFcnJvclxuICAgICAgICAvLyBJdCBpcyBhIGxpdHRsZSB2ZXJib3NlIGZvciBlZmZpY2llbmN5IGNvbnNpZGVyaW5nIHRoaXMgbWV0aG9kXG4gICAgICAgIC8vIGlzIGEgaG90c3BvdC5cbiAgICAgICAgaWYgKGNsYW1wKSB7XG4gICAgICAgICAgICBpZiAoc3ViRG9tYWluID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPD0gZG9tYWluWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByYW5nZVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsID49IGRvbWFpblsxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA+PSBkb21haW5bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgPD0gZG9tYWluWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByYW5nZVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsID09PSBkb21haW5bMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsID09PSBkb21haW5bMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHZhbCAtIGRvbWFpblswXSkgLyBzdWJEb21haW4gKiBzdWJSYW5nZSArIHJhbmdlWzBdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgcGVyY2VudCBzdHJpbmcgdG8gYWJzb2x1dGUgbnVtYmVyLlxuICAgICAqIFJldHVybnMgTmFOIGlmIHBlcmNlbnQgaXMgbm90IGEgdmFsaWQgc3RyaW5nIG9yIG51bWJlclxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZWNoYXJ0cy91dGlsL251bWJlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gcGVyY2VudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbGxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbnVtYmVyLnBhcnNlUGVyY2VudCA9IGZ1bmN0aW9uKHBlcmNlbnQsIGFsbCkge1xuICAgICAgICBzd2l0Y2ggKHBlcmNlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAnNTAlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gJzAlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9ICcxMDAlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBlcmNlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoX3RyaW0ocGVyY2VudCkubWF0Y2goLyUkLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChwZXJjZW50KSAvIDEwMCAqIGFsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocGVyY2VudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGVyY2VudCA9PSBudWxsID8gTmFOIDogK3BlcmNlbnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICgxKSBGaXggcm91bmRpbmcgZXJyb3Igb2YgZmxvYXQgbnVtYmVycy5cbiAgICAgKiAoMikgU3VwcG9ydCByZXR1cm4gc3RyaW5nIHRvIGF2b2lkIHNjaWVudGlmaWMgbm90YXRpb24gbGlrZSAnMy41ZS03Jy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb25dXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0dXJuU3RyXVxuICAgICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd9XG4gICAgICovXG4gICAgbnVtYmVyLnJvdW5kID0gZnVuY3Rpb24gKHgsIHByZWNpc2lvbiwgcmV0dXJuU3RyKSB7XG4gICAgICAgIGlmIChwcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXZvaWQgcmFuZ2UgZXJyb3JcbiAgICAgICAgcHJlY2lzaW9uID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgcHJlY2lzaW9uKSwgMjApO1xuICAgICAgICB4ID0gKCt4KS50b0ZpeGVkKHByZWNpc2lvbik7XG4gICAgICAgIHJldHVybiByZXR1cm5TdHIgPyB4IDogK3g7XG4gICAgfTtcblxuICAgIG51bWJlci5hc2MgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcHJlY2lzaW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbFxuICAgICAqL1xuICAgIG51bWJlci5nZXRQcmVjaXNpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhbCA9ICt2YWw7XG4gICAgICAgIGlmIChpc05hTih2YWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBtdWNoIGZhc3RlciB0aGFuIG1ldGhvZHMgY29udmVydGluZyBudW1iZXIgdG8gc3RyaW5nIGFzIGZvbGxvd3NcbiAgICAgICAgLy8gICAgICB2YXIgdG1wID0gdmFsLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vICAgICAgcmV0dXJuIHRtcC5sZW5ndGggLSAxIC0gdG1wLmluZGV4T2YoJy4nKTtcbiAgICAgICAgLy8gZXNwZWNpYWxseSB3aGVuIHByZWNpc2lvbiBpcyBsb3dcbiAgICAgICAgdmFyIGUgPSAxO1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICB3aGlsZSAoTWF0aC5yb3VuZCh2YWwgKiBlKSAvIGUgIT09IHZhbCkge1xuICAgICAgICAgICAgZSAqPSAxMDtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIuZ2V0UHJlY2lzaW9uU2FmZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIHN0ciA9IHZhbC50b1N0cmluZygpO1xuXG4gICAgICAgIC8vIENvbnNpZGVyIHNjaWVudGlmaWMgbm90YXRpb246ICczLjRlLTEyJyAnMy40ZSsxMidcbiAgICAgICAgdmFyIGVJbmRleCA9IHN0ci5pbmRleE9mKCdlJyk7XG4gICAgICAgIGlmIChlSW5kZXggPiAwKSB7XG4gICAgICAgICAgICB2YXIgcHJlY2lzaW9uID0gK3N0ci5zbGljZShlSW5kZXggKyAxKTtcbiAgICAgICAgICAgIHJldHVybiBwcmVjaXNpb24gPCAwID8gLXByZWNpc2lvbiA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZG90SW5kZXggPSBzdHIuaW5kZXhPZignLicpO1xuICAgICAgICAgICAgcmV0dXJuIGRvdEluZGV4IDwgMCA/IDAgOiBzdHIubGVuZ3RoIC0gMSAtIGRvdEluZGV4O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1pbmltYWwgZGljZXJuaWJsZSBkYXRhIHByZWNpc2lvaW4gYWNjb3JkaW5nIHRvIGEgc2luZ2xlIHBpeGVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZGF0YUV4dGVudFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBpeGVsRXh0ZW50XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBwcmVjaXNpb25cbiAgICAgKi9cbiAgICBudW1iZXIuZ2V0UGl4ZWxQcmVjaXNpb24gPSBmdW5jdGlvbiAoZGF0YUV4dGVudCwgcGl4ZWxFeHRlbnQpIHtcbiAgICAgICAgdmFyIGxvZyA9IE1hdGgubG9nO1xuICAgICAgICB2YXIgTE4xMCA9IE1hdGguTE4xMDtcbiAgICAgICAgdmFyIGRhdGFRdWFudGl0eSA9IE1hdGguZmxvb3IobG9nKGRhdGFFeHRlbnRbMV0gLSBkYXRhRXh0ZW50WzBdKSAvIExOMTApO1xuICAgICAgICB2YXIgc2l6ZVF1YW50aXR5ID0gTWF0aC5yb3VuZChsb2coTWF0aC5hYnMocGl4ZWxFeHRlbnRbMV0gLSBwaXhlbEV4dGVudFswXSkpIC8gTE4xMCk7XG4gICAgICAgIC8vIHRvRml4ZWQoKSBkaWdpdHMgYXJndW1lbnQgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDIwLlxuICAgICAgICB2YXIgcHJlY2lzaW9uID0gTWF0aC5taW4oTWF0aC5tYXgoLWRhdGFRdWFudGl0eSArIHNpemVRdWFudGl0eSwgMCksIDIwKTtcbiAgICAgICAgcmV0dXJuICFpc0Zpbml0ZShwcmVjaXNpb24pID8gMjAgOiBwcmVjaXNpb247XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGRhdGEgb2YgZ2l2ZW4gcHJlY2lzaW9uLCBhc3N1cmluZyB0aGUgc3VtIG9mIHBlcmNlbnRhZ2VzXG4gICAgICogaW4gdmFsdWVMaXN0IGlzIDEuXG4gICAgICogVGhlIGxhcmdlc3QgcmVtYWluZXIgbWV0aG9kIGlzIHVzZWQuXG4gICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGFyZ2VzdF9yZW1haW5kZXJfbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZUxpc3QgYSBsaXN0IG9mIGFsbCBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeCBpbmRleCBvZiB0aGUgZGF0YSB0byBiZSBwcm9jZXNzZWQgaW4gdmFsdWVMaXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiBpbnRlZ2VyIG51bWJlciBzaG93aW5nIGRpZ2l0cyBvZiBwcmVjaXNpb25cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHBlcmNlbnQgcmFuZ2luZyBmcm9tIDAgdG8gMTAwXG4gICAgICovXG4gICAgbnVtYmVyLmdldFBlcmNlbnRXaXRoUHJlY2lzaW9uID0gZnVuY3Rpb24gKHZhbHVlTGlzdCwgaWR4LCBwcmVjaXNpb24pIHtcbiAgICAgICAgaWYgKCF2YWx1ZUxpc3RbaWR4XSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3VtID0genJVdGlsLnJlZHVjZSh2YWx1ZUxpc3QsIGZ1bmN0aW9uIChhY2MsIHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFjYyArIChpc05hTih2YWwpID8gMCA6IHZhbCk7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBpZiAoc3VtID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWdpdHMgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICAgICAgdmFyIHZvdGVzUGVyUXVvdGEgPSB6clV0aWwubWFwKHZhbHVlTGlzdCwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIChpc05hTih2YWwpID8gMCA6IHZhbCkgLyBzdW0gKiBkaWdpdHMgKiAxMDA7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdGFyZ2V0U2VhdHMgPSBkaWdpdHMgKiAxMDA7XG5cbiAgICAgICAgdmFyIHNlYXRzID0genJVdGlsLm1hcCh2b3Rlc1BlclF1b3RhLCBmdW5jdGlvbiAodm90ZXMpIHtcbiAgICAgICAgICAgIC8vIEFzc2lnbiBhdXRvbWF0aWMgc2VhdHMuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih2b3Rlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY3VycmVudFN1bSA9IHpyVXRpbC5yZWR1Y2Uoc2VhdHMsIGZ1bmN0aW9uIChhY2MsIHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFjYyArIHZhbDtcbiAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgdmFyIHJlbWFpbmRlciA9IHpyVXRpbC5tYXAodm90ZXNQZXJRdW90YSwgZnVuY3Rpb24gKHZvdGVzLCBpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB2b3RlcyAtIHNlYXRzW2lkeF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEhhcyByZW1haW5kaW5nIHZvdGVzLlxuICAgICAgICB3aGlsZSAoY3VycmVudFN1bSA8IHRhcmdldFNlYXRzKSB7XG4gICAgICAgICAgICAvLyBGaW5kIG5leHQgbGFyZ2VzdCByZW1haW5kZXIuXG4gICAgICAgICAgICB2YXIgbWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgdmFyIG1heElkID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZW1haW5kZXIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVtYWluZGVyW2ldID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IHJlbWFpbmRlcltpXTtcbiAgICAgICAgICAgICAgICAgICAgbWF4SWQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIGEgdm90ZSB0byBtYXggcmVtYWluZGVyLlxuICAgICAgICAgICAgKytzZWF0c1ttYXhJZF07XG4gICAgICAgICAgICByZW1haW5kZXJbbWF4SWRdID0gMDtcbiAgICAgICAgICAgICsrY3VycmVudFN1bTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWF0c1tpZHhdIC8gZGlnaXRzO1xuICAgIH07XG5cbiAgICAvLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgaWUgZG8gbm90IHN1cHBvcnQuXG4gICAgbnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4gICAgLyoqXG4gICAgICogVG8gMCAtIDIgKiBQSSwgY29uc2lkZXJpbmcgbmVnYXRpdmUgcmFkaWFuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbnVtYmVyLnJlbVJhZGlhbiA9IGZ1bmN0aW9uIChyYWRpYW4pIHtcbiAgICAgICAgdmFyIHBpMiA9IE1hdGguUEkgKiAyO1xuICAgICAgICByZXR1cm4gKHJhZGlhbiAlIHBpMiArIHBpMikgJSBwaTI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7dHlwZX0gcmFkaWFuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBudW1iZXIuaXNSYWRpYW5Bcm91bmRaZXJvID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gLVJBRElBTl9FUFNJTE9OICYmIHZhbCA8IFJBRElBTl9FUFNJTE9OO1xuICAgIH07XG5cbiAgICB2YXIgVElNRV9SRUcgPSAvXig/OihcXGR7NH0pKD86Wy1cXC9dKFxcZHsxLDJ9KSg/OlstXFwvXShcXGR7MSwyfSkoPzpbVCBdKFxcZHsxLDJ9KSg/OjooXFxkXFxkKSg/OjooXFxkXFxkKSg/OlsuLF0oXFxkKykpPyk/KT8oWnxbXFwrXFwtXVxcZFxcZDo/XFxkXFxkKT8pPyk/KT8pPyQvOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gaW4gbWludXRlc1xuICAgICAqL1xuICAgIG51bWJlci5nZXRUaW1lem9uZU9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xEYXRlfG51bWJlcn0gdmFsdWUgVGhlc2UgdmFsdWVzIGNhbiBiZSBhY2NlcHRlZDpcbiAgICAgKiAgICsgQW4gaW5zdGFuY2Ugb2YgRGF0ZSwgcmVwcmVzZW50IGEgdGltZSBpbiBpdHMgb3duIHRpbWUgem9uZS5cbiAgICAgKiAgICsgT3Igc3RyaW5nIGluIGEgc3Vic2V0IG9mIElTTyA4NjAxLCBvbmx5IGluY2x1ZGluZzpcbiAgICAgKiAgICAgKyBvbmx5IHllYXIsIG1vbnRoLCBkYXRlOiAnMjAxMi0wMycsICcyMDEyLTAzLTAxJywgJzIwMTItMDMtMDEgMDUnLCAnMjAxMi0wMy0wMSAwNTowNicsXG4gICAgICogICAgICsgc2VwYXJhdGVkIHdpdGggVCBvciBzcGFjZTogJzIwMTItMDMtMDFUMTI6MjI6MzMuMTIzJywgJzIwMTItMDMtMDEgMTI6MjI6MzMuMTIzJyxcbiAgICAgKiAgICAgKyB0aW1lIHpvbmU6ICcyMDEyLTAzLTAxVDEyOjIyOjMzWicsICcyMDEyLTAzLTAxVDEyOjIyOjMzKzgwMDAnLCAnMjAxMi0wMy0wMVQxMjoyMjozMy0wNTowMCcsXG4gICAgICogICAgIGFsbCBvZiB3aGljaCB3aWxsIGJlIHRyZWF0ZWQgYXMgbG9jYWwgdGltZSBpZiB0aW1lIHpvbmUgaXMgbm90IHNwZWNpZmllZFxuICAgICAqICAgICAoc2VlIDxodHRwczovL21vbWVudGpzLmNvbS8+KS5cbiAgICAgKiAgICsgT3Igb3RoZXIgc3RyaW5nIGZvcm1hdCwgaW5jbHVkaW5nIChhbGwgb2Ygd2hpY2ggd2lsbCBiZSB0cmVhdGVkIGFzIGxvYWNhbCB0aW1lKTpcbiAgICAgKiAgICAgJzIwMTInLCAnMjAxMi0zLTEnLCAnMjAxMi8zLzEnLCAnMjAxMi8wMy8wMScsXG4gICAgICogICAgICcyMDA5LzYvMTIgMjowMCcsICcyMDA5LzYvMTIgMjowNTowOCcsICcyMDA5LzYvMTIgMjowNTowOC4xMjMnXG4gICAgICogICArIGEgdGltZXN0YW1wLCB3aGljaCByZXByZXNlbnQgYSB0aW1lIGluIFVUQy5cbiAgICAgKiBAcmV0dXJuIHtEYXRlfSBkYXRlXG4gICAgICovXG4gICAgbnVtYmVyLnBhcnNlRGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gRGlmZmVyZW50IGJyb3dzZXJzIHBhcnNlIGRhdGUgaW4gZGlmZmVyZW50IHdheSwgc28gd2UgcGFyc2UgaXQgbWFudWFsbHkuXG4gICAgICAgICAgICAvLyBTb21lIG90aGVyIGlzc3VlczpcbiAgICAgICAgICAgIC8vIG5ldyBEYXRlKCcxOTcwLTAxLTAxJykgaXMgVVRDLFxuICAgICAgICAgICAgLy8gbmV3IERhdGUoJzE5NzAvMDEvMDEnKSBhbmQgbmV3IERhdGUoJzE5NzAtMS0wMScpIGlzIGxvY2FsLlxuICAgICAgICAgICAgLy8gU2VlIGlzc3VlICMzNjIzXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBUSU1FX1JFRy5leGVjKHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBJbnZhbGlkIERhdGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0aW1lem9uZU9mZnNldCA9IG51bWJlci5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgICAgICAgdmFyIHRpbWVPZmZzZXQgPSAhbWF0Y2hbOF1cbiAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICA6IG1hdGNoWzhdLnRvVXBwZXJDYXNlKCkgPT09ICdaJ1xuICAgICAgICAgICAgICAgID8gdGltZXpvbmVPZmZzZXRcbiAgICAgICAgICAgICAgICA6ICttYXRjaFs4XS5zbGljZSgwLCAzKSAqIDYwICsgdGltZXpvbmVPZmZzZXQ7XG5cbiAgICAgICAgICAgIC8vIG1hdGNoW25dIGNhbiBvbmx5IGJlIHN0cmluZyBvciB1bmRlZmluZWQuXG4gICAgICAgICAgICAvLyBCdXQgdGFrZSBjYXJlIG9mICcxMicgKyAxID0+ICcxMjEnLlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKFxuICAgICAgICAgICAgICAgICttYXRjaFsxXSxcbiAgICAgICAgICAgICAgICArKG1hdGNoWzJdIHx8IDEpIC0gMSxcbiAgICAgICAgICAgICAgICArbWF0Y2hbM10gfHwgMSxcbiAgICAgICAgICAgICAgICArbWF0Y2hbNF0gfHwgMCxcbiAgICAgICAgICAgICAgICArKG1hdGNoWzVdIHx8IDApIC0gdGltZU9mZnNldCxcbiAgICAgICAgICAgICAgICArbWF0Y2hbNl0gfHwgMCxcbiAgICAgICAgICAgICAgICArbWF0Y2hbN10gfHwgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShNYXRoLnJvdW5kKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFF1YW50aXR5IG9mIGEgbnVtYmVyLiBlLmcuIDAuMSwgMSwgMTAsIDEwMFxuICAgICAqXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbnVtYmVyLnF1YW50aXR5ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gTWF0aC5wb3coMTAsIHF1YW50aXR5RXhwb25lbnQodmFsKSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHF1YW50aXR5RXhwb25lbnQodmFsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMTApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZpbmQgYSDigJxuaWNl4oCdIG51bWJlciBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIHguIFJvdW5kIHRoZSBudW1iZXIgaWYgcm91bmQgPSB0cnVlLFxuICAgICAqIHRha2UgY2VpbGluZyBpZiByb3VuZCA9IGZhbHNlLiBUaGUgcHJpbWFyeSBvYnNlcnZhdGlvbiBpcyB0aGF0IHRoZSDigJxuaWNlc3TigJ1cbiAgICAgKiBudW1iZXJzIGluIGRlY2ltYWwgYXJlIDEsIDIsIGFuZCA1LCBhbmQgYWxsIHBvd2VyLW9mLXRlbiBtdWx0aXBsZXMgb2YgdGhlc2UgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIFNlZSBcIk5pY2UgTnVtYmVycyBmb3IgR3JhcGggTGFiZWxzXCIgb2YgR3JhcGhpYyBHZW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWwgTm9uLW5lZ2F0aXZlIHZhbHVlLlxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IHJvdW5kXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlci5uaWNlID0gZnVuY3Rpb24gKHZhbCwgcm91bmQpIHtcbiAgICAgICAgdmFyIGV4cG9uZW50ID0gcXVhbnRpdHlFeHBvbmVudCh2YWwpO1xuICAgICAgICB2YXIgZXhwMTAgPSBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xuICAgICAgICB2YXIgZiA9IHZhbCAvIGV4cDEwOyAvLyAxIDw9IGYgPCAxMFxuICAgICAgICB2YXIgbmY7XG4gICAgICAgIGlmIChyb3VuZCkge1xuICAgICAgICAgICAgaWYgKGYgPCAxLjUpIHsgbmYgPSAxOyB9XG4gICAgICAgICAgICBlbHNlIGlmIChmIDwgMi41KSB7IG5mID0gMjsgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZiA8IDQpIHsgbmYgPSAzOyB9XG4gICAgICAgICAgICBlbHNlIGlmIChmIDwgNykgeyBuZiA9IDU7IH1cbiAgICAgICAgICAgIGVsc2UgeyBuZiA9IDEwOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZiA8IDEpIHsgbmYgPSAxOyB9XG4gICAgICAgICAgICBlbHNlIGlmIChmIDwgMikgeyBuZiA9IDI7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGYgPCAzKSB7IG5mID0gMzsgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZiA8IDUpIHsgbmYgPSA1OyB9XG4gICAgICAgICAgICBlbHNlIHsgbmYgPSAxMDsgfVxuICAgICAgICB9XG4gICAgICAgIHZhbCA9IG5mICogZXhwMTA7XG5cbiAgICAgICAgLy8gRml4IDMgKiAwLjEgPT09IDAuMzAwMDAwMDAwMDAwMDAwMDQgaXNzdWUgKHNlZSBJRUVFIDc1NCkuXG4gICAgICAgIC8vIDIwIGlzIHRoZSB1cHBwZXIgYm91bmQgb2YgdG9GaXhlZC5cbiAgICAgICAgcmV0dXJuIGV4cG9uZW50ID49IC0yMCA/ICt2YWwudG9GaXhlZChleHBvbmVudCA8IDAgPyAtZXhwb25lbnQgOiAwKSA6IHZhbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogT3JkZXIgaW50ZXJ2YWxzIGFzYywgYW5kIHNwbGl0IHRoZW0gd2hlbiBvdmVybGFwLlxuICAgICAqIGV4cGVjdChudW1iZXJVdGlsLnJlZm9ybUludGVydmFscyhbXG4gICAgICogICAgIHtpbnRlcnZhbDogWzE4LCA2Ml0sIGNsb3NlOiBbMSwgMV19LFxuICAgICAqICAgICB7aW50ZXJ2YWw6IFstSW5maW5pdHksIC03MF0sIGNsb3NlOiBbMCwgMF19LFxuICAgICAqICAgICB7aW50ZXJ2YWw6IFstNzAsIC0yNl0sIGNsb3NlOiBbMSwgMV19LFxuICAgICAqICAgICB7aW50ZXJ2YWw6IFstMjYsIDE4XSwgY2xvc2U6IFsxLCAxXX0sXG4gICAgICogICAgIHtpbnRlcnZhbDogWzYyLCAxNTBdLCBjbG9zZTogWzEsIDFdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbMTA2LCAxNTBdLCBjbG9zZTogWzEsIDFdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbMTUwLCBJbmZpbml0eV0sIGNsb3NlOiBbMCwgMF19XG4gICAgICogXSkpLnRvRXF1YWwoW1xuICAgICAqICAgICB7aW50ZXJ2YWw6IFstSW5maW5pdHksIC03MF0sIGNsb3NlOiBbMCwgMF19LFxuICAgICAqICAgICB7aW50ZXJ2YWw6IFstNzAsIC0yNl0sIGNsb3NlOiBbMSwgMV19LFxuICAgICAqICAgICB7aW50ZXJ2YWw6IFstMjYsIDE4XSwgY2xvc2U6IFswLCAxXX0sXG4gICAgICogICAgIHtpbnRlcnZhbDogWzE4LCA2Ml0sIGNsb3NlOiBbMCwgMV19LFxuICAgICAqICAgICB7aW50ZXJ2YWw6IFs2MiwgMTUwXSwgY2xvc2U6IFswLCAxXX0sXG4gICAgICogICAgIHtpbnRlcnZhbDogWzE1MCwgSW5maW5pdHldLCBjbG9zZTogWzAsIDBdfVxuICAgICAqIF0pO1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGxpc3QsIHdoZXJlIGBjbG9zZWAgbWVhbiBvcGVuIG9yIGNsb3NlXG4gICAgICogICAgICAgIG9mIHRoZSBpbnRlcnZhbCwgYW5kIEluZmluaXR5IGNhbiBiZSB1c2VkLlxuICAgICAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fSBUaGUgb3JpZ2luIGxpc3QsIHdoaWNoIGhhcyBiZWVuIHJlZm9ybWVkLlxuICAgICAqL1xuICAgIG51bWJlci5yZWZvcm1JbnRlcnZhbHMgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICBsaXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXR0bGVUaGFuKGEsIGIsIDApID8gLTEgOiAxO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgY3VyciA9IC1JbmZpbml0eTtcbiAgICAgICAgdmFyIGN1cnJDbG9zZSA9IDE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7KSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBsaXN0W2ldLmludGVydmFsO1xuICAgICAgICAgICAgdmFyIGNsb3NlID0gbGlzdFtpXS5jbG9zZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgbGcgPSAwOyBsZyA8IDI7IGxnKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJ2YWxbbGddIDw9IGN1cnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxbbGddID0gY3VycjtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VbbGddID0gIWxnID8gMSAtIGN1cnJDbG9zZSA6IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnIgPSBpbnRlcnZhbFtsZ107XG4gICAgICAgICAgICAgICAgY3VyckNsb3NlID0gY2xvc2VbbGddO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWxbMF0gPT09IGludGVydmFsWzFdICYmIGNsb3NlWzBdICogY2xvc2VbMV0gIT09IDEpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaXN0O1xuXG4gICAgICAgIGZ1bmN0aW9uIGxpdHRsZVRoYW4oYSwgYiwgbGcpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmludGVydmFsW2xnXSA8IGIuaW50ZXJ2YWxbbGddXG4gICAgICAgICAgICAgICAgfHwgKFxuICAgICAgICAgICAgICAgICAgICBhLmludGVydmFsW2xnXSA9PT0gYi5pbnRlcnZhbFtsZ11cbiAgICAgICAgICAgICAgICAgICAgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGEuY2xvc2VbbGddIC0gYi5jbG9zZVtsZ10gPT09ICghbGcgPyAxIDogLTEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKCFsZyAmJiBsaXR0bGVUaGFuKGEsIGIsIDEpKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAobnVsbHx0cnVlfGZhbHNlfFwiXCIpXG4gICAgICogLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuICAgICAqIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBudW1iZXIuaXNOdW1lcmljID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgLSBwYXJzZUZsb2F0KHYpID49IDA7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gbnVtYmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3V0aWwvbnVtYmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = __webpack_require__(20);\n    var BoundingRect = __webpack_require__(25);\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME 高度计算比较粗暴\n        var lineHeight = getTextWidth('国', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var lineHeight = textRect.lineHeight;\n        var halfHeight = height / 2 - textHeight / 2 + lineHeight;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight - lineHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance + lineHeight;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance + lineHeight;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance + lineHeight;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance + lineHeight;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'alphabetic'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('国', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qcz8zYTQzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFLHVCQUF1Qiw2Q0FBNkM7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQ0FBaUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICAgIHZhciB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPSAwO1xuICAgIHZhciBURVhUX0NBQ0hFX01BWCA9IDUwMDA7XG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciByZXRyaWV2ZSA9IHV0aWwucmV0cmlldmU7XG5cbiAgICBmdW5jdGlvbiBnZXRUZXh0V2lkdGgodGV4dCwgdGV4dEZvbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IHRleHQgKyAnOicgKyB0ZXh0Rm9udDtcbiAgICAgICAgaWYgKHRleHRXaWR0aENhY2hlW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0V2lkdGhDYWNoZVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRMaW5lcyA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1lYXN1cmVUZXh0IOWPr+S7peiiq+imhuebluS7peWFvOWuueS4jeaUr+aMgSBDYW52YXMg55qE546v5aKDXG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHRleHRDb250YWluLm1lYXN1cmVUZXh0KHRleHRMaW5lc1tpXSwgdGV4dEZvbnQpLndpZHRoLCB3aWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dFdpZHRoQ2FjaGVDb3VudGVyID4gVEVYVF9DQUNIRV9NQVgpIHtcbiAgICAgICAgICAgIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG4gICAgICAgICAgICB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRleHRXaWR0aENhY2hlQ291bnRlcisrO1xuICAgICAgICB0ZXh0V2lkdGhDYWNoZVtrZXldID0gd2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRleHRSZWN0KHRleHQsIHRleHRGb250LCB0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSkge1xuICAgICAgICB2YXIgdGV4dExpbmVMZW4gPSAoKHRleHQgfHwgJycpICsgJycpLnNwbGl0KCdcXG4nKS5sZW5ndGg7XG5cbiAgICAgICAgdmFyIHdpZHRoID0gZ2V0VGV4dFdpZHRoKHRleHQsIHRleHRGb250KTtcbiAgICAgICAgLy8gRklYTUUg6auY5bqm6K6h566X5q+U6L6D57KX5pq0XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gZ2V0VGV4dFdpZHRoKCflm70nLCB0ZXh0Rm9udCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0ZXh0TGluZUxlbiAqIGxpbmVIZWlnaHQ7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvLyBUZXh0IGhhcyBhIHNwZWNpYWwgbGluZSBoZWlnaHQgcHJvcGVydHlcbiAgICAgICAgcmVjdC5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcblxuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGNhc2UgJ2FscGhhYmV0aWMnOlxuICAgICAgICAgICAgICAgIHJlY3QueSAtPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICByZWN0LnkgLT0gbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdoYW5naW5nJzpcbiAgICAgICAgICAgIC8vIGNhc2UgJ3RvcCc6XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGSVhNRSBSaWdodCB0byBsZWZ0IGxhbmd1YWdlXG4gICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHJlY3QueCAtPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZWN0LnggLT0gcmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAvLyBjYXNlICdsZWZ0JzpcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIHRleHRSZWN0LCBkaXN0YW5jZSkge1xuXG4gICAgICAgIHZhciB4ID0gcmVjdC54O1xuICAgICAgICB2YXIgeSA9IHJlY3QueTtcblxuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG5cbiAgICAgICAgdmFyIHRleHRIZWlnaHQgPSB0ZXh0UmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSB0ZXh0UmVjdC5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDIgLSB0ZXh0SGVpZ2h0IC8gMiArIGxpbmVIZWlnaHQ7XG5cbiAgICAgICAgdmFyIHRleHRBbGlnbiA9ICdsZWZ0JztcblxuICAgICAgICBzd2l0Y2ggKHRleHRQb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgeCAtPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IGRpc3RhbmNlICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSAtPSBkaXN0YW5jZSArIHRleHRIZWlnaHQgLSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCArIGRpc3RhbmNlICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZSc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlTGVmdCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlUmlnaHQnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVRvcCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSArPSBkaXN0YW5jZSArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVCb3R0b20nOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gdGV4dEhlaWdodCAtIGRpc3RhbmNlICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVRvcExlZnQnOlxuICAgICAgICAgICAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBkaXN0YW5jZSArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlVG9wUmlnaHQnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGRpc3RhbmNlICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlQm90dG9tTGVmdCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCAtIHRleHRIZWlnaHQgLSBkaXN0YW5jZSArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVCb3R0b21SaWdodCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gdGV4dEhlaWdodCAtIGRpc3RhbmNlICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICdhbHBoYWJldGljJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3cgZWxsaXBzaXMgaWYgb3ZlcmZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRhaW5lcldpZHRoXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0Rm9udFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW2VsbGlwc2lzPScuLi4nXVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5tYXhJdGVyYXRpb25zPTNdXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5taW5DaGFyPTBdIElmIHRydW5jYXRlIHJlc3VsdCBhcmUgbGVzc1xuICAgICAqICAgICAgICAgICAgICAgICAgdGhlbiBtaW5DaGFyLCBlbGxpcHNpcyB3aWxsIG5vdCBzaG93LCB3aGljaCBpc1xuICAgICAqICAgICAgICAgICAgICAgICAgYmV0dGVyIGZvciB1c2VyIGhpbnQgaW4gc29tZSBjYXNlcy5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLnBsYWNlaG9sZGVyPScnXSBXaGVuIGFsbCB0cnVuY2F0ZWQsIHVzZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlVGV4dCh0ZXh0LCBjb250YWluZXJXaWR0aCwgdGV4dEZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGVsbGlwc2lzID0gcmV0cmlldmUoZWxsaXBzaXMsICcuLi4nKTtcbiAgICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSByZXRyaWV2ZShvcHRpb25zLm1heEl0ZXJhdGlvbnMsIDIpO1xuICAgICAgICB2YXIgbWluQ2hhciA9IHJldHJpZXZlKG9wdGlvbnMubWluQ2hhciwgMCk7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIE90aGVyIGxhbmd1YWdlcz9cbiAgICAgICAgdmFyIGNuQ2hhcldpZHRoID0gZ2V0VGV4dFdpZHRoKCflm70nLCB0ZXh0Rm9udCk7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIENvbnNpZGVyIHByb3BvcnRpb25hbCBmb250P1xuICAgICAgICB2YXIgYXNjQ2hhcldpZHRoID0gZ2V0VGV4dFdpZHRoKCdhJywgdGV4dEZvbnQpO1xuICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSByZXRyaWV2ZShvcHRpb25zLnBsYWNlaG9sZGVyLCAnJyk7XG5cbiAgICAgICAgLy8gRXhhbXBsZSAxOiBtaW5DaGFyOiAzLCB0ZXh0OiAnYXNkZnp4Y3YnLCB0cnVuY2F0ZSByZXN1bHQ6ICdhc2RmJywgYnV0IG5vdDogJ2EuLi4nLlxuICAgICAgICAvLyBFeGFtcGxlIDI6IG1pbkNoYXI6IDMsIHRleHQ6ICfnu7TluqYnLCB0cnVuY2F0ZSByZXN1bHQ6ICfnu7QnLCBidXQgbm90OiAnLi4uJy5cbiAgICAgICAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRhaW5lcldpZHRoID0gTWF0aC5tYXgoMCwgY29udGFpbmVyV2lkdGggLSAxKTsgLy8gUmVzZXJ2ZSBzb21lIGdhcC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5DaGFyICYmIGNvbnRlbnRXaWR0aCA+PSBhc2NDaGFyV2lkdGg7IGkrKykge1xuICAgICAgICAgICAgY29udGVudFdpZHRoIC09IGFzY0NoYXJXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGxpcHNpc1dpZHRoID0gZ2V0VGV4dFdpZHRoKGVsbGlwc2lzKTtcbiAgICAgICAgaWYgKGVsbGlwc2lzV2lkdGggPiBjb250ZW50V2lkdGgpIHtcbiAgICAgICAgICAgIGVsbGlwc2lzID0gJyc7XG4gICAgICAgICAgICBlbGxpcHNpc1dpZHRoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRlbnRXaWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gZWxsaXBzaXNXaWR0aDtcblxuICAgICAgICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZXh0TGluZSA9IHRleHRMaW5lc1tpXTtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBnZXRUZXh0V2lkdGgodGV4dExpbmUsIHRleHRGb250KTtcblxuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA8PSBjb250YWluZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDs7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPD0gY29udGVudFdpZHRoIHx8IGogPj0gbWF4SXRlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0TGluZSArPSBlbGxpcHNpcztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHN1Ykxlbmd0aCA9IGogPT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBlc3RpbWF0ZUxlbmd0aCh0ZXh0TGluZSwgY29udGVudFdpZHRoLCBhc2NDaGFyV2lkdGgsIGNuQ2hhcldpZHRoKVxuICAgICAgICAgICAgICAgICAgICA6IGxpbmVXaWR0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBNYXRoLmZsb29yKHRleHRMaW5lLmxlbmd0aCAqIGNvbnRlbnRXaWR0aCAvIGxpbmVXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xuXG4gICAgICAgICAgICAgICAgdGV4dExpbmUgPSB0ZXh0TGluZS5zdWJzdHIoMCwgc3ViTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSBnZXRUZXh0V2lkdGgodGV4dExpbmUsIHRleHRGb250KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRleHRMaW5lID09PSAnJykge1xuICAgICAgICAgICAgICAgIHRleHRMaW5lID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHRMaW5lc1tpXSA9IHRleHRMaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHRMaW5lcy5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc3RpbWF0ZUxlbmd0aCh0ZXh0LCBjb250ZW50V2lkdGgsIGFzY0NoYXJXaWR0aCwgY25DaGFyV2lkdGgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBmb3IgKHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDsgaSA8IGxlbiAmJiB3aWR0aCA8IGNvbnRlbnRXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB3aWR0aCArPSAoMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAxMjcpID8gYXNjQ2hhcldpZHRoIDogY25DaGFyV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgdmFyIHRleHRDb250YWluID0ge1xuXG4gICAgICAgIGdldFdpZHRoOiBnZXRUZXh0V2lkdGgsXG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBnZXRUZXh0UmVjdCxcblxuICAgICAgICBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3Q6IGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCxcblxuICAgICAgICB0cnVuY2F0ZVRleHQ6IHRydW5jYXRlVGV4dCxcblxuICAgICAgICBtZWFzdXJlVGV4dDogZnVuY3Rpb24gKHRleHQsIHRleHRGb250KSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdXRpbC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICBjdHguZm9udCA9IHRleHRGb250IHx8ICcxMnB4IHNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRleHRDb250YWluO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = __webpack_require__(26);\n    var matrix = __webpack_require__(27);\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // 矩阵右乘\n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzPzc2ZjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsaUNBQWlDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQixpQ0FBaUM7QUFDckQsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLDBDQUEwQztBQUM3RCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx3Q0FBd0M7QUFDdkQsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0XG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xuXG4gICAgdmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCb3VuZGluZ1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG4gICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgIHggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cblxuICAgIEJvdW5kaW5nUmVjdC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEJvdW5kaW5nUmVjdCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH0gb3RoZXJcbiAgICAgICAgICovXG4gICAgICAgIHVuaW9uOiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gbWF0aE1pbihvdGhlci54LCB0aGlzLngpO1xuICAgICAgICAgICAgdmFyIHkgPSBtYXRoTWluKG90aGVyLnksIHRoaXMueSk7XG5cbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBtYXRoTWF4KFxuICAgICAgICAgICAgICAgICAgICBvdGhlci54ICsgb3RoZXIud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCArIHRoaXMud2lkdGhcbiAgICAgICAgICAgICAgICApIC0geDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gbWF0aE1heChcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIueSArIG90aGVyLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ICsgdGhpcy5oZWlnaHRcbiAgICAgICAgICAgICAgICApIC0geTtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtXG4gICAgICAgICAqIEBtZXRob2RzXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseVRyYW5zZm9ybTogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsdCA9IFtdO1xuICAgICAgICAgICAgdmFyIHJiID0gW107XG4gICAgICAgICAgICB2YXIgbGIgPSBbXTtcbiAgICAgICAgICAgIHZhciBydCA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB1c2FnZSBsaWtlIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBlbC5nZXRCb3VuZGluZ1JlY3QoKS5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgLy8gQW5kIGVsZW1lbnQgaGFzIG5vIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGx0WzBdID0gbGJbMF0gPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgbHRbMV0gPSBydFsxXSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICByYlswXSA9IHJ0WzBdID0gdGhpcy54ICsgdGhpcy53aWR0aDtcbiAgICAgICAgICAgICAgICByYlsxXSA9IGxiWzFdID0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKGx0LCBsdCwgbSk7XG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShyYiwgcmIsIG0pO1xuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0obGIsIGxiLCBtKTtcbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHJ0LCBydCwgbSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnggPSBtYXRoTWluKGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSBtYXRoTWluKGx0WzFdLCByYlsxXSwgbGJbMV0sIHJ0WzFdKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4WCA9IG1hdGhNYXgobHRbMF0sIHJiWzBdLCBsYlswXSwgcnRbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBtYXhZID0gbWF0aE1heChsdFsxXSwgcmJbMV0sIGxiWzFdLCBydFsxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IG1heFggLSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBtYXhZIC0gdGhpcy55O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIG1hdHJpeCBvZiB0cmFuc2Zvcm1pbmcgZnJvbSBzZWxmIHRvIHRhcmdldCByZWN0XG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSBiXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgY2FsY3VsYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHN4ID0gYi53aWR0aCAvIGEud2lkdGg7XG4gICAgICAgICAgICB2YXIgc3kgPSBiLmhlaWdodCAvIGEuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgbSA9IG1hdHJpeC5jcmVhdGUoKTtcblxuICAgICAgICAgICAgLy8g55+p6Zi15Y+z5LmYXG4gICAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFstYS54LCAtYS55XSk7XG4gICAgICAgICAgICBtYXRyaXguc2NhbGUobSwgbSwgW3N4LCBzeV0pO1xuICAgICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbYi54LCBiLnldKTtcblxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7KG1vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fE9iamVjdCl9IGJcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGludGVyc2VjdDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoYiBpbnN0YW5jZW9mIEJvdW5kaW5nUmVjdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxpemUgbmVnYXRpdmUgd2lkdGgvaGVpZ2h0LlxuICAgICAgICAgICAgICAgIGIgPSBCb3VuZGluZ1JlY3QuY3JlYXRlKGIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXgwID0gYS54O1xuICAgICAgICAgICAgdmFyIGF4MSA9IGEueCArIGEud2lkdGg7XG4gICAgICAgICAgICB2YXIgYXkwID0gYS55O1xuICAgICAgICAgICAgdmFyIGF5MSA9IGEueSArIGEuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgYngwID0gYi54O1xuICAgICAgICAgICAgdmFyIGJ4MSA9IGIueCArIGIud2lkdGg7XG4gICAgICAgICAgICB2YXIgYnkwID0gYi55O1xuICAgICAgICAgICAgdmFyIGJ5MSA9IGIueSArIGIuaGVpZ2h0O1xuXG4gICAgICAgICAgICByZXR1cm4gISAoYXgxIDwgYngwIHx8IGJ4MSA8IGF4MCB8fCBheTEgPCBieTAgfHwgYnkxIDwgYXkwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHggPj0gcmVjdC54XG4gICAgICAgICAgICAgICAgJiYgeCA8PSAocmVjdC54ICsgcmVjdC53aWR0aClcbiAgICAgICAgICAgICAgICAmJiB5ID49IHJlY3QueVxuICAgICAgICAgICAgICAgICYmIHkgPD0gKHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29weSBmcm9tIGFub3RoZXIgcmVjdFxuICAgICAgICAgKi9cbiAgICAgICAgY29weTogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICB0aGlzLnggPSBvdGhlci54O1xuICAgICAgICAgICAgdGhpcy55ID0gb3RoZXIueTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBvdGhlci53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gb3RoZXIuaGVpZ2h0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBsYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxtb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gcmVjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LnhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVjdC55XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlY3Qud2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVjdC5oZWlnaHRcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgKi9cbiAgICBCb3VuZGluZ1JlY3QuY3JlYXRlID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCb3VuZGluZ1JlY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports){eval("\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * 二维向量类\n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * 创建一个向量\n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * 复制向量数据\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 克隆一个向量\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 设置向量的两个项\n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} 结果\n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * 向量相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * 向量缩放后相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * 向量相减\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * 向量长度\n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * 向量长度平方\n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * 向量乘法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * 向量除法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * 向量点乘\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * 向量缩放\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * 向量归一化\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * 计算向量间距离\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * 向量距离平方\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * 求负向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * 插值两个点\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * 矩阵左乘向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * 求两个向量最小值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * 求两个向量最大值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzPzY2NTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgdmFyIEFycmF5Q3RvciA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gQXJyYXlcbiAgICAgICAgOiBGbG9hdDMyQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBWZWN0b3IyXG4gICAgICovXG4gICAgLyoqXG4gICAgICog5LqM57u05ZCR6YeP57G7XG4gICAgICogQGV4cG9ydHMgenJlbmRlci90b29sL3ZlY3RvclxuICAgICAqL1xuICAgIHZhciB2ZWN0b3IgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJvlu7rkuIDkuKrlkJHph49cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoMik7XG4gICAgICAgICAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRbMF0gPSB4O1xuICAgICAgICAgICAgb3V0WzFdID0geTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWkjeWItuWQkemHj+aVsOaNrlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICAgICAgICovXG4gICAgICAgIGNvcHk6IGZ1bmN0aW9uIChvdXQsIHYpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHZbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5YWL6ZqG5LiA5Liq5ZCR6YePXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbmV3IEFycmF5Q3RvcigyKTtcbiAgICAgICAgICAgIG91dFswXSA9IHZbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5ZCR6YeP55qE5Lik5Liq6aG5XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9IOe7k+aenFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBhO1xuICAgICAgICAgICAgb3V0WzFdID0gYjtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+ebuOWKoFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSArIHYyWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+e8qeaUvuWQjuebuOWKoFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGFcbiAgICAgICAgICovXG4gICAgICAgIHNjYWxlQW5kQWRkOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIsIGEpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdICsgdjJbMF0gKiBhO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXSAqIGE7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/nm7jlh49cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBzdWI6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gLSB2MlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdIC0gdjJbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/plb/luqZcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxlbjogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5sZW5TcXVhcmUodikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/plb/luqblubPmlrlcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxlblNxdWFyZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2WzBdICogdlswXSArIHZbMV0gKiB2WzFdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/kuZjms5VcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBtdWw6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gKiB2MlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdICogdjJbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/pmaTms5VcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBkaXY6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gLyB2MlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdIC8gdjJbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/ngrnkuZhcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGRvdDogZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICAgICAgcmV0dXJuIHYxWzBdICogdjJbMF0gKyB2MVsxXSAqIHYyWzFdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/nvKnmlL5cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzXG4gICAgICAgICAqL1xuICAgICAgICBzY2FsZTogZnVuY3Rpb24gKG91dCwgdiwgcykge1xuICAgICAgICAgICAgb3V0WzBdID0gdlswXSAqIHM7XG4gICAgICAgICAgICBvdXRbMV0gPSB2WzFdICogcztcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+W9kuS4gOWMllxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICovXG4gICAgICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24gKG91dCwgdikge1xuICAgICAgICAgICAgdmFyIGQgPSB2ZWN0b3IubGVuKHYpO1xuICAgICAgICAgICAgaWYgKGQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBvdXRbMF0gPSAwO1xuICAgICAgICAgICAgICAgIG91dFsxXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRbMF0gPSB2WzBdIC8gZDtcbiAgICAgICAgICAgICAgICBvdXRbMV0gPSB2WzFdIC8gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuoeeul+WQkemHj+mXtOi3neemu1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzdGFuY2U6IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgKHYxWzBdIC0gdjJbMF0pICogKHYxWzBdIC0gdjJbMF0pXG4gICAgICAgICAgICAgICAgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+i3neemu+W5s+aWuVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzdGFuY2VTcXVhcmU6IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgICAgIHJldHVybiAodjFbMF0gLSB2MlswXSkgKiAodjFbMF0gLSB2MlswXSlcbiAgICAgICAgICAgICAgICArICh2MVsxXSAtIHYyWzFdKSAqICh2MVsxXSAtIHYyWzFdKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5rGC6LSf5ZCR6YePXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlOiBmdW5jdGlvbiAob3V0LCB2KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAtdlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IC12WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5o+S5YC85Lik5Liq54K5XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdFxuICAgICAgICAgKi9cbiAgICAgICAgbGVycDogZnVuY3Rpb24gKG91dCwgdjEsIHYyLCB0KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSArIHQgKiAodjJbMF0gLSB2MVswXSk7XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSArIHQgKiAodjJbMV0gLSB2MVsxXSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnn6npmLXlt6bkuZjlkJHph49cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gbVxuICAgICAgICAgKi9cbiAgICAgICAgYXBwbHlUcmFuc2Zvcm06IGZ1bmN0aW9uIChvdXQsIHYsIG0pIHtcbiAgICAgICAgICAgIHZhciB4ID0gdlswXTtcbiAgICAgICAgICAgIHZhciB5ID0gdlsxXTtcbiAgICAgICAgICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICAgICAgICAgICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5rGC5Lik5Liq5ZCR6YeP5pyA5bCP5YC8XG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgbWluOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IE1hdGgubWluKHYxWzBdLCB2MlswXSk7XG4gICAgICAgICAgICBvdXRbMV0gPSBNYXRoLm1pbih2MVsxXSwgdjJbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaxguS4pOS4quWQkemHj+acgOWkp+WAvFxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIG1heDogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBNYXRoLm1heCh2MVswXSwgdjJbMF0pO1xuICAgICAgICAgICAgb3V0WzFdID0gTWF0aC5tYXgodjFbMV0sIHYyWzFdKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmVjdG9yLmxlbmd0aCA9IHZlY3Rvci5sZW47XG4gICAgdmVjdG9yLmxlbmd0aFNxdWFyZSA9IHZlY3Rvci5sZW5TcXVhcmU7XG4gICAgdmVjdG9yLmRpc3QgPSB2ZWN0b3IuZGlzdGFuY2U7XG4gICAgdmVjdG9yLmRpc3RTcXVhcmUgPSB2ZWN0b3IuZGlzdGFuY2VTcXVhcmU7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHZlY3RvcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2矩阵操作类\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * 创建一个单位矩阵\n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * 设置矩阵为单位矩阵\n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * 复制矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * 矩阵相乘\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * 平移变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * 旋转变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * 缩放变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * 求逆矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzPzk3YTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgdmFyIEFycmF5Q3RvciA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gQXJyYXlcbiAgICAgICAgOiBGbG9hdDMyQXJyYXk7XG4gICAgLyoqXG4gICAgICogM3gy55+p6Zi15pON5L2c57G7XG4gICAgICogQGV4cG9ydHMgenJlbmRlci90b29sL21hdHJpeFxuICAgICAqL1xuICAgIHZhciBtYXRyaXggPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJvlu7rkuIDkuKrljZXkvY3nn6npmLVcbiAgICAgICAgICogQHJldHVybiB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbmV3IEFycmF5Q3Rvcig2KTtcbiAgICAgICAgICAgIG1hdHJpeC5pZGVudGl0eShvdXQpO1xuXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u55+p6Zi15Li65Y2V5L2N55+p6Zi1XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICovXG4gICAgICAgIGlkZW50aXR5IDogZnVuY3Rpb24ob3V0KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAxO1xuICAgICAgICAgICAgb3V0WzFdID0gMDtcbiAgICAgICAgICAgIG91dFsyXSA9IDA7XG4gICAgICAgICAgICBvdXRbM10gPSAxO1xuICAgICAgICAgICAgb3V0WzRdID0gMDtcbiAgICAgICAgICAgIG91dFs1XSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5aSN5Yi255+p6Zi1XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG1cbiAgICAgICAgICovXG4gICAgICAgIGNvcHk6IGZ1bmN0aW9uKG91dCwgbSkge1xuICAgICAgICAgICAgb3V0WzBdID0gbVswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IG1bMV07XG4gICAgICAgICAgICBvdXRbMl0gPSBtWzJdO1xuICAgICAgICAgICAgb3V0WzNdID0gbVszXTtcbiAgICAgICAgICAgIG91dFs0XSA9IG1bNF07XG4gICAgICAgICAgICBvdXRbNV0gPSBtWzVdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOefqemYteebuOS5mFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtMVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbTJcbiAgICAgICAgICovXG4gICAgICAgIG11bCA6IGZ1bmN0aW9uIChvdXQsIG0xLCBtMikge1xuICAgICAgICAgICAgLy8gQ29uc2lkZXIgbWF0cml4Lm11bChtLCBtMiwgbSk7XG4gICAgICAgICAgICAvLyB3aGVyZSBvdXQgaXMgdGhlIHNhbWUgYXMgbTIuXG4gICAgICAgICAgICAvLyBTbyB1c2UgdGVtcCB2YXJpYWJsZSB0byBlc2NhcGUgZXJyb3IuXG4gICAgICAgICAgICB2YXIgb3V0MCA9IG0xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdO1xuICAgICAgICAgICAgdmFyIG91dDEgPSBtMVsxXSAqIG0yWzBdICsgbTFbM10gKiBtMlsxXTtcbiAgICAgICAgICAgIHZhciBvdXQyID0gbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM107XG4gICAgICAgICAgICB2YXIgb3V0MyA9IG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdO1xuICAgICAgICAgICAgdmFyIG91dDQgPSBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdO1xuICAgICAgICAgICAgdmFyIG91dDUgPSBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdO1xuICAgICAgICAgICAgb3V0WzBdID0gb3V0MDtcbiAgICAgICAgICAgIG91dFsxXSA9IG91dDE7XG4gICAgICAgICAgICBvdXRbMl0gPSBvdXQyO1xuICAgICAgICAgICAgb3V0WzNdID0gb3V0MztcbiAgICAgICAgICAgIG91dFs0XSA9IG91dDQ7XG4gICAgICAgICAgICBvdXRbNV0gPSBvdXQ1O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW5s+enu+WPmOaNolxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSB2XG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2xhdGUgOiBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICAgICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSBhWzFdO1xuICAgICAgICAgICAgb3V0WzJdID0gYVsyXTtcbiAgICAgICAgICAgIG91dFszXSA9IGFbM107XG4gICAgICAgICAgICBvdXRbNF0gPSBhWzRdICsgdlswXTtcbiAgICAgICAgICAgIG91dFs1XSA9IGFbNV0gKyB2WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaXi+i9rOWPmOaNolxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRcbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0ZSA6IGZ1bmN0aW9uKG91dCwgYSwgcmFkKSB7XG4gICAgICAgICAgICB2YXIgYWEgPSBhWzBdO1xuICAgICAgICAgICAgdmFyIGFjID0gYVsyXTtcbiAgICAgICAgICAgIHZhciBhdHggPSBhWzRdO1xuICAgICAgICAgICAgdmFyIGFiID0gYVsxXTtcbiAgICAgICAgICAgIHZhciBhZCA9IGFbM107XG4gICAgICAgICAgICB2YXIgYXR5ID0gYVs1XTtcbiAgICAgICAgICAgIHZhciBzdCA9IE1hdGguc2luKHJhZCk7XG4gICAgICAgICAgICB2YXIgY3QgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgICAgICAgICBvdXRbMF0gPSBhYSAqIGN0ICsgYWIgKiBzdDtcbiAgICAgICAgICAgIG91dFsxXSA9IC1hYSAqIHN0ICsgYWIgKiBjdDtcbiAgICAgICAgICAgIG91dFsyXSA9IGFjICogY3QgKyBhZCAqIHN0O1xuICAgICAgICAgICAgb3V0WzNdID0gLWFjICogc3QgKyBjdCAqIGFkO1xuICAgICAgICAgICAgb3V0WzRdID0gY3QgKiBhdHggKyBzdCAqIGF0eTtcbiAgICAgICAgICAgIG91dFs1XSA9IGN0ICogYXR5IC0gc3QgKiBhdHg7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog57yp5pS+5Y+Y5o2iXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IHZcbiAgICAgICAgICovXG4gICAgICAgIHNjYWxlIDogZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgICAgICAgICB2YXIgdnggPSB2WzBdO1xuICAgICAgICAgICAgdmFyIHZ5ID0gdlsxXTtcbiAgICAgICAgICAgIG91dFswXSA9IGFbMF0gKiB2eDtcbiAgICAgICAgICAgIG91dFsxXSA9IGFbMV0gKiB2eTtcbiAgICAgICAgICAgIG91dFsyXSA9IGFbMl0gKiB2eDtcbiAgICAgICAgICAgIG91dFszXSA9IGFbM10gKiB2eTtcbiAgICAgICAgICAgIG91dFs0XSA9IGFbNF0gKiB2eDtcbiAgICAgICAgICAgIG91dFs1XSA9IGFbNV0gKiB2eTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmsYLpgIbnn6npmLVcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICAgICAgICAgKi9cbiAgICAgICAgaW52ZXJ0IDogZnVuY3Rpb24ob3V0LCBhKSB7XG5cbiAgICAgICAgICAgIHZhciBhYSA9IGFbMF07XG4gICAgICAgICAgICB2YXIgYWMgPSBhWzJdO1xuICAgICAgICAgICAgdmFyIGF0eCA9IGFbNF07XG4gICAgICAgICAgICB2YXIgYWIgPSBhWzFdO1xuICAgICAgICAgICAgdmFyIGFkID0gYVszXTtcbiAgICAgICAgICAgIHZhciBhdHkgPSBhWzVdO1xuXG4gICAgICAgICAgICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG4gICAgICAgICAgICBpZiAoIWRldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgICAgICAgICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgICAgICAgICAgIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgICAgICAgICAgIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgICAgICAgICAgIG91dFszXSA9IGFhICogZGV0O1xuICAgICAgICAgICAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICAgICAgICAgICAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1hdHJpeDtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("/**\n * @module echarts/model/Model\n */\n\n\n    var zrUtil = __webpack_require__(20);\n    var clazzUtil = __webpack_require__(29);\n    var env = __webpack_require__(18);\n\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;\n\n        // Simple optimization\n        // if (this.init) {\n        //     if (arguments.length <= 4) {\n        //         this.init(option, parentModel, ecModel, extraOpt);\n        //     }\n        //     else {\n        //         this.init.apply(this, arguments);\n        //     }\n        // }\n    }\n\n    Model.prototype = {\n\n        constructor: Model,\n\n        /**\n         * Model 的初始化函数\n         * @param {Object} option\n         */\n        init: null,\n\n        /**\n         * 从新的 Option merge\n         */\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        get: function (path, ignoreParent) {\n            if (path == null) {\n                return this.option;\n            }\n\n            return doGet(\n                this.option,\n                this.parsePath(path),\n                !ignoreParent && getParent(this, path)\n            );\n        },\n\n        /**\n         * @param {string} key\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n\n            var val = option == null ? option : option[key];\n            var parentModel = !ignoreParent && getParent(this, key);\n            if (val == null && parentModel) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n\n        /**\n         * @param {string|Array.<string>} [path]\n         * @param {module:echarts/model/Model} [parentModel]\n         * @return {module:echarts/model/Model}\n         */\n        getModel: function (path, parentModel) {\n            var obj = path == null\n                ? this.option\n                : doGet(this.option, path = this.parsePath(path));\n\n            var thisParentModel;\n            parentModel = parentModel || (\n                (thisParentModel = getParent(this, path))\n                    && thisParentModel.getModel(path)\n            );\n\n            return new Model(obj, parentModel, this.ecModel);\n        },\n\n        /**\n         * If model has option\n         */\n        isEmpty: function () {\n            return this.option == null;\n        },\n\n        restoreData: function () {},\n\n        // Pending\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        },\n\n        // If path is null/undefined, return null/undefined.\n        parsePath: function(path) {\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            return path;\n        },\n\n        /**\n         * @param {Function} getParentMethod\n         *        param {Array.<string>|string} path\n         *        return {module:echarts/model/Model}\n         */\n        customizeGetParent: function (getParentMethod) {\n            clazzUtil.set(this, 'getParent', getParentMethod);\n        },\n\n        isAnimationEnabled: function () {\n            if (!env.node) {\n                if (this.option.animation != null) {\n                    return !!this.option.animation;\n                }\n                else if (this.parentModel) {\n                    return this.parentModel.isAnimationEnabled();\n                }\n            }\n        }\n    };\n\n    function doGet(obj, pathArr, parentModel) {\n        for (var i = 0; i < pathArr.length; i++) {\n            // Ignore empty\n            if (!pathArr[i]) {\n                continue;\n            }\n            // obj could be number/string/... (like 0)\n            obj = (obj && typeof obj === 'object') ? obj[pathArr[i]] : null;\n            if (obj == null) {\n                break;\n            }\n        }\n        if (obj == null && parentModel) {\n            obj = parentModel.get(pathArr);\n        }\n        return obj;\n    }\n\n    // `path` can be null/undefined\n    function getParent(model, path) {\n        var getParentMethod = clazzUtil.get(model, 'getParent');\n        return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n    }\n\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n\n    var mixin = zrUtil.mixin;\n    mixin(Model, __webpack_require__(30));\n    mixin(Model, __webpack_require__(32));\n    mixin(Model, __webpack_require__(33));\n    mixin(Model, __webpack_require__(84));\n\n    module.exports = Model;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL21vZGVsL01vZGVsLmpzP2Y0ZGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDLG1CQUFtQiwyQkFBMkI7QUFDOUMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLHlCQUF5QixzQkFBc0I7QUFDL0MsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvbW9kZWwvTW9kZWxcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGNsYXp6VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhenonKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9lbnYnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbcGFyZW50TW9kZWxdXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IFtlY01vZGVsXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1vZGVsKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcmVudE1vZGVsID0gcGFyZW50TW9kZWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb24gPSBvcHRpb247XG5cbiAgICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxuICAgICAgICAvLyBpZiAodGhpcy5pbml0KSB7XG4gICAgICAgIC8vICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSA0KSB7XG4gICAgICAgIC8vICAgICAgICAgdGhpcy5pbml0KG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIGVsc2Uge1xuICAgICAgICAvLyAgICAgICAgIHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG4gICAgfVxuXG4gICAgTW9kZWwucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBNb2RlbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWwg55qE5Yid5aeL5YyW5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIGluaXQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS7juaWsOeahCBPcHRpb24gbWVyZ2VcbiAgICAgICAgICovXG4gICAgICAgIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICB6clV0aWwubWVyZ2UodGhpcy5vcHRpb24sIG9wdGlvbiwgdHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBwYXRoXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZVBhcmVudD1mYWxzZV1cbiAgICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKHBhdGgsIGlnbm9yZVBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRvR2V0KFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uLFxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VQYXRoKHBhdGgpLFxuICAgICAgICAgICAgICAgICFpZ25vcmVQYXJlbnQgJiYgZ2V0UGFyZW50KHRoaXMsIHBhdGgpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZVBhcmVudD1mYWxzZV1cbiAgICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFNoYWxsb3c6IGZ1bmN0aW9uIChrZXksIGlnbm9yZVBhcmVudCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuXG4gICAgICAgICAgICB2YXIgdmFsID0gb3B0aW9uID09IG51bGwgPyBvcHRpb24gOiBvcHRpb25ba2V5XTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRNb2RlbCA9ICFpZ25vcmVQYXJlbnQgJiYgZ2V0UGFyZW50KHRoaXMsIGtleSk7XG4gICAgICAgICAgICBpZiAodmFsID09IG51bGwgJiYgcGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBwYXJlbnRNb2RlbC5nZXRTaGFsbG93KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW3BhdGhdXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFtwYXJlbnRNb2RlbF1cbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRNb2RlbDogZnVuY3Rpb24gKHBhdGgsIHBhcmVudE1vZGVsKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gcGF0aCA9PSBudWxsXG4gICAgICAgICAgICAgICAgPyB0aGlzLm9wdGlvblxuICAgICAgICAgICAgICAgIDogZG9HZXQodGhpcy5vcHRpb24sIHBhdGggPSB0aGlzLnBhcnNlUGF0aChwYXRoKSk7XG5cbiAgICAgICAgICAgIHZhciB0aGlzUGFyZW50TW9kZWw7XG4gICAgICAgICAgICBwYXJlbnRNb2RlbCA9IHBhcmVudE1vZGVsIHx8IChcbiAgICAgICAgICAgICAgICAodGhpc1BhcmVudE1vZGVsID0gZ2V0UGFyZW50KHRoaXMsIHBhdGgpKVxuICAgICAgICAgICAgICAgICAgICAmJiB0aGlzUGFyZW50TW9kZWwuZ2V0TW9kZWwocGF0aClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9kZWwob2JqLCBwYXJlbnRNb2RlbCwgdGhpcy5lY01vZGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbW9kZWwgaGFzIG9wdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uID09IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzdG9yZURhdGE6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgIC8vIFBlbmRpbmdcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBDdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcih6clV0aWwuY2xvbmUodGhpcy5vcHRpb24pKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRSZWFkT25seTogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGNsYXp6VXRpbC5zZXRSZWFkT25seSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJZiBwYXRoIGlzIG51bGwvdW5kZWZpbmVkLCByZXR1cm4gbnVsbC91bmRlZmluZWQuXG4gICAgICAgIHBhcnNlUGF0aDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0UGFyZW50TWV0aG9kXG4gICAgICAgICAqICAgICAgICBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSBwYXRoXG4gICAgICAgICAqICAgICAgICByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgY3VzdG9taXplR2V0UGFyZW50OiBmdW5jdGlvbiAoZ2V0UGFyZW50TWV0aG9kKSB7XG4gICAgICAgICAgICBjbGF6elV0aWwuc2V0KHRoaXMsICdnZXRQYXJlbnQnLCBnZXRQYXJlbnRNZXRob2QpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzQW5pbWF0aW9uRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFlbnYubm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbi5hbmltYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzLm9wdGlvbi5hbmltYXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50TW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRvR2V0KG9iaiwgcGF0aEFyciwgcGFyZW50TW9kZWwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgZW1wdHlcbiAgICAgICAgICAgIGlmICghcGF0aEFycltpXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb2JqIGNvdWxkIGJlIG51bWJlci9zdHJpbmcvLi4uIChsaWtlIDApXG4gICAgICAgICAgICBvYmogPSAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSA/IG9ialtwYXRoQXJyW2ldXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqID09IG51bGwgJiYgcGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAgIG9iaiA9IHBhcmVudE1vZGVsLmdldChwYXRoQXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIC8vIGBwYXRoYCBjYW4gYmUgbnVsbC91bmRlZmluZWRcbiAgICBmdW5jdGlvbiBnZXRQYXJlbnQobW9kZWwsIHBhdGgpIHtcbiAgICAgICAgdmFyIGdldFBhcmVudE1ldGhvZCA9IGNsYXp6VXRpbC5nZXQobW9kZWwsICdnZXRQYXJlbnQnKTtcbiAgICAgICAgcmV0dXJuIGdldFBhcmVudE1ldGhvZCA/IGdldFBhcmVudE1ldGhvZC5jYWxsKG1vZGVsLCBwYXRoKSA6IG1vZGVsLnBhcmVudE1vZGVsO1xuICAgIH1cblxuICAgIC8vIEVuYWJsZSBNb2RlbC5leHRlbmQuXG4gICAgY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKE1vZGVsKTtcblxuICAgIHZhciBtaXhpbiA9IHpyVXRpbC5taXhpbjtcbiAgICBtaXhpbihNb2RlbCwgcmVxdWlyZSgnLi9taXhpbi9saW5lU3R5bGUnKSk7XG4gICAgbWl4aW4oTW9kZWwsIHJlcXVpcmUoJy4vbWl4aW4vYXJlYVN0eWxlJykpO1xuICAgIG1peGluKE1vZGVsLCByZXF1aXJlKCcuL21peGluL3RleHRTdHlsZScpKTtcbiAgICBtaXhpbihNb2RlbCwgcmVxdWlyZSgnLi9taXhpbi9pdGVtU3R5bGUnKSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL21vZGVsL01vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n\n    var clazz = {};\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    var MEMBER_PRIFIX = '\\0ec_\\0';\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name] = value;` (can be right-value)\n     * @public\n     */\n    clazz.set = function (host, name, value) {\n        return (host[MEMBER_PRIFIX + name] = value);\n    };\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name];`\n     * @public\n     */\n    clazz.get = function (host, name) {\n        return host[MEMBER_PRIFIX + name];\n    };\n\n    /**\n     * For hidden private class member.\n     * The same behavior as `host.hasOwnProperty(name);`\n     * @public\n     */\n    clazz.hasOwn = function (host, name) {\n        return host.hasOwnProperty(MEMBER_PRIFIX + name);\n    };\n\n    /**\n     * Notice, parseClassType('') should returns {main: '', sub: ''}\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n        var ret = {main: '', sub: ''};\n        if (componentType) {\n            componentType = componentType.split(TYPE_DELIMITER);\n            ret.main = componentType[0] || '';\n            ret.sub = componentType[1] || '';\n        }\n        return ret;\n    };\n\n    /**\n     * @public\n     */\n    function checkClassType(componentType) {\n        zrUtil.assert(\n            /^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType),\n            'componentType \"' + componentType + '\" illegal'\n        );\n    }\n\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n\n            if (__DEV__) {\n                zrUtil.each(mandatoryMethods, function (method) {\n                    if (!proto[method]) {\n                        console.warn(\n                            'Method `' + method + '` should be implemented'\n                            + (proto.type ? ' in ' + proto.type : '') + '.'\n                        );\n                    }\n                });\n            }\n\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                }\n                else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n\n            zrUtil.extend(ExtendedClass.prototype, proto);\n\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n\n            return ExtendedClass;\n        };\n    };\n\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                checkClassType(componentType);\n                componentType = parseClassType(componentType);\n\n                if (!componentType.sub) {\n                    if (__DEV__) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                }\n                else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n\n        entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n            var Clazz = storage[componentMainType];\n\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error(\n                    !subType\n                        ? componentMainType + '.' + 'type should be specified.'\n                        : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.'\n                );\n            }\n\n            return Clazz;\n        };\n\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n\n            var result = [];\n            var obj = storage[componentType.main];\n\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            }\n            else {\n                result.push(obj);\n            }\n\n            return result;\n        };\n\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n\n        entity.parseClassType = parseClassType;\n\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n\n        return entity;\n    };\n\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n        // FIXME It seems broken in IE8 simulation of IE11\n        // if (!zrUtil.isArray(properties)) {\n        //     properties = properties != null ? [properties] : [];\n        // }\n        // zrUtil.each(properties, function (prop) {\n        //     var value = obj[prop];\n\n        //     Object.defineProperty\n        //         && Object.defineProperty(obj, prop, {\n        //             value: value, writable: false\n        //         });\n        //     zrUtil.isArray(obj[prop])\n        //         && Object.freeze\n        //         && Object.freeze(obj[prop]);\n        // });\n    };\n\n    module.exports = clazz;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3V0aWwvY2xhenouanM/M2U2NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQSIsImZpbGUiOiIyOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIGNsYXp6ID0ge307XG5cbiAgICB2YXIgVFlQRV9ERUxJTUlURVIgPSAnLic7XG4gICAgdmFyIElTX0NPTlRBSU5FUiA9ICdfX19FQ19fQ09NUE9ORU5UX19DT05UQUlORVJfX18nO1xuICAgIHZhciBNRU1CRVJfUFJJRklYID0gJ1xcMGVjX1xcMCc7XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHByaXZhdGUgY2xhc3MgbWVtYmVyLlxuICAgICAqIFRoZSBzYW1lIGJlaGF2aW9yIGFzIGBob3N0W25hbWVdID0gdmFsdWU7YCAoY2FuIGJlIHJpZ2h0LXZhbHVlKVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGF6ei5zZXQgPSBmdW5jdGlvbiAoaG9zdCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChob3N0W01FTUJFUl9QUklGSVggKyBuYW1lXSA9IHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGlkZSBwcml2YXRlIGNsYXNzIG1lbWJlci5cbiAgICAgKiBUaGUgc2FtZSBiZWhhdmlvciBhcyBgaG9zdFtuYW1lXTtgXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXp6LmdldCA9IGZ1bmN0aW9uIChob3N0LCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBob3N0W01FTUJFUl9QUklGSVggKyBuYW1lXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRm9yIGhpZGRlbiBwcml2YXRlIGNsYXNzIG1lbWJlci5cbiAgICAgKiBUaGUgc2FtZSBiZWhhdmlvciBhcyBgaG9zdC5oYXNPd25Qcm9wZXJ0eShuYW1lKTtgXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXp6Lmhhc093biA9IGZ1bmN0aW9uIChob3N0LCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBob3N0Lmhhc093blByb3BlcnR5KE1FTUJFUl9QUklGSVggKyBuYW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTm90aWNlLCBwYXJzZUNsYXNzVHlwZSgnJykgc2hvdWxkIHJldHVybnMge21haW46ICcnLCBzdWI6ICcnfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB2YXIgcGFyc2VDbGFzc1R5cGUgPSBjbGF6ei5wYXJzZUNsYXNzVHlwZSA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgICAgIHZhciByZXQgPSB7bWFpbjogJycsIHN1YjogJyd9O1xuICAgICAgICBpZiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IGNvbXBvbmVudFR5cGUuc3BsaXQoVFlQRV9ERUxJTUlURVIpO1xuICAgICAgICAgICAgcmV0Lm1haW4gPSBjb21wb25lbnRUeXBlWzBdIHx8ICcnO1xuICAgICAgICAgICAgcmV0LnN1YiA9IGNvbXBvbmVudFR5cGVbMV0gfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgenJVdGlsLmFzc2VydChcbiAgICAgICAgICAgIC9eW2EtekEtWjAtOV9dKyhbLl1bYS16QS1aMC05X10rKT8kLy50ZXN0KGNvbXBvbmVudFR5cGUpLFxuICAgICAgICAgICAgJ2NvbXBvbmVudFR5cGUgXCInICsgY29tcG9uZW50VHlwZSArICdcIiBpbGxlZ2FsJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGF6ei5lbmFibGVDbGFzc0V4dGVuZCA9IGZ1bmN0aW9uIChSb290Q2xhc3MsIG1hbmRhdG9yeU1ldGhvZHMpIHtcblxuICAgICAgICBSb290Q2xhc3MuJGNvbnN0cnVjdG9yID0gUm9vdENsYXNzO1xuICAgICAgICBSb290Q2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3RvKSB7XG5cbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2gobWFuZGF0b3J5TWV0aG9kcywgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3RvW21ldGhvZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTWV0aG9kIGAnICsgbWV0aG9kICsgJ2Agc2hvdWxkIGJlIGltcGxlbWVudGVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgKHByb3RvLnR5cGUgPyAnIGluICcgKyBwcm90by50eXBlIDogJycpICsgJy4nXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdXBlckNsYXNzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBFeHRlbmRlZENsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghcHJvdG8uJGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyQ2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvLiRjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHpyVXRpbC5leHRlbmQoRXh0ZW5kZWRDbGFzcy5wcm90b3R5cGUsIHByb3RvKTtcblxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5leHRlbmQgPSB0aGlzLmV4dGVuZDtcbiAgICAgICAgICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJDYWxsID0gc3VwZXJDYWxsO1xuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckFwcGx5ID0gc3VwZXJBcHBseTtcbiAgICAgICAgICAgIHpyVXRpbC5pbmhlcml0cyhFeHRlbmRlZENsYXNzLCB0aGlzKTtcbiAgICAgICAgICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3M7XG5cbiAgICAgICAgICAgIHJldHVybiBFeHRlbmRlZENsYXNzO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBzdXBlckNhbGwgc2hvdWxkIGhhdmUgY2xhc3MgaW5mbywgd2hpY2ggY2FuIG5vdCBiZSBmZXRjaCBmcm9tICd0aGlzJy5cbiAgICAvLyBDb25zaWRlciB0aGlzIGNhc2U6XG4gICAgLy8gY2xhc3MgQSBoYXMgbWV0aG9kIGYsXG4gICAgLy8gY2xhc3MgQiBpbmhlcml0cyBjbGFzcyBBLCBvdmVycmlkZXMgbWV0aG9kIGYsIGYgY2FsbCBzdXBlckFwcGx5KCdmJyksXG4gICAgLy8gY2xhc3MgQyBpbmhlcml0cyBjbGFzcyBCLCBkbyBub3Qgb3ZlcnJpZGVzIG1ldGhvZCBmLFxuICAgIC8vIHRoZW4gd2hlbiBtZXRob2Qgb2YgY2xhc3MgQyBpcyBjYWxsZWQsIGRlYWQgbG9vcCBvY2N1cmVkLlxuICAgIGZ1bmN0aW9uIHN1cGVyQ2FsbChjb250ZXh0LCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBhcmdzID0genJVdGlsLnNsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1cGVyQXBwbHkoY29udGV4dCwgbWV0aG9kTmFtZSwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlckNsYXNzLnByb3RvdHlwZVttZXRob2ROYW1lXS5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW50aXR5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlZ2lzdGVyV2hlbkV4dGVuZF1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhenouZW5hYmxlQ2xhc3NNYW5hZ2VtZW50ID0gZnVuY3Rpb24gKGVudGl0eSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50IG1vZGVsIGNsYXNzZXNcbiAgICAgICAgICoga2V5OiBjb21wb25lbnRUeXBlLFxuICAgICAgICAgKiB2YWx1ZTpcbiAgICAgICAgICogICAgIGNvbXBvbmVudENsYXNzLCB3aGVuIGNvbXBvbmVudFR5cGUgaXMgJ3h4eCdcbiAgICAgICAgICogICAgIG9yIE9iamVjdC48c3ViS2V5LCBjb21wb25lbnRDbGFzcz4sIHdoZW4gY29tcG9uZW50VHlwZSBpcyAneHh4Lnl5J1xuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB7fTtcblxuICAgICAgICBlbnRpdHkucmVnaXN0ZXJDbGFzcyA9IGZ1bmN0aW9uIChDbGF6eiwgY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjaGVja0NsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudFR5cGUuc3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbXBvbmVudFR5cGUubWFpbiArICcgZXhpc3RzLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXSA9IENsYXp6O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnRUeXBlLnN1YiAhPT0gSVNfQ09OVEFJTkVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBtYWtlQ29udGFpbmVyKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJbY29tcG9uZW50VHlwZS5zdWJdID0gQ2xheno7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENsYXp6O1xuICAgICAgICB9O1xuXG4gICAgICAgIGVudGl0eS5nZXRDbGFzcyA9IGZ1bmN0aW9uIChjb21wb25lbnRNYWluVHlwZSwgc3ViVHlwZSwgdGhyb3dXaGVuTm90Rm91bmQpIHtcbiAgICAgICAgICAgIHZhciBDbGF6eiA9IHN0b3JhZ2VbY29tcG9uZW50TWFpblR5cGVdO1xuXG4gICAgICAgICAgICBpZiAoQ2xhenogJiYgQ2xhenpbSVNfQ09OVEFJTkVSXSkge1xuICAgICAgICAgICAgICAgIENsYXp6ID0gc3ViVHlwZSA/IENsYXp6W3N1YlR5cGVdIDogbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRocm93V2hlbk5vdEZvdW5kICYmICFDbGF6eikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgIXN1YlR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29tcG9uZW50TWFpblR5cGUgKyAnLicgKyAndHlwZSBzaG91bGQgYmUgc3BlY2lmaWVkLidcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ0NvbXBvbmVudCAnICsgY29tcG9uZW50TWFpblR5cGUgKyAnLicgKyAoc3ViVHlwZSB8fCAnJykgKyAnIG5vdCBleGlzdHMuIExvYWQgaXQgZmlyc3QuJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBDbGF6ejtcbiAgICAgICAgfTtcblxuICAgICAgICBlbnRpdHkuZ2V0Q2xhc3Nlc0J5TWFpblR5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xuXG4gICAgICAgICAgICBpZiAob2JqICYmIG9ialtJU19DT05UQUlORVJdKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2gob2JqLCBmdW5jdGlvbiAobywgdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlICE9PSBJU19DT05UQUlORVIgJiYgcmVzdWx0LnB1c2gobyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGVudGl0eS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAvLyBKdXN0IGNvbnNpZGVyIGNvbXBvbmVudFR5cGUubWFpbi5cbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgIHJldHVybiAhIXN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IExpa2UgWydhYScsICdiYiddLCBidXQgY2FuIG5vdCBiZSBbJ2FhLnh4J11cbiAgICAgICAgICovXG4gICAgICAgIGVudGl0eS5nZXRBbGxDbGFzc01haW5UeXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0eXBlcyA9IFtdO1xuICAgICAgICAgICAgenJVdGlsLmVhY2goc3RvcmFnZSwgZnVuY3Rpb24gKG9iaiwgdHlwZSkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBtYWluIHR5cGUgaXMgY29udGFpbmVyIGFuZCBoYXMgc3ViIHR5cGVzXG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gIG1haW5UeXBlXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBlbnRpdHkuaGFzU3ViVHlwZXMgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgdmFyIG9iaiA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgb2JqW0lTX0NPTlRBSU5FUl07XG4gICAgICAgIH07XG5cbiAgICAgICAgZW50aXR5LnBhcnNlQ2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGU7XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZUNvbnRhaW5lcihjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lcltJU19DT05UQUlORVJdKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dID0ge307XG4gICAgICAgICAgICAgICAgY29udGFpbmVyW0lTX0NPTlRBSU5FUl0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnJlZ2lzdGVyV2hlbkV4dGVuZCkge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXh0ZW5kID0gZW50aXR5LmV4dGVuZDtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEV4dGVuZCkge1xuICAgICAgICAgICAgICAgIGVudGl0eS5leHRlbmQgPSBmdW5jdGlvbiAocHJvdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIEV4dGVuZGVkQ2xhc3MgPSBvcmlnaW5hbEV4dGVuZC5jYWxsKHRoaXMsIHByb3RvKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudGl0eS5yZWdpc3RlckNsYXNzKEV4dGVuZGVkQ2xhc3MsIHByb3RvLnR5cGUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gcHJvcGVydGllc1xuICAgICAqL1xuICAgIGNsYXp6LnNldFJlYWRPbmx5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcGVydGllcykge1xuICAgICAgICAvLyBGSVhNRSBJdCBzZWVtcyBicm9rZW4gaW4gSUU4IHNpbXVsYXRpb24gb2YgSUUxMVxuICAgICAgICAvLyBpZiAoIXpyVXRpbC5pc0FycmF5KHByb3BlcnRpZXMpKSB7XG4gICAgICAgIC8vICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyAhPSBudWxsID8gW3Byb3BlcnRpZXNdIDogW107XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8genJVdGlsLmVhY2gocHJvcGVydGllcywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgLy8gICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wXTtcblxuICAgICAgICAvLyAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICAgICAgIC8vICAgICAgICAgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgICAgICAvLyAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgICAvLyAgICAgICAgIH0pO1xuICAgICAgICAvLyAgICAgenJVdGlsLmlzQXJyYXkob2JqW3Byb3BdKVxuICAgICAgICAvLyAgICAgICAgICYmIE9iamVjdC5mcmVlemVcbiAgICAgICAgLy8gICAgICAgICAmJiBPYmplY3QuZnJlZXplKG9ialtwcm9wXSk7XG4gICAgICAgIC8vIH0pO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNsYXp6O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3V0aWwvY2xhenouanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("\n    var getLineStyle = __webpack_require__(31)(\n        [\n            ['lineWidth', 'width'],\n            ['stroke', 'color'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash(style.lineWidth);\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getLineDash: function (lineWidth) {\n            if (lineWidth == null) {\n                lineWidth = 1;\n            }\n            var lineType = this.get('type');\n            var dotSize = Math.max(lineWidth, 2);\n            var dashSize = lineWidth * 4;\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL21vZGVsL21peGluL2xpbmVTdHlsZS5qcz8zNTc5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjMwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgdmFyIGdldExpbmVTdHlsZSA9IHJlcXVpcmUoJy4vbWFrZVN0eWxlTWFwcGVyJykoXG4gICAgICAgIFtcbiAgICAgICAgICAgIFsnbGluZVdpZHRoJywgJ3dpZHRoJ10sXG4gICAgICAgICAgICBbJ3N0cm9rZScsICdjb2xvciddLFxuICAgICAgICAgICAgWydvcGFjaXR5J10sXG4gICAgICAgICAgICBbJ3NoYWRvd0JsdXInXSxcbiAgICAgICAgICAgIFsnc2hhZG93T2Zmc2V0WCddLFxuICAgICAgICAgICAgWydzaGFkb3dPZmZzZXRZJ10sXG4gICAgICAgICAgICBbJ3NoYWRvd0NvbG9yJ11cbiAgICAgICAgXVxuICAgICk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGdldExpbmVTdHlsZTogZnVuY3Rpb24gKGV4Y2x1ZGVzKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRMaW5lU3R5bGUuY2FsbCh0aGlzLCBleGNsdWRlcyk7XG4gICAgICAgICAgICB2YXIgbGluZURhc2ggPSB0aGlzLmdldExpbmVEYXNoKHN0eWxlLmxpbmVXaWR0aCk7XG4gICAgICAgICAgICBsaW5lRGFzaCAmJiAoc3R5bGUubGluZURhc2ggPSBsaW5lRGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGluZURhc2g6IGZ1bmN0aW9uIChsaW5lV2lkdGgpIHtcbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGluZVR5cGUgPSB0aGlzLmdldCgndHlwZScpO1xuICAgICAgICAgICAgdmFyIGRvdFNpemUgPSBNYXRoLm1heChsaW5lV2lkdGgsIDIpO1xuICAgICAgICAgICAgdmFyIGRhc2hTaXplID0gbGluZVdpZHRoICogNDtcbiAgICAgICAgICAgIHJldHVybiAobGluZVR5cGUgPT09ICdzb2xpZCcgfHwgbGluZVR5cGUgPT0gbnVsbCkgPyBudWxsXG4gICAgICAgICAgICAgICAgOiAobGluZVR5cGUgPT09ICdkYXNoZWQnID8gW2Rhc2hTaXplLCBkYXNoU2l6ZV0gOiBbZG90U2l6ZSwgZG90U2l6ZV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9saW5lU3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("// TODO Parse shadow style\n// TODO Only shallow path support\n\n    var zrUtil = __webpack_require__(20);\n\n    module.exports = function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n               properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes, includes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if ((excludes && zrUtil.indexOf(excludes, propName) >= 0)\n                    || (includes && zrUtil.indexOf(includes, propName) < 0)\n                ) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL21vZGVsL21peGluL21ha2VTdHlsZU1hcHBlci5qcz9lMmIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETyBQYXJzZSBzaGFkb3cgc3R5bGVcbi8vIFRPRE8gT25seSBzaGFsbG93IHBhdGggc3VwcG9ydFxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICAvLyBOb3JtYWxpemVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXByb3BlcnRpZXNbaV1bMV0pIHtcbiAgICAgICAgICAgICAgIHByb3BlcnRpZXNbaV1bMV0gPSBwcm9wZXJ0aWVzW2ldWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXhjbHVkZXMsIGluY2x1ZGVzKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnRpZXNbaV1bMV07XG4gICAgICAgICAgICAgICAgaWYgKChleGNsdWRlcyAmJiB6clV0aWwuaW5kZXhPZihleGNsdWRlcywgcHJvcE5hbWUpID49IDApXG4gICAgICAgICAgICAgICAgICAgIHx8IChpbmNsdWRlcyAmJiB6clV0aWwuaW5kZXhPZihpbmNsdWRlcywgcHJvcE5hbWUpIDwgMClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmdldFNoYWxsb3cocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVtwcm9wZXJ0aWVzW2ldWzBdXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9tYWtlU3R5bGVNYXBwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n    module.exports = {\n        getAreaStyle: __webpack_require__(31)(\n            [\n                ['fill', 'color'],\n                ['shadowBlur'],\n                ['shadowOffsetX'],\n                ['shadowOffsetY'],\n                ['opacity'],\n                ['shadowColor']\n            ]\n        )\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL21vZGVsL21peGluL2FyZWFTdHlsZS5qcz80ZTQxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZ2V0QXJlYVN0eWxlOiByZXF1aXJlKCcuL21ha2VTdHlsZU1hcHBlcicpKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFsnZmlsbCcsICdjb2xvciddLFxuICAgICAgICAgICAgICAgIFsnc2hhZG93Qmx1ciddLFxuICAgICAgICAgICAgICAgIFsnc2hhZG93T2Zmc2V0WCddLFxuICAgICAgICAgICAgICAgIFsnc2hhZG93T2Zmc2V0WSddLFxuICAgICAgICAgICAgICAgIFsnb3BhY2l0eSddLFxuICAgICAgICAgICAgICAgIFsnc2hhZG93Q29sb3InXVxuICAgICAgICAgICAgXVxuICAgICAgICApXG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9hcmVhU3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n    var textContain = __webpack_require__(24);\n    var graphicUtil = __webpack_require__(34);\n\n    module.exports = {\n        /**\n         * Get color property or get color from option.textStyle.color\n         * @return {string}\n         */\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color')\n                || (ecModel && ecModel.get('textStyle.color'));\n        },\n\n        /**\n         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n         * @return {string}\n         */\n        getFont: function () {\n            return graphicUtil.getFont({\n                fontStyle: this.getShallow('fontStyle'),\n                fontWeight: this.getShallow('fontWeight'),\n                fontSize: this.getShallow('fontSize'),\n                fontFamily: this.getShallow('fontFamily')\n            }, this.ecModel);\n        },\n\n        getTextRect: function (text) {\n            return textContain.getBoundingRect(\n                text,\n                this.getFont(),\n                this.getShallow('align'),\n                this.getShallow('baseline')\n            );\n        },\n\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(\n                text, containerWidth, this.getFont(), ellipsis, options\n            );\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL21vZGVsL21peGluL3RleHRTdHlsZS5qcz9lNGM4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xuICAgIHZhciBncmFwaGljVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY29sb3IgcHJvcGVydHkgb3IgZ2V0IGNvbG9yIGZyb20gb3B0aW9uLnRleHRTdHlsZS5jb2xvclxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUZXh0Q29sb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2hhbGxvdygnY29sb3InKVxuICAgICAgICAgICAgICAgIHx8IChlY01vZGVsICYmIGVjTW9kZWwuZ2V0KCd0ZXh0U3R5bGUuY29sb3InKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBmb250IHN0cmluZyBmcm9tIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHlcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Rm9udDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdyYXBoaWNVdGlsLmdldEZvbnQoe1xuICAgICAgICAgICAgICAgIGZvbnRTdHlsZTogdGhpcy5nZXRTaGFsbG93KCdmb250U3R5bGUnKSxcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiB0aGlzLmdldFNoYWxsb3coJ2ZvbnRXZWlnaHQnKSxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogdGhpcy5nZXRTaGFsbG93KCdmb250U2l6ZScpLFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IHRoaXMuZ2V0U2hhbGxvdygnZm9udEZhbWlseScpXG4gICAgICAgICAgICB9LCB0aGlzLmVjTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFRleHRSZWN0OiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0U2hhbGxvdygnYWxpZ24nKSxcbiAgICAgICAgICAgICAgICB0aGlzLmdldFNoYWxsb3coJ2Jhc2VsaW5lJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJ1bmNhdGVUZXh0OiBmdW5jdGlvbiAodGV4dCwgY29udGFpbmVyV2lkdGgsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dENvbnRhaW4udHJ1bmNhdGVUZXh0KFxuICAgICAgICAgICAgICAgIHRleHQsIGNvbnRhaW5lcldpZHRoLCB0aGlzLmdldEZvbnQoKSwgZWxsaXBzaXMsIG9wdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL21vZGVsL21peGluL3RleHRTdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var zrUtil = __webpack_require__(20);\n\n    var pathTool = __webpack_require__(35);\n    var Path = __webpack_require__(36);\n    var colorTool = __webpack_require__(47);\n    var matrix = __webpack_require__(27);\n    var vector = __webpack_require__(26);\n    var Transformable = __webpack_require__(42);\n    var BoundingRect = __webpack_require__(25);\n\n    var round = Math.round;\n    var mathMax = Math.max;\n    var mathMin = Math.min;\n\n    var graphic = {};\n\n    graphic.Group = __webpack_require__(64);\n\n    graphic.Image = __webpack_require__(65);\n\n    graphic.Text = __webpack_require__(66);\n\n    graphic.Circle = __webpack_require__(67);\n\n    graphic.Sector = __webpack_require__(68);\n\n    graphic.Ring = __webpack_require__(69);\n\n    graphic.Polygon = __webpack_require__(70);\n\n    graphic.Polyline = __webpack_require__(74);\n\n    graphic.Rect = __webpack_require__(75);\n\n    graphic.Line = __webpack_require__(77);\n\n    graphic.BezierCurve = __webpack_require__(78);\n\n    graphic.Arc = __webpack_require__(79);\n\n    graphic.CompoundPath = __webpack_require__(80);\n\n    graphic.LinearGradient = __webpack_require__(81);\n\n    graphic.RadialGradient = __webpack_require__(83);\n\n    graphic.BoundingRect = BoundingRect;\n\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                }\n                else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n\n            graphic.resizePath(path, rect);\n        }\n        return path;\n    };\n\n    graphic.mergePath = pathTool.mergePath,\n\n    /**\n     * Resize a path to fit the rect\n     * @param {module:zrender/graphic/Path} path\n     * @param {Object} rect\n     */\n    graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n\n        var pathRect = path.getBoundingRect();\n\n        var m = pathRect.calculateTransform(rect);\n\n        path.applyTransform(m);\n    };\n\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n            originWidth === 0 ? 0 : 1\n        );\n        shape.height = Math.max(\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n            originHeight === 0 ? 0 : 1\n        );\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill\n                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke\n                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n\n            el.__normalStl = normalStyle;\n\n            el.__hoverStlDirty = false;\n        }\n    }\n\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n\n        cacheElementStl(el);\n\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        }\n        else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n\n        el.__isHover = true;\n    }\n\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        }\n        else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n\n        el.__isHover = false;\n    }\n\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleEnterHover(child);\n                }\n            })\n            : doSingleEnterHover(el);\n    }\n\n    function doLeaveHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleLeaveHover(child);\n                }\n            })\n            : doSingleLeaveHover(el);\n    }\n\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOver(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOut(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n\n    /**\n     * Set hover style of element.\n     * This method can be called repeatly without side-effects.\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     * @param {Object} [opt]\n     * @param {boolean} [opt.hoverSilentOnTouch=false]\n     *        In touch device, mouseover event will be trigger on touchstart event\n     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n     *        conviniently use hoverStyle when tap on touch screen without additional\n     *        code for compatibility.\n     *        But if the chart/component has select feature, which usually also use\n     *        hoverStyle, there might be conflict between 'select-highlight' and\n     *        'hover-highlight' especially when roam is enabled (see geo for example).\n     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n     *        on touch device.\n     */\n    graphic.setHoverStyle = function (el, hoverStyle, opt) {\n        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    setElementHoverStl(child, hoverStyle);\n                }\n            })\n            : setElementHoverStl(el, hoverStyle);\n\n        // Duplicated function will be auto-ignored, see Eventful.js.\n        el.on('mouseover', onElementMouseOver)\n          .on('mouseout', onElementMouseOut);\n\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis)\n          .on('normal', leaveEmphasis);\n    };\n\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelOffset = labelModel.getShallow('offset');\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textOffset: labelOffset,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n\n    graphic.getFont = function (opt, ecModel) {\n        var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n        return [\n            // FIXME in node-canvas fontWeight is before fontStyle\n            opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '',\n            opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '',\n            (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px',\n            opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'\n        ].join(' ');\n    };\n\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        // Do not check 'animation' property directly here. Consider this case:\n        // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n        // but its parent model (`seriesModel`) does.\n        var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(\n                    dataIndex,\n                    animatableModel.getAnimationDelayParams\n                        ? animatableModel.getAnimationDelayParams(el, dataIndex)\n                        : null\n                );\n            }\n            if (typeof duration === 'function') {\n                duration = duration(dataIndex);\n            }\n\n            duration > 0\n                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n                : (el.stopAnimation(), el.attr(props), cb && cb());\n        }\n        else {\n            el.stopAnimation();\n            el.attr(props);\n            cb && cb();\n        }\n    }\n\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n\n        return mat;\n    };\n\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} target [x, y]\n     * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:\n     *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n     *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (target, transform, invert) {\n        if (transform && !zrUtil.isArrayLike(transform)) {\n            transform = Transformable.getLocalTransform(transform);\n        }\n\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], target, transform);\n    };\n\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n        var vertex = [\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n        ];\n\n        vertex = graphic.applyTransform(vertex, transform, invert);\n\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n            ? (vertex[0] > 0 ? 'right' : 'left')\n            : (vertex[1] > 0 ? 'bottom' : 'top');\n    };\n\n    /**\n     * Apply group transition animation from g1 to g2.\n     * If no animatableModel, no animation.\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                position: vector.clone(el.position),\n                rotation: el.rotation\n            };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }\n                // else {\n                //     if (el.previousProps) {\n                //         graphic.updateProps\n                //     }\n                // }\n            }\n        });\n    };\n\n    /**\n     * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]\n     * @param {Object} rect {x, y, width, height}\n     * @return {Array.<Array.<number>>} A new clipped points.\n     */\n    graphic.clipPointsByRect = function (points, rect) {\n        return zrUtil.map(points, function (point) {\n            var x = point[0];\n            x = mathMax(x, rect.x);\n            x = mathMin(x, rect.x + rect.width);\n            var y = point[1];\n            y = mathMax(y, rect.y);\n            y = mathMin(y, rect.y + rect.height);\n            return [x, y];\n        });\n    };\n\n    /**\n     * @param {Object} targetRect {x, y, width, height}\n     * @param {Object} rect {x, y, width, height}\n     * @return {Object} A new clipped rect. If rect size are negative, return undefined.\n     */\n    graphic.clipRectByRect = function (targetRect, rect) {\n        var x = mathMax(targetRect.x, rect.x);\n        var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n        var y = mathMax(targetRect.y, rect.y);\n        var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);\n\n        if (x2 >= x && y2 >= y) {\n            return {\n                x: x,\n                y: y,\n                width: x2 - x,\n                height: y2 - y\n            };\n        }\n    };\n\n    module.exports = graphic;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3V0aWwvZ3JhcGhpYy5qcz9lMjY3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLGlDQUFpQztBQUNoRCxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLE9BQU87QUFDdEIsZUFBZSwyQkFBMkI7QUFDMUMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVDQUF1QyxnQ0FBZ0MsRUFBRTtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QixnQ0FBZ0MsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRCxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsMENBQTBDO0FBQ3pEO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLE9BQU8sT0FBTztBQUM3QixnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxPQUFPLGFBQWE7QUFDbkMsZUFBZSxPQUFPLE9BQU87QUFDN0IsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIzNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIHBhdGhUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvdG9vbC9wYXRoJyk7XG4gICAgdmFyIFBhdGggPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1BhdGgnKTtcbiAgICB2YXIgY29sb3JUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvdG9vbC9jb2xvcicpO1xuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeCcpO1xuICAgIHZhciB2ZWN0b3IgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciBUcmFuc2Zvcm1hYmxlID0gcmVxdWlyZSgnenJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZScpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG5cbiAgICB2YXIgZ3JhcGhpYyA9IHt9O1xuXG4gICAgZ3JhcGhpYy5Hcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cCcpO1xuXG4gICAgZ3JhcGhpYy5JbWFnZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UnKTtcblxuICAgIGdyYXBoaWMuVGV4dCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dCcpO1xuXG4gICAgZ3JhcGhpYy5DaXJjbGUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZScpO1xuXG4gICAgZ3JhcGhpYy5TZWN0b3IgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3RvcicpO1xuXG4gICAgZ3JhcGhpYy5SaW5nID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nJyk7XG5cbiAgICBncmFwaGljLlBvbHlnb24gPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24nKTtcblxuICAgIGdyYXBoaWMuUG9seWxpbmUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lJyk7XG5cbiAgICBncmFwaGljLlJlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QnKTtcblxuICAgIGdyYXBoaWMuTGluZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZScpO1xuXG4gICAgZ3JhcGhpYy5CZXppZXJDdXJ2ZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUnKTtcblxuICAgIGdyYXBoaWMuQXJjID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMnKTtcblxuICAgIGdyYXBoaWMuQ29tcG91bmRQYXRoID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9Db21wb3VuZFBhdGgnKTtcblxuICAgIGdyYXBoaWMuTGluZWFyR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0xpbmVhckdyYWRpZW50Jyk7XG5cbiAgICBncmFwaGljLlJhZGlhbEdyYWRpZW50ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudCcpO1xuXG4gICAgZ3JhcGhpYy5Cb3VuZGluZ1JlY3QgPSBCb3VuZGluZ1JlY3Q7XG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgc2hhcGUgd2l0aCBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgZ3JhcGhpYy5leHRlbmRTaGFwZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIHJldHVybiBQYXRoLmV4dGVuZChvcHRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIHBhdGhcbiAgICAgKi9cbiAgICBncmFwaGljLmV4dGVuZFBhdGggPSBmdW5jdGlvbiAocGF0aERhdGEsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhUb29sLmV4dGVuZEZyb21TdHJpbmcocGF0aERhdGEsIG9wdHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBwYXRoIGVsZW1lbnQgZnJvbSBwYXRoIGRhdGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhEYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSByZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYXlvdXQ9Y292ZXJdICdjZW50ZXInIG9yICdjb3ZlcidcbiAgICAgKi9cbiAgICBncmFwaGljLm1ha2VQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBvcHRzLCByZWN0LCBsYXlvdXQpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoVG9vbC5jcmVhdGVGcm9tU3RyaW5nKHBhdGhEYXRhLCBvcHRzKTtcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICB2YXIgYXNwZWN0ID0gYm91bmRpbmdSZWN0LndpZHRoIC8gYm91bmRpbmdSZWN0LmhlaWdodDtcblxuICAgICAgICAgICAgaWYgKGxheW91dCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgcmVjdCB0byBjZW50ZXIsIGtlZXAgd2lkdGggLyBoZWlnaHQgcmF0aW8uXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gcmVjdC5oZWlnaHQgKiBhc3BlY3Q7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggPD0gcmVjdC53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjeCA9IHJlY3QueCArIHJlY3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHZhciBjeSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMjtcblxuICAgICAgICAgICAgICAgIHJlY3QueCA9IGN4IC0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHJlY3QueSA9IGN5IC0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICByZWN0LndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgcmVjdC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyYXBoaWMucmVzaXplUGF0aChwYXRoLCByZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuXG4gICAgZ3JhcGhpYy5tZXJnZVBhdGggPSBwYXRoVG9vbC5tZXJnZVBhdGgsXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgYSBwYXRoIHRvIGZpdCB0aGUgcmVjdFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3RcbiAgICAgKi9cbiAgICBncmFwaGljLnJlc2l6ZVBhdGggPSBmdW5jdGlvbiAocGF0aCwgcmVjdCkge1xuICAgICAgICBpZiAoIXBhdGguYXBwbHlUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXRoUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG5cbiAgICAgICAgdmFyIG0gPSBwYXRoUmVjdC5jYWxjdWxhdGVUcmFuc2Zvcm0ocmVjdCk7XG5cbiAgICAgICAgcGF0aC5hcHBseVRyYW5zZm9ybShtKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIGxpbmUgZm9yIGNhbnZhc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zaGFwZV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLngxXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueTFdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54Ml1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnkyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc3R5bGVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zdHlsZS5saW5lV2lkdGhdXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBNb2RpZmllZCBwYXJhbVxuICAgICAqL1xuICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZUxpbmUgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgdmFyIHN1YlBpeGVsT3B0aW1pemUgPSBncmFwaGljLnN1YlBpeGVsT3B0aW1pemU7XG4gICAgICAgIHZhciBzaGFwZSA9IHBhcmFtLnNoYXBlO1xuICAgICAgICB2YXIgbGluZVdpZHRoID0gcGFyYW0uc3R5bGUubGluZVdpZHRoO1xuXG4gICAgICAgIGlmIChyb3VuZChzaGFwZS54MSAqIDIpID09PSByb3VuZChzaGFwZS54MiAqIDIpKSB7XG4gICAgICAgICAgICBzaGFwZS54MSA9IHNoYXBlLngyID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS54MSwgbGluZVdpZHRoLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91bmQoc2hhcGUueTEgKiAyKSA9PT0gcm91bmQoc2hhcGUueTIgKiAyKSkge1xuICAgICAgICAgICAgc2hhcGUueTEgPSBzaGFwZS55MiA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueTEsIGxpbmVXaWR0aCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdWIgcGl4ZWwgb3B0aW1pemUgcmVjdCBmb3IgY2FudmFzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnNoYXBlXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnldXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS53aWR0aF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnN0eWxlXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc3R5bGUubGluZVdpZHRoXVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gTW9kaWZpZWQgcGFyYW1cbiAgICAgKi9cbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVSZWN0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIHZhciBzdWJQaXhlbE9wdGltaXplID0gZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplO1xuICAgICAgICB2YXIgc2hhcGUgPSBwYXJhbS5zaGFwZTtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHBhcmFtLnN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgdmFyIG9yaWdpblggPSBzaGFwZS54O1xuICAgICAgICB2YXIgb3JpZ2luWSA9IHNoYXBlLnk7XG4gICAgICAgIHZhciBvcmlnaW5XaWR0aCA9IHNoYXBlLndpZHRoO1xuICAgICAgICB2YXIgb3JpZ2luSGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuICAgICAgICBzaGFwZS54ID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS54LCBsaW5lV2lkdGgsIHRydWUpO1xuICAgICAgICBzaGFwZS55ID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS55LCBsaW5lV2lkdGgsIHRydWUpO1xuICAgICAgICBzaGFwZS53aWR0aCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5YICsgb3JpZ2luV2lkdGgsIGxpbmVXaWR0aCwgZmFsc2UpIC0gc2hhcGUueCxcbiAgICAgICAgICAgIG9yaWdpbldpZHRoID09PSAwID8gMCA6IDFcbiAgICAgICAgKTtcbiAgICAgICAgc2hhcGUuaGVpZ2h0ID0gTWF0aC5tYXgoXG4gICAgICAgICAgICBzdWJQaXhlbE9wdGltaXplKG9yaWdpblkgKyBvcmlnaW5IZWlnaHQsIGxpbmVXaWR0aCwgZmFsc2UpIC0gc2hhcGUueSxcbiAgICAgICAgICAgIG9yaWdpbkhlaWdodCA9PT0gMCA/IDAgOiAxXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIGZvciBjYW52YXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBDb29yZGluYXRlLCBzdWNoIGFzIHgsIHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVdpZHRoIFNob3VsZCBiZSBub25uZWdhdGl2ZSBpbnRlZ2VyLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHBvc2l0aXZlT3JOZWdhdGl2ZSBEZWZhdWx0IGZhbHNlIChuZWdhdGl2ZSkuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBPcHRpbWl6ZWQgcG9zaXRpb24uXG4gICAgICovXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBsaW5lV2lkdGgsIHBvc2l0aXZlT3JOZWdhdGl2ZSkge1xuICAgICAgICAvLyBBc3N1cmUgdGhhdCAocG9zaXRpb24gKyBsaW5lV2lkdGggLyAyKSBpcyBuZWFyIGludGVnZXIgZWRnZSxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGxpbmUgd2lsbCBiZSBmdXp6eSBpbiBjYW52YXMuXG4gICAgICAgIHZhciBkb3VibGVkUG9zaXRpb24gPSByb3VuZChwb3NpdGlvbiAqIDIpO1xuICAgICAgICByZXR1cm4gKGRvdWJsZWRQb3NpdGlvbiArIHJvdW5kKGxpbmVXaWR0aCkpICUgMiA9PT0gMFxuICAgICAgICAgICAgPyBkb3VibGVkUG9zaXRpb24gLyAyXG4gICAgICAgICAgICA6IChkb3VibGVkUG9zaXRpb24gKyAocG9zaXRpdmVPck5lZ2F0aXZlID8gMSA6IC0xKSkgLyAyO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoYXNGaWxsT3JTdHJva2UoZmlsbE9yU3Ryb2tlKSB7XG4gICAgICAgIHJldHVybiBmaWxsT3JTdHJva2UgIT0gbnVsbCAmJiBmaWxsT3JTdHJva2UgIT0gJ25vbmUnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpZnRDb2xvcihjb2xvcikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyA/IGNvbG9yVG9vbC5saWZ0KGNvbG9yLCAtMC4xKSA6IGNvbG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FjaGVFbGVtZW50U3RsKGVsKSB7XG4gICAgICAgIGlmIChlbC5fX2hvdmVyU3RsRGlydHkpIHtcbiAgICAgICAgICAgIHZhciBzdHJva2UgPSBlbC5zdHlsZS5zdHJva2U7XG4gICAgICAgICAgICB2YXIgZmlsbCA9IGVsLnN0eWxlLmZpbGw7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBob3ZlclN0eWxlIG9uIG1vdXNlb3ZlclxuICAgICAgICAgICAgdmFyIGhvdmVyU3R5bGUgPSBlbC5fX2hvdmVyU3RsO1xuICAgICAgICAgICAgaG92ZXJTdHlsZS5maWxsID0gaG92ZXJTdHlsZS5maWxsXG4gICAgICAgICAgICAgICAgfHwgKGhhc0ZpbGxPclN0cm9rZShmaWxsKSA/IGxpZnRDb2xvcihmaWxsKSA6IG51bGwpO1xuICAgICAgICAgICAgaG92ZXJTdHlsZS5zdHJva2UgPSBob3ZlclN0eWxlLnN0cm9rZVxuICAgICAgICAgICAgICAgIHx8IChoYXNGaWxsT3JTdHJva2Uoc3Ryb2tlKSA/IGxpZnRDb2xvcihzdHJva2UpIDogbnVsbCk7XG5cbiAgICAgICAgICAgIHZhciBub3JtYWxTdHlsZSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBob3ZlclN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyU3R5bGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsU3R5bGVbbmFtZV0gPSBlbC5zdHlsZVtuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLl9fbm9ybWFsU3RsID0gbm9ybWFsU3R5bGU7XG5cbiAgICAgICAgICAgIGVsLl9faG92ZXJTdGxEaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb1NpbmdsZUVudGVySG92ZXIoZWwpIHtcbiAgICAgICAgaWYgKGVsLl9faXNIb3Zlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FjaGVFbGVtZW50U3RsKGVsKTtcblxuICAgICAgICBpZiAoZWwudXNlSG92ZXJMYXllcikge1xuICAgICAgICAgICAgZWwuX196ciAmJiBlbC5fX3pyLmFkZEhvdmVyKGVsLCBlbC5fX2hvdmVyU3RsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnNldFN0eWxlKGVsLl9faG92ZXJTdGwpO1xuICAgICAgICAgICAgZWwuejIgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLl9faXNIb3ZlciA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9TaW5nbGVMZWF2ZUhvdmVyKGVsKSB7XG4gICAgICAgIGlmICghZWwuX19pc0hvdmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9ybWFsU3RsID0gZWwuX19ub3JtYWxTdGw7XG4gICAgICAgIGlmIChlbC51c2VIb3ZlckxheWVyKSB7XG4gICAgICAgICAgICBlbC5fX3pyICYmIGVsLl9fenIucmVtb3ZlSG92ZXIoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9ybWFsU3RsICYmIGVsLnNldFN0eWxlKG5vcm1hbFN0bCk7XG4gICAgICAgICAgICBlbC56MiAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuX19pc0hvdmVyID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9FbnRlckhvdmVyKGVsKSB7XG4gICAgICAgIGVsLnR5cGUgPT09ICdncm91cCdcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09ICdncm91cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9TaW5nbGVFbnRlckhvdmVyKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBkb1NpbmdsZUVudGVySG92ZXIoZWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvTGVhdmVIb3ZlcihlbCkge1xuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXG4gICAgICAgICAgICA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvU2luZ2xlTGVhdmVIb3ZlcihjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogZG9TaW5nbGVMZWF2ZUhvdmVyKGVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRFbGVtZW50SG92ZXJTdGwoZWwsIGhvdmVyU3RsKSB7XG4gICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIHNlcGNpZmllZCBob3ZlclN0eWxlLCB0aGVuIHVzZSBpdCBpbnN0ZWFkIG9mIGdpdmVuIGhvdmVyU3R5bGVcbiAgICAgICAgLy8gT2Z0ZW4gdXNlZCB3aGVuIGl0ZW0gZ3JvdXAgaGFzIGEgbGFiZWwgZWxlbWVudCBhbmQgaXQncyBob3ZlclN0eWxlIGlzIGRpZmZlcmVudFxuICAgICAgICBlbC5fX2hvdmVyU3RsID0gZWwuaG92ZXJTdHlsZSB8fCBob3ZlclN0bCB8fCB7fTtcbiAgICAgICAgZWwuX19ob3ZlclN0bERpcnR5ID0gdHJ1ZTtcblxuICAgICAgICBpZiAoZWwuX19pc0hvdmVyKSB7XG4gICAgICAgICAgICBjYWNoZUVsZW1lbnRTdGwoZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdmVyKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX19ob3ZlclNpbGVudE9uVG91Y2ggJiYgZS56ckJ5VG91Y2gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgaWYgZWxlbWVudCBpcyBub3QgaW4gZW1waGFzaXMgc3RhdHVzXG4gICAgICAgICF0aGlzLl9faXNFbXBoYXNpcyAmJiBkb0VudGVySG92ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdXQoZSkge1xuICAgICAgICBpZiAodGhpcy5fX2hvdmVyU2lsZW50T25Ub3VjaCAmJiBlLnpyQnlUb3VjaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBpZiBlbGVtZW50IGlzIG5vdCBpbiBlbXBoYXNpcyBzdGF0dXNcbiAgICAgICAgIXRoaXMuX19pc0VtcGhhc2lzICYmIGRvTGVhdmVIb3Zlcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbnRlckVtcGhhc2lzKCkge1xuICAgICAgICB0aGlzLl9faXNFbXBoYXNpcyA9IHRydWU7XG4gICAgICAgIGRvRW50ZXJIb3Zlcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZWF2ZUVtcGhhc2lzKCkge1xuICAgICAgICB0aGlzLl9faXNFbXBoYXNpcyA9IGZhbHNlO1xuICAgICAgICBkb0xlYXZlSG92ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGhvdmVyIHN0eWxlIG9mIGVsZW1lbnQuXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCByZXBlYXRseSB3aXRob3V0IHNpZGUtZWZmZWN0cy5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtob3ZlclN0eWxlXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5ob3ZlclNpbGVudE9uVG91Y2g9ZmFsc2VdXG4gICAgICogICAgICAgIEluIHRvdWNoIGRldmljZSwgbW91c2VvdmVyIGV2ZW50IHdpbGwgYmUgdHJpZ2dlciBvbiB0b3VjaHN0YXJ0IGV2ZW50XG4gICAgICogICAgICAgIChzZWUgbW9kdWxlOnpyZW5kZXIvZG9tL0hhbmRsZXJQcm94eSkuIEJ5IHRoaXMgbWVjaGFuaXNtLCB3ZSBjYW5cbiAgICAgKiAgICAgICAgY29udmluaWVudGx5IHVzZSBob3ZlclN0eWxlIHdoZW4gdGFwIG9uIHRvdWNoIHNjcmVlbiB3aXRob3V0IGFkZGl0aW9uYWxcbiAgICAgKiAgICAgICAgY29kZSBmb3IgY29tcGF0aWJpbGl0eS5cbiAgICAgKiAgICAgICAgQnV0IGlmIHRoZSBjaGFydC9jb21wb25lbnQgaGFzIHNlbGVjdCBmZWF0dXJlLCB3aGljaCB1c3VhbGx5IGFsc28gdXNlXG4gICAgICogICAgICAgIGhvdmVyU3R5bGUsIHRoZXJlIG1pZ2h0IGJlIGNvbmZsaWN0IGJldHdlZW4gJ3NlbGVjdC1oaWdobGlnaHQnIGFuZFxuICAgICAqICAgICAgICAnaG92ZXItaGlnaGxpZ2h0JyBlc3BlY2lhbGx5IHdoZW4gcm9hbSBpcyBlbmFibGVkIChzZWUgZ2VvIGZvciBleGFtcGxlKS5cbiAgICAgKiAgICAgICAgSW4gdGhpcyBjYXNlLCBob3ZlclNpbGVudE9uVG91Y2ggc2hvdWxkIGJlIHVzZWQgdG8gZGlzYWJsZSBob3Zlci1oaWdobGlnaHRcbiAgICAgKiAgICAgICAgb24gdG91Y2ggZGV2aWNlLlxuICAgICAqL1xuICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZSA9IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSwgb3B0KSB7XG4gICAgICAgIGVsLl9faG92ZXJTaWxlbnRPblRvdWNoID0gb3B0ICYmIG9wdC5ob3ZlclNpbGVudE9uVG91Y2g7XG5cbiAgICAgICAgZWwudHlwZSA9PT0gJ2dyb3VwJ1xuICAgICAgICAgICAgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50SG92ZXJTdGwoY2hpbGQsIGhvdmVyU3R5bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IHNldEVsZW1lbnRIb3ZlclN0bChlbCwgaG92ZXJTdHlsZSk7XG5cbiAgICAgICAgLy8gRHVwbGljYXRlZCBmdW5jdGlvbiB3aWxsIGJlIGF1dG8taWdub3JlZCwgc2VlIEV2ZW50ZnVsLmpzLlxuICAgICAgICBlbC5vbignbW91c2VvdmVyJywgb25FbGVtZW50TW91c2VPdmVyKVxuICAgICAgICAgIC5vbignbW91c2VvdXQnLCBvbkVsZW1lbnRNb3VzZU91dCk7XG5cbiAgICAgICAgLy8gRW1waGFzaXMsIG5vcm1hbCBjYW4gYmUgdHJpZ2dlcmVkIG1hbnVhbGx5XG4gICAgICAgIGVsLm9uKCdlbXBoYXNpcycsIGVudGVyRW1waGFzaXMpXG4gICAgICAgICAgLm9uKCdub3JtYWwnLCBsZWF2ZUVtcGhhc2lzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRleHQgb3B0aW9uIGluIHRoZSBzdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXh0U3R5bGVcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBsYWJlbE1vZGVsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICovXG4gICAgZ3JhcGhpYy5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHRTdHlsZSwgbGFiZWxNb2RlbCwgY29sb3IpIHtcbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Bvc2l0aW9uJykgfHwgJ2luc2lkZSc7XG4gICAgICAgIHZhciBsYWJlbE9mZnNldCA9IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnb2Zmc2V0Jyk7XG4gICAgICAgIHZhciBsYWJlbENvbG9yID0gbGFiZWxQb3NpdGlvbi5pbmRleE9mKCdpbnNpZGUnKSA+PSAwID8gJ3doaXRlJyA6IGNvbG9yO1xuICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBsYWJlbE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICAgICAgenJVdGlsLmV4dGVuZCh0ZXh0U3R5bGUsIHtcbiAgICAgICAgICAgIHRleHREaXN0YW5jZTogbGFiZWxNb2RlbC5nZXRTaGFsbG93KCdkaXN0YW5jZScpIHx8IDUsXG4gICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgdGV4dFBvc2l0aW9uOiBsYWJlbFBvc2l0aW9uLFxuICAgICAgICAgICAgdGV4dE9mZnNldDogbGFiZWxPZmZzZXQsXG4gICAgICAgICAgICB0ZXh0RmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCkgfHwgbGFiZWxDb2xvclxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZ3JhcGhpYy5nZXRGb250ID0gZnVuY3Rpb24gKG9wdCwgZWNNb2RlbCkge1xuICAgICAgICB2YXIgZ1RleHRTdHlsZU1vZGVsID0gZWNNb2RlbCAmJiBlY01vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC8vIEZJWE1FIGluIG5vZGUtY2FudmFzIGZvbnRXZWlnaHQgaXMgYmVmb3JlIGZvbnRTdHlsZVxuICAgICAgICAgICAgb3B0LmZvbnRTdHlsZSB8fCBnVGV4dFN0eWxlTW9kZWwgJiYgZ1RleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRTdHlsZScpIHx8ICcnLFxuICAgICAgICAgICAgb3B0LmZvbnRXZWlnaHQgfHwgZ1RleHRTdHlsZU1vZGVsICYmIGdUZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdmb250V2VpZ2h0JykgfHwgJycsXG4gICAgICAgICAgICAob3B0LmZvbnRTaXplIHx8IGdUZXh0U3R5bGVNb2RlbCAmJiBnVGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnZm9udFNpemUnKSB8fCAxMikgKyAncHgnLFxuICAgICAgICAgICAgb3B0LmZvbnRGYW1pbHkgfHwgZ1RleHRTdHlsZU1vZGVsICYmIGdUZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdmb250RmFtaWx5JykgfHwgJ3NhbnMtc2VyaWYnXG4gICAgICAgIF0uam9pbignICcpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhbmltYXRlT3JTZXRQcm9wcyhpc1VwZGF0ZSwgZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhSW5kZXggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gZGF0YUluZGV4O1xuICAgICAgICAgICAgZGF0YUluZGV4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3QgY2hlY2sgJ2FuaW1hdGlvbicgcHJvcGVydHkgZGlyZWN0bHkgaGVyZS4gQ29uc2lkZXIgdGhpcyBjYXNlOlxuICAgICAgICAvLyBhbmltYXRpb24gbW9kZWwgaXMgYW4gYGl0ZW1Nb2RlbGAsIHdob3NlIGRvZXMgbm90IGhhdmUgYGlzQW5pbWF0aW9uRW5hYmxlZGBcbiAgICAgICAgLy8gYnV0IGl0cyBwYXJlbnQgbW9kZWwgKGBzZXJpZXNNb2RlbGApIGRvZXMuXG4gICAgICAgIHZhciBhbmltYXRpb25FbmFibGVkID0gYW5pbWF0YWJsZU1vZGVsICYmIGFuaW1hdGFibGVNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKTtcblxuICAgICAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgdmFyIHBvc3RmaXggPSBpc1VwZGF0ZSA/ICdVcGRhdGUnIDogJyc7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBhbmltYXRhYmxlTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uRHVyYXRpb24nICsgcG9zdGZpeCk7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uRWFzaW5nID0gYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkVhc2luZycgKyBwb3N0Zml4KTtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25EZWxheSA9IGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb25EZWxheScgKyBwb3N0Zml4KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5pbWF0aW9uRGVsYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25EZWxheSA9IGFuaW1hdGlvbkRlbGF5KFxuICAgICAgICAgICAgICAgICAgICBkYXRhSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGFibGVNb2RlbC5nZXRBbmltYXRpb25EZWxheVBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBhbmltYXRhYmxlTW9kZWwuZ2V0QW5pbWF0aW9uRGVsYXlQYXJhbXMoZWwsIGRhdGFJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbihkYXRhSW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkdXJhdGlvbiA+IDBcbiAgICAgICAgICAgICAgICA/IGVsLmFuaW1hdGVUbyhwcm9wcywgZHVyYXRpb24sIGFuaW1hdGlvbkRlbGF5IHx8IDAsIGFuaW1hdGlvbkVhc2luZywgY2IpXG4gICAgICAgICAgICAgICAgOiAoZWwuc3RvcEFuaW1hdGlvbigpLCBlbC5hdHRyKHByb3BzKSwgY2IgJiYgY2IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBlbC5hdHRyKHByb3BzKTtcbiAgICAgICAgICAgIGNiICYmIGNiKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZ3JhcGhpYyBlbGVtZW50IHByb3BlcnRpZXMgd2l0aCBvciB3aXRob3V0IGFuaW1hdGlvbiBhY2NvcmRpbmcgdG8gdGhlIGNvbmZpZ3VyYXRpb24gaW4gc2VyaWVzXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFthbmltYXRhYmxlTW9kZWxdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhSW5kZXhdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoZWwsIHtcbiAgICAgKiAgICAgICAgIHBvc2l0aW9uOiBbMTAwLCAxMDBdXG4gICAgICogICAgIH0sIHNlcmllc01vZGVsLCBkYXRhSW5kZXgsIGZ1bmN0aW9uICgpIHsgY29uc29sZS5sb2coJ0FuaW1hdGlvbiBkb25lIScpOyB9KTtcbiAgICAgKiAgICAgLy8gT3JcbiAgICAgKiAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xuICAgICAqICAgICAgICAgcG9zaXRpb246IFsxMDAsIDEwMF1cbiAgICAgKiAgICAgfSwgc2VyaWVzTW9kZWwsIGZ1bmN0aW9uICgpIHsgY29uc29sZS5sb2coJ0FuaW1hdGlvbiBkb25lIScpOyB9KTtcbiAgICAgKi9cbiAgICBncmFwaGljLnVwZGF0ZVByb3BzID0gZnVuY3Rpb24gKGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiKSB7XG4gICAgICAgIGFuaW1hdGVPclNldFByb3BzKHRydWUsIGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdCBncmFwaGljIGVsZW1lbnQgcHJvcGVydGllcyB3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uIGFjY29yZGluZyB0byB0aGUgY29uZmlndXJhdGlvbiBpbiBzZXJpZXNcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW2FuaW1hdGFibGVNb2RlbF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqL1xuICAgIGdyYXBoaWMuaW5pdFByb3BzID0gZnVuY3Rpb24gKGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiKSB7XG4gICAgICAgIGFuaW1hdGVPclNldFByb3BzKGZhbHNlLCBlbCwgcHJvcHMsIGFuaW1hdGFibGVNb2RlbCwgZGF0YUluZGV4LCBjYik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0cmFuc2Zvcm0gbWF0cml4IG9mIHRhcmdldCAocGFyYW0gdGFyZ2V0KSxcbiAgICAgKiBpbiBjb29yZGluYXRlIG9mIGl0cyBhbmNlc3RvciAocGFyYW0gYW5jZXN0b3IpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX0gW2FuY2VzdG9yXVxuICAgICAqL1xuICAgIGdyYXBoaWMuZ2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKHRhcmdldCwgYW5jZXN0b3IpIHtcbiAgICAgICAgdmFyIG1hdCA9IG1hdHJpeC5pZGVudGl0eShbXSk7XG5cbiAgICAgICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQgIT09IGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBtYXRyaXgubXVsKG1hdCwgdGFyZ2V0LmdldExvY2FsVHJhbnNmb3JtKCksIG1hdCk7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdHJhbnNmb3JtIHRvIGFuIHZlcnRleC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0YXJnZXQgW3gsIHldXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPnxUeXBlZEFycmF5LjxudW1iZXI+fE9iamVjdH0gdHJhbnNmb3JtIENhbiBiZTpcbiAgICAgKiAgICAgICsgVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cbiAgICAgKiAgICAgICsge3Bvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGV9LCB0aGUgc2FtZSBhcyBgenJlbmRlci9UcmFuc2Zvcm1hYmxlYC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbnZlcnQgV2hldGhlciB1c2UgaW52ZXJ0IG1hdHJpeC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gW3gsIHldXG4gICAgICovXG4gICAgZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRyYW5zZm9ybSwgaW52ZXJ0KSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm0gJiYgIXpyVXRpbC5pc0FycmF5TGlrZSh0cmFuc2Zvcm0pKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBUcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW52ZXJ0KSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBtYXRyaXguaW52ZXJ0KFtdLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0oW10sIHRhcmdldCwgdHJhbnNmb3JtKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiAnbGVmdCcgJ3JpZ2h0JyAndG9wJyAnYm90dG9tJ1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRyYW5zZm9ybSBUcmFuc2Zvcm0gbWF0cml4OiBsaWtlIFsxLCAwLCAwLCAxLCAwLCAwXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVHJhbnNmb3JtZWQgZGlyZWN0aW9uLiAnbGVmdCcgJ3JpZ2h0JyAndG9wJyAnYm90dG9tJ1xuICAgICAqL1xuICAgIGdyYXBoaWMudHJhbnNmb3JtRGlyZWN0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcblxuICAgICAgICAvLyBQaWNrIGEgYmFzZSwgZW5zdXJlIHRoYXQgdHJhbnNmb3JtIHJlc3VsdCB3aWxsIG5vdCBiZSAoMCwgMCkuXG4gICAgICAgIHZhciBoQmFzZSA9ICh0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVswXSA9PT0gMClcbiAgICAgICAgICAgID8gMSA6IE1hdGguYWJzKDIgKiB0cmFuc2Zvcm1bNF0gLyB0cmFuc2Zvcm1bMF0pO1xuICAgICAgICB2YXIgdkJhc2UgPSAodHJhbnNmb3JtWzRdID09PSAwIHx8IHRyYW5zZm9ybVs1XSA9PT0gMCB8fCB0cmFuc2Zvcm1bMl0gPT09IDApXG4gICAgICAgICAgICA/IDEgOiBNYXRoLmFicygyICogdHJhbnNmb3JtWzRdIC8gdHJhbnNmb3JtWzJdKTtcblxuICAgICAgICB2YXIgdmVydGV4ID0gW1xuICAgICAgICAgICAgZGlyZWN0aW9uID09PSAnbGVmdCcgPyAtaEJhc2UgOiBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyBoQmFzZSA6IDAsXG4gICAgICAgICAgICBkaXJlY3Rpb24gPT09ICd0b3AnID8gLXZCYXNlIDogZGlyZWN0aW9uID09PSAnYm90dG9tJyA/IHZCYXNlIDogMFxuICAgICAgICBdO1xuXG4gICAgICAgIHZlcnRleCA9IGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0odmVydGV4LCB0cmFuc2Zvcm0sIGludmVydCk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHZlcnRleFswXSkgPiBNYXRoLmFicyh2ZXJ0ZXhbMV0pXG4gICAgICAgICAgICA/ICh2ZXJ0ZXhbMF0gPiAwID8gJ3JpZ2h0JyA6ICdsZWZ0JylcbiAgICAgICAgICAgIDogKHZlcnRleFsxXSA+IDAgPyAnYm90dG9tJyA6ICd0b3AnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbHkgZ3JvdXAgdHJhbnNpdGlvbiBhbmltYXRpb24gZnJvbSBnMSB0byBnMi5cbiAgICAgKiBJZiBubyBhbmltYXRhYmxlTW9kZWwsIG5vIGFuaW1hdGlvbi5cbiAgICAgKi9cbiAgICBncmFwaGljLmdyb3VwVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChnMSwgZzIsIGFuaW1hdGFibGVNb2RlbCwgY2IpIHtcbiAgICAgICAgaWYgKCFnMSB8fCAhZzIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEVsTWFwKGcpIHtcbiAgICAgICAgICAgIHZhciBlbE1hcCA9IHt9O1xuICAgICAgICAgICAgZy50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVsLmlzR3JvdXAgJiYgZWwuYW5pZCkge1xuICAgICAgICAgICAgICAgICAgICBlbE1hcFtlbC5hbmlkXSA9IGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVsTWFwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEFuaW1hdGFibGVQcm9wcyhlbCkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogdmVjdG9yLmNsb25lKGVsLnBvc2l0aW9uKSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogZWwucm90YXRpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZWwuc2hhcGUpIHtcbiAgICAgICAgICAgICAgICBvYmouc2hhcGUgPSB6clV0aWwuZXh0ZW5kKHt9LCBlbC5zaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbE1hcDEgPSBnZXRFbE1hcChnMSk7XG5cbiAgICAgICAgZzIudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoIWVsLmlzR3JvdXAgJiYgZWwuYW5pZCkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRFbCA9IGVsTWFwMVtlbC5hbmlkXTtcbiAgICAgICAgICAgICAgICBpZiAob2xkRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1Byb3AgPSBnZXRBbmltYXRhYmxlUHJvcHMoZWwpO1xuICAgICAgICAgICAgICAgICAgICBlbC5hdHRyKGdldEFuaW1hdGFibGVQcm9wcyhvbGRFbCkpO1xuICAgICAgICAgICAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCBuZXdQcm9wLCBhbmltYXRhYmxlTW9kZWwsIGVsLmRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vICAgICBpZiAoZWwucHJldmlvdXNQcm9wcykge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wc1xuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwb2ludHMgTGlrZTogW1syMywgNDRdLCBbNTMsIDY2XSwgLi4uXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IEEgbmV3IGNsaXBwZWQgcG9pbnRzLlxuICAgICAqL1xuICAgIGdyYXBoaWMuY2xpcFBvaW50c0J5UmVjdCA9IGZ1bmN0aW9uIChwb2ludHMsIHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcG9pbnRbMF07XG4gICAgICAgICAgICB4ID0gbWF0aE1heCh4LCByZWN0LngpO1xuICAgICAgICAgICAgeCA9IG1hdGhNaW4oeCwgcmVjdC54ICsgcmVjdC53aWR0aCk7XG4gICAgICAgICAgICB2YXIgeSA9IHBvaW50WzFdO1xuICAgICAgICAgICAgeSA9IG1hdGhNYXgoeSwgcmVjdC55KTtcbiAgICAgICAgICAgIHkgPSBtYXRoTWluKHksIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0UmVjdCB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdCB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IGNsaXBwZWQgcmVjdC4gSWYgcmVjdCBzaXplIGFyZSBuZWdhdGl2ZSwgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBncmFwaGljLmNsaXBSZWN0QnlSZWN0ID0gZnVuY3Rpb24gKHRhcmdldFJlY3QsIHJlY3QpIHtcbiAgICAgICAgdmFyIHggPSBtYXRoTWF4KHRhcmdldFJlY3QueCwgcmVjdC54KTtcbiAgICAgICAgdmFyIHgyID0gbWF0aE1pbih0YXJnZXRSZWN0LnggKyB0YXJnZXRSZWN0LndpZHRoLCByZWN0LnggKyByZWN0LndpZHRoKTtcbiAgICAgICAgdmFyIHkgPSBtYXRoTWF4KHRhcmdldFJlY3QueSwgcmVjdC55KTtcbiAgICAgICAgdmFyIHkyID0gbWF0aE1pbih0YXJnZXRSZWN0LnkgKyB0YXJnZXRSZWN0LmhlaWdodCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuXG4gICAgICAgIGlmICh4MiA+PSB4ICYmIHkyID49IHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB4MiAtIHgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB5MiAtIHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBncmFwaGljO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvdXRpbC9ncmFwaGljLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("\n\n    var Path = __webpack_require__(36);\n    var PathProxy = __webpack_require__(52);\n    var transformPath = __webpack_require__(63);\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            if (path.setData) {\n                path.setData(pathProxy.data);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            }\n            else {\n                var ctx = path;\n                pathProxy.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            transformPath(pathProxy, m);\n\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (!pathEl.path) {\n                    pathEl.createPathProxy();\n                }\n                if (pathEl.__dirtyPath) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            // Need path proxy.\n            pathBundle.createPathProxy();\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qcz9kYzRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIzNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIFBhdGggPSByZXF1aXJlKCcuLi9ncmFwaGljL1BhdGgnKTtcbiAgICB2YXIgUGF0aFByb3h5ID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKTtcbiAgICB2YXIgdHJhbnNmb3JtUGF0aCA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtUGF0aCcpO1xuXG4gICAgLy8gY29tbWFuZCBjaGFyc1xuICAgIHZhciBjYyA9IFtcbiAgICAgICAgJ20nLCAnTScsICdsJywgJ0wnLCAndicsICdWJywgJ2gnLCAnSCcsICd6JywgJ1onLFxuICAgICAgICAnYycsICdDJywgJ3EnLCAnUScsICd0JywgJ1QnLCAncycsICdTJywgJ2EnLCAnQSdcbiAgICBdO1xuXG4gICAgdmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBtYXRoU2luID0gTWF0aC5zaW47XG4gICAgdmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgUEkgPSBNYXRoLlBJO1xuXG4gICAgdmFyIHZNYWcgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodlswXSAqIHZbMF0gKyB2WzFdICogdlsxXSk7XG4gICAgfTtcbiAgICB2YXIgdlJhdGlvID0gZnVuY3Rpb24odSwgdikge1xuICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pIC8gKHZNYWcodSkgKiB2TWFnKHYpKTtcbiAgICB9O1xuICAgIHZhciB2QW5nbGUgPSBmdW5jdGlvbih1LCB2KSB7XG4gICAgICAgIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSlcbiAgICAgICAgICAgICAgICAqIE1hdGguYWNvcyh2UmF0aW8odSwgdikpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQXJjKHgxLCB5MSwgeDIsIHkyLCBmYSwgZnMsIHJ4LCByeSwgcHNpRGVnLCBjbWQsIHBhdGgpIHtcbiAgICAgICAgdmFyIHBzaSA9IHBzaURlZyAqIChQSSAvIDE4MC4wKTtcbiAgICAgICAgdmFyIHhwID0gbWF0aENvcyhwc2kpICogKHgxIC0geDIpIC8gMi4wXG4gICAgICAgICAgICAgICAgICsgbWF0aFNpbihwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuICAgICAgICB2YXIgeXAgPSAtMSAqIG1hdGhTaW4ocHNpKSAqICh4MSAtIHgyKSAvIDIuMFxuICAgICAgICAgICAgICAgICArIG1hdGhDb3MocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcblxuICAgICAgICB2YXIgbGFtYmRhID0gKHhwICogeHApIC8gKHJ4ICogcngpICsgKHlwICogeXApIC8gKHJ5ICogcnkpO1xuXG4gICAgICAgIGlmIChsYW1iZGEgPiAxKSB7XG4gICAgICAgICAgICByeCAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgICAgICAgICAgcnkgKj0gbWF0aFNxcnQobGFtYmRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmID0gKGZhID09PSBmcyA/IC0xIDogMSlcbiAgICAgICAgICAgICogbWF0aFNxcnQoKCgocnggKiByeCkgKiAocnkgKiByeSkpXG4gICAgICAgICAgICAgICAgICAgIC0gKChyeCAqIHJ4KSAqICh5cCAqIHlwKSlcbiAgICAgICAgICAgICAgICAgICAgLSAoKHJ5ICogcnkpICogKHhwICogeHApKSkgLyAoKHJ4ICogcngpICogKHlwICogeXApXG4gICAgICAgICAgICAgICAgICAgICsgKHJ5ICogcnkpICogKHhwICogeHApKVxuICAgICAgICAgICAgICAgICkgfHwgMDtcblxuICAgICAgICB2YXIgY3hwID0gZiAqIHJ4ICogeXAgLyByeTtcbiAgICAgICAgdmFyIGN5cCA9IGYgKiAtcnkgKiB4cCAvIHJ4O1xuXG4gICAgICAgIHZhciBjeCA9ICh4MSArIHgyKSAvIDIuMFxuICAgICAgICAgICAgICAgICArIG1hdGhDb3MocHNpKSAqIGN4cFxuICAgICAgICAgICAgICAgICAtIG1hdGhTaW4ocHNpKSAqIGN5cDtcbiAgICAgICAgdmFyIGN5ID0gKHkxICsgeTIpIC8gMi4wXG4gICAgICAgICAgICAgICAgKyBtYXRoU2luKHBzaSkgKiBjeHBcbiAgICAgICAgICAgICAgICArIG1hdGhDb3MocHNpKSAqIGN5cDtcblxuICAgICAgICB2YXIgdGhldGEgPSB2QW5nbGUoWyAxLCAwIF0sIFsgKHhwIC0gY3hwKSAvIHJ4LCAoeXAgLSBjeXApIC8gcnkgXSk7XG4gICAgICAgIHZhciB1ID0gWyAoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeSBdO1xuICAgICAgICB2YXIgdiA9IFsgKC0xICogeHAgLSBjeHApIC8gcngsICgtMSAqIHlwIC0gY3lwKSAvIHJ5IF07XG4gICAgICAgIHZhciBkVGhldGEgPSB2QW5nbGUodSwgdik7XG5cbiAgICAgICAgaWYgKHZSYXRpbyh1LCB2KSA8PSAtMSkge1xuICAgICAgICAgICAgZFRoZXRhID0gUEk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZSYXRpbyh1LCB2KSA+PSAxKSB7XG4gICAgICAgICAgICBkVGhldGEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcyA9PT0gMCAmJiBkVGhldGEgPiAwKSB7XG4gICAgICAgICAgICBkVGhldGEgPSBkVGhldGEgLSAyICogUEk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZzID09PSAxICYmIGRUaGV0YSA8IDApIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBQSTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoUHJveHlGcm9tU3RyaW5nKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb21tYW5kIHN0cmluZ1xuICAgICAgICB2YXIgY3MgPSBkYXRhLnJlcGxhY2UoLy0vZywgJyAtJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8gIC9nLCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZSgvIC9nLCAnLCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvLCwvZywgJywnKTtcblxuICAgICAgICB2YXIgbjtcbiAgICAgICAgLy8gY3JlYXRlIHBpcGVzIHNvIHRoYXQgd2UgY2FuIHNwbGl0IHRoZSBkYXRhXG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBjYy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgY3MgPSBjcy5yZXBsYWNlKG5ldyBSZWdFeHAoY2Nbbl0sICdnJyksICd8JyArIGNjW25dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhcnJheVxuICAgICAgICB2YXIgYXJyID0gY3Muc3BsaXQoJ3wnKTtcbiAgICAgICAgLy8gaW5pdCBjb250ZXh0IHBvaW50XG4gICAgICAgIHZhciBjcHggPSAwO1xuICAgICAgICB2YXIgY3B5ID0gMDtcblxuICAgICAgICB2YXIgcGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICAgICAgdmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG5cbiAgICAgICAgdmFyIHByZXZDbWQ7XG4gICAgICAgIGZvciAobiA9IDE7IG4gPCBhcnIubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBhcnJbbl07XG4gICAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoMCk7XG4gICAgICAgICAgICB2YXIgb2ZmID0gMDtcbiAgICAgICAgICAgIHZhciBwID0gc3RyLnNsaWNlKDEpLnJlcGxhY2UoL2UsLS9nLCAnZS0nKS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgdmFyIGNtZDtcblxuICAgICAgICAgICAgaWYgKHAubGVuZ3RoID4gMCAmJiBwWzBdID09PSAnJykge1xuICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFtpXSA9IHBhcnNlRmxvYXQocFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAob2ZmIDwgcC5sZW5ndGggJiYgIWlzTmFOKHBbb2ZmXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocFswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjdGxQdHg7XG4gICAgICAgICAgICAgICAgdmFyIGN0bFB0eTtcblxuICAgICAgICAgICAgICAgIHZhciByeDtcbiAgICAgICAgICAgICAgICB2YXIgcnk7XG4gICAgICAgICAgICAgICAgdmFyIHBzaTtcbiAgICAgICAgICAgICAgICB2YXIgZmE7XG4gICAgICAgICAgICAgICAgdmFyIGZzO1xuXG4gICAgICAgICAgICAgICAgdmFyIHgxID0gY3B4O1xuICAgICAgICAgICAgICAgIHZhciB5MSA9IGNweTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJ2wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdMJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtZCwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY21kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5DKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELkMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IGNweCArIHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBjcHkgKyBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHBbb2ZmKytdICsgY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBwW29mZisrXSArIGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuUSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcnggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IGNweCwgeTEgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2ksIGNtZCwgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICByeSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBmYSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMgPSBwW29mZisrXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2ksIGNtZCwgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGMgPT09ICd6JyB8fCBjID09PSAnWicpIHtcbiAgICAgICAgICAgICAgICBjbWQgPSBDTUQuWjtcbiAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldkNtZCA9IGNtZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGgudG9TdGF0aWMoKTtcblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICAvLyBUT0RPIE9wdGltaXplIGRvdWJsZSBtZW1vcnkgY29zdCBwcm9ibGVtXG4gICAgZnVuY3Rpb24gY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSB7XG4gICAgICAgIHZhciBwYXRoUHJveHkgPSBjcmVhdGVQYXRoUHJveHlGcm9tU3RyaW5nKHN0cik7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBvcHRzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICBpZiAocGF0aC5zZXREYXRhKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5zZXREYXRhKHBhdGhQcm94eS5kYXRhKTtcbiAgICAgICAgICAgICAgICAvLyBTdmcgYW5kIHZtbCByZW5kZXJlciBkb24ndCBoYXZlIGNvbnRleHRcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gcGF0aC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHBhdGg7XG4gICAgICAgICAgICAgICAgcGF0aFByb3h5LnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgb3B0cy5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1QYXRoKHBhdGhQcm94eSwgbSk7XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkodHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBQYXRoIG9iamVjdCBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAgICAgICAgICogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRzIE90aGVyIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUZyb21TdHJpbmc6IGZ1bmN0aW9uIChzdHIsIG9wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGF0aChjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgUGF0aCBjbGFzcyBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRzIE90aGVyIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGV4dGVuZEZyb21TdHJpbmc6IGZ1bmN0aW9uIChzdHIsIG9wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBQYXRoLmV4dGVuZChjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWVyZ2UgbXVsdGlwbGUgcGF0aHNcbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE8gQXBwbHkgdHJhbnNmb3JtXG4gICAgICAgIC8vIFRPRE8gc3Ryb2tlIGRhc2hcbiAgICAgICAgLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuICAgICAgICBtZXJnZVBhdGg6IGZ1bmN0aW9uIChwYXRoRWxzLCBvcHRzKSB7XG4gICAgICAgICAgICB2YXIgcGF0aExpc3QgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoRWxzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aEVsID0gcGF0aEVsc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGhFbC5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhFbC5jcmVhdGVQYXRoUHJveHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhFbC5fX2RpcnR5UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoRWwuYnVpbGRQYXRoKHBhdGhFbC5wYXRoLCBwYXRoRWwuc2hhcGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRoTGlzdC5wdXNoKHBhdGhFbC5wYXRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhdGhCdW5kbGUgPSBuZXcgUGF0aChvcHRzKTtcbiAgICAgICAgICAgIC8vIE5lZWQgcGF0aCBwcm94eS5cbiAgICAgICAgICAgIHBhdGhCdW5kbGUuY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgICAgICAgICBwYXRoQnVuZGxlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5hcHBlbmRQYXRoKHBhdGhMaXN0KTtcbiAgICAgICAgICAgICAgICAvLyBTdmcgYW5kIHZtbCByZW5kZXJlciBkb24ndCBoYXZlIGNvbnRleHRcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gcGF0aC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHBhdGhCdW5kbGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = __webpack_require__(37);\n    var zrUtil = __webpack_require__(20);\n    var PathProxy = __webpack_require__(52);\n    var pathContain = __webpack_require__(55);\n\n    var Pattern = __webpack_require__(62);\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    var pathProxyForDraw = new PathProxy(true);\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = null;\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path || pathProxyForDraw;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect;\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath\n                || (lineDash && !ctxLineDash && hasStroke)\n            ) {\n                path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                if (this.path) {\n                    this.__dirtyPath = false;\n                }\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        createPathProxy: function () {\n            this.path = new PathProxy();\n        },\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (!path) {\n                    // Create path on demand.\n                    path = this.path = new PathProxy();\n                }\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     * 扩展一个 Path element, 比如星形，圆等。\n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME 不能 extend position, rotation 等引用对象\n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qcz9jMTE5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakMsbUJBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjM2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQYXRoIGVsZW1lbnRcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL1BhdGhcbiAqL1xuXG5cblxuICAgIHZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoJy4vRGlzcGxheWFibGUnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoJy4uL2NvcmUvUGF0aFByb3h5Jyk7XG4gICAgdmFyIHBhdGhDb250YWluID0gcmVxdWlyZSgnLi4vY29udGFpbi9wYXRoJyk7XG5cbiAgICB2YXIgUGF0dGVybiA9IHJlcXVpcmUoJy4vUGF0dGVybicpO1xuICAgIHZhciBnZXRDYW52YXNQYXR0ZXJuID0gUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybjtcblxuICAgIHZhciBhYnMgPSBNYXRoLmFicztcblxuICAgIHZhciBwYXRoUHJveHlGb3JEcmF3ID0gbmV3IFBhdGhQcm94eSh0cnVlKTtcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGF0aChvcHRzKSB7XG4gICAgICAgIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgIH1cblxuICAgIFBhdGgucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBQYXRoLFxuXG4gICAgICAgIHR5cGU6ICdwYXRoJyxcblxuICAgICAgICBfX2RpcnR5UGF0aDogdHJ1ZSxcblxuICAgICAgICBzdHJva2VDb250YWluVGhyZXNob2xkOiA1LFxuXG4gICAgICAgIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aCB8fCBwYXRoUHJveHlGb3JEcmF3O1xuICAgICAgICAgICAgdmFyIGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpO1xuICAgICAgICAgICAgdmFyIGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCk7XG4gICAgICAgICAgICB2YXIgZmlsbCA9IHN0eWxlLmZpbGw7XG4gICAgICAgICAgICB2YXIgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgICAgICAgICAgdmFyIGhhc0ZpbGxHcmFkaWVudCA9IGhhc0ZpbGwgJiYgISEoZmlsbC5jb2xvclN0b3BzKTtcbiAgICAgICAgICAgIHZhciBoYXNTdHJva2VHcmFkaWVudCA9IGhhc1N0cm9rZSAmJiAhIShzdHJva2UuY29sb3JTdG9wcyk7XG4gICAgICAgICAgICB2YXIgaGFzRmlsbFBhdHRlcm4gPSBoYXNGaWxsICYmICEhKGZpbGwuaW1hZ2UpO1xuICAgICAgICAgICAgdmFyIGhhc1N0cm9rZVBhdHRlcm4gPSBoYXNTdHJva2UgJiYgISEoc3Ryb2tlLmltYWdlKTtcblxuICAgICAgICAgICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3Q7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGdyYWRpZW50IGJlY2F1c2UgYm91bmRpbmcgcmVjdCBtYXkgY2hhbmdlZFxuICAgICAgICAgICAgICAgIGlmIChoYXNGaWxsR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHJlY3QgfHwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsbEdyYWRpZW50ID0gc3R5bGUuZ2V0R3JhZGllbnQoY3R4LCBmaWxsLCByZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc1N0cm9rZUdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSByZWN0IHx8IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0cm9rZUdyYWRpZW50ID0gc3R5bGUuZ2V0R3JhZGllbnQoY3R4LCBzdHJva2UsIHJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVzZSB0aGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuICAgICAgICAgICAgaWYgKGhhc0ZpbGxHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgSWYgbWF5IGhhdmUgYWZmZWN0IHRoZSBzdGF0ZVxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9maWxsR3JhZGllbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNGaWxsUGF0dGVybikge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoZmlsbCwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZUdyYWRpZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzU3Ryb2tlUGF0dGVybikge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGdldENhbnZhc1BhdHRlcm4uY2FsbChzdHJva2UsIGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsaW5lRGFzaCA9IHN0eWxlLmxpbmVEYXNoO1xuICAgICAgICAgICAgdmFyIGxpbmVEYXNoT2Zmc2V0ID0gc3R5bGUubGluZURhc2hPZmZzZXQ7XG5cbiAgICAgICAgICAgIHZhciBjdHhMaW5lRGFzaCA9ICEhY3R4LnNldExpbmVEYXNoO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgcGF0aCBzeCwgc3lcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICAgICAgICAgIHBhdGguc2V0U2NhbGUoc2NhbGVbMF0sIHNjYWxlWzFdKTtcblxuICAgICAgICAgICAgLy8gUHJveHkgY29udGV4dFxuICAgICAgICAgICAgLy8gUmVidWlsZCBwYXRoIGluIGZvbGxvd2luZyAyIGNhc2VzXG4gICAgICAgICAgICAvLyAxLiBQYXRoIGlzIGRpcnR5XG4gICAgICAgICAgICAvLyAyLiBQYXRoIG5lZWRzIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZURhc2ggc3Ryb2tpbmcuXG4gICAgICAgICAgICAvLyAgICBJbiB0aGlzIGNhc2UsIGxpbmVEYXNoIGluZm9ybWF0aW9uIHdpbGwgbm90IGJlIHNhdmVkIGluIFBhdGhQcm94eVxuICAgICAgICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGhcbiAgICAgICAgICAgICAgICB8fCAobGluZURhc2ggJiYgIWN0eExpbmVEYXNoICYmIGhhc1N0cm9rZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHBhdGguYmVnaW5QYXRoKGN0eCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIGxpbmUgZGFzaCBiZWZvcmUgYnVpbGQgcGF0aFxuICAgICAgICAgICAgICAgIGlmIChsaW5lRGFzaCAmJiAhY3R4TGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRMaW5lRGFzaChsaW5lRGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2V0TGluZURhc2hPZmZzZXQobGluZURhc2hPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRQYXRoKHBhdGgsIHRoaXMuc2hhcGUsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHBhdGggZGlydHkgZmxhZ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlcGxheSBwYXRoIGJ1aWxkaW5nXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aC5yZWJ1aWxkUGF0aChjdHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYXNGaWxsICYmIHBhdGguZmlsbChjdHgpO1xuXG4gICAgICAgICAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYXNTdHJva2UgJiYgcGF0aC5zdHJva2UoY3R4KTtcblxuICAgICAgICAgICAgaWYgKGxpbmVEYXNoICYmIGN0eExpbmVEYXNoKSB7XG4gICAgICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBsaW5lRGFzaFxuICAgICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgIC8vIERyYXcgcmVjdCB0ZXh0XG4gICAgICAgICAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBXaGVuIGJ1bmRsaW5nIHBhdGgsIHNvbWUgc2hhcGUgbWF5IGRlY2lkZSBpZiB1c2UgbW92ZVRvIHRvIGJlZ2luIGEgbmV3IHN1YnBhdGggb3IgY2xvc2VQYXRoXG4gICAgICAgIC8vIExpa2UgaW4gY2lyY2xlXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGVDZmcsIGluQnVuZGxlKSB7fSxcblxuICAgICAgICBjcmVhdGVQYXRoUHJveHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5fcmVjdDtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgbmVlZHNVcGRhdGVSZWN0ID0gIXJlY3Q7XG4gICAgICAgICAgICBpZiAobmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBwYXRoIG9uIGRlbWFuZC5cbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuXG4gICAgICAgICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkcyB1cGRhdGUgcmVjdCB3aXRoIHN0cm9rZSBsaW5lV2lkdGggd2hlblxuICAgICAgICAgICAgICAgIC8vIDEuIEVsZW1lbnQgY2hhbmdlcyBzY2FsZSBvciBsaW5lV2lkdGhcbiAgICAgICAgICAgICAgICAvLyAyLiBTaGFwZSBpcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgdmFyIHJlY3RXaXRoU3Ryb2tlID0gdGhpcy5fcmVjdFdpdGhTdHJva2UgfHwgKHRoaXMuX3JlY3RXaXRoU3Ryb2tlID0gcmVjdC5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5IHx8IG5lZWRzVXBkYXRlUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS5jb3B5KHJlY3QpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBNdXN0IGFmdGVyIHVwZGF0ZVRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUEVORElORywgTWluIGxpbmUgd2lkdGggaXMgbmVlZGVkIHdoZW4gbGluZSBpcyBob3Jpem9udGFsIG9yIHZlcnRpY2FsXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhZGQgZXh0cmEgaG92ZXIgbGluZVdpZHRoIHdoZW4gdGhlcmUgYXJlIG5vIGZpbGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSBNYXRoLm1heCh3LCB0aGlzLnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQgfHwgNCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgbGluZSB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIHNjYWxlIGNhbid0IGJlIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2Uud2lkdGggKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLmhlaWdodCArPSB3IC8gbGluZVNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2UueCAtPSB3IC8gbGluZVNjYWxlIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnkgLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gcmVjdCB3aXRoIHN0cm9rZVxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0V2l0aFN0cm9rZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbFBvcyA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHggPSBsb2NhbFBvc1swXTtcbiAgICAgICAgICAgIHkgPSBsb2NhbFBvc1sxXTtcblxuICAgICAgICAgICAgaWYgKHJlY3QuY29udGFpbih4LCB5KSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMucGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVNjYWxlID0gc3R5bGUuc3Ryb2tlTm9TY2FsZSA/IHRoaXMuZ2V0TGluZVNjYWxlKCkgOiAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIHNjYWxlIGNhbid0IGJlIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhZGQgZXh0cmEgaG92ZXIgbGluZVdpZHRoIHdoZW4gdGhlcmUgYXJlIG5vIGZpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoID0gTWF0aC5tYXgobGluZVdpZHRoLCB0aGlzLnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhDb250YWluLmNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aERhdGEsIGxpbmVXaWR0aCAvIGxpbmVTY2FsZSwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhDb250YWluLmNvbnRhaW4ocGF0aERhdGEsIHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gZGlydHlQYXRoXG4gICAgICAgICAqL1xuICAgICAgICBkaXJ0eTogZnVuY3Rpb24gKGRpcnR5UGF0aCkge1xuICAgICAgICAgICAgaWYgKGRpcnR5UGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlydHlQYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgbWFyayBkaXJ0eSwgbm90IG1hcmsgY2xlYW5cbiAgICAgICAgICAgIGlmIChkaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZGlydHlQYXRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcblxuICAgICAgICAgICAgLy8gVXNlZCBhcyBhIGNsaXBwaW5nIHBhdGhcbiAgICAgICAgICAgIGlmICh0aGlzLl9fY2xpcFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19jbGlwVGFyZ2V0LmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWFzIGZvciBhbmltYXRlKCdzaGFwZScpXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0ZVNoYXBlOiBmdW5jdGlvbiAobG9vcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgnc2hhcGUnLCBsb29wKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBPdmVyd3JpdGUgYXR0cktWXG4gICAgICAgIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnc2hhcGUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBEaXNwbGF5YWJsZS5wcm90b3R5cGUuYXR0cktWLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIHNldFNoYXBlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgIC8vIFBhdGggZnJvbSBzdHJpbmcgbWF5IG5vdCBoYXZlIHNoYXBlXG4gICAgICAgICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZVtuYW1lXSA9IGtleVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGluZVNjYWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBsaW5lIHNjYWxlLlxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5hbnQgb2YgYG1gIG1lYW5zIGhvdyBtdWNoIHRoZSBhcmVhIGlzIGVubGFyZ2VkIGJ5IHRoZVxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgICAgICAgICAgLy8gZm9yIHdpZHRoLlxuICAgICAgICAgICAgcmV0dXJuIG0gJiYgYWJzKG1bMF0gLSAxKSA+IDFlLTEwICYmIGFicyhtWzNdIC0gMSkgPiAxZS0xMFxuICAgICAgICAgICAgICAgID8gTWF0aC5zcXJ0KGFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKSlcbiAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5omp5bGV5LiA5LiqIFBhdGggZWxlbWVudCwg5q+U5aaC5pif5b2i77yM5ZyG562J44CCXG4gICAgICogRXh0ZW5kIGEgcGF0aCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BzLnR5cGUgUGF0aCB0eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuaW5pdCBJbml0aWFsaXplXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuYnVpbGRQYXRoIE92ZXJ3cml0ZSBidWlsZFBhdGggbWV0aG9kXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5zdHlsZV0gRXh0ZW5kZWQgZGVmYXVsdCBzdHlsZSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnNoYXBlXSBFeHRlbmRlZCBkZWZhdWx0IHNoYXBlIGNvbmZpZ1xuICAgICAqL1xuICAgIFBhdGguZXh0ZW5kID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBTdWIgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgUGF0aC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgICAgICBpZiAoZGVmYXVsdHMuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRlbmQgZGVmYXVsdCBzdHlsZVxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuZXh0ZW5kRnJvbShkZWZhdWx0cy5zdHlsZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFeHRlbmQgZGVmYXVsdCBzaGFwZVxuICAgICAgICAgICAgdmFyIGRlZmF1bHRTaGFwZSA9IGRlZmF1bHRzLnNoYXBlO1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRTaGFwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSB0aGlzLnNoYXBlIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciB0aGlzU2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdFNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICEgdGhpc1NoYXBlLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBkZWZhdWx0U2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzU2hhcGVbbmFtZV0gPSBkZWZhdWx0U2hhcGVbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHRzLmluaXQgJiYgZGVmYXVsdHMuaW5pdC5jYWxsKHRoaXMsIG9wdHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHpyVXRpbC5pbmhlcml0cyhTdWIsIFBhdGgpO1xuXG4gICAgICAgIC8vIEZJWE1FIOS4jeiDvSBleHRlbmQgcG9zaXRpb24sIHJvdGF0aW9uIOetieW8leeUqOWvueixoVxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICAvLyBFeHRlbmRpbmcgcHJvdG90eXBlIHZhbHVlcyBhbmQgbWV0aG9kc1xuICAgICAgICAgICAgaWYgKG5hbWUgIT09ICdzdHlsZScgJiYgbmFtZSAhPT0gJ3NoYXBlJykge1xuICAgICAgICAgICAgICAgIFN1Yi5wcm90b3R5cGVbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBTdWI7XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhQYXRoLCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhdGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("/**\n * 可绘制的图形基类\n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = __webpack_require__(20);\n\n    var Style = __webpack_require__(38);\n\n    var Element = __webpack_require__(39);\n    var RectText = __webpack_require__(51);\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * z层level，决定绘画在哪层canvas中\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * 是否可拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * 是否正在拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * 是否相应鼠标事件\n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * 图形绘制方法\n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * 获取最小包围盒\n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         * 判断坐标 x, y 是否在图形上\n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         * 判断坐标 x, y 是否在图形的包围盒上\n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * 标记图形元素为脏，并且在下一帧重绘\n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * 图形是否会触发事件\n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO, 通过 bind 绑定的事件\n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanM/NWM0NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUEsc0NBQXNDOztBQUV0QyxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQkFBb0IsU0FBUztBQUM3QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakMsbUJBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIOWPr+e7mOWItueahOWbvuW9ouWfuuexu1xuICogQmFzZSBjbGFzcyBvZiBhbGwgZGlzcGxheWFibGUgZ3JhcGhpYyBvYmplY3RzXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICovXG5cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIFN0eWxlID0gcmVxdWlyZSgnLi9TdHlsZScpO1xuXG4gICAgdmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuLi9FbGVtZW50Jyk7XG4gICAgdmFyIFJlY3RUZXh0ID0gcmVxdWlyZSgnLi9taXhpbi9SZWN0VGV4dCcpO1xuICAgIC8vIHZhciBTdGF0ZWZ1bCA9IHJlcXVpcmUoJy4vbWl4aW4vU3RhdGVmdWwnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvbWl4aW4vUmVjdFRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEaXNwbGF5YWJsZShvcHRzKSB7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgRWxlbWVudC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIC8vIEV4dGVuZCBwcm9wZXJ0aWVzXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gb3B0cykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG9wdHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICAgICAgICBuYW1lICE9PSAnc3R5bGUnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gb3B0c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob3B0cy5zdHlsZSk7XG5cbiAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgICAgIC8vIFNoYXBlcyBmb3IgY2FzY2FkZSBjbGlwcGluZy5cbiAgICAgICAgdGhpcy5fX2NsaXBQYXRocyA9IFtdO1xuXG4gICAgICAgIC8vIEZJWE1FIFN0YXRlZnVsIG11c3QgYmUgbWl4aW5lZCBhZnRlciBzdHlsZSBpcyBzZXR0ZWRcbiAgICAgICAgLy8gU3RhdGVmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB9XG5cbiAgICBEaXNwbGF5YWJsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IERpc3BsYXlhYmxlLFxuXG4gICAgICAgIHR5cGU6ICdkaXNwbGF5YWJsZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXlhYmxlIOaYr+WQpuS4uuiEj++8jFBhaW50ZXIg5Lit5Lya5qC55o2u6K+l5qCH6K6w5Yik5pat5piv5ZCm6ZyA6KaB5piv5ZCm6ZyA6KaB6YeN5paw57uY5Yi2XG4gICAgICAgICAqIERpcnR5IGZsYWcuIEZyb20gd2hpY2ggcGFpbnRlciB3aWxsIGRldGVybWluZSBpZiB0aGlzIGRpc3BsYXlhYmxlIG9iamVjdCBuZWVkcyBicnVzaFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI19fZGlydHlcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfX2RpcnR5OiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlm77lvaLmmK/lkKblj6/op4HvvIzkuLp0cnVl5pe25LiN57uY5Yi25Zu+5b2i77yM5L2G5piv5LuN6IO96Kem5Y+R6byg5qCH5LqL5Lu2XG4gICAgICAgICAqIElmIGlnbm9yZSBkcmF3aW5nIG9mIHRoZSBkaXNwbGF5YWJsZSBvYmplY3QuIE1vdXNlIGV2ZW50IHdpbGwgc3RpbGwgYmUgdHJpZ2dlcmVkXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2ludmlzaWJsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGludmlzaWJsZTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgejogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjelxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB6MjogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogeuWxgmxldmVs77yM5Yaz5a6a57uY55S75Zyo5ZOq5bGCY2FudmFz5LitXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3psZXZlbFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB6bGV2ZWw6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuWPr+aLluaLvVxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNkcmFnZ2FibGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbmraPlnKjmi5bmi71cbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbnm7jlupTpvKDmoIfkuovku7ZcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjc2lsZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lsZW50OiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZW5hYmxlIGN1bGxpbmdcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBjdWxsaW5nOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW91c2UgY3Vyc29yIHdoZW4gaG92ZXJlZFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNjdXJzb3JcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBob3ZlciBhcmVhIGlzIGJvdW5kaW5nIHJlY3RcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjcmVjdEhvdmVyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICByZWN0SG92ZXI6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIGVsZW1lbnQgcHJvZ3Jlc3NpdmVseSB3aGVuIHRoZSB2YWx1ZSA+PSAwLFxuICAgICAgICAgKiB1c2VmdWxsIGZvciBsYXJnZSBkYXRhLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvZ3Jlc3NpdmU6IC0xLFxuXG4gICAgICAgIGJlZm9yZUJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcblxuICAgICAgICBhZnRlckJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i57uY5Yi25pa55rOVXG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzMkRSZW5kZXJpbmdDb250ZXh0fSBjdHhcbiAgICAgICAgICovXG4gICAgICAgIC8vIEludGVyZmFjZVxuICAgICAgICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5pyA5bCP5YyF5Zu055uSXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gSW50ZXJmYWNlXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIpOaWreWdkOaghyB4LCB5IOaYr+WQpuWcqOWbvuW9ouS4ilxuICAgICAgICAgKiBJZiBkaXNwbGF5YWJsZSBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjdENvbnRhaW4oeCwgeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yik5pat5Z2Q5qCHIHgsIHkg5piv5ZCm5Zyo5Zu+5b2i55qE5YyF5Zu055uS5LiKXG4gICAgICAgICAqIElmIGJvdW5kaW5nIHJlY3Qgb2YgZWxlbWVudCBjb250YWluIGNvb3JkIHgsIHlcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgcmVjdENvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgY29vcmQgPSB0aGlzLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCh4LCB5KTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0LmNvbnRhaW4oY29vcmRbMF0sIGNvb3JkWzFdKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5qCH6K6w5Zu+5b2i5YWD57Sg5Li66ISP77yM5bm25LiU5Zyo5LiL5LiA5bin6YeN57uYXG4gICAgICAgICAqIE1hcmsgZGlzcGxheWFibGUgZWxlbWVudCBkaXJ0eSBhbmQgcmVmcmVzaCBuZXh0IGZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICBkaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG5cbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlm77lvaLmmK/lkKbkvJrop6blj5Hkuovku7ZcbiAgICAgICAgICogSWYgZGlzcGxheWFibGUgb2JqZWN0IGJpbmRlZCBhbnkgZXZlbnRcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE8sIOmAmui/hyBiaW5kIOe7keWumueahOS6i+S7tlxuICAgICAgICAvLyBpc1NpbGVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAgICAgcmV0dXJuICEoXG4gICAgICAgIC8vICAgICAgICAgdGhpcy5ob3ZlcmFibGUgfHwgdGhpcy5kcmFnZ2FibGVcbiAgICAgICAgLy8gICAgICAgICB8fCB0aGlzLm9ubW91c2Vtb3ZlIHx8IHRoaXMub25tb3VzZW92ZXIgfHwgdGhpcy5vbm1vdXNlb3V0XG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlZG93biB8fCB0aGlzLm9ubW91c2V1cCB8fCB0aGlzLm9uY2xpY2tcbiAgICAgICAgLy8gICAgICAgICB8fCB0aGlzLm9uZHJhZ2VudGVyIHx8IHRoaXMub25kcmFnb3ZlciB8fCB0aGlzLm9uZHJhZ2xlYXZlXG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbmRyb3BcbiAgICAgICAgLy8gICAgICk7XG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc3R5bGUnKVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGVTdHlsZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoJ3N0eWxlJywgbG9vcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgIEVsZW1lbnQucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5zZXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBzZXRTdHlsZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIGdpdmVuIHN0eWxlIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9ialxuICAgICAgICAgKi9cbiAgICAgICAgdXNlU3R5bGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob2JqKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKERpc3BsYXlhYmxlLCBFbGVtZW50KTtcblxuICAgIHpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgUmVjdFRleHQpO1xuICAgIC8vIHpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgU3RhdGVmdWwpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEaXNwbGF5YWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0Rpc3BsYXlhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        var x = obj.x == null ? 0 : obj.x;\n        var x2 = obj.x2 == null ? 1 : obj.x2;\n        var y = obj.y == null ? 0 : obj.y;\n        var y2 = obj.y2 == null ? 0 : obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x == null ? 0.5 : obj.x;\n        var y = obj.y == null ? 0.5 : obj.y;\n        var r = obj.r == null ? 0.5 : obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * If not specified, use the boundingRect of a `displayable`.\n         * @type {Object}\n         */\n        textPositionRect: null,\n\n        /**\n         * [x, y]\n         * @type {Array.<number>}\n         */\n        textOffset: null,\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvU3R5bGUuanM/MjJkOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLCtCQUErQjtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDLG1CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6IjM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9TdHlsZVxuICovXG5cblxuICAgIHZhciBTVFlMRV9DT01NT05fUFJPUFMgPSBbXG4gICAgICAgIFsnc2hhZG93Qmx1cicsIDBdLCBbJ3NoYWRvd09mZnNldFgnLCAwXSwgWydzaGFkb3dPZmZzZXRZJywgMF0sIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLFxuICAgICAgICBbJ2xpbmVDYXAnLCAnYnV0dCddLCBbJ2xpbmVKb2luJywgJ21pdGVyJ10sIFsnbWl0ZXJMaW1pdCcsIDEwXVxuICAgIF07XG5cbiAgICAvLyB2YXIgU0hBRE9XX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDAsIDQpO1xuICAgIC8vIHZhciBMSU5FX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDQpO1xuXG4gICAgdmFyIFN0eWxlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgdGhpcy5leHRlbmRGcm9tKG9wdHMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMaW5lYXJHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICAgICAgICB2YXIgeCA9IG9iai54ID09IG51bGwgPyAwIDogb2JqLng7XG4gICAgICAgIHZhciB4MiA9IG9iai54MiA9PSBudWxsID8gMSA6IG9iai54MjtcbiAgICAgICAgdmFyIHkgPSBvYmoueSA9PSBudWxsID8gMCA6IG9iai55O1xuICAgICAgICB2YXIgeTIgPSBvYmoueTIgPT0gbnVsbCA/IDAgOiBvYmoueTI7XG5cbiAgICAgICAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgICAgICAgICB4ID0geCAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgICAgICAgICB4MiA9IHgyICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICAgICAgICAgIHkgPSB5ICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgICAgICB5MiA9IHkyICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeDIsIHkyKTtcblxuICAgICAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmFkaWFsR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgdmFyIHggPSBvYmoueCA9PSBudWxsID8gMC41IDogb2JqLng7XG4gICAgICAgIHZhciB5ID0gb2JqLnkgPT0gbnVsbCA/IDAuNSA6IG9iai55O1xuICAgICAgICB2YXIgciA9IG9iai5yID09IG51bGwgPyAwLjUgOiBvYmoucjtcbiAgICAgICAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgICAgICAgICB4ID0geCAqIHdpZHRoICsgcmVjdC54O1xuICAgICAgICAgICAgeSA9IHkgKiBoZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgICAgICByID0gciAqIG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4LCB5LCAwLCB4LCB5LCByKTtcblxuICAgICAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gICAgfVxuXG5cbiAgICBTdHlsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFN0eWxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsbDogJyMwMDAwMDAnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgc3Ryb2tlOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgb3BhY2l0eTogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgbGluZURhc2g6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsaW5lRGFzaE9mZnNldDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNoYWRvd0JsdXI6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBzaGFkb3dPZmZzZXRYOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2hhZG93T2Zmc2V0WTogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpbmVXaWR0aDogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc3Ryb2tlIGlnbm9yZSBzY2FsZVxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHN0cm9rZU5vU2NhbGU6IGZhbHNlLFxuXG4gICAgICAgIC8vIEJvdW5kaW5nIHJlY3QgdGV4dCBjb25maWd1cmF0aW9uXG4gICAgICAgIC8vIE5vdCBhZmZlY3RlZCBieSBlbGVtZW50IHRyYW5zZm9ybVxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0RmlsbDogJyMwMDAnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFN0cm9rZTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogJ2luc2lkZScsICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXG4gICAgICAgICAqIFt4LCB5XVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfEFycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAZGVmYXVsdCAnaW5zaWRlJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFBvc2l0aW9uOiAnaW5zaWRlJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbm90IHNwZWNpZmllZCwgdXNlIHRoZSBib3VuZGluZ1JlY3Qgb2YgYSBgZGlzcGxheWFibGVgLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFBvc2l0aW9uUmVjdDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogW3gsIHldXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRPZmZzZXQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0QmFzZWxpbmU6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0QWxpZ246IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dERpc3RhbmNlOiA1LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0U2hhZG93Qmx1cjogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFNoYWRvd09mZnNldFg6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRTaGFkb3dPZmZzZXRZOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cmFuc2Zvcm0gdGV4dFxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFRyYW5zZm9ybTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRleHQgcm90YXRlIGFyb3VuZCBwb3NpdGlvbiBvZiBQYXRoIG9yIEltYWdlXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnQgYW5kIHRleHRUcmFuc2Zvcm0gaXMgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0Um90YXRpb246IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBibGVuZDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDogZnVuY3Rpb24gKGN0eCwgZWwsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcztcbiAgICAgICAgICAgIHZhciBwcmV2U3R5bGUgPSBwcmV2RWwgJiYgcHJldkVsLnN0eWxlO1xuICAgICAgICAgICAgdmFyIGZpcnN0RHJhdyA9ICFwcmV2U3R5bGU7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU1RZTEVfQ09NTU9OX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBTVFlMRV9DT01NT05fUFJPUFNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlTmFtZSA9IHByb3BbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlW3N0eWxlTmFtZV0gIT09IHByZXZTdHlsZVtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIEludmFsaWQgcHJvcGVydHkgdmFsdWUgd2lsbCBjYXVzZSBzdHlsZSBsZWFrIGZyb20gcHJldmlvdXMgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgY3R4W3N0eWxlTmFtZV0gPSBzdHlsZVtzdHlsZU5hbWVdIHx8IHByb3BbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGZpcnN0RHJhdyB8fCBzdHlsZS5maWxsICE9PSBwcmV2U3R5bGUuZmlsbCkpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuZmlsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZmlyc3REcmF3IHx8IHN0eWxlLnN0cm9rZSAhPT0gcHJldlN0eWxlLnN0cm9rZSkpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5zdHJva2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGZpcnN0RHJhdyB8fCBzdHlsZS5vcGFjaXR5ICE9PSBwcmV2U3R5bGUub3BhY2l0eSkpIHtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzdHlsZS5vcGFjaXR5ID09IG51bGwgPyAxIDogc3R5bGUub3BhY2l0eTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChmaXJzdERyYXcgfHwgc3R5bGUuYmxlbmQgIT09IHByZXZTdHlsZS5ibGVuZCkpIHtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gc3R5bGUuYmxlbmQgfHwgJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoIC8gKFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5zdHJva2VOb1NjYWxlICYmIGVsICYmIGVsLmdldExpbmVTY2FsZSkgPyBlbC5nZXRMaW5lU2NhbGUoKSA6IDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhhc0ZpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmaWxsID0gdGhpcy5maWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGwgIT0gbnVsbCAmJiBmaWxsICE9PSAnbm9uZSc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzU3Ryb2tlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3Ryb2tlID0gdGhpcy5zdHJva2U7XG4gICAgICAgICAgICByZXR1cm4gc3Ryb2tlICE9IG51bGwgJiYgc3Ryb2tlICE9PSAnbm9uZScgJiYgdGhpcy5saW5lV2lkdGggPiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRlbmQgZnJvbSBvdGhlciBzdHlsZVxuICAgICAgICAgKiBAcGFyYW0ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gb3RoZXJTdHlsZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJ3cml0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZXh0ZW5kRnJvbTogZnVuY3Rpb24gKG90aGVyU3R5bGUsIG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgaWYgKG90aGVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG90aGVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyU3R5bGUuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChvdmVyd3JpdGUgfHwgISB0YXJnZXQuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gb3RoZXJTdHlsZVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQmF0Y2ggc2V0dGluZyBzdHlsZSB3aXRoIGEgZ2l2ZW4gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gb2JqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29ial1cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG9iaiwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXNbb2JqXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRGcm9tKG9iaiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb25lXG4gICAgICAgICAqIEByZXR1cm4ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdTdHlsZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgICBuZXdTdHlsZS5leHRlbmRGcm9tKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1N0eWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEdyYWRpZW50OiBmdW5jdGlvbiAoY3R4LCBvYmosIHJlY3QpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBvYmoudHlwZSA9PT0gJ3JhZGlhbCcgPyBjcmVhdGVSYWRpYWxHcmFkaWVudCA6IGNyZWF0ZUxpbmVhckdyYWRpZW50O1xuICAgICAgICAgICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gbWV0aG9kKGN0eCwgb2JqLCByZWN0KTtcbiAgICAgICAgICAgIHZhciBjb2xvclN0b3BzID0gb2JqLmNvbG9yU3RvcHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yU3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3AoXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yU3RvcHNbaV0ub2Zmc2V0LCBjb2xvclN0b3BzW2ldLmNvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW52YXNHcmFkaWVudDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3R5bGVQcm90byA9IFN0eWxlLnByb3RvdHlwZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IFNUWUxFX0NPTU1PTl9QUk9QU1tpXTtcbiAgICAgICAgaWYgKCEocHJvcFswXSBpbiBzdHlsZVByb3RvKSkge1xuICAgICAgICAgICAgc3R5bGVQcm90b1twcm9wWzBdXSA9IHByb3BbMV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm92aWRlIGZvciBvdGhlcnNcbiAgICBTdHlsZS5nZXRHcmFkaWVudCA9IHN0eWxlUHJvdG8uZ2V0R3JhZGllbnQ7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFN0eWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvU3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = __webpack_require__(40);\n    var Eventful = __webpack_require__(41);\n    var Transformable = __webpack_require__(42);\n    var Animatable = __webpack_require__(43);\n    var zrUtil = __webpack_require__(20);\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * 画布元素ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * 元素类型\n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * 元素名字\n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n         * 该路径会继承被裁减对象的变换\n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // 添加动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // 移除动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL0VsZW1lbnQuanM/MzI1YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IscUJBQXFCO0FBQ3JCO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDLG1CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvRWxlbWVudFxuICovXG5cblxuICAgIHZhciBndWlkID0gcmVxdWlyZSgnLi9jb3JlL2d1aWQnKTtcbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuL21peGluL0V2ZW50ZnVsJyk7XG4gICAgdmFyIFRyYW5zZm9ybWFibGUgPSByZXF1aXJlKCcuL21peGluL1RyYW5zZm9ybWFibGUnKTtcbiAgICB2YXIgQW5pbWF0YWJsZSA9IHJlcXVpcmUoJy4vbWl4aW4vQW5pbWF0YWJsZScpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZX1cbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX1cbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWx9XG4gICAgICovXG4gICAgdmFyIEVsZW1lbnQgPSBmdW5jdGlvbiAob3B0cykge1xuXG4gICAgICAgIFRyYW5zZm9ybWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgQW5pbWF0YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnlLvluIPlhYPntKBJRFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG9wdHMuaWQgfHwgZ3VpZCgpO1xuICAgIH07XG5cbiAgICBFbGVtZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICog5YWD57Sg57G75Z6LXG4gICAgICAgICAqIEVsZW1lbnQgdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2VsZW1lbnQnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlhYPntKDlkI3lrZdcbiAgICAgICAgICogRWxlbWVudCBuYW1lXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBuYW1lOiAnJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogWlJlbmRlciDlrp7kvovlr7nosaHvvIzkvJrlnKggZWxlbWVudCDmt7vliqDliLAgenJlbmRlciDlrp7kvovkuK3lkI7oh6rliqjotYvlgLxcbiAgICAgICAgICogWlJlbmRlciBpbnN0YW5jZSB3aWxsIGJlIGFzc2lnbmVkIHdoZW4gZWxlbWVudCBpcyBhc3NvY2lhdGVkIHdpdGggenJlbmRlclxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNfX3pyXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX196cjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i5piv5ZCm5b+955Wl77yM5Li6dHJ1ZeaXtuW/veeVpeWbvuW9oueahOe7mOWItuS7peWPiuS6i+S7tuinpuWPkVxuICAgICAgICAgKiBJZiBpZ25vcmUgZHJhd2luZyBhbmQgZXZlbnRzIG9mIHRoZSBlbGVtZW50IG9iamVjdFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNpZ25vcmVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpZ25vcmU6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnlKjkuo7oo4HliarnmoTot6/lvoQoc2hhcGUp77yM5omA5pyJIEdyb3VwIOWGheeahOi3r+W+hOWcqOe7mOWItuaXtumDveS8muiiq+i/meS4qui3r+W+hOijgeWJqlxuICAgICAgICAgKiDor6Xot6/lvoTkvJrnu6fmib/ooqvoo4Hlh4/lr7nosaHnmoTlj5jmjaJcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH1cbiAgICAgICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvI2NsaXBwaW5nLXJlZ2lvblxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGNsaXBQYXRoOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmlmdCBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gZHggZHggb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR5IGR5IG9uIHRoZSBnbG9iYWwgc3BhY2VcbiAgICAgICAgICovXG4gICAgICAgIGRyaWZ0OiBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICAgICAgICAgICAgICAgIGR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgICAgICAgICAgICBkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgbSA9IHRoaXMudHJhbnNmb3JtID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbVs0XSArPSBkeDtcbiAgICAgICAgICAgIG1bNV0gKz0gZHk7XG5cbiAgICAgICAgICAgIHRoaXMuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSG9vayBiZWZvcmUgdXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSG9vayBhZnRlciB1cGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyVXBkYXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBlYWNoIGZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicgfHwga2V5ID09PSAnc2NhbGUnIHx8IGtleSA9PT0gJ29yaWdpbicpIHtcbiAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBhcnJheVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpc1trZXldID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WzBdID0gdmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFsxXSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIHRoZSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pZ25vcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBhdHRyOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyS1Yoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cktWKG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGNsaXBQYXRoXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDbGlwUGF0aDogZnVuY3Rpb24gKGNsaXBQYXRoKSB7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgICAgICAgICBpZiAoenIpIHtcbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBjbGlwIHBhdGhcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBQYXRoICYmIHRoaXMuY2xpcFBhdGggIT09IGNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDbGlwUGF0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNsaXBQYXRoID0gY2xpcFBhdGg7XG4gICAgICAgICAgICBjbGlwUGF0aC5fX3pyID0genI7XG4gICAgICAgICAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNsaXBQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsaXBQYXRoLl9fenIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcFBhdGgucmVtb3ZlU2VsZkZyb21acihjbGlwUGF0aC5fX3pyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5fX3pyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpcFBhdGggPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICAgICAgICogTm90IHJlY3Vyc2l2ZWx5IGJlY2F1c2UgaXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWxlbWVudCBhZGRlZCB0byBzdG9yYWdlLlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAgICAgICAqL1xuICAgICAgICBhZGRTZWxmVG9acjogZnVuY3Rpb24gKHpyKSB7XG4gICAgICAgICAgICB0aGlzLl9fenIgPSB6cjtcbiAgICAgICAgICAgIC8vIOa3u+WKoOWKqOeUu1xuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgICAgICAgICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHpyLmFuaW1hdGlvbi5hZGRBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHNlbGYgZnJvbSB6cmVuZGVyIGluc3RhbmNlLlxuICAgICAgICAgKiBOb3QgcmVjdXJzaXZlbHkgYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgd2hlbiBlbGVtZW50IGFkZGVkIHRvIHN0b3JhZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZVNlbGZGcm9tWnI6IGZ1bmN0aW9uICh6cikge1xuICAgICAgICAgICAgdGhpcy5fX3pyID0gbnVsbDtcbiAgICAgICAgICAgIC8vIOenu+mZpOWKqOeUu1xuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgICAgICAgICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHpyLmFuaW1hdGlvbi5yZW1vdmVBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoenIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5taXhpbihFbGVtZW50LCBBbmltYXRhYmxlKTtcbiAgICB6clV0aWwubWl4aW4oRWxlbWVudCwgVHJhbnNmb3JtYWJsZSk7XG4gICAgenJVdGlsLm1peGluKEVsZW1lbnQsIEV2ZW50ZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gRWxlbWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9FbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("/**\n * zrender: 生成唯一id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qcz9mMGU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI0MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogenJlbmRlcjog55Sf5oiQ5ZSv5LiAaWRcbiAqXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4gICAgdmFyIGlkU3RhcnQgPSAweDA5MDc7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlkU3RhcnQrKztcbiAgICB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9ndWlkLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("/**\n * 事件扩展\n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * 事件分发器\n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * 单次触发绑定，trigger后销毁\n         *\n         * @param {string} event 事件名\n         * @param {Function} handler 响应函数\n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 绑定事件\n         * @param {string} event 事件名\n         * @param {Function} handler 事件处理函数\n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 是否绑定了事件\n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * 解绑事件\n         * @param {string} event 事件名\n         * @param {Function} [handler] 事件处理函数\n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * 事件分发\n         *\n         * @param {string} type 事件类型\n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * 带有context的事件分发, 最后一个参数是事件回调的context\n         * @param {string} type 事件类型\n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    // 对象可以通过 onxxxx 绑定事件\n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsLmpzPzIyM2IiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQSIsImZpbGUiOiI0MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog5LqL5Lu25omp5bGVXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIGFycnlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qKlxuICAgICAqIOS6i+S7tuWIhuWPkeWZqFxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBFdmVudGZ1bCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgfTtcblxuICAgIEV2ZW50ZnVsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogRXZlbnRmdWwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWNleasoeinpuWPkee7keWumu+8jHRyaWdnZXLlkI7plIDmr4FcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOWTjeW6lOWHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgb25lOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIV9oW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIF9oW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9oW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF1baV0uaCA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9oW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICAgICAgICBoOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjdHg6IGNvbnRleHQgfHwgdGhpc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnu5Hlrprkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAgICAgICAqL1xuICAgICAgICBvbjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICAgICAgICAgIGlmICghaGFuZGxlciB8fCAhZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFfaFtldmVudF0pIHtcbiAgICAgICAgICAgICAgICBfaFtldmVudF0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaFtldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgaDogaGFuZGxlcixcbiAgICAgICAgICAgICAgICBvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGN0eDogY29udGV4dCB8fCB0aGlzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpue7keWumuS6huS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBldmVudFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNTaWxlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuICAgICAgICAgICAgcmV0dXJuIF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDop6Pnu5Hkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0g5LqL5Lu25aSE55CG5Ye95pWwXG4gICAgICAgICAqL1xuICAgICAgICBvZmY6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9oW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9oW2V2ZW50XS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF1baV1bJ2gnXSAhPSBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlzdC5wdXNoKF9oW2V2ZW50XVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2hbZXZlbnRdID0gbmV3TGlzdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgX2hbZXZlbnRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5LqL5Lu25YiG5Y+RXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl8kaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnTGVuID4gMykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShfaFtpXVsnY3R4J10sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDluKbmnIljb250ZXh055qE5LqL5Lu25YiG5Y+RLCDmnIDlkI7kuIDkuKrlj4LmlbDmmK/kuovku7blm57osIPnmoRjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcldpdGhDb250ZXh0OiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuXyRoYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdMZW4gPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIOWvueixoeWPr+S7pemAmui/hyBvbnh4eHgg57uR5a6a5LqL5Lu2XG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uY2xpY2tcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3ZlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdXRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlbW92ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V3aGVlbFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2Vkb3duXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZXVwXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnc3RhcnRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbmRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbnRlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2xlYXZlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnb3ZlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJvcFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50ZnVsO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("'use strict';\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = __webpack_require__(27);\n    var vector = __webpack_require__(26);\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * 平移\n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * 旋转\n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * 缩放\n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * 旋转和缩放的原点\n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * 判断是否需要有坐标变换\n     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // 应用父节点变换\n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // 保存这个变换矩阵\n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        return Transformable.getLocalTransform(this, m);\n    };\n\n    /**\n     * 将自己的transform应用到context上\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    };\n\n    var tmpTransform = [];\n\n    /**\n     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     * 变换坐标位置到 shape 的局部坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * 变换局部坐标位置到全局坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    /**\n     * @static\n     * @param {Object} target\n     * @param {Array.<number>} target.origin\n     * @param {number} target.rotation\n     * @param {Array.<number>} target.position\n     * @param {Array.<number>} [m]\n     */\n    Transformable.getLocalTransform = function (target, m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = target.origin;\n        var scale = target.scale || [1, 1];\n        var rotation = target.rotation || 0;\n        var position = target.position || [0, 0];\n\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n\n    module.exports = Transformable;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL1RyYW5zZm9ybWFibGUuanM/ZjYxYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZUFBZTtBQUM5QixlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiI0Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog5o+Q5L6b5Y+Y5o2i5omp5bGVXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJy4uL2NvcmUvbWF0cml4Jyk7XG4gICAgdmFyIHZlY3RvciA9IHJlcXVpcmUoJy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIG1JZGVudGl0eSA9IG1hdHJpeC5pZGVudGl0eTtcblxuICAgIHZhciBFUFNJTE9OID0gNWUtNTtcblxuICAgIGZ1bmN0aW9uIGlzTm90QXJvdW5kWmVybyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+IEVQU0lMT04gfHwgdmFsIDwgLUVQU0lMT047XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgVHJhbnNmb3JtYWJsZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZ2l2ZW4gcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZVxuICAgICAgICBpZiAoIW9wdHMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5bmz56e7XG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCBbMCwgMF1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFswLCAwXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5yb3RhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOaXi+i9rFxuICAgICAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdHMuc2NhbGUpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog57yp5pS+XG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCBbMSwgMV1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IFsxLCAxXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICog5peL6L2s5ZKM57yp5pS+55qE5Y6f54K5XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLm9yaWdpbiB8fCBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgdHJhbnNmb3JtYWJsZVByb3RvID0gVHJhbnNmb3JtYWJsZS5wcm90b3R5cGU7XG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiDliKTmlq3mmK/lkKbpnIDopoHmnInlnZDmoIflj5jmjaJcbiAgICAgKiDlpoLmnpzmnInlnZDmoIflj5jmjaIsIOWImeS7jnBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGXku6Xlj4rniLboioLngrnnmoR0cmFuc2Zvcm3orqHnrpflh7roh6rouqvnmoR0cmFuc2Zvcm3nn6npmLVcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8ubmVlZExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaXNOb3RBcm91bmRaZXJvKHRoaXMucm90YXRpb24pXG4gICAgICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5wb3NpdGlvblswXSlcbiAgICAgICAgICAgIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzFdKVxuICAgICAgICAgICAgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMuc2NhbGVbMF0gLSAxKVxuICAgICAgICAgICAgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMuc2NhbGVbMV0gLSAxKTtcbiAgICB9O1xuXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgcGFyZW50SGFzVHJhbnNmb3JtID0gcGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm07XG4gICAgICAgIHZhciBuZWVkTG9jYWxUcmFuc2Zvcm0gPSB0aGlzLm5lZWRMb2NhbFRyYW5zZm9ybSgpO1xuXG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmICghKG5lZWRMb2NhbFRyYW5zZm9ybSB8fCBwYXJlbnRIYXNUcmFuc2Zvcm0pKSB7XG4gICAgICAgICAgICBtICYmIG1JZGVudGl0eShtKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG0gPSBtIHx8IG1hdHJpeC5jcmVhdGUoKTtcblxuICAgICAgICBpZiAobmVlZExvY2FsVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB0aGlzLmdldExvY2FsVHJhbnNmb3JtKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbUlkZW50aXR5KG0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5bqU55So54i26IqC54K55Y+Y5o2iXG4gICAgICAgIGlmIChwYXJlbnRIYXNUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBtYXRyaXgubXVsKG0sIHBhcmVudC50cmFuc2Zvcm0sIG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0cml4LmNvcHkobSwgcGFyZW50LnRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8g5L+d5a2Y6L+Z5Liq5Y+Y5o2i55+p6Zi1XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbTtcblxuICAgICAgICB0aGlzLmludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtIHx8IG1hdHJpeC5jcmVhdGUoKTtcbiAgICAgICAgbWF0cml4LmludmVydCh0aGlzLmludlRyYW5zZm9ybSwgbSk7XG4gICAgfTtcblxuICAgIHRyYW5zZm9ybWFibGVQcm90by5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtKHRoaXMsIG0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDlsIboh6rlt7HnmoR0cmFuc2Zvcm3lupTnlKjliLBjb250ZXh05LiKXG4gICAgICogQHBhcmFtIHtDb250ZXh0MkR9IGN0eFxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKGRwciAqIG1bMF0sIGRwciAqIG1bMV0sIGRwciAqIG1bMl0sIGRwciAqIG1bM10sIGRwciAqIG1bNF0sIGRwciAqIG1bNV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybShkcHIsIDAsIDAsIGRwciwgMCwgMCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnJlc3RvcmVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xuICAgIH07XG5cbiAgICB2YXIgdG1wVHJhbnNmb3JtID0gW107XG5cbiAgICAvKipcbiAgICAgKiDliIbop6NgdHJhbnNmb3JtYOefqemYteWIsGBwb3NpdGlvbmAsIGByb3RhdGlvbmAsIGBzY2FsZWBcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8uZGVjb21wb3NlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEdldCBsb2NhbCB0cmFuc2Zvcm0gYW5kIGRlY29tcG9zZSB0aGVtIHRvIHBvc2l0aW9uLCBzY2FsZSwgcm90YXRpb25cbiAgICAgICAgICAgIG1hdHJpeC5tdWwodG1wVHJhbnNmb3JtLCBwYXJlbnQuaW52VHJhbnNmb3JtLCBtKTtcbiAgICAgICAgICAgIG0gPSB0bXBUcmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN4ID0gbVswXSAqIG1bMF0gKyBtWzFdICogbVsxXTtcbiAgICAgICAgdmFyIHN5ID0gbVsyXSAqIG1bMl0gKyBtWzNdICogbVszXTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhzeCAtIDEpKSB7XG4gICAgICAgICAgICBzeCA9IE1hdGguc3FydChzeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhzeSAtIDEpKSB7XG4gICAgICAgICAgICBzeSA9IE1hdGguc3FydChzeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1bMF0gPCAwKSB7XG4gICAgICAgICAgICBzeCA9IC1zeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobVszXSA8IDApIHtcbiAgICAgICAgICAgIHN5ID0gLXN5O1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9uWzBdID0gbVs0XTtcbiAgICAgICAgcG9zaXRpb25bMV0gPSBtWzVdO1xuICAgICAgICBzY2FsZVswXSA9IHN4O1xuICAgICAgICBzY2FsZVsxXSA9IHN5O1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gTWF0aC5hdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZ2xvYmFsIHNjYWxlXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLmdldEdsb2JhbFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBbMSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN4ID0gTWF0aC5zcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICB2YXIgc3kgPSBNYXRoLnNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICAgIGlmIChtWzBdIDwgMCkge1xuICAgICAgICAgICAgc3ggPSAtc3g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1bM10gPCAwKSB7XG4gICAgICAgICAgICBzeSA9IC1zeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3N4LCBzeV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDlj5jmjaLlnZDmoIfkvY3nva7liLAgc2hhcGUg55qE5bGA6YOo5Z2Q5qCH56m66Ze0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtQ29vcmRUb0xvY2FsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHYyID0gW3gsIHldO1xuICAgICAgICB2YXIgaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm07XG4gICAgICAgIGlmIChpbnZUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIGludlRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDlj5jmjaLlsYDpg6jlnZDmoIfkvY3nva7liLDlhajlsYDlnZDmoIfnqbrpl7RcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvR2xvYmFsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHYyID0gW3gsIHldO1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRhcmdldC5vcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0LnJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdGFyZ2V0LnBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW21dXG4gICAgICovXG4gICAgVHJhbnNmb3JtYWJsZS5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0YXJnZXQsIG0pIHtcbiAgICAgICAgbSA9IG0gfHwgW107XG4gICAgICAgIG1JZGVudGl0eShtKTtcblxuICAgICAgICB2YXIgb3JpZ2luID0gdGFyZ2V0Lm9yaWdpbjtcbiAgICAgICAgdmFyIHNjYWxlID0gdGFyZ2V0LnNjYWxlIHx8IFsxLCAxXTtcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gdGFyZ2V0LnJvdGF0aW9uIHx8IDA7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRhcmdldC5wb3NpdGlvbiB8fCBbMCwgMF07XG5cbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgLy8gVHJhbnNsYXRlIHRvIG9yaWdpblxuICAgICAgICAgICAgbVs0XSAtPSBvcmlnaW5bMF07XG4gICAgICAgICAgICBtWzVdIC09IG9yaWdpblsxXTtcbiAgICAgICAgfVxuICAgICAgICBtYXRyaXguc2NhbGUobSwgbSwgc2NhbGUpO1xuICAgICAgICBpZiAocm90YXRpb24pIHtcbiAgICAgICAgICAgIG1hdHJpeC5yb3RhdGUobSwgbSwgcm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSBiYWNrIGZyb20gb3JpZ2luXG4gICAgICAgICAgICBtWzRdICs9IG9yaWdpblswXTtcbiAgICAgICAgICAgIG1bNV0gKz0gb3JpZ2luWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgbVs0XSArPSBwb3NpdGlvblswXTtcbiAgICAgICAgbVs1XSArPSBwb3NpdGlvblsxXTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm1hYmxlO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = __webpack_require__(44);\n    var util = __webpack_require__(20);\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = __webpack_require__(49);\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * 动画\n         *\n         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\n         * @param {boolean} [loop] 动画是否循环\n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL0FuaW1hdGFibGUuanM/MzVjYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QyxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxPQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZSxVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFDQUFxQyxVQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjQzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZVxuICovXG5cblxuICAgIHZhciBBbmltYXRvciA9IHJlcXVpcmUoJy4uL2FuaW1hdGlvbi9BbmltYXRvcicpO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIGlzU3RyaW5nID0gdXRpbC5pc1N0cmluZztcbiAgICB2YXIgaXNGdW5jdGlvbiA9IHV0aWwuaXNGdW5jdGlvbjtcbiAgICB2YXIgaXNPYmplY3QgPSB1dGlsLmlzT2JqZWN0O1xuICAgIHZhciBsb2cgPSByZXF1aXJlKCcuLi9jb3JlL2xvZycpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBBbmltYXRhYmxlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcj59XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRvcnMgPSBbXTtcbiAgICB9O1xuXG4gICAgQW5pbWF0YWJsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEFuaW1hdGFibGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWKqOeUu1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCDpnIDopoHmt7vliqDliqjnlLvnmoTlsZ7mgKfojrflj5bot6/lvoTvvIzlj6/ku6XpgJrov4dhLmIuY+adpeiOt+WPlua3seWxgueahOWxnuaAp1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtsb29wXSDliqjnlLvmmK/lkKblvqrnjq9cbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKiBAZXhhbXBsZTpcbiAgICAgICAgICogICAgIGVsLmFuaW1hdGUoJ3N0eWxlJywgZmFsc2UpXG4gICAgICAgICAqICAgICAgICAgLndoZW4oMTAwMCwge3g6IDEwfSApXG4gICAgICAgICAqICAgICAgICAgLmRvbmUoZnVuY3Rpb24oKXsgLy8gQW5pbWF0aW9uIGRvbmUgfSlcbiAgICAgICAgICogICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0ZTogZnVuY3Rpb24gKHBhdGgsIGxvb3ApIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQ7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW5nU2hhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoU3BsaXR0ZWQgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBlbDtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbmltYXRpbmcgc2hhcGVcbiAgICAgICAgICAgICAgICBhbmltYXRpbmdTaGFwZSA9IHBhdGhTcGxpdHRlZFswXSA9PT0gJ3NoYXBlJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhTcGxpdHRlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9wID0gcHJvcFtwYXRoU3BsaXR0ZWRbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBwcm9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IGVsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgICAgICAgICAgJ1Byb3BlcnR5IFwiJ1xuICAgICAgICAgICAgICAgICAgICArIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgKyAnXCIgaXMgbm90IGV4aXN0ZWQgaW4gZWxlbWVudCAnXG4gICAgICAgICAgICAgICAgICAgICsgZWwuaWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IGVsLmFuaW1hdG9ycztcblxuICAgICAgICAgICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKHRhcmdldCwgbG9vcCk7XG5cbiAgICAgICAgICAgIGFuaW1hdG9yLmR1cmluZyhmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZWwuZGlydHkoYW5pbWF0aW5nU2hhcGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBBbmltYXRvciB3aWxsIG5vdCBiZSByZW1vdmVkIGlmIHVzZSBgQW5pbWF0b3Ijc3RvcGAgdG8gc3RvcCBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBhbmltYXRvcnMuc3BsaWNlKHV0aWwuaW5kZXhPZihhbmltYXRvcnMsIGFuaW1hdG9yKSwgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYW5pbWF0b3JzLnB1c2goYW5pbWF0b3IpO1xuXG4gICAgICAgICAgICAvLyBJZiBhbmltYXRlIGFmdGVyIGFkZGVkIHRvIHRoZSB6cmVuZGVyXG4gICAgICAgICAgICBpZiAoenIpIHtcbiAgICAgICAgICAgICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0b3I7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWBnOatouWKqOeUu1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcndhcmRUb0xhc3QgSWYgbW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wQW5pbWF0aW9uOiBmdW5jdGlvbiAoZm9yd2FyZFRvTGFzdCkge1xuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGFuaW1hdG9ycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JzW2ldLnN0b3AoZm9yd2FyZFRvTGFzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmltYXRvcnMubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF0gVGltZSBpbiBtc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Vhc2luZz0nbGluZWFyJ11cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICAvLyBBbmltYXRlIHBvc2l0aW9uXG4gICAgICAgICAqICBlbC5hbmltYXRlVG8oe1xuICAgICAgICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgICAgICAgKiAgfSwgZnVuY3Rpb24gKCkgeyAvLyBkb25lIH0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAvLyBBbmltYXRlIHNoYXBlLCBzdHlsZSBhbmQgcG9zaXRpb24gaW4gMTAwbXMsIGRlbGF5ZWQgMTAwbXMsIHdpdGggY3ViaWNPdXQgZWFzaW5nXG4gICAgICAgICAqICBlbC5hbmltYXRlVG8oe1xuICAgICAgICAgKiAgICAgIHNoYXBlOiB7XG4gICAgICAgICAqICAgICAgICAgIHdpZHRoOiA1MDBcbiAgICAgICAgICogICAgICB9LFxuICAgICAgICAgKiAgICAgIHN0eWxlOiB7XG4gICAgICAgICAqICAgICAgICAgIGZpbGw6ICdyZWQnXG4gICAgICAgICAqICAgICAgfVxuICAgICAgICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgICAgICAgKiAgfSwgMTAwLCAxMDAsICdjdWJpY091dCcsIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICAgICAgICAgKi9cbiAgICAgICAgIC8vIFRPRE8gUmV0dXJuIGFuaW1hdGlvbiBrZXlcbiAgICAgICAgYW5pbWF0ZVRvOiBmdW5jdGlvbiAodGFyZ2V0LCB0aW1lLCBkZWxheSwgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgICAgICAgICAgZWFzaW5nID0gZGVsYXk7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgZGVsYXksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZWFzaW5nKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgICAgICAgICAgIGVhc2luZyA9ICdsaW5lYXInO1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBkZWxheTtcbiAgICAgICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCBjYWxsYmFjaylcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24odGltZSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHRpbWU7XG4gICAgICAgICAgICAgICAgdGltZSA9IDUwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQpXG4gICAgICAgICAgICBlbHNlIGlmICghdGltZSkge1xuICAgICAgICAgICAgICAgIHRpbWUgPSA1MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdG9wIGFsbCBwcmV2aW91cyBhbmltYXRpb25zXG4gICAgICAgICAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVUb1NoYWxsb3coJycsIHRoaXMsIHRhcmdldCwgdGltZSwgZGVsYXksIGVhc2luZywgY2FsbGJhY2spO1xuXG4gICAgICAgICAgICAvLyBBbmltYXRvcnMgbWF5IGJlIHJlbW92ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgc3RhcnRcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gYW5pbWF0ZVxuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzLnNsaWNlKCk7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBhbmltYXRvcnMubGVuZ3RoO1xuICAgICAgICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vIGFuaW1hdG9ycy4gVGhpcyBzaG91bGQgYmUgY2hlY2tlZCBiZWZvcmUgYW5pbWF0b3JzW2ldLnN0YXJ0KCksXG4gICAgICAgICAgICAvLyBiZWNhdXNlICdkb25lJyBtYXkgYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkgaWYgbm8gbmVlZCB0byBhbmltYXRlLlxuICAgICAgICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCBhZnRlciBhbGwgYW5pbWF0b3JzIGNyZWF0ZWRcbiAgICAgICAgICAgIC8vIEluY2FzZSBhbnkgYW5pbWF0b3IgaXMgZG9uZSBpbW1lZGlhdGVseSB3aGVuIGFsbCBhbmltYXRpb24gcHJvcGVydGllcyBhcmUgbm90IGNoYW5nZWRcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JzW2ldXG4gICAgICAgICAgICAgICAgICAgIC5kb25lKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIC5zdGFydChlYXNpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aD0nJ1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlPXRoaXNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICAvLyBBbmltYXRlIHBvc2l0aW9uXG4gICAgICAgICAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gICAgICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICAgICAqICB9KVxuICAgICAgICAgKlxuICAgICAgICAgKiAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zXG4gICAgICAgICAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gICAgICAgICAqICAgICAgc2hhcGU6IHtcbiAgICAgICAgICogICAgICAgICAgd2lkdGg6IDUwMFxuICAgICAgICAgKiAgICAgIH0sXG4gICAgICAgICAqICAgICAgc3R5bGU6IHtcbiAgICAgICAgICogICAgICAgICAgZmlsbDogJ3JlZCdcbiAgICAgICAgICogICAgICB9XG4gICAgICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICAgICAqICB9LCAxMDAsIDEwMClcbiAgICAgICAgICovXG4gICAgICAgIF9hbmltYXRlVG9TaGFsbG93OiBmdW5jdGlvbiAocGF0aCwgc291cmNlLCB0YXJnZXQsIHRpbWUsIGRlbGF5KSB7XG4gICAgICAgICAgICB2YXIgb2JqU2hhbGxvdyA9IHt9O1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5Q291bnQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHRhcmdldFtuYW1lXSkgJiYgIXV0aWwuaXNBcnJheUxpa2UodGFyZ2V0W25hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZVRvU2hhbGxvdyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID8gcGF0aCArICcuJyArIG5hbWUgOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVtuYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialNoYWxsb3dbbmFtZV0gPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0W25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ciBkaXJlY3RseSBpZiBub3QgaGFzIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FLCBpZiBzb21lIHByb3BlcnR5IG5vdCBuZWVkZWQgZm9yIGVsZW1lbnQgP1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cihuYW1lLCB0YXJnZXRbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAgLy8gU2hhcGUgb3Igc3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbcGF0aF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW3BhdGhdW25hbWVdID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByb3BlcnR5Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlKHBhdGgsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAud2hlbih0aW1lID09IG51bGwgPyA1MDAgOiB0aW1lLCBvYmpTaGFsbG93KVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoZGVsYXkgfHwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQW5pbWF0YWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = __webpack_require__(45);\n    var color = __webpack_require__(47);\n    var util = __webpack_require__(20);\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = len && p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function getArrayDim(keyframes) {\n        var lastValue = keyframes[keyframes.length - 1].value;\n        return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * 设置动画关键帧\n         * @param  {number} time 关键帧时间，单位是ms\n         * @param  {Object} props 关键帧的属性值，key-value表示\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * 添加动画每一帧的回调函数\n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        pause: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].pause();\n            }\n            this._paused = true;\n        },\n\n        resume: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].resume();\n            }\n            this._paused = false;\n        },\n\n        isPaused: function () {\n            return !!this._paused;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * 开始执行动画\n         * @param  {string|Function} easing\n         *         动画缓动函数，详见{@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * 设置动画延迟开始的时间\n         * @param  {number} time 单位ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * 添加动画结束的回调\n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qcz9kMmI5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEMsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQywrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyw2QkFBNkI7QUFDN0Isb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyw4QkFBOEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9hbmltYXRpb24vQW5pbWF0b3JcbiAqL1xuXG5cbiAgICB2YXIgQ2xpcCA9IHJlcXVpcmUoJy4vQ2xpcCcpO1xuICAgIHZhciBjb2xvciA9IHJlcXVpcmUoJy4uL3Rvb2wvY29sb3InKTtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBpc0FycmF5TGlrZSA9IHV0aWwuaXNBcnJheUxpa2U7XG5cbiAgICB2YXIgYXJyYXlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRHZXR0ZXIodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRTZXR0ZXIodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVOdW1iZXIocDAsIHAxLCBwZXJjZW50KSB7XG4gICAgICAgIHJldHVybiAocDEgLSBwMCkgKiBwZXJjZW50ICsgcDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBwMFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVTdHJpbmcocDAsIHAxLCBwZXJjZW50KSB7XG4gICAgICAgIHJldHVybiBwZXJjZW50ID4gMC41ID8gcDEgOiBwMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcGVyY2VudCwgb3V0LCBhcnJEaW0pIHtcbiAgICAgICAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV0sIHAxW2ldLCBwZXJjZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZW4yID0gbGVuICYmIHAwWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBvdXRbaV1bal0gPSBpbnRlcnBvbGF0ZU51bWJlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHAwW2ldW2pdLCBwMVtpXVtqXSwgcGVyY2VudFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFycjAgaXMgc291cmNlIGFycmF5LCBhcnIxIGlzIHRhcmdldCBhcnJheS5cbiAgICAvLyBEbyBzb21lIHByZXByb2Nlc3MgdG8gYXZvaWQgZXJyb3IgaGFwcGVuZWQgd2hlbiBpbnRlcnBvbGF0aW5nIGZyb20gYXJyMCB0byBhcnIxXG4gICAgZnVuY3Rpb24gZmlsbEFycihhcnIwLCBhcnIxLCBhcnJEaW0pIHtcbiAgICAgICAgdmFyIGFycjBMZW4gPSBhcnIwLmxlbmd0aDtcbiAgICAgICAgdmFyIGFycjFMZW4gPSBhcnIxLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycjBMZW4gIT09IGFycjFMZW4pIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIE5vdCB3b3JrIGZvciBUeXBlZEFycmF5XG4gICAgICAgICAgICB2YXIgaXNQcmV2aW91c0xhcmdlciA9IGFycjBMZW4gPiBhcnIxTGVuO1xuICAgICAgICAgICAgaWYgKGlzUHJldmlvdXNMYXJnZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBDdXQgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgYXJyMC5sZW5ndGggPSBhcnIxTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRmlsbCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gYXJyMExlbjsgaSA8IGFycjFMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnIwLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJEaW0gPT09IDEgPyBhcnIxW2ldIDogYXJyYXlTbGljZS5jYWxsKGFycjFbaV0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsaW5nIE5hTiB2YWx1ZVxuICAgICAgICB2YXIgbGVuMiA9IGFycjBbMF0gJiYgYXJyMFswXS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFyckRpbSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihhcnIwW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBhcnIwW2ldID0gYXJyMVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYXJyMFtpXVtqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycjBbaV1bal0gPSBhcnIxW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFycjBcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5U2FtZShhcnIwLCBhcnIxLCBhcnJEaW0pIHtcbiAgICAgICAgaWYgKGFycjAgPT09IGFycjEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW4gPSBhcnIwLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiAhPT0gYXJyMS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycjBbaV0gIT09IGFycjFbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZW4yID0gYXJyMFswXS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycjBbaV1bal0gIT09IGFycjFbaV1bal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBhcnJheVxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMVxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMlxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQzXG4gICAgICogQHBhcmFtICB7QXJyYXl9IG91dFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkoXG4gICAgICAgIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMsIG91dCwgYXJyRGltXG4gICAgKSB7XG4gICAgICAgIHZhciBsZW4gPSBwMC5sZW5ndGg7XG4gICAgICAgIGlmIChhcnJEaW0gPT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgcDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQsIHQyLCB0M1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGVuMiA9IHAwWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBvdXRbaV1bal0gPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBwMFtpXVtqXSwgcDFbaV1bal0sIHAyW2ldW2pdLCBwM1tpXVtqXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQsIHQyLCB0M1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhdG11bGwgUm9tIGludGVycG9sYXRlIG51bWJlclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0M1xuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mykge1xuICAgICAgICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG4gICAgICAgIHZhciB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgICAgICAgcmV0dXJuICgyICogKHAxIC0gcDIpICsgdjAgKyB2MSkgKiB0M1xuICAgICAgICAgICAgICAgICsgKC0zICogKHAxIC0gcDIpIC0gMiAqIHYwIC0gdjEpICogdDJcbiAgICAgICAgICAgICAgICArIHYwICogdCArIHAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZVswXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChhcnJheVNsaWNlLmNhbGwodmFsdWVbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFycmF5U2xpY2UuY2FsbCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmdiYTJTdHJpbmcocmdiYSkge1xuICAgICAgICByZ2JhWzBdID0gTWF0aC5mbG9vcihyZ2JhWzBdKTtcbiAgICAgICAgcmdiYVsxXSA9IE1hdGguZmxvb3IocmdiYVsxXSk7XG4gICAgICAgIHJnYmFbMl0gPSBNYXRoLmZsb29yKHJnYmFbMl0pO1xuXG4gICAgICAgIHJldHVybiAncmdiYSgnICsgcmdiYS5qb2luKCcsJykgKyAnKSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXJyYXlEaW0oa2V5ZnJhbWVzKSB7XG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSBrZXlmcmFtZXNba2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnZhbHVlO1xuICAgICAgICByZXR1cm4gaXNBcnJheUxpa2UobGFzdFZhbHVlICYmIGxhc3RWYWx1ZVswXSkgPyAyIDogMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVUcmFja0NsaXAgKGFuaW1hdG9yLCBlYXNpbmcsIG9uZVRyYWNrRG9uZSwga2V5ZnJhbWVzLCBwcm9wTmFtZSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gYW5pbWF0b3IuX2dldHRlcjtcbiAgICAgICAgdmFyIHNldHRlciA9IGFuaW1hdG9yLl9zZXR0ZXI7XG4gICAgICAgIHZhciB1c2VTcGxpbmUgPSBlYXNpbmcgPT09ICdzcGxpbmUnO1xuXG4gICAgICAgIHZhciB0cmFja0xlbiA9IGtleWZyYW1lcy5sZW5ndGg7XG4gICAgICAgIGlmICghdHJhY2tMZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHdWVzcyBkYXRhIHR5cGVcbiAgICAgICAgdmFyIGZpcnN0VmFsID0ga2V5ZnJhbWVzWzBdLnZhbHVlO1xuICAgICAgICB2YXIgaXNWYWx1ZUFycmF5ID0gaXNBcnJheUxpa2UoZmlyc3RWYWwpO1xuICAgICAgICB2YXIgaXNWYWx1ZUNvbG9yID0gZmFsc2U7XG4gICAgICAgIHZhciBpc1ZhbHVlU3RyaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gRm9yIHZlcnRpY2VzIG1vcnBoaW5nXG4gICAgICAgIHZhciBhcnJEaW0gPSBpc1ZhbHVlQXJyYXkgPyBnZXRBcnJheURpbShrZXlmcmFtZXMpIDogMDtcblxuICAgICAgICB2YXIgdHJhY2tNYXhUaW1lO1xuICAgICAgICAvLyBTb3J0IGtleWZyYW1lIGFzIGFzY2VuZGluZ1xuICAgICAgICBrZXlmcmFtZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuICAgICAgICB9KTtcblxuICAgICAgICB0cmFja01heFRpbWUgPSBrZXlmcmFtZXNbdHJhY2tMZW4gLSAxXS50aW1lO1xuICAgICAgICAvLyBQZXJjZW50cyBvZiBlYWNoIGtleWZyYW1lXG4gICAgICAgIHZhciBrZlBlcmNlbnRzID0gW107XG4gICAgICAgIC8vIFZhbHVlIG9mIGVhY2gga2V5ZnJhbWVcbiAgICAgICAgdmFyIGtmVmFsdWVzID0gW107XG4gICAgICAgIHZhciBwcmV2VmFsdWUgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gICAgICAgIHZhciBpc0FsbFZhbHVlRXF1YWwgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGtmUGVyY2VudHMucHVzaChrZXlmcmFtZXNbaV0udGltZSAvIHRyYWNrTWF4VGltZSk7XG4gICAgICAgICAgICAvLyBBc3N1bWUgdmFsdWUgaXMgYSBjb2xvciB3aGVuIGl0IGlzIGEgc3RyaW5nXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBrZXlmcmFtZXNbaV0udmFsdWU7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHZhbHVlIGlzIGVxdWFsLCBkZWVwIGNoZWNrIGlmIHZhbHVlIGlzIGFycmF5XG4gICAgICAgICAgICBpZiAoISgoaXNWYWx1ZUFycmF5ICYmIGlzQXJyYXlTYW1lKHZhbHVlLCBwcmV2VmFsdWUsIGFyckRpbSkpXG4gICAgICAgICAgICAgICAgfHwgKCFpc1ZhbHVlQXJyYXkgJiYgdmFsdWUgPT09IHByZXZWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgaXNBbGxWYWx1ZUVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gVHJ5IGNvbnZlcnRpbmcgYSBzdHJpbmcgdG8gYSBjb2xvciBhcnJheVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvckFycmF5ID0gY29sb3IucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChjb2xvckFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29sb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWx1ZUNvbG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsdWVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtmVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FsbFZhbHVlRXF1YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSBrZlZhbHVlc1t0cmFja0xlbiAtIDFdO1xuICAgICAgICAvLyBQb2x5ZmlsbCBhcnJheSBhbmQgTmFOIHZhbHVlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBmaWxsQXJyKGtmVmFsdWVzW2ldLCBsYXN0VmFsdWUsIGFyckRpbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oa2ZWYWx1ZXNbaV0pICYmICFpc05hTihsYXN0VmFsdWUpICYmICFpc1ZhbHVlU3RyaW5nICYmICFpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAga2ZWYWx1ZXNbaV0gPSBsYXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlzVmFsdWVBcnJheSAmJiBmaWxsQXJyKGdldHRlcihhbmltYXRvci5fdGFyZ2V0LCBwcm9wTmFtZSksIGxhc3RWYWx1ZSwgYXJyRGltKTtcblxuICAgICAgICAvLyBDYWNoZSB0aGUga2V5IG9mIGxhc3QgZnJhbWUgdG8gc3BlZWQgdXAgd2hlblxuICAgICAgICAvLyBhbmltYXRpb24gcGxheWJhY2sgaXMgc2VxdWVuY3lcbiAgICAgICAgdmFyIGxhc3RGcmFtZSA9IDA7XG4gICAgICAgIHZhciBsYXN0RnJhbWVQZXJjZW50ID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICB2YXIgdztcbiAgICAgICAgdmFyIHAwO1xuICAgICAgICB2YXIgcDE7XG4gICAgICAgIHZhciBwMjtcbiAgICAgICAgdmFyIHAzO1xuXG4gICAgICAgIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgIHZhciByZ2JhID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9uZnJhbWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwZXJjZW50KSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSByYW5nZSBrZXlmcmFtZXNcbiAgICAgICAgICAgIC8vIGtmMS0tLS0ta2YyLS0tLS0tLS0tY3VycmVudC0tLS0tLS0ta2YzXG4gICAgICAgICAgICAvLyBmaW5kIGtmMiBhbmQga2YzIGFuZCBkbyBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICB2YXIgZnJhbWU7XG4gICAgICAgICAgICAvLyBJbiB0aGUgZWFzaW5nIGZ1bmN0aW9uIGxpa2UgZWxhc3RpY091dCwgcGVyY2VudCBtYXkgbGVzcyB0aGFuIDBcbiAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIGZyYW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBlcmNlbnQgPCBsYXN0RnJhbWVQZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSBuZXh0IGtleVxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgc3RhcnQgZnJvbSBsYXN0RnJhbWUgP1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5taW4obGFzdEZyYW1lICsgMSwgdHJhY2tMZW4gLSAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGZyYW1lID0gc3RhcnQ7IGZyYW1lID49IDA7IGZyYW1lLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdIDw9IHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgcmVhbGx5IG5lZWQgdG8gZG8gdGhpcyA/XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSwgdHJhY2tMZW4gLSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoZnJhbWUgPSBsYXN0RnJhbWU7IGZyYW1lIDwgdHJhY2tMZW47IGZyYW1lKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdID4gcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSAtIDEsIHRyYWNrTGVuIC0gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0RnJhbWUgPSBmcmFtZTtcbiAgICAgICAgICAgIGxhc3RGcmFtZVBlcmNlbnQgPSBwZXJjZW50O1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSAoa2ZQZXJjZW50c1tmcmFtZSArIDFdIC0ga2ZQZXJjZW50c1tmcmFtZV0pO1xuICAgICAgICAgICAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdyA9IChwZXJjZW50IC0ga2ZQZXJjZW50c1tmcmFtZV0pIC8gcmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlU3BsaW5lKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBrZlZhbHVlc1tmcmFtZV07XG4gICAgICAgICAgICAgICAgcDAgPSBrZlZhbHVlc1tmcmFtZSA9PT0gMCA/IGZyYW1lIDogZnJhbWUgLSAxXTtcbiAgICAgICAgICAgICAgICBwMiA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAyID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAxXTtcbiAgICAgICAgICAgICAgICBwMyA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAzID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAyXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJEaW1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZ2JhLCAxXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmcgaXMgc3RlcCgwLjUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcocDEsIHAyLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICBrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJEaW1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmdiYSwgMVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWx1ZVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlU3RyaW5nKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGludGVycG9sYXRlTnVtYmVyKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2xpcCA9IG5ldyBDbGlwKHtcbiAgICAgICAgICAgIHRhcmdldDogYW5pbWF0b3IuX3RhcmdldCxcbiAgICAgICAgICAgIGxpZmU6IHRyYWNrTWF4VGltZSxcbiAgICAgICAgICAgIGxvb3A6IGFuaW1hdG9yLl9sb29wLFxuICAgICAgICAgICAgZGVsYXk6IGFuaW1hdG9yLl9kZWxheSxcbiAgICAgICAgICAgIG9uZnJhbWU6IG9uZnJhbWUsXG4gICAgICAgICAgICBvbmRlc3Ryb3k6IG9uZVRyYWNrRG9uZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZWFzaW5nICYmIGVhc2luZyAhPT0gJ3NwbGluZScpIHtcbiAgICAgICAgICAgIGNsaXAuZWFzaW5nID0gZWFzaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsaXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXJcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0b3IgPSBmdW5jdGlvbih0YXJnZXQsIGxvb3AsIGdldHRlciwgc2V0dGVyKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgdGhpcy5fbG9vcCA9IGxvb3AgfHwgZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fZ2V0dGVyID0gZ2V0dGVyIHx8IGRlZmF1bHRHZXR0ZXI7XG4gICAgICAgIHRoaXMuX3NldHRlciA9IHNldHRlciB8fCBkZWZhdWx0U2V0dGVyO1xuXG4gICAgICAgIHRoaXMuX2NsaXBDb3VudCA9IDA7XG5cbiAgICAgICAgdGhpcy5fZGVsYXkgPSAwO1xuXG4gICAgICAgIHRoaXMuX2RvbmVMaXN0ID0gW107XG5cbiAgICAgICAgdGhpcy5fb25mcmFtZUxpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9jbGlwTGlzdCA9IFtdO1xuICAgIH07XG5cbiAgICBBbmltYXRvci5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7liqjnlLvlhbPplK7luKdcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWFs+mUruW4p+aXtumXtO+8jOWNleS9jeaYr21zXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMg5YWz6ZSu5bin55qE5bGe5oCn5YC877yMa2V5LXZhbHVl6KGo56S6XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHdoZW46IGZ1bmN0aW9uKHRpbWUgLyogbXMgKi8sIHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tzID0gdGhpcy5fdHJhY2tzO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRyYWNrc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tzW3Byb3BOYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldHRlcih0aGlzLl90YXJnZXQsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHpyTG9nKCdJbnZhbGlkIHByb3BlcnR5ICcgKyBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aW1lIGlzIDBcbiAgICAgICAgICAgICAgICAgICAgLy8gIFRoZW4gcHJvcHMgaXMgZ2l2ZW4gaW5pdGlhbGl6ZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlXG4gICAgICAgICAgICAgICAgICAgIC8vICBJbml0aWFsaXplIHZhbHVlIGZyb20gY3VycmVudCBwcm9wIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNsb25lVmFsdWUodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcHJvcHNbcHJvcE5hbWVdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWKqOeUu+avj+S4gOW4p+eahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZHVyaW5nOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX29uZnJhbWVMaXN0LnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGlwTGlzdFtpXS5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGlwTGlzdFtpXS5yZXN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzUGF1c2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLl9wYXVzZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvbmVDYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgYWxsIHRyYWNrc1xuICAgICAgICAgICAgdGhpcy5fdHJhY2tzID0ge307XG4gICAgICAgICAgICAvLyBDbGVhciBhbGwgY2xpcHNcbiAgICAgICAgICAgIHRoaXMuX2NsaXBMaXN0Lmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHZhciBkb25lTGlzdCA9IHRoaXMuX2RvbmVMaXN0O1xuICAgICAgICAgICAgdmFyIGxlbiA9IGRvbmVMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkb25lTGlzdFtpXS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5byA5aeL5omn6KGM5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ3xGdW5jdGlvbn0gZWFzaW5nXG4gICAgICAgICAqICAgICAgICAg5Yqo55S757yT5Yqo5Ye95pWw77yM6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmd9XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoZWFzaW5nKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjbGlwQ291bnQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgb25lVHJhY2tEb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2xpcENvdW50LS07XG4gICAgICAgICAgICAgICAgaWYgKCFjbGlwQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZG9uZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGxhc3RDbGlwO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdGhpcy5fdHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFja3MuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IGNyZWF0ZVRyYWNrQ2xpcChcbiAgICAgICAgICAgICAgICAgICAgdGhpcywgZWFzaW5nLCBvbmVUcmFja0RvbmUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrc1twcm9wTmFtZV0sIHByb3BOYW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xpcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGlwTGlzdC5wdXNoKGNsaXApO1xuICAgICAgICAgICAgICAgICAgICBjbGlwQ291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzdGFydCBhZnRlciBhZGRlZCB0byBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGRDbGlwKGNsaXApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdENsaXAgPSBjbGlwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIGR1cmluZyBjYWxsYmFjayBvbiB0aGUgbGFzdCBjbGlwXG4gICAgICAgICAgICBpZiAobGFzdENsaXApIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkT25GcmFtZSA9IGxhc3RDbGlwLm9uZnJhbWU7XG4gICAgICAgICAgICAgICAgbGFzdENsaXAub25mcmFtZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkT25GcmFtZSh0YXJnZXQsIHBlcmNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fb25mcmFtZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uZnJhbWVMaXN0W2ldKHRhcmdldCwgcGVyY2VudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvbmVDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLliqjnlLtcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgIHZhciBjbGlwTGlzdCA9IHRoaXMuX2NsaXBMaXN0O1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbGlwID0gY2xpcExpc3RbaV07XG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAgICAgICAgICAgICAgICAgIGNsaXAub25mcmFtZSh0aGlzLl90YXJnZXQsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnJlbW92ZUNsaXAoY2xpcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGlwTGlzdC5sZW5ndGggPSAwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5Yqo55S75bu26L+f5byA5aeL55qE5pe26Ze0XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDljZXkvY1tc1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkZWxheTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5ID0gdGltZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5Yqo55S757uT5p2f55qE5Zue6LCDXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkb25lOiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9uZUxpc3QucHVzaChjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldENsaXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xpcExpc3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBbmltYXRvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("/**\n * 动画主控制器\n * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n * @config life(1000) 动画时长\n * @config delay(0) 动画延迟时间\n * @config loop(true)\n * @config gap(0) 循环的间隔时间\n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = __webpack_require__(46);\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // 生命周期\n        this._life = options.life || 1000;\n        // 延时\n        this._delay = options.delay || 0;\n        // 开始时间\n        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n        this._initialized = false;\n\n        // 是否循环\n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n\n        this._pausedTime = 0;\n        this._paused = false;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime, deltaTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            if (this._paused) {\n                this._pausedTime += deltaTime;\n                return;\n            }\n\n            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n\n            // 还没开始\n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // 结束\n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // 重新开始周期\n                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n                    return 'restart';\n                }\n\n                // 动画完成将这个控制器标识为待删除\n                // 在Animation.update中进行批量删除\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._pausedTime = 0;\n\n            this._needsRemove = false;\n        },\n\n        fire: function (eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        },\n\n        pause: function () {\n            this._paused = true;\n        },\n\n        resume: function () {\n            this._paused = false;\n        }\n    };\n\n    module.exports = Clip;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9DbGlwLmpzP2ZlZjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI0NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog5Yqo55S75Li75o6n5Yi25ZmoXG4gKiBAY29uZmlnIHRhcmdldCDliqjnlLvlr7nosaHvvIzlj6/ku6XmmK/mlbDnu4TvvIzlpoLmnpzmmK/mlbDnu4TnmoTor53kvJrmibnph4/liIblj5FvbmZyYW1l562J5LqL5Lu2XG4gKiBAY29uZmlnIGxpZmUoMTAwMCkg5Yqo55S75pe26ZW/XG4gKiBAY29uZmlnIGRlbGF5KDApIOWKqOeUu+W7tui/n+aXtumXtFxuICogQGNvbmZpZyBsb29wKHRydWUpXG4gKiBAY29uZmlnIGdhcCgwKSDlvqrnjq/nmoTpl7TpmpTml7bpl7RcbiAqIEBjb25maWcgb25mcmFtZVxuICogQGNvbmZpZyBlYXNpbmcob3B0aW9uYWwpXG4gKiBAY29uZmlnIG9uZGVzdHJveShvcHRpb25hbClcbiAqIEBjb25maWcgb25yZXN0YXJ0KG9wdGlvbmFsKVxuICpcbiAqIFRPRE8gcGF1c2VcbiAqL1xuXG5cbiAgICB2YXIgZWFzaW5nRnVuY3MgPSByZXF1aXJlKCcuL2Vhc2luZycpO1xuXG4gICAgZnVuY3Rpb24gQ2xpcChvcHRpb25zKSB7XG5cbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG5cbiAgICAgICAgLy8g55Sf5ZG95ZGo5pyfXG4gICAgICAgIHRoaXMuX2xpZmUgPSBvcHRpb25zLmxpZmUgfHwgMTAwMDtcbiAgICAgICAgLy8g5bu25pe2XG4gICAgICAgIHRoaXMuX2RlbGF5ID0gb3B0aW9ucy5kZWxheSB8fCAwO1xuICAgICAgICAvLyDlvIDlp4vml7bpl7RcbiAgICAgICAgLy8gdGhpcy5fc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyB0aGlzLl9kZWxheTsvLyDljZXkvY3mr6vnp5JcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyDmmK/lkKblvqrnjq9cbiAgICAgICAgdGhpcy5sb29wID0gb3B0aW9ucy5sb29wID09IG51bGwgPyBmYWxzZSA6IG9wdGlvbnMubG9vcDtcblxuICAgICAgICB0aGlzLmdhcCA9IG9wdGlvbnMuZ2FwIHx8IDA7XG5cbiAgICAgICAgdGhpcy5lYXNpbmcgPSBvcHRpb25zLmVhc2luZyB8fCAnTGluZWFyJztcblxuICAgICAgICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWU7XG4gICAgICAgIHRoaXMub25kZXN0cm95ID0gb3B0aW9ucy5vbmRlc3Ryb3k7XG4gICAgICAgIHRoaXMub25yZXN0YXJ0ID0gb3B0aW9ucy5vbnJlc3RhcnQ7XG5cbiAgICAgICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIENsaXAucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBDbGlwLFxuXG4gICAgICAgIHN0ZXA6IGZ1bmN0aW9uIChnbG9iYWxUaW1lLCBkZWx0YVRpbWUpIHtcbiAgICAgICAgICAgIC8vIFNldCBzdGFydFRpbWUgb24gZmlyc3Qgc3RlcCwgb3IgX3N0YXJ0VGltZSBtYXkgaGFzIG1pbGxlc2Vjb25kcyBkaWZmZXJlbnQgYmV0d2VlbiBjbGlwc1xuICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IGdsb2JhbFRpbWUgKyB0aGlzLl9kZWxheTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZWRUaW1lICs9IGRlbHRhVGltZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gKGdsb2JhbFRpbWUgLSB0aGlzLl9zdGFydFRpbWUgLSB0aGlzLl9wYXVzZWRUaW1lKSAvIHRoaXMuX2xpZmU7XG5cbiAgICAgICAgICAgIC8vIOi/mOayoeW8gOWni1xuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwZXJjZW50ID0gTWF0aC5taW4ocGVyY2VudCwgMSk7XG5cbiAgICAgICAgICAgIHZhciBlYXNpbmcgPSB0aGlzLmVhc2luZztcbiAgICAgICAgICAgIHZhciBlYXNpbmdGdW5jID0gdHlwZW9mIGVhc2luZyA9PSAnc3RyaW5nJyA/IGVhc2luZ0Z1bmNzW2Vhc2luZ10gOiBlYXNpbmc7XG4gICAgICAgICAgICB2YXIgc2NoZWR1bGUgPSB0eXBlb2YgZWFzaW5nRnVuYyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gZWFzaW5nRnVuYyhwZXJjZW50KVxuICAgICAgICAgICAgICAgIDogcGVyY2VudDtcblxuICAgICAgICAgICAgdGhpcy5maXJlKCdmcmFtZScsIHNjaGVkdWxlKTtcblxuICAgICAgICAgICAgLy8g57uT5p2fXG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9vcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RhcnQgKGdsb2JhbFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyDph43mlrDlvIDlp4vlkajmnJ9cbiAgICAgICAgICAgICAgICAgICAgLy8g5oqb5Ye66ICM5LiN5piv55u05o6l6LCD55So5LqL5Lu255u05YiwIHN0YWdlLnVwZGF0ZSDlkI7lho3nu5/kuIDosIPnlKjov5nkupvkuovku7ZcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyZXN0YXJ0JztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyDliqjnlLvlrozmiJDlsIbov5nkuKrmjqfliLblmajmoIfor4bkuLrlvoXliKDpmaRcbiAgICAgICAgICAgICAgICAvLyDlnKhBbmltYXRpb24udXBkYXRl5Lit6L+b6KGM5om56YeP5Yig6ZmkXG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNSZW1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZGVzdHJveSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RhcnQ6IGZ1bmN0aW9uIChnbG9iYWxUaW1lKSB7XG4gICAgICAgICAgICB2YXIgcmVtYWluZGVyID0gKGdsb2JhbFRpbWUgLSB0aGlzLl9zdGFydFRpbWUgLSB0aGlzLl9wYXVzZWRUaW1lKSAlIHRoaXMuX2xpZmU7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lIC0gcmVtYWluZGVyICsgdGhpcy5nYXA7XG4gICAgICAgICAgICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcblxuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZW1vdmUgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaXJlOiBmdW5jdGlvbiAoZXZlbnRUeXBlLCBhcmcpIHtcbiAgICAgICAgICAgIGV2ZW50VHlwZSA9ICdvbicgKyBldmVudFR5cGU7XG4gICAgICAgICAgICBpZiAodGhpc1tldmVudFR5cGVdKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tldmVudFR5cGVdKHRoaXMuX3RhcmdldCwgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2xpcDtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9DbGlwLmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("/**\n * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // 三次方的缓动（t^3）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // 四次方的缓动（t^4）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // 五次方的缓动（t^5）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // 正弦曲线的缓动（sin(t)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 指数曲线的缓动（2^t）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // 圆形曲线的缓动（sqrt(1-t^2)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // 创建类似于弹簧在停止前来回振荡的动画\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // 创建弹跳效果\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanM/NjRiNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjQ2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDnvJPliqjku6PnoIHmnaXoh6ogaHR0cHM6Ly9naXRodWIuY29tL3NvbGUvdHdlZW4uanMvYmxvYi9tYXN0ZXIvc3JjL1R3ZWVuLmpzXG4gKiBAc2VlIGh0dHA6Ly9zb2xlLmdpdGh1Yi5pby90d2Vlbi5qcy9leGFtcGxlcy8wM19ncmFwaHMuaHRtbFxuICogQGV4cG9ydHMgenJlbmRlci9hbmltYXRpb24vZWFzaW5nXG4gKi9cblxuICAgIHZhciBlYXNpbmcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBsaW5lYXI6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhZHJhdGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqIGs7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFkcmF0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqICgyIC0gayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFkcmF0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5LiJ5qyh5pa555qE57yT5Yqo77yIdF4z77yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjdWJpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrICogaztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGN1YmljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGN1YmljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWbm+asoeaWueeahOe8k+WKqO+8iHReNO+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhcnRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrICogayAqIGs7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFydGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSAoLS1rICogayAqIGsgKiBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YXJ0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKChrIC09IDIpICogayAqIGsgKiBrIC0gMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5LqU5qyh5pa555qE57yT5Yqo77yIdF4177yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWludGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqIGsgKiBrICogayAqIGs7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWludGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIC0tayAqIGsgKiBrICogayAqIGsgKyAxO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVpbnRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5q2j5bym5puy57q/55qE57yT5Yqo77yIc2luKHQp77yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBzaW51c29pZGFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIE1hdGguY29zKGsgKiBNYXRoLlBJIC8gMik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBzaW51c29pZGFsT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc2luKGsgKiBNYXRoLlBJIC8gMik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBzaW51c29pZGFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOaMh+aVsOabsue6v+eahOe8k+WKqO+8iDJedO+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZXhwb25lbnRpYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrID09PSAwID8gMCA6IE1hdGgucG93KDEwMjQsIGsgLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGV4cG9uZW50aWFsT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgPT09IDEgPyAxIDogMSAtIE1hdGgucG93KDIsIC0xMCAqIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZXhwb25lbnRpYWxJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAoayAtIDEpKSArIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWchuW9ouabsue6v+eahOe8k+WKqO+8iHNxcnQoMS10XjIp77yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjaXJjdWxhckluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIGsgKiBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGNpcmN1bGFyT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCgxIC0gKC0tayAqIGspKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGNpcmN1bGFySW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBrICogaykgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoayAtPSAyKSAqIGspICsgMSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5Yib5bu657G75Ly85LqO5by557Cn5Zyo5YGc5q2i5YmN5p2l5Zue5oyv6I2h55qE5Yqo55S7XG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBlbGFzdGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcztcbiAgICAgICAgICAgIHZhciBhID0gMC4xO1xuICAgICAgICAgICAgdmFyIHAgPSAwLjQ7XG4gICAgICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgICAgICAgICAgIGEgPSAxOyBzID0gcCAvIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0oYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZWxhc3RpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzO1xuICAgICAgICAgICAgdmFyIGEgPSAwLjE7XG4gICAgICAgICAgICB2YXIgcCA9IDAuNDtcbiAgICAgICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICAgICAgICAgICAgYSA9IDE7IHMgPSBwIC8gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGEgKiBNYXRoLnBvdygyLCAtMTAgKiBrKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGVsYXN0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzO1xuICAgICAgICAgICAgdmFyIGEgPSAwLjE7XG4gICAgICAgICAgICB2YXIgcCA9IDAuNDtcbiAgICAgICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICAgICAgICAgICAgYSA9IDE7IHMgPSBwIC8gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpXG4gICAgICAgICAgICAgICAgICAgICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIChrIC09IDEpKVxuICAgICAgICAgICAgICAgICAgICAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5Zyo5p+Q5LiA5Yqo55S75byA5aeL5rK/5oyH56S655qE6Lev5b6E6L+b6KGM5Yqo55S75aSE55CG5YmN56iN56iN5pS25Zue6K+l5Yqo55S755qE56e75YqoXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBiYWNrSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJhY2tPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gLS1rICogayAqICgocyArIDEpICogayArIHMpICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJhY2tJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1OCAqIDEuNTI1O1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiAoayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqICgocyArIDEpICogayArIHMpICsgMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5Yib5bu65by56Lez5pWI5p6cXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBib3VuY2VJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gZWFzaW5nLmJvdW5jZU91dCgxIC0gayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBib3VuY2VPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoayA8ICgxIC8gMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrIDwgKDIgLyAyLjc1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAoMS41IC8gMi43NSkpICogayArIDAuNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrIDwgKDIuNSAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgyLjI1IC8gMi43NSkpICogayArIDAuOTM3NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAoMi42MjUgLyAyLjc1KSkgKiBrICsgMC45ODQzNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBib3VuY2VJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrIDwgMC41KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVhc2luZy5ib3VuY2VJbihrICogMikgKiAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZU91dChrICogMiAtIDEpICogMC41ICsgMC41O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZWFzaW5nO1xuXG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vZWFzaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("/**\n * @module zrender/tool/color\n */\n\n\n    var LRU = __webpack_require__(48);\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    function setRgba(out, r, g, b, a) {\n        out[0] = r; out[1] = g; out[2] = b; out[3] = a;\n        return out;\n    }\n    function copyRgba(out, a) {\n        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n        return out;\n    }\n    var colorCache = new LRU(20);\n    var lastRemovedArr = null;\n    function putToCache(colorStr, rgbaArr) {\n        // Reuse removed array\n        if (lastRemovedArr) {\n            copyRgba(lastRemovedArr, rgbaArr);\n        }\n        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n    }\n    /**\n     * @param {string} colorStr\n     * @param {Array.<number>} out\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr, rgbaArr) {\n        if (!colorStr) {\n            return;\n        }\n        rgbaArr = rgbaArr || [];\n\n        var cached = colorCache.get(colorStr);\n        if (cached) {\n            return copyRgba(rgbaArr, cached);\n        }\n\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            copyRgba(rgbaArr, kCSSColorTable[str]);\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    setRgba(rgbaArr,\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    );\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsla':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsl':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                default:\n                    return;\n            }\n        }\n\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla, rgba) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        rgba = rgba || [];\n        setRgba(rgba,\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),\n            1\n        );\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array.\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>} will be null/undefined if input illegal.\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        out = out || [];\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssFloat(lerp(leftColor[3], rightColor[3], dv));\n\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<number>} arrColor like [12,33,44,0.4]\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color. (If input illegal, return undefined).\n     */\n    function stringify(arrColor, type) {\n        if (!arrColor || !arrColor.length) {\n            return;\n        }\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3Rvb2wvY29sb3IuanM/Mjg0ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0IsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsWUFBWSxZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlLGVBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZUFBZTtBQUM5QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLGVBQWU7QUFDOUIsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZUFBZTtBQUM5QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLGdCQUFnQjtBQUNoQyx5Q0FBeUMsd0RBQXdEO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgenJlbmRlci90b29sL2NvbG9yXG4gKi9cblxuXG4gICAgdmFyIExSVSA9IHJlcXVpcmUoJy4uL2NvcmUvTFJVJyk7XG5cbiAgICB2YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gICAgICAgICd0cmFuc3BhcmVudCc6IFswLDAsMCwwXSwgJ2FsaWNlYmx1ZSc6IFsyNDAsMjQ4LDI1NSwxXSxcbiAgICAgICAgJ2FudGlxdWV3aGl0ZSc6IFsyNTAsMjM1LDIxNSwxXSwgJ2FxdWEnOiBbMCwyNTUsMjU1LDFdLFxuICAgICAgICAnYXF1YW1hcmluZSc6IFsxMjcsMjU1LDIxMiwxXSwgJ2F6dXJlJzogWzI0MCwyNTUsMjU1LDFdLFxuICAgICAgICAnYmVpZ2UnOiBbMjQ1LDI0NSwyMjAsMV0sICdiaXNxdWUnOiBbMjU1LDIyOCwxOTYsMV0sXG4gICAgICAgICdibGFjayc6IFswLDAsMCwxXSwgJ2JsYW5jaGVkYWxtb25kJzogWzI1NSwyMzUsMjA1LDFdLFxuICAgICAgICAnYmx1ZSc6IFswLDAsMjU1LDFdLCAnYmx1ZXZpb2xldCc6IFsxMzgsNDMsMjI2LDFdLFxuICAgICAgICAnYnJvd24nOiBbMTY1LDQyLDQyLDFdLCAnYnVybHl3b29kJzogWzIyMiwxODQsMTM1LDFdLFxuICAgICAgICAnY2FkZXRibHVlJzogWzk1LDE1OCwxNjAsMV0sICdjaGFydHJldXNlJzogWzEyNywyNTUsMCwxXSxcbiAgICAgICAgJ2Nob2NvbGF0ZSc6IFsyMTAsMTA1LDMwLDFdLCAnY29yYWwnOiBbMjU1LDEyNyw4MCwxXSxcbiAgICAgICAgJ2Nvcm5mbG93ZXJibHVlJzogWzEwMCwxNDksMjM3LDFdLCAnY29ybnNpbGsnOiBbMjU1LDI0OCwyMjAsMV0sXG4gICAgICAgICdjcmltc29uJzogWzIyMCwyMCw2MCwxXSwgJ2N5YW4nOiBbMCwyNTUsMjU1LDFdLFxuICAgICAgICAnZGFya2JsdWUnOiBbMCwwLDEzOSwxXSwgJ2RhcmtjeWFuJzogWzAsMTM5LDEzOSwxXSxcbiAgICAgICAgJ2Rhcmtnb2xkZW5yb2QnOiBbMTg0LDEzNCwxMSwxXSwgJ2RhcmtncmF5JzogWzE2OSwxNjksMTY5LDFdLFxuICAgICAgICAnZGFya2dyZWVuJzogWzAsMTAwLDAsMV0sICdkYXJrZ3JleSc6IFsxNjksMTY5LDE2OSwxXSxcbiAgICAgICAgJ2RhcmtraGFraSc6IFsxODksMTgzLDEwNywxXSwgJ2RhcmttYWdlbnRhJzogWzEzOSwwLDEzOSwxXSxcbiAgICAgICAgJ2RhcmtvbGl2ZWdyZWVuJzogWzg1LDEwNyw0NywxXSwgJ2RhcmtvcmFuZ2UnOiBbMjU1LDE0MCwwLDFdLFxuICAgICAgICAnZGFya29yY2hpZCc6IFsxNTMsNTAsMjA0LDFdLCAnZGFya3JlZCc6IFsxMzksMCwwLDFdLFxuICAgICAgICAnZGFya3NhbG1vbic6IFsyMzMsMTUwLDEyMiwxXSwgJ2RhcmtzZWFncmVlbic6IFsxNDMsMTg4LDE0MywxXSxcbiAgICAgICAgJ2RhcmtzbGF0ZWJsdWUnOiBbNzIsNjEsMTM5LDFdLCAnZGFya3NsYXRlZ3JheSc6IFs0Nyw3OSw3OSwxXSxcbiAgICAgICAgJ2RhcmtzbGF0ZWdyZXknOiBbNDcsNzksNzksMV0sICdkYXJrdHVycXVvaXNlJzogWzAsMjA2LDIwOSwxXSxcbiAgICAgICAgJ2Rhcmt2aW9sZXQnOiBbMTQ4LDAsMjExLDFdLCAnZGVlcHBpbmsnOiBbMjU1LDIwLDE0NywxXSxcbiAgICAgICAgJ2RlZXBza3libHVlJzogWzAsMTkxLDI1NSwxXSwgJ2RpbWdyYXknOiBbMTA1LDEwNSwxMDUsMV0sXG4gICAgICAgICdkaW1ncmV5JzogWzEwNSwxMDUsMTA1LDFdLCAnZG9kZ2VyYmx1ZSc6IFszMCwxNDQsMjU1LDFdLFxuICAgICAgICAnZmlyZWJyaWNrJzogWzE3OCwzNCwzNCwxXSwgJ2Zsb3JhbHdoaXRlJzogWzI1NSwyNTAsMjQwLDFdLFxuICAgICAgICAnZm9yZXN0Z3JlZW4nOiBbMzQsMTM5LDM0LDFdLCAnZnVjaHNpYSc6IFsyNTUsMCwyNTUsMV0sXG4gICAgICAgICdnYWluc2Jvcm8nOiBbMjIwLDIyMCwyMjAsMV0sICdnaG9zdHdoaXRlJzogWzI0OCwyNDgsMjU1LDFdLFxuICAgICAgICAnZ29sZCc6IFsyNTUsMjE1LDAsMV0sICdnb2xkZW5yb2QnOiBbMjE4LDE2NSwzMiwxXSxcbiAgICAgICAgJ2dyYXknOiBbMTI4LDEyOCwxMjgsMV0sICdncmVlbic6IFswLDEyOCwwLDFdLFxuICAgICAgICAnZ3JlZW55ZWxsb3cnOiBbMTczLDI1NSw0NywxXSwgJ2dyZXknOiBbMTI4LDEyOCwxMjgsMV0sXG4gICAgICAgICdob25leWRldyc6IFsyNDAsMjU1LDI0MCwxXSwgJ2hvdHBpbmsnOiBbMjU1LDEwNSwxODAsMV0sXG4gICAgICAgICdpbmRpYW5yZWQnOiBbMjA1LDkyLDkyLDFdLCAnaW5kaWdvJzogWzc1LDAsMTMwLDFdLFxuICAgICAgICAnaXZvcnknOiBbMjU1LDI1NSwyNDAsMV0sICdraGFraSc6IFsyNDAsMjMwLDE0MCwxXSxcbiAgICAgICAgJ2xhdmVuZGVyJzogWzIzMCwyMzAsMjUwLDFdLCAnbGF2ZW5kZXJibHVzaCc6IFsyNTUsMjQwLDI0NSwxXSxcbiAgICAgICAgJ2xhd25ncmVlbic6IFsxMjQsMjUyLDAsMV0sICdsZW1vbmNoaWZmb24nOiBbMjU1LDI1MCwyMDUsMV0sXG4gICAgICAgICdsaWdodGJsdWUnOiBbMTczLDIxNiwyMzAsMV0sICdsaWdodGNvcmFsJzogWzI0MCwxMjgsMTI4LDFdLFxuICAgICAgICAnbGlnaHRjeWFuJzogWzIyNCwyNTUsMjU1LDFdLCAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiBbMjUwLDI1MCwyMTAsMV0sXG4gICAgICAgICdsaWdodGdyYXknOiBbMjExLDIxMSwyMTEsMV0sICdsaWdodGdyZWVuJzogWzE0NCwyMzgsMTQ0LDFdLFxuICAgICAgICAnbGlnaHRncmV5JzogWzIxMSwyMTEsMjExLDFdLCAnbGlnaHRwaW5rJzogWzI1NSwxODIsMTkzLDFdLFxuICAgICAgICAnbGlnaHRzYWxtb24nOiBbMjU1LDE2MCwxMjIsMV0sICdsaWdodHNlYWdyZWVuJzogWzMyLDE3OCwxNzAsMV0sXG4gICAgICAgICdsaWdodHNreWJsdWUnOiBbMTM1LDIwNiwyNTAsMV0sICdsaWdodHNsYXRlZ3JheSc6IFsxMTksMTM2LDE1MywxXSxcbiAgICAgICAgJ2xpZ2h0c2xhdGVncmV5JzogWzExOSwxMzYsMTUzLDFdLCAnbGlnaHRzdGVlbGJsdWUnOiBbMTc2LDE5NiwyMjIsMV0sXG4gICAgICAgICdsaWdodHllbGxvdyc6IFsyNTUsMjU1LDIyNCwxXSwgJ2xpbWUnOiBbMCwyNTUsMCwxXSxcbiAgICAgICAgJ2xpbWVncmVlbic6IFs1MCwyMDUsNTAsMV0sICdsaW5lbic6IFsyNTAsMjQwLDIzMCwxXSxcbiAgICAgICAgJ21hZ2VudGEnOiBbMjU1LDAsMjU1LDFdLCAnbWFyb29uJzogWzEyOCwwLDAsMV0sXG4gICAgICAgICdtZWRpdW1hcXVhbWFyaW5lJzogWzEwMiwyMDUsMTcwLDFdLCAnbWVkaXVtYmx1ZSc6IFswLDAsMjA1LDFdLFxuICAgICAgICAnbWVkaXVtb3JjaGlkJzogWzE4Niw4NSwyMTEsMV0sICdtZWRpdW1wdXJwbGUnOiBbMTQ3LDExMiwyMTksMV0sXG4gICAgICAgICdtZWRpdW1zZWFncmVlbic6IFs2MCwxNzksMTEzLDFdLCAnbWVkaXVtc2xhdGVibHVlJzogWzEyMywxMDQsMjM4LDFdLFxuICAgICAgICAnbWVkaXVtc3ByaW5nZ3JlZW4nOiBbMCwyNTAsMTU0LDFdLCAnbWVkaXVtdHVycXVvaXNlJzogWzcyLDIwOSwyMDQsMV0sXG4gICAgICAgICdtZWRpdW12aW9sZXRyZWQnOiBbMTk5LDIxLDEzMywxXSwgJ21pZG5pZ2h0Ymx1ZSc6IFsyNSwyNSwxMTIsMV0sXG4gICAgICAgICdtaW50Y3JlYW0nOiBbMjQ1LDI1NSwyNTAsMV0sICdtaXN0eXJvc2UnOiBbMjU1LDIyOCwyMjUsMV0sXG4gICAgICAgICdtb2NjYXNpbic6IFsyNTUsMjI4LDE4MSwxXSwgJ25hdmFqb3doaXRlJzogWzI1NSwyMjIsMTczLDFdLFxuICAgICAgICAnbmF2eSc6IFswLDAsMTI4LDFdLCAnb2xkbGFjZSc6IFsyNTMsMjQ1LDIzMCwxXSxcbiAgICAgICAgJ29saXZlJzogWzEyOCwxMjgsMCwxXSwgJ29saXZlZHJhYic6IFsxMDcsMTQyLDM1LDFdLFxuICAgICAgICAnb3JhbmdlJzogWzI1NSwxNjUsMCwxXSwgJ29yYW5nZXJlZCc6IFsyNTUsNjksMCwxXSxcbiAgICAgICAgJ29yY2hpZCc6IFsyMTgsMTEyLDIxNCwxXSwgJ3BhbGVnb2xkZW5yb2QnOiBbMjM4LDIzMiwxNzAsMV0sXG4gICAgICAgICdwYWxlZ3JlZW4nOiBbMTUyLDI1MSwxNTIsMV0sICdwYWxldHVycXVvaXNlJzogWzE3NSwyMzgsMjM4LDFdLFxuICAgICAgICAncGFsZXZpb2xldHJlZCc6IFsyMTksMTEyLDE0NywxXSwgJ3BhcGF5YXdoaXAnOiBbMjU1LDIzOSwyMTMsMV0sXG4gICAgICAgICdwZWFjaHB1ZmYnOiBbMjU1LDIxOCwxODUsMV0sICdwZXJ1JzogWzIwNSwxMzMsNjMsMV0sXG4gICAgICAgICdwaW5rJzogWzI1NSwxOTIsMjAzLDFdLCAncGx1bSc6IFsyMjEsMTYwLDIyMSwxXSxcbiAgICAgICAgJ3Bvd2RlcmJsdWUnOiBbMTc2LDIyNCwyMzAsMV0sICdwdXJwbGUnOiBbMTI4LDAsMTI4LDFdLFxuICAgICAgICAncmVkJzogWzI1NSwwLDAsMV0sICdyb3N5YnJvd24nOiBbMTg4LDE0MywxNDMsMV0sXG4gICAgICAgICdyb3lhbGJsdWUnOiBbNjUsMTA1LDIyNSwxXSwgJ3NhZGRsZWJyb3duJzogWzEzOSw2OSwxOSwxXSxcbiAgICAgICAgJ3NhbG1vbic6IFsyNTAsMTI4LDExNCwxXSwgJ3NhbmR5YnJvd24nOiBbMjQ0LDE2NCw5NiwxXSxcbiAgICAgICAgJ3NlYWdyZWVuJzogWzQ2LDEzOSw4NywxXSwgJ3NlYXNoZWxsJzogWzI1NSwyNDUsMjM4LDFdLFxuICAgICAgICAnc2llbm5hJzogWzE2MCw4Miw0NSwxXSwgJ3NpbHZlcic6IFsxOTIsMTkyLDE5MiwxXSxcbiAgICAgICAgJ3NreWJsdWUnOiBbMTM1LDIwNiwyMzUsMV0sICdzbGF0ZWJsdWUnOiBbMTA2LDkwLDIwNSwxXSxcbiAgICAgICAgJ3NsYXRlZ3JheSc6IFsxMTIsMTI4LDE0NCwxXSwgJ3NsYXRlZ3JleSc6IFsxMTIsMTI4LDE0NCwxXSxcbiAgICAgICAgJ3Nub3cnOiBbMjU1LDI1MCwyNTAsMV0sICdzcHJpbmdncmVlbic6IFswLDI1NSwxMjcsMV0sXG4gICAgICAgICdzdGVlbGJsdWUnOiBbNzAsMTMwLDE4MCwxXSwgJ3Rhbic6IFsyMTAsMTgwLDE0MCwxXSxcbiAgICAgICAgJ3RlYWwnOiBbMCwxMjgsMTI4LDFdLCAndGhpc3RsZSc6IFsyMTYsMTkxLDIxNiwxXSxcbiAgICAgICAgJ3RvbWF0byc6IFsyNTUsOTksNzEsMV0sICd0dXJxdW9pc2UnOiBbNjQsMjI0LDIwOCwxXSxcbiAgICAgICAgJ3Zpb2xldCc6IFsyMzgsMTMwLDIzOCwxXSwgJ3doZWF0JzogWzI0NSwyMjIsMTc5LDFdLFxuICAgICAgICAnd2hpdGUnOiBbMjU1LDI1NSwyNTUsMV0sICd3aGl0ZXNtb2tlJzogWzI0NSwyNDUsMjQ1LDFdLFxuICAgICAgICAneWVsbG93JzogWzI1NSwyNTUsMCwxXSwgJ3llbGxvd2dyZWVuJzogWzE1NCwyMDUsNTAsMV1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2xhbXBDc3NCeXRlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gICAgICAgIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gICAgICAgIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFtcENzc0FuZ2xlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAzNjAuXG4gICAgICAgIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gICAgICAgIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMzYwID8gMzYwIDogaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFtcENzc0Zsb2F0KGYpIHsgIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXG4gICAgICAgIHJldHVybiBmIDwgMCA/IDAgOiBmID4gMSA/IDEgOiBmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ3NzSW50KHN0cikgeyAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIGlmIChzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhbXBDc3NCeXRlKHBhcnNlSW50KHN0ciwgMTApKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNzc0Zsb2F0KHN0cikgeyAgLy8gZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgICAgICAgICAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhbXBDc3NGbG9hdChwYXJzZUZsb2F0KHN0cikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkge1xuICAgICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgICAgIGggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoID4gMSkge1xuICAgICAgICAgICAgaCAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGggKiA2IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGggKiAyIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG0yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoICogMyA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyLzMgLSBoKSAqIDY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxlcnAoYSwgYiwgcCkge1xuICAgICAgICByZXR1cm4gYSArIChiIC0gYSkgKiBwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFJnYmEob3V0LCByLCBnLCBiLCBhKSB7XG4gICAgICAgIG91dFswXSA9IHI7IG91dFsxXSA9IGc7IG91dFsyXSA9IGI7IG91dFszXSA9IGE7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlSZ2JhKG91dCwgYSkge1xuICAgICAgICBvdXRbMF0gPSBhWzBdOyBvdXRbMV0gPSBhWzFdOyBvdXRbMl0gPSBhWzJdOyBvdXRbM10gPSBhWzNdO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB2YXIgY29sb3JDYWNoZSA9IG5ldyBMUlUoMjApO1xuICAgIHZhciBsYXN0UmVtb3ZlZEFyciA9IG51bGw7XG4gICAgZnVuY3Rpb24gcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycikge1xuICAgICAgICAvLyBSZXVzZSByZW1vdmVkIGFycmF5XG4gICAgICAgIGlmIChsYXN0UmVtb3ZlZEFycikge1xuICAgICAgICAgICAgY29weVJnYmEobGFzdFJlbW92ZWRBcnIsIHJnYmFBcnIpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RSZW1vdmVkQXJyID0gY29sb3JDYWNoZS5wdXQoY29sb3JTdHIsIGxhc3RSZW1vdmVkQXJyIHx8IChyZ2JhQXJyLnNsaWNlKCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yU3RyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZShjb2xvclN0ciwgcmdiYUFycikge1xuICAgICAgICBpZiAoIWNvbG9yU3RyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmdiYUFyciA9IHJnYmFBcnIgfHwgW107XG5cbiAgICAgICAgdmFyIGNhY2hlZCA9IGNvbG9yQ2FjaGUuZ2V0KGNvbG9yU3RyKTtcbiAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcHlSZ2JhKHJnYmFBcnIsIGNhY2hlZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb2xvclN0ciBtYXkgYmUgbm90IHN0cmluZ1xuICAgICAgICBjb2xvclN0ciA9IGNvbG9yU3RyICsgJyc7XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLlxuICAgICAgICB2YXIgc3RyID0gY29sb3JTdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG4gICAgICAgIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHtcbiAgICAgICAgICAgIGNvcHlSZ2JhKHJnYmFBcnIsIGtDU1NDb2xvclRhYmxlW3N0cl0pO1xuICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICByZXR1cm4gcmdiYUFycjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuICAgICAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgIC8vIENvdmVycyBOYU4uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFycixcbiAgICAgICAgICAgICAgICAgICAgKChpdiAmIDB4ZjAwKSA+PiA0KSB8ICgoaXYgJiAweGYwMCkgPj4gOCksXG4gICAgICAgICAgICAgICAgICAgIChpdiAmIDB4ZjApIHwgKChpdiAmIDB4ZjApID4+IDQpLFxuICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGYpIHwgKChpdiAmIDB4ZikgPDwgNCksXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gNykge1xuICAgICAgICAgICAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgIC8vIENvdmVycyBOYU4uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFycixcbiAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmZjAwMDApID4+IDE2LFxuICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsXG4gICAgICAgICAgICAgICAgICAgIGl2ICYgMHhmZixcbiAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLCBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG4gICAgICAgIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZm5hbWUgPSBzdHIuc3Vic3RyKDAsIG9wKTtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wICsgMSwgZXAgLSAob3AgKyAxKSkuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IDE7ICAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuICAgICAgICAgICAgc3dpdGNoIChmbmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zLnBvcCgpKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFycixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQ3NzSW50KHBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUNzc0ludChwYXJhbXNbMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VDc3NJbnQocGFyYW1zWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmdiYUFycjtcbiAgICAgICAgICAgICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zWzNdID0gcGFyc2VDc3NGbG9hdChwYXJhbXNbM10pO1xuICAgICAgICAgICAgICAgICAgICBoc2xhMnJnYmEocGFyYW1zLCByZ2JhQXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhzbGEycmdiYShwYXJhbXMsIHJnYmFBcnIpO1xuICAgICAgICAgICAgICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoc2xhMnJnYmEoaHNsYSwgcmdiYSkge1xuICAgICAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQoaHNsYVswXSkgJSAzNjApICsgMzYwKSAlIDM2MCkgLyAzNjA7ICAvLyAwIC4uIDFcbiAgICAgICAgLy8gTk9URShkZWFubSk6IEFjY29yZGluZyB0byB0aGUgQ1NTIHNwZWMgcy9sIHNob3VsZCBvbmx5IGJlXG4gICAgICAgIC8vIHBlcmNlbnRhZ2VzLCBidXQgd2UgZG9uJ3QgYm90aGVyIGFuZCBsZXQgZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgdmFyIHMgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMV0pO1xuICAgICAgICB2YXIgbCA9IHBhcnNlQ3NzRmxvYXQoaHNsYVsyXSk7XG4gICAgICAgIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgbTEgPSBsICogMiAtIG0yO1xuXG4gICAgICAgIHJnYmEgPSByZ2JhIHx8IFtdO1xuICAgICAgICBzZXRSZ2JhKHJnYmEsXG4gICAgICAgICAgICBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoICsgMSAvIDMpICogMjU1KSxcbiAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGgpICogMjU1KSxcbiAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGggLSAxIC8gMykgKiAyNTUpLFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChoc2xhLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgcmdiYVszXSA9IGhzbGFbM107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmdiYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZ2JhMmhzbGEocmdiYSkge1xuICAgICAgICBpZiAoIXJnYmEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJHQiBmcm9tIDAgdG8gMjU1XG4gICAgICAgIHZhciBSID0gcmdiYVswXSAvIDI1NTtcbiAgICAgICAgdmFyIEcgPSByZ2JhWzFdIC8gMjU1O1xuICAgICAgICB2YXIgQiA9IHJnYmFbMl0gLyAyNTU7XG5cbiAgICAgICAgdmFyIHZNaW4gPSBNYXRoLm1pbihSLCBHLCBCKTsgLy8gTWluLiB2YWx1ZSBvZiBSR0JcbiAgICAgICAgdmFyIHZNYXggPSBNYXRoLm1heChSLCBHLCBCKTsgLy8gTWF4LiB2YWx1ZSBvZiBSR0JcbiAgICAgICAgdmFyIGRlbHRhID0gdk1heCAtIHZNaW47IC8vIERlbHRhIFJHQiB2YWx1ZVxuXG4gICAgICAgIHZhciBMID0gKHZNYXggKyB2TWluKSAvIDI7XG4gICAgICAgIHZhciBIO1xuICAgICAgICB2YXIgUztcbiAgICAgICAgLy8gSFNMIHJlc3VsdHMgZnJvbSAwIHRvIDFcbiAgICAgICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAgICAgICBIID0gMDtcbiAgICAgICAgICAgIFMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKEwgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICBTID0gZGVsdGEgLyAodk1heCArIHZNaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgUyA9IGRlbHRhIC8gKDIgLSB2TWF4IC0gdk1pbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkZWx0YVIgPSAoKCh2TWF4IC0gUikgLyA2KSArIChkZWx0YSAvIDIpKSAvIGRlbHRhO1xuICAgICAgICAgICAgdmFyIGRlbHRhRyA9ICgoKHZNYXggLSBHKSAvIDYpICsgKGRlbHRhIC8gMikpIC8gZGVsdGE7XG4gICAgICAgICAgICB2YXIgZGVsdGFCID0gKCgodk1heCAtIEIpIC8gNikgKyAoZGVsdGEgLyAyKSkgLyBkZWx0YTtcblxuICAgICAgICAgICAgaWYgKFIgPT09IHZNYXgpIHtcbiAgICAgICAgICAgICAgICBIID0gZGVsdGFCIC0gZGVsdGFHO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoRyA9PT0gdk1heCkge1xuICAgICAgICAgICAgICAgIEggPSAoMSAvIDMpICsgZGVsdGFSIC0gZGVsdGFCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQiA9PT0gdk1heCkge1xuICAgICAgICAgICAgICAgIEggPSAoMiAvIDMpICsgZGVsdGFHIC0gZGVsdGFSO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoSCA8IDApIHtcbiAgICAgICAgICAgICAgICBIICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChIID4gMSkge1xuICAgICAgICAgICAgICAgIEggLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoc2xhID0gW0ggKiAzNjAsIFMsIExdO1xuXG4gICAgICAgIGlmIChyZ2JhWzNdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhzbGEucHVzaChyZ2JhWzNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoc2xhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpZnQoY29sb3IsIGxldmVsKSB7XG4gICAgICAgIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcbiAgICAgICAgaWYgKGNvbG9yQXJyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JBcnJbaV0gPSBjb2xvckFycltpXSAqICgxIC0gbGV2ZWwpIHwgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yQXJyW2ldID0gKCgyNTUgLSBjb2xvckFycltpXSkgKiBsZXZlbCArIGNvbG9yQXJyW2ldKSB8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvckFyciwgY29sb3JBcnIubGVuZ3RoID09PSA0ID8gJ3JnYmEnIDogJ3JnYicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9IZXgoY29sb3IsIGxldmVsKSB7XG4gICAgICAgIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcbiAgICAgICAgaWYgKGNvbG9yQXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gKCgxIDw8IDI0KSArIChjb2xvckFyclswXSA8PCAxNikgKyAoY29sb3JBcnJbMV0gPDwgOCkgKyAoK2NvbG9yQXJyWzJdKSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFwIHZhbHVlIHRvIGNvbG9yLiBGYXN0ZXIgdGhhbiBtYXBUb0NvbG9yIG1ldGhvZHMgYmVjYXVzZSBjb2xvciBpcyByZXByZXNlbnRlZCBieSByZ2JhIGFycmF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBub3JtYWxpemVkVmFsdWUgQSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBjb2xvcnMgTGlzdCBvZiByZ2JhIGNvbG9yIGFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW291dF0gTWFwcGVkIGdiYSBjb2xvciBhcnJheVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSB3aWxsIGJlIG51bGwvdW5kZWZpbmVkIGlmIGlucHV0IGlsbGVnYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmFzdE1hcFRvQ29sb3Iobm9ybWFsaXplZFZhbHVlLCBjb2xvcnMsIG91dCkge1xuICAgICAgICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aClcbiAgICAgICAgICAgIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0ID0gb3V0IHx8IFtdO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIChjb2xvcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgdmFyIHJpZ2h0SW5kZXggPSBNYXRoLmNlaWwodmFsdWUpO1xuICAgICAgICB2YXIgbGVmdENvbG9yID0gY29sb3JzW2xlZnRJbmRleF07XG4gICAgICAgIHZhciByaWdodENvbG9yID0gY29sb3JzW3JpZ2h0SW5kZXhdO1xuICAgICAgICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcbiAgICAgICAgb3V0WzBdID0gY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpO1xuICAgICAgICBvdXRbMV0gPSBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSk7XG4gICAgICAgIG91dFsyXSA9IGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclsyXSwgcmlnaHRDb2xvclsyXSwgZHYpKTtcbiAgICAgICAgb3V0WzNdID0gY2xhbXBDc3NGbG9hdChsZXJwKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKTtcblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9ycyBDb2xvciBsaXN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZ1bGxPdXRwdXQgRGVmYXVsdCBmYWxzZS5cbiAgICAgKiBAcmV0dXJuIHsoc3RyaW5nfE9iamVjdCl9IFJlc3VsdCBjb2xvci4gSWYgZnVsbE91dHB1dCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29sb3I6IC4uLiwgbGVmdEluZGV4OiAuLi4sIHJpZ2h0SW5kZXg6IC4uLiwgdmFsdWU6IC4uLn0sXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBUb0NvbG9yKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBmdWxsT3V0cHV0KSB7XG4gICAgICAgIGlmICghKGNvbG9ycyAmJiBjb2xvcnMubGVuZ3RoKVxuICAgICAgICAgICAgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgICAgIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgICAgICAgdmFyIGxlZnRDb2xvciA9IHBhcnNlKGNvbG9yc1tsZWZ0SW5kZXhdKTtcbiAgICAgICAgdmFyIHJpZ2h0Q29sb3IgPSBwYXJzZShjb2xvcnNbcmlnaHRJbmRleF0pO1xuICAgICAgICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcblxuICAgICAgICB2YXIgY29sb3IgPSBzdHJpbmdpZnkoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpLFxuICAgICAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKSxcbiAgICAgICAgICAgICAgICBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMl0sIHJpZ2h0Q29sb3JbMl0sIGR2KSksXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NGbG9hdChsZXJwKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdyZ2JhJ1xuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBmdWxsT3V0cHV0XG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgbGVmdEluZGV4OiBsZWZ0SW5kZXgsXG4gICAgICAgICAgICAgICAgcmlnaHRJbmRleDogcmlnaHRJbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogY29sb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBoIDAgfiAzNjAsIGlnbm9yZSB3aGVuIG51bGwuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBzIDAgfiAxLCBpZ25vcmUgd2hlbiBudWxsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbCAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vZGlmeUhTTChjb2xvciwgaCwgcywgbCkge1xuICAgICAgICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgIGNvbG9yID0gcmdiYTJoc2xhKGNvbG9yKTtcbiAgICAgICAgICAgIGggIT0gbnVsbCAmJiAoY29sb3JbMF0gPSBjbGFtcENzc0FuZ2xlKGgpKTtcbiAgICAgICAgICAgIHMgIT0gbnVsbCAmJiAoY29sb3JbMV0gPSBwYXJzZUNzc0Zsb2F0KHMpKTtcbiAgICAgICAgICAgIGwgIT0gbnVsbCAmJiAoY29sb3JbMl0gPSBwYXJzZUNzc0Zsb2F0KGwpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShoc2xhMnJnYmEoY29sb3IpLCAncmdiYScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBhbHBoYSAwIH4gMVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbW9kaWZ5QWxwaGEoY29sb3IsIGFscGhhKSB7XG4gICAgICAgIGNvbG9yID0gcGFyc2UoY29sb3IpO1xuXG4gICAgICAgIGlmIChjb2xvciAmJiBhbHBoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb2xvclszXSA9IGNsYW1wQ3NzRmxvYXQoYWxwaGEpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvciwgJ3JnYmEnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFyckNvbG9yIGxpa2UgWzEyLDMzLDQ0LDAuNF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAncmdiYScsICdoc3ZhJywgLi4uXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHQgY29sb3IuIChJZiBpbnB1dCBpbGxlZ2FsLCByZXR1cm4gdW5kZWZpbmVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkoYXJyQ29sb3IsIHR5cGUpIHtcbiAgICAgICAgaWYgKCFhcnJDb2xvciB8fCAhYXJyQ29sb3IubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbG9yU3RyID0gYXJyQ29sb3JbMF0gKyAnLCcgKyBhcnJDb2xvclsxXSArICcsJyArIGFyckNvbG9yWzJdO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3JnYmEnIHx8IHR5cGUgPT09ICdoc3ZhJyB8fCB0eXBlID09PSAnaHNsYScpIHtcbiAgICAgICAgICAgIGNvbG9yU3RyICs9ICcsJyArIGFyckNvbG9yWzNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlICsgJygnICsgY29sb3JTdHIgKyAnKSc7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHBhcnNlOiBwYXJzZSxcbiAgICAgICAgbGlmdDogbGlmdCxcbiAgICAgICAgdG9IZXg6IHRvSGV4LFxuICAgICAgICBmYXN0TWFwVG9Db2xvcjogZmFzdE1hcFRvQ29sb3IsXG4gICAgICAgIG1hcFRvQ29sb3I6IG1hcFRvQ29sb3IsXG4gICAgICAgIG1vZGlmeUhTTDogbW9kaWZ5SFNMLFxuICAgICAgICBtb2RpZnlBbHBoYTogbW9kaWZ5QWxwaGEsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5XG4gICAgfTtcblxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvdG9vbC9jb2xvci5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports){eval("// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function () {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function (val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function (entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            entry.next = null;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function (entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function () {\n        return this._len;\n    };\n\n    /**\n     * Clear list\n     */\n    linkedListProto.clear = function () {\n        this.head = this.tail = null;\n        this._len = 0;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function (val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function (maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n\n        this._lastRemovedEntry = null;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     * @return {} Removed value\n     */\n    LRUProto.put = function (key, value) {\n        var list = this._list;\n        var map = this._map;\n        var removed = null;\n        if (map[key] == null) {\n            var len = list.len();\n            // Reuse last removed entry\n            var entry = this._lastRemovedEntry;\n\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n\n                removed = leastUsedEntry.value;\n                this._lastRemovedEntry = leastUsedEntry;\n            }\n\n            if (entry) {\n                entry.value = value;\n            }\n            else {\n                entry = new Entry(value);\n            }\n            entry.key = key;\n            list.insertEntry(entry);\n            map[key] = entry;\n        }\n\n        return removed;\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function (key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function () {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvTFJVLmpzPzAxOGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTaW1wbGUgTFJVIGNhY2hlIHVzZSBkb3VibHkgbGlua2VkIGxpc3Rcbi8vIEBtb2R1bGUgenJlbmRlci9jb3JlL0xSVVxuXG5cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgZG91YmxlIGxpbmtlZCBsaXN0LiBDb21wYXJlZCB3aXRoIGFycmF5LCBpdCBoYXMgTygxKSByZW1vdmUgb3BlcmF0aW9uLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2xlbiA9IDA7XG4gICAgfTtcblxuICAgIHZhciBsaW5rZWRMaXN0UHJvdG8gPSBMaW5rZWRMaXN0LnByb3RvdHlwZTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBuZXcgdmFsdWUgYXQgdGhlIHRhaWxcbiAgICAgKiBAcGFyYW0gIHt9IHZhbFxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgICAqL1xuICAgIGxpbmtlZExpc3RQcm90by5pbnNlcnQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG5ldyBFbnRyeSh2YWwpO1xuICAgICAgICB0aGlzLmluc2VydEVudHJ5KGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYW4gZW50cnkgYXQgdGhlIHRhaWxcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAgICAgKi9cbiAgICBsaW5rZWRMaXN0UHJvdG8uaW5zZXJ0RW50cnkgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5LnByZXYgPSB0aGlzLnRhaWw7XG4gICAgICAgICAgICBlbnRyeS5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xlbisrO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZW50cnkuXG4gICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9IGVudHJ5XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnByZXY7XG4gICAgICAgIHZhciBuZXh0ID0gZW50cnkubmV4dDtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJcyBoZWFkXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSXMgdGFpbFxuICAgICAgICAgICAgdGhpcy50YWlsID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeS5uZXh0ID0gZW50cnkucHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xlbi0tO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLmxlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgbGlzdFxuICAgICAqL1xuICAgIGxpbmtlZExpc3RQcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHt9IHZhbFxuICAgICAqL1xuICAgIHZhciBFbnRyeSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHt9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5leHQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTFJVIENhY2hlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2NvcmUvTFJVXG4gICAgICovXG4gICAgdmFyIExSVSA9IGZ1bmN0aW9uIChtYXhTaXplKSB7XG5cbiAgICAgICAgdGhpcy5fbGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XG5cbiAgICAgICAgdGhpcy5fbWFwID0ge307XG5cbiAgICAgICAgdGhpcy5fbWF4U2l6ZSA9IG1heFNpemUgfHwgMTA7XG5cbiAgICAgICAgdGhpcy5fbGFzdFJlbW92ZWRFbnRyeSA9IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBMUlVQcm90byA9IExSVS5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSAge30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHt9IFJlbW92ZWQgdmFsdWVcbiAgICAgKi9cbiAgICBMUlVQcm90by5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gICAgICAgIHZhciByZW1vdmVkID0gbnVsbDtcbiAgICAgICAgaWYgKG1hcFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBsaXN0LmxlbigpO1xuICAgICAgICAgICAgLy8gUmV1c2UgbGFzdCByZW1vdmVkIGVudHJ5XG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5O1xuXG4gICAgICAgICAgICBpZiAobGVuID49IHRoaXMuX21heFNpemUgJiYgbGVuID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZFxuICAgICAgICAgICAgICAgIHZhciBsZWFzdFVzZWRFbnRyeSA9IGxpc3QuaGVhZDtcbiAgICAgICAgICAgICAgICBsaXN0LnJlbW92ZShsZWFzdFVzZWRFbnRyeSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hcFtsZWFzdFVzZWRFbnRyeS5rZXldO1xuXG4gICAgICAgICAgICAgICAgcmVtb3ZlZCA9IGxlYXN0VXNlZEVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RSZW1vdmVkRW50cnkgPSBsZWFzdFVzZWRFbnRyeTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgZW50cnkudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVudHJ5ID0gbmV3IEVudHJ5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJ5LmtleSA9IGtleTtcbiAgICAgICAgICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgbWFwW2tleV0gPSBlbnRyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm4ge31cbiAgICAgKi9cbiAgICBMUlVQcm90by5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX21hcFtrZXldO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gICAgICAgIGlmIChlbnRyeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBQdXQgdGhlIGxhdGVzdCB1c2VkIGVudHJ5IGluIHRoZSB0YWlsXG4gICAgICAgICAgICBpZiAoZW50cnkgIT09IGxpc3QudGFpbCkge1xuICAgICAgICAgICAgICAgIGxpc3QucmVtb3ZlKGVudHJ5KTtcbiAgICAgICAgICAgICAgICBsaXN0Lmluc2VydEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjYWNoZVxuICAgICAqL1xuICAgIExSVVByb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9saXN0LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX21hcCA9IHt9O1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExSVTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL0xSVS5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\n        var config = __webpack_require__(50);\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvbG9nLmpzPzI2YTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAgICAgdmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL3Rvb2wvbG9nXG4gICAgICAgICAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuZGVidWdNb2RlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLmRlYnVnTW9kZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3VtZW50c1trXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLmRlYnVnTW9kZSA+IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHNba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKiBmb3IgZGVidWdcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG1lcykge1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dyb25nLW1lc3NhZ2UnKS5pbm5lckhUTUwgPVxuICAgICAgICAgICAgICAgIG1lcyArICcgJyArIChuZXcgRGF0ZSgpIC0gMClcbiAgICAgICAgICAgICAgICArICc8YnIvPidcbiAgICAgICAgICAgICAgICArIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3cm9uZy1tZXNzYWdlJykuaW5uZXJIVE1MO1xuICAgICAgICB9O1xuICAgICAgICAqL1xuICAgIFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvbG9nLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config默认配置项\n     * @exports zrender/config\n     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debug日志选项：catchBrushException为true下有效\n         * 0 : 不生成debug数据，发布用\n         * 1 : 异常抛出，调试用\n         * 2 : 控制台输出，调试用\n         */\n        debugMode: 0,\n\n        // retina 屏幕优化\n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbmZpZy5qcz8yODYxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICB2YXIgZHByID0gMTtcbiAgICAvLyBJZiBpbiBicm93c2VyIGVudmlyb25tZW50XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRwciA9IE1hdGgubWF4KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25maWfpu5jorqTphY3nva7poblcbiAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL2NvbmZpZ1xuICAgICAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICAgICAqL1xuICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZWJ1Z+aXpeW/l+mAiemhue+8mmNhdGNoQnJ1c2hFeGNlcHRpb27kuLp0cnVl5LiL5pyJ5pWIXG4gICAgICAgICAqIDAgOiDkuI3nlJ/miJBkZWJ1Z+aVsOaNru+8jOWPkeW4g+eUqFxuICAgICAgICAgKiAxIDog5byC5bi45oqb5Ye677yM6LCD6K+V55SoXG4gICAgICAgICAqIDIgOiDmjqfliLblj7DovpPlh7rvvIzosIPor5XnlKhcbiAgICAgICAgICovXG4gICAgICAgIGRlYnVnTW9kZTogMCxcblxuICAgICAgICAvLyByZXRpbmEg5bGP5bmV5LyY5YyWXG4gICAgICAgIGRldmljZVBpeGVsUmF0aW86IGRwclxuICAgIH07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb25maWc7XG5cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = __webpack_require__(24);\n    var BoundingRect = __webpack_require__(25);\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var textOffset = style.textOffset;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n            rect = style.textPositionRect || rect;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            if (textOffset) {\n                x += textOffset[0];\n                y += textOffset[1];\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                // Fill after stroke so the outline will not cover the main part.\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                textFill && ctx.fillText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanM/OTRlYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1peGluIGZvciBkcmF3aW5nIHRleHQgaW4gYSBlbGVtZW50IGJvdW5kaW5nIHJlY3RcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9SZWN0VGV4dFxuICovXG5cblxuXG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnLi4vLi4vY29udGFpbi90ZXh0Jyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG5cbiAgICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoKTtcblxuICAgIHZhciBSZWN0VGV4dCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VQZXJjZW50KHZhbHVlLCBtYXhWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxhc3RJbmRleE9mKCclJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIG1heFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBSZWN0VGV4dC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFJlY3RUZXh0LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmF3IHRleHQgaW4gYSByZWN0IHdpdGggc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0fSBjdHhcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSByZWN0IERpc3BsYXlhYmxlIHJlY3RcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0ZXh0UmVjdCBBbHRlcm5hdGl2ZSBwcmVjYWxjdWxhdGVkIHRleHQgYm91bmRpbmcgcmVjdFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhd1JlY3RUZXh0OiBmdW5jdGlvbiAoY3R4LCByZWN0LCB0ZXh0UmVjdCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gc3RyaW5nXG4gICAgICAgICAgICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuICAgICAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgICB2YXIgeTtcbiAgICAgICAgICAgIHZhciB0ZXh0UG9zaXRpb24gPSBzdHlsZS50ZXh0UG9zaXRpb247XG4gICAgICAgICAgICB2YXIgdGV4dE9mZnNldCA9IHN0eWxlLnRleHRPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBzdHlsZS50ZXh0RGlzdGFuY2U7XG4gICAgICAgICAgICB2YXIgYWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gICAgICAgICAgICB2YXIgZm9udCA9IHN0eWxlLnRleHRGb250IHx8IHN0eWxlLmZvbnQ7XG4gICAgICAgICAgICB2YXIgYmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICB2YXIgdmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduO1xuICAgICAgICAgICAgcmVjdCA9IHN0eWxlLnRleHRQb3NpdGlvblJlY3QgfHwgcmVjdDtcblxuICAgICAgICAgICAgdGV4dFJlY3QgPSB0ZXh0UmVjdCB8fCB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgYWxpZ24sIGJhc2VsaW5lKTtcblxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHJlY3QgdG8gdmlldyBzcGFjZVxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgaWYgKCFzdHlsZS50ZXh0VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0bXBSZWN0LmNvcHkocmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHRtcFJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGV4dCBwb3NpdGlvbiByZXByZXNlbnRlZCBieSBjb29yZFxuICAgICAgICAgICAgaWYgKHRleHRQb3NpdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgLy8gUGVyY2VudFxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzBdLCByZWN0LndpZHRoKTtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblsxXSwgcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGFsaWduID0gYWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJhc2VsaW5lID0gYmFzZWxpbmUgfHwgJ3RvcCc7XG5cbiAgICAgICAgICAgICAgICBpZiAodmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSB0ZXh0UmVjdC5oZWlnaHQgLyAyIC0gdGV4dFJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gdGV4dFJlY3QuaGVpZ2h0IC0gdGV4dFJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gdGV4dFJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgYnNlbGluZSB0byBiZSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgYmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KFxuICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb24sIHJlY3QsIHRleHRSZWN0LCBkaXN0YW5jZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgeCA9IHJlcy54O1xuICAgICAgICAgICAgICAgIHkgPSByZXMueTtcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGFsaWduIGFuZCBiYXNlbGluZSB3aGVuIGhhcyB0ZXh0UG9zaXRpb25cbiAgICAgICAgICAgICAgICBhbGlnbiA9IGFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgYmFzZWxpbmUgPSBiYXNlbGluZSB8fCByZXMudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGV4dE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHggKz0gdGV4dE9mZnNldFswXTtcbiAgICAgICAgICAgICAgICB5ICs9IHRleHRPZmZzZXRbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgZGVmYXVsdCBsZWZ0IHRleHRBbGlnbi4gR2l2aW5nIGludmFsaWQgdmFsdWUgd2lsbCBjYXVzZSBzdGF0ZSBub3QgY2hhbmdlXG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gYWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyBkZWZhdWx0IGFscGhhYmV0aWMgYmFzZWxpbmVcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBiYXNlbGluZSB8fCAnYWxwaGFiZXRpYyc7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0RmlsbCA9IHN0eWxlLnRleHRGaWxsO1xuICAgICAgICAgICAgdmFyIHRleHRTdHJva2UgPSBzdHlsZS50ZXh0U3Ryb2tlO1xuICAgICAgICAgICAgdGV4dEZpbGwgJiYgKGN0eC5maWxsU3R5bGUgPSB0ZXh0RmlsbCk7XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlICYmIChjdHguc3Ryb2tlU3R5bGUgPSB0ZXh0U3Ryb2tlKTtcblxuICAgICAgICAgICAgLy8gVE9ETyBJbnZhbGlkIGZvbnRcbiAgICAgICAgICAgIGN0eC5mb250ID0gZm9udCB8fCAnMTJweCBzYW5zLXNlcmlmJztcblxuICAgICAgICAgICAgLy8gVGV4dCBzaGFkb3dcbiAgICAgICAgICAgIC8vIEFsd2F5cyBzZXQgc2hhZG93Qmx1ciBhbmQgc2hhZG93T2Zmc2V0IHRvIGF2b2lkIGxlYWsgZnJvbSBkaXNwbGF5YWJsZVxuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSBzdHlsZS50ZXh0U2hhZG93Qmx1cjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHN0eWxlLnRleHRTaGFkb3dDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WDtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gc3R5bGUudGV4dFNoYWRvd09mZnNldFk7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0TGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlLnRleHRSb3RhdGlvbikge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSAmJiBjdHgudHJhbnNsYXRlKHRyYW5zZm9ybVs0XSwgdHJhbnNmb3JtWzVdKTtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKHN0eWxlLnRleHRSb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtICYmIGN0eC50cmFuc2xhdGUoLXRyYW5zZm9ybVs0XSwgLXRyYW5zZm9ybVs1XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlsbCBhZnRlciBzdHJva2Ugc28gdGhlIG91dGxpbmUgd2lsbCBub3QgY292ZXIgdGhlIG1haW4gcGFydC5cbiAgICAgICAgICAgICAgICB0ZXh0U3Ryb2tlICYmIGN0eC5zdHJva2VUZXh0KHRleHRMaW5lc1tpXSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgdGV4dEZpbGwgJiYgY3R4LmZpbGxUZXh0KHRleHRMaW5lc1tpXSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgeSArPSB0ZXh0UmVjdC5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUmVjdFRleHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n/**\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n * 可以用于 isInsidePath 判断以及获取boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = __webpack_require__(53);\n    var vec2 = __webpack_require__(26);\n    var bbox = __webpack_require__(54);\n    var BoundingRect = __webpack_require__(25);\n    var dpr = __webpack_require__(50).devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    // var CMD_MEM_SIZE = {\n    //     M: 3,\n    //     L: 3,\n    //     C: 7,\n    //     Q: 5,\n    //     A: 9,\n    //     R: 5,\n    //     Z: 1\n    // };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function (notSaveData) {\n\n        this._saveData = !(notSaveData || false);\n\n        if (this._saveData) {\n            /**\n             * Path data. Stored as flat array\n             * @type {Array.<Object>}\n             */\n            this.data = [];\n        }\n\n        this._ctx = null;\n    };\n\n    /**\n     * 快速计算Path包围盒（并不是最小包围盒）\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _xi: 0,\n        _yi: 0,\n\n        _x0: 0,\n        _y0: 0,\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        _ux: 0,\n        _uy: 0,\n\n        _len: 0,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            if (this._saveData) {\n                this._len = 0;\n            }\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._yi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n         * stroke 同样\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         * 直接设置 Path 数据\n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * 添加子路径\n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         * 填充 Path 数据。\n         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n         */\n        addData: function (cmd) {\n            if (!this._saveData) {\n                return;\n            }\n\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                // 因为之前的数组已经转换成静态的 Float32Array\n                // 所以不够用时需要扩展一个新的动态数组\n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         * 转成静态的 Float32Array 减少堆内存占用\n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                        // 在 closePath 的时候使用\n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc 判断的开销比较大\n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc 旋转\n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvUGF0aFByb3h5LmpzPzY5ZTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLG9FQUFvRTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0EsK0JBQStCLDJCQUEyQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixpQkFBaUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiI1Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogUGF0aCDku6PnkIbvvIzlj6/ku6XlnKhgYnVpbGRQYXRoYOS4reeUqOS6juabv+S7o2BjdHhgLCDkvJrkv53lrZjmr4/kuKpwYXRo5pON5L2c55qE5ZG95Luk5YiwcGF0aENvbW1hbmRz5bGe5oCn5LitXG4gKiDlj6/ku6XnlKjkuo4gaXNJbnNpZGVQYXRoIOWIpOaWreS7peWPiuiOt+WPlmJvdW5kaW5nUmVjdFxuICpcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL1BhdGhQcm94eVxuICogQGF1dGhvciBZaSBTaGVuIChodHRwOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG4gLy8gVE9ETyBnZXRUb3RhbExlbmd0aCwgZ2V0UG9pbnRBdExlbmd0aFxuXG5cbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJyk7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciBiYm94ID0gcmVxdWlyZSgnLi9iYm94Jyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4vQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIGRwciA9IHJlcXVpcmUoJy4uL2NvbmZpZycpLmRldmljZVBpeGVsUmF0aW87XG5cbiAgICB2YXIgQ01EID0ge1xuICAgICAgICBNOiAxLFxuICAgICAgICBMOiAyLFxuICAgICAgICBDOiAzLFxuICAgICAgICBROiA0LFxuICAgICAgICBBOiA1LFxuICAgICAgICBaOiA2LFxuICAgICAgICAvLyBSZWN0XG4gICAgICAgIFI6IDdcbiAgICB9O1xuXG4gICAgLy8gdmFyIENNRF9NRU1fU0laRSA9IHtcbiAgICAvLyAgICAgTTogMyxcbiAgICAvLyAgICAgTDogMyxcbiAgICAvLyAgICAgQzogNyxcbiAgICAvLyAgICAgUTogNSxcbiAgICAvLyAgICAgQTogOSxcbiAgICAvLyAgICAgUjogNSxcbiAgICAvLyAgICAgWjogMVxuICAgIC8vIH07XG5cbiAgICB2YXIgbWluID0gW107XG4gICAgdmFyIG1heCA9IFtdO1xuICAgIHZhciBtaW4yID0gW107XG4gICAgdmFyIG1heDIgPSBbXTtcbiAgICB2YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgbWF0aFNpbiA9IE1hdGguc2luO1xuICAgIHZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgdmFyIGhhc1R5cGVkQXJyYXkgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9ICd1bmRlZmluZWQnO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFBhdGhQcm94eSA9IGZ1bmN0aW9uIChub3RTYXZlRGF0YSkge1xuXG4gICAgICAgIHRoaXMuX3NhdmVEYXRhID0gIShub3RTYXZlRGF0YSB8fCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhdGggZGF0YS4gU3RvcmVkIGFzIGZsYXQgYXJyYXlcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jdHggPSBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDlv6vpgJ/orqHnrpdQYXRo5YyF5Zu055uS77yI5bm25LiN5piv5pyA5bCP5YyF5Zu055uS77yJXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIFBhdGhQcm94eS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFBhdGhQcm94eSxcblxuICAgICAgICBfeGk6IDAsXG4gICAgICAgIF95aTogMCxcblxuICAgICAgICBfeDA6IDAsXG4gICAgICAgIF95MDogMCxcbiAgICAgICAgLy8gVW5pdCB4LCBVbml0IHkuIFByb3ZpZGUgZm9yIGF2b2lkaW5nIGRyYXdpbmcgdGhhdCB0b28gc2hvcnQgbGluZSBzZWdtZW50XG4gICAgICAgIF91eDogMCxcbiAgICAgICAgX3V5OiAwLFxuXG4gICAgICAgIF9sZW46IDAsXG5cbiAgICAgICAgX2xpbmVEYXNoOiBudWxsLFxuXG4gICAgICAgIF9kYXNoT2Zmc2V0OiAwLFxuXG4gICAgICAgIF9kYXNoSWR4OiAwLFxuXG4gICAgICAgIF9kYXNoU3VtOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHNldFNjYWxlOiBmdW5jdGlvbiAoc3gsIHN5KSB7XG4gICAgICAgICAgICB0aGlzLl91eCA9IG1hdGhBYnMoMSAvIGRwciAvIHN4KSB8fCAwO1xuICAgICAgICAgICAgdGhpcy5fdXkgPSBtYXRoQWJzKDEgLyBkcHIgLyBzeSkgfHwgMDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3R4O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGJlZ2luUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuXG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG5cbiAgICAgICAgICAgIGN0eCAmJiBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIGN0eCAmJiAodGhpcy5kcHIgPSBjdHguZHByKTtcblxuICAgICAgICAgICAgLy8gUmVzZXRcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlRGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlbiA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5lRGFzaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVEYXNoID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIG1vdmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuTSwgeCwgeSk7XG4gICAgICAgICAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4Lm1vdmVUbyh4LCB5KTtcblxuICAgICAgICAgICAgLy8geDAsIHkwLCB4aSwgeWkg5piv6K6w5b2V5ZyoIF9kYXNoZWRYWFhYVG8g5pa55rOV5Lit5L2/55SoXG4gICAgICAgICAgICAvLyB4aSwgeWkg6K6w5b2V5b2T5YmN54K5LCB4MCwgeTAg5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnlm57liLDotbflp4vngrnjgIJcbiAgICAgICAgICAgIC8vIOacieWPr+iDveWcqCBiZWdpblBhdGgg5LmL5ZCO55u05o6l6LCD55SoIGxpbmVUb++8jOi/meaXtuWAmSB4MCwgeTAg6ZyA6KaBXG4gICAgICAgICAgICAvLyDlnKggbGluZVRvIOaWueazleS4reiusOW9le+8jOi/memHjOWFiOS4jeiAg+iZkei/meenjeaDheWGte+8jGRhc2hlZCBsaW5lIOS5n+WPquWcqCBJRTEwLSDkuK3kuI3mlK/mjIFcbiAgICAgICAgICAgIHRoaXMuX3gwID0geDtcbiAgICAgICAgICAgIHRoaXMuX3kwID0geTtcblxuICAgICAgICAgICAgdGhpcy5feGkgPSB4O1xuICAgICAgICAgICAgdGhpcy5feWkgPSB5O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGxpbmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBleGNlZWRVbml0ID0gbWF0aEFicyh4IC0gdGhpcy5feGkpID4gdGhpcy5fdXhcbiAgICAgICAgICAgICAgICB8fCBtYXRoQWJzKHkgLSB0aGlzLl95aSkgPiB0aGlzLl91eVxuICAgICAgICAgICAgICAgIC8vIEZvcmNlIGRyYXcgdGhlIGZpcnN0IHNlZ21lbnRcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9sZW4gPCA1O1xuXG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELkwsIHgsIHkpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fY3R4ICYmIGV4Y2VlZFVuaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZExpbmVUbyh4LCB5KVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2N0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhjZWVkVW5pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3hpID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl95aSA9IHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5M1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELkMsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MylcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9jdHguYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDM7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHkzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTJcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuUSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkUXVhZHJhdGljVG8oeDEsIHkxLCB4MiwgeTIpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fY3R4LnF1YWRyYXRpY0N1cnZlVG8oeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5feGkgPSB4MjtcbiAgICAgICAgICAgIHRoaXMuX3lpID0geTI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBlbmRBbmdsZVxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBhbnRpY2xvY2t3aXNlXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgYXJjOiBmdW5jdGlvbiAoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKFxuICAgICAgICAgICAgICAgIENNRC5BLCBjeCwgY3ksIHIsIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSwgMCwgYW50aWNsb2Nrd2lzZSA/IDAgOiAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5hcmMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3hpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByICsgY3g7XG4gICAgICAgICAgICB0aGlzLl95aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogciArIGN4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICBhcmNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHguYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgICAgICAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELlIsIHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2VQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELlopO1xuXG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5feDA7XG4gICAgICAgICAgICB2YXIgeTAgPSB0aGlzLl95MDtcbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSAmJiB0aGlzLl9kYXNoZWRMaW5lVG8oeDAsIHkwKTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDA7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHkwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRleHQg5LuO5aSW6YOo5Lyg5YWl77yM5Zug5Li65pyJ5Y+v6IO95pivIHJlYnVpbGRQYXRoIOWujOS5i+WQjuWGjSBmaWxs44CCXG4gICAgICAgICAqIHN0cm9rZSDlkIzmoLdcbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGZpbGw6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIGN0eCAmJiBjdHguZmlsbCgpO1xuICAgICAgICAgICAgdGhpcy50b1N0YXRpYygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgc3Ryb2tlOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBjdHggJiYgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgdGhpcy50b1N0YXRpYygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICAgICAgICogTXVzdCBiZSBpbnZva2VkIGJlZm9yZSBhbGwgb3RoZXIgcGF0aCBkcmF3aW5nIG1ldGhvZHNcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBzZXRMaW5lRGFzaDogZnVuY3Rpb24gKGxpbmVEYXNoKSB7XG4gICAgICAgICAgICBpZiAobGluZURhc2ggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVEYXNoID0gbGluZURhc2g7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kYXNoSWR4ID0gMDtcblxuICAgICAgICAgICAgICAgIHZhciBsaW5lRGFzaFN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lRGFzaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lRGFzaFN1bSArPSBsaW5lRGFzaFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGFzaFN1bSA9IGxpbmVEYXNoU3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW/hemhu+WcqOWFtuWug+e7mOWItuWRveS7pOWJjeiwg+eUqFxuICAgICAgICAgKiBNdXN0IGJlIGludm9rZWQgYmVmb3JlIGFsbCBvdGhlciBwYXRoIGRyYXdpbmcgbWV0aG9kc1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIHNldExpbmVEYXNoT2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBsZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOebtOaOpeiuvue9riBQYXRoIOaVsOaNrlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcblxuICAgICAgICAgICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoISAodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5sZW5ndGggPT0gbGVuKSAmJiBoYXNUeXBlZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gZGF0YVtpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbGVuID0gbGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlrZDot6/lvoRcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eXxBcnJheS48bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHk+fSBwYXRoXG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBbcGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYXBwZW5kU2l6ZSA9IDA7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fbGVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFwcGVuZFNpemUgKz0gcGF0aFtpXS5sZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNUeXBlZEFycmF5ICYmICh0aGlzLmRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShvZmZzZXQgKyBhcHBlbmRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBwZW5kUGF0aERhdGEgPSBwYXRoW2ldLmRhdGE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcHBlbmRQYXRoRGF0YS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbb2Zmc2V0KytdID0gYXBwZW5kUGF0aERhdGFba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGVuID0gb2Zmc2V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDloavlhYUgUGF0aCDmlbDmja7jgIJcbiAgICAgICAgICog5bC96YeP5aSN55So6ICM5LiN55Sz5piO5paw55qE5pWw57uE44CC5aSn6YOo5YiG5Zu+5b2i6YeN57uY55qE5oyH5Luk5pWw5o2u6ZW/5bqm6YO95piv5LiN5Y+Y55qE44CCXG4gICAgICAgICAqL1xuICAgICAgICBhZGREYXRhOiBmdW5jdGlvbiAoY21kKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZW4gKyBhcmd1bWVudHMubGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyDlm6DkuLrkuYvliY3nmoTmlbDnu4Tlt7Lnu4/ovazmjaLmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5XG4gICAgICAgICAgICAgICAgLy8g5omA5Lul5LiN5aSf55So5pe26ZyA6KaB5omp5bGV5LiA5Liq5paw55qE5Yqo5oCB5pWw57uEXG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kRGF0YSgpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRhdGFbdGhpcy5fbGVuKytdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9wcmV2Q21kID0gY21kO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9leHBhbmREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGlmIGRhdGEgaXMgRmxvYXQzMkFycmF5XG4gICAgICAgICAgICBpZiAoISh0aGlzLmRhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtpXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3RGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbmVlZHMganMgaW1wbGVtZW50ZWQgZGFzaGVkIGxpbmVcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9uZWVkc0Rhc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lRGFzaDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGFzaGVkTGluZVRvOiBmdW5jdGlvbiAoeDEsIHkxKSB7XG4gICAgICAgICAgICB2YXIgZGFzaFN1bSA9IHRoaXMuX2Rhc2hTdW07XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblxuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgICAgICAgICB2YXIgeTAgPSB0aGlzLl95aTtcbiAgICAgICAgICAgIHZhciBkeCA9IHgxIC0geDA7XG4gICAgICAgICAgICB2YXIgZHkgPSB5MSAtIHkwO1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBtYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICB2YXIgeCA9IHgwO1xuICAgICAgICAgICAgdmFyIHkgPSB5MDtcbiAgICAgICAgICAgIHZhciBkYXNoO1xuICAgICAgICAgICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGlkeDtcbiAgICAgICAgICAgIGR4IC89IGRpc3Q7XG4gICAgICAgICAgICBkeSAvPSBkaXN0O1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZGFzaFN1bSArIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgICAgICAgICAgeCAtPSBvZmZzZXQgKiBkeDtcbiAgICAgICAgICAgIHkgLT0gb2Zmc2V0ICogZHk7XG5cbiAgICAgICAgICAgIHdoaWxlICgoZHggPiAwICYmIHggPD0geDEpIHx8IChkeCA8IDAgJiYgeCA+PSB4MSlcbiAgICAgICAgICAgIHx8IChkeCA9PSAwICYmICgoZHkgPiAwICYmIHkgPD0geTEpIHx8IChkeSA8IDAgJiYgeSA+PSB5MSkpKSkge1xuICAgICAgICAgICAgICAgIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgICAgICAgICAgICAgZGFzaCA9IGxpbmVEYXNoW2lkeF07XG4gICAgICAgICAgICAgICAgeCArPSBkeCAqIGRhc2g7XG4gICAgICAgICAgICAgICAgeSArPSBkeSAqIGRhc2g7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGFzaElkeCA9IChpZHggKyAxKSAlIG5EYXNoO1xuICAgICAgICAgICAgICAgIC8vIFNraXAgcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgaWYgKChkeCA+IDAgJiYgeCA8IHgwKSB8fCAoZHggPCAwICYmIHggPiB4MCkgfHwgKGR5ID4gMCAmJiB5IDwgeTApIHx8IChkeSA8IDAgJiYgeSA+IHkwKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4W2lkeCAlIDIgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShcbiAgICAgICAgICAgICAgICAgICAgZHggPj0gMCA/IG1hdGhNaW4oeCwgeDEpIDogbWF0aE1heCh4LCB4MSksXG4gICAgICAgICAgICAgICAgICAgIGR5ID49IDAgPyBtYXRoTWluKHksIHkxKSA6IG1hdGhNYXgoeSwgeTEpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9mZnNldCBmb3IgbmV4dCBsaW5lVG9cbiAgICAgICAgICAgIGR4ID0geCAtIHgxO1xuICAgICAgICAgICAgZHkgPSB5IC0geTE7XG4gICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gLW1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBOb3QgYWNjdXJhdGUgZGFzaGVkIGxpbmUgdG9cbiAgICAgICAgX2Rhc2hlZEJlemllclRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICAgICAgdmFyIGRhc2hTdW0gPSB0aGlzLl9kYXNoU3VtO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2Rhc2hPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cbiAgICAgICAgICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgICAgICAgICAgdmFyIHkwID0gdGhpcy5feWk7XG4gICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgIHZhciBkeDtcbiAgICAgICAgICAgIHZhciBkeTtcbiAgICAgICAgICAgIHZhciBjdWJpY0F0ID0gY3VydmUuY3ViaWNBdDtcbiAgICAgICAgICAgIHZhciBiZXppZXJMZW4gPSAwO1xuICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgICAgICAgICB2YXIgbkRhc2ggPSBsaW5lRGFzaC5sZW5ndGg7XG5cbiAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgdmFyIHk7XG5cbiAgICAgICAgICAgIHZhciB0bXBMZW4gPSAwO1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZGFzaFN1bSArIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgICAgICAgICAgLy8gQmV6aWVyIGFwcHJveCBsZW5ndGhcbiAgICAgICAgICAgIGZvciAodCA9IDA7IHQgPCAxOyB0ICs9IDAuMSkge1xuICAgICAgICAgICAgICAgIGR4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCArIDAuMSlcbiAgICAgICAgICAgICAgICAgICAgLSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgICAgICAgICBkeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQgKyAwLjEpXG4gICAgICAgICAgICAgICAgICAgIC0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG4gICAgICAgICAgICAgICAgYmV6aWVyTGVuICs9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmluZCBpZHggYWZ0ZXIgYWRkIG9mZnNldFxuICAgICAgICAgICAgZm9yICg7IGlkeCA8IG5EYXNoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHRtcExlbiArPSBsaW5lRGFzaFtpZHhdO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMZW4gPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCA9ICh0bXBMZW4gLSBvZmZzZXQpIC8gYmV6aWVyTGVuO1xuXG4gICAgICAgICAgICB3aGlsZSAodCA8PSAxKSB7XG5cbiAgICAgICAgICAgICAgICB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICAgICAgeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGxpbmUgdG8gYXBwcm94aW1hdGUgZGFzaGVkIGJlemllclxuICAgICAgICAgICAgICAgIC8vIEJhZCByZXN1bHQgaWYgZGFzaCBpcyBsb25nXG4gICAgICAgICAgICAgICAgaWR4ICUgMiA/IGN0eC5tb3ZlVG8oeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgOiBjdHgubGluZVRvKHgsIHkpO1xuXG4gICAgICAgICAgICAgICAgdCArPSBsaW5lRGFzaFtpZHhdIC8gYmV6aWVyTGVuO1xuXG4gICAgICAgICAgICAgICAgaWR4ID0gKGlkeCArIDEpICUgbkRhc2g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbmlzaCB0aGUgbGFzdCBzZWdtZW50IGFuZCBjYWxjdWxhdGUgdGhlIG5ldyBvZmZzZXRcbiAgICAgICAgICAgIChpZHggJSAyICE9PSAwKSAmJiBjdHgubGluZVRvKHgzLCB5Myk7XG4gICAgICAgICAgICBkeCA9IHgzIC0geDtcbiAgICAgICAgICAgIGR5ID0geTMgLSB5O1xuICAgICAgICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IC1tYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2Rhc2hlZFF1YWRyYXRpY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcXVhZHJhdGljIHRvIGN1YmljIHVzaW5nIGRlZ3JlZSBlbGV2YXRpb25cbiAgICAgICAgICAgIHZhciB4MyA9IHgyO1xuICAgICAgICAgICAgdmFyIHkzID0geTI7XG4gICAgICAgICAgICB4MiA9ICh4MiArIDIgKiB4MSkgLyAzO1xuICAgICAgICAgICAgeTIgPSAoeTIgKyAyICogeTEpIC8gMztcbiAgICAgICAgICAgIHgxID0gKHRoaXMuX3hpICsgMiAqIHgxKSAvIDM7XG4gICAgICAgICAgICB5MSA9ICh0aGlzLl95aSArIDIgKiB5MSkgLyAzO1xuXG4gICAgICAgICAgICB0aGlzLl9kYXNoZWRCZXppZXJUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6L2s5oiQ6Z2Z5oCB55qEIEZsb2F0MzJBcnJheSDlh4/lsJHloIblhoXlrZjljaDnlKhcbiAgICAgICAgICogQ29udmVydCBkeW5hbWljIGFycmF5IHRvIHN0YXRpYyBGbG9hdDMyQXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RhdGljOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmxlbmd0aCA9IHRoaXMuX2xlbjtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVHlwZWRBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1pblswXSA9IG1pblsxXSA9IG1pbjJbMF0gPSBtaW4yWzFdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIG1heFswXSA9IG1heFsxXSA9IG1heDJbMF0gPSBtYXgyWzFdID0gLU51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgdmFyIHhpID0gMDtcbiAgICAgICAgICAgIHZhciB5aSA9IDA7XG4gICAgICAgICAgICB2YXIgeDAgPSAwO1xuICAgICAgICAgICAgdmFyIHkwID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgICAgICAgICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcblxuICAgICAgICAgICAgICAgICAgICB4MCA9IHhpO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHlpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnkvb/nlKhcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjJbMF0gPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjJbMV0gPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDJbMF0gPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDJbMV0gPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tTGluZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbUN1YmljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4yLCBtYXgyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tUXVhZHJhdGljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjIsIG1heDJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQXJjIOaXi+i9rFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSBtYXRoQ29zKHN0YXJ0QW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MCA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21BcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gsIGN5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFudGljbG9ja3dpc2UsIG1pbjIsIG1heDJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBmcm9tTGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tTGluZSh4MCwgeTAsIHgwICsgd2lkdGgsIHkwICsgaGVpZ2h0LCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVbmlvblxuICAgICAgICAgICAgICAgIHZlYzIubWluKG1pbiwgbWluLCBtaW4yKTtcbiAgICAgICAgICAgICAgICB2ZWMyLm1heChtYXgsIG1heCwgbWF4Mik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vIGRhdGFcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWluWzBdID0gbWluWzFdID0gbWF4WzBdID0gbWF4WzFdID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgbWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWJ1aWxkIHBhdGggZnJvbSBjdXJyZW50IGRhdGFcbiAgICAgICAgICogUmVidWlsZCBwYXRoIHdpbGwgbm90IGNvbnNpZGVyIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZSBkYXNoLlxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHR9IGN0eFxuICAgICAgICAgKi9cbiAgICAgICAgcmVidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgdmFyIHgwLCB5MDtcbiAgICAgICAgICAgIHZhciB4aSwgeWk7XG4gICAgICAgICAgICB2YXIgeCwgeTtcbiAgICAgICAgICAgIHZhciB1eCA9IHRoaXMuX3V4O1xuICAgICAgICAgICAgdmFyIHV5ID0gdGhpcy5fdXk7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5fbGVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNtZCA9IGRbaSsrXTtcblxuICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgICAgICAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRbaV07XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZFtpICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSB5aTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IHlpID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4aSwgeWkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBkcmF3IHRvbyBzbWFsbCBzZWcgYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGhBYnMoeCAtIHhpKSA+IHV4IHx8IG1hdGhBYnMoeSAtIHlpKSA+IHV5IHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK11cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZFtpIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3kgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZFRoZXRhID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcyA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gKHJ4ID4gcnkpID8gcnggOiByeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZVggPSAocnggPiByeSkgPyAxIDogcnggLyByeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZVkgPSAocnggPiByeSkgPyByeSAvIHJ4IDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0VsbGlwc2UgPSBNYXRoLmFicyhyeCAtIHJ5KSA+IDFlLTM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSB0aGV0YSArIGRUaGV0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VsbGlwc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYygwLCAwLCByLCB0aGV0YSwgZW5kQW5nbGUsIDEgLSBmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKGN4LCBjeSwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g55u05o6l5L2/55SoIGFyYyDlkb3ku6RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MCA9IG1hdGhDb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MCA9IG1hdGhTaW4odGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5aSA9IGRbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFBhdGhQcm94eS5DTUQgPSBDTUQ7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhdGhQcm94eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eS5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("'use strict';\n/**\n * 曲线辅助模块\n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = __webpack_require__(26);\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // 临时变量\n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * 计算三次贝塞尔值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * 计算三次贝塞尔导数值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * 计算三次贝塞尔方程根，使用盛金公式\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算三次贝塞尔方程极限值的位置\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} 有效数目\n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 细分三次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * 投射点到三次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] 投射点\n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * 计算二次方贝塞尔值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * 计算二次方贝塞尔导数值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * 计算二次方贝塞尔方程根\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算二次贝塞尔方程极限值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * 细分二次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * 投射点到二次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out 投射点\n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvY3VydmUuanM/OTUxMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLGVBQWU7QUFDOUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIOabsue6v+i+heWKqeaooeWdl1xuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciB2MkNyZWF0ZSA9IHZlYzIuY3JlYXRlO1xuICAgIHZhciB2MkRpc3RTcXVhcmUgPSB2ZWMyLmRpc3RTcXVhcmU7XG4gICAgdmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcbiAgICB2YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG5cbiAgICB2YXIgRVBTSUxPTiA9IDFlLTg7XG4gICAgdmFyIEVQU0lMT05fTlVNRVJJQyA9IDFlLTQ7XG5cbiAgICB2YXIgVEhSRUVfU1FSVCA9IG1hdGhTcXJ0KDMpO1xuICAgIHZhciBPTkVfVEhJUkQgPSAxIC8gMztcblxuICAgIC8vIOS4tOaXtuWPmOmHj1xuICAgIHZhciBfdjAgPSB2MkNyZWF0ZSgpO1xuICAgIHZhciBfdjEgPSB2MkNyZWF0ZSgpO1xuICAgIHZhciBfdjIgPSB2MkNyZWF0ZSgpO1xuICAgIC8vIHZhciBfdjMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgZnVuY3Rpb24gaXNBcm91bmRaZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gLUVQU0lMT04gJiYgdmFsIDwgRVBTSUxPTjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5YC8XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgICAgICAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIG9uZXQgKiBvbmV0ICogKG9uZXQgKiBwMCArIDMgKiB0ICogcDEpXG4gICAgICAgICAgICAgKyB0ICogdCAqICh0ICogcDMgKyAzICogb25ldCAqIHAyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTlr7zmlbDlgLxcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNEZXJpdmF0aXZlQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgICAgICAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIDMgKiAoXG4gICAgICAgICAgICAoKHAxIC0gcDApICogb25ldCArIDIgKiAocDIgLSBwMSkgKiB0KSAqIG9uZXRcbiAgICAgICAgICAgICsgKHAzIC0gcDIpICogdCAqIHRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTmlrnnqIvmoLnvvIzkvb/nlKjnm5vph5HlhazlvI9cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbFxuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICAgICAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5qC55pWw55uuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNSb290QXQocDAsIHAxLCBwMiwgcDMsIHZhbCwgcm9vdHMpIHtcbiAgICAgICAgLy8gRXZhbHVhdGUgcm9vdHMgb2YgY3ViaWMgZnVuY3Rpb25zXG4gICAgICAgIHZhciBhID0gcDMgKyAzICogKHAxIC0gcDIpIC0gcDA7XG4gICAgICAgIHZhciBiID0gMyAqIChwMiAtIHAxICogMiArIHAwKTtcbiAgICAgICAgdmFyIGMgPSAzICogKHAxICAtIHAwKTtcbiAgICAgICAgdmFyIGQgPSBwMCAtIHZhbDtcblxuICAgICAgICB2YXIgQSA9IGIgKiBiIC0gMyAqIGEgKiBjO1xuICAgICAgICB2YXIgQiA9IGIgKiBjIC0gOSAqIGEgKiBkO1xuICAgICAgICB2YXIgQyA9IGMgKiBjIC0gMyAqIGIgKiBkO1xuXG4gICAgICAgIHZhciBuID0gMDtcblxuICAgICAgICBpZiAoaXNBcm91bmRaZXJvKEEpICYmIGlzQXJvdW5kWmVybyhCKSkge1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhiKSkge1xuICAgICAgICAgICAgICAgIHJvb3RzWzBdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1jIC8gYjsgIC8vdDEsIHQyLCB0MywgYiBpcyBub3QgemVyb1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkaXNjID0gQiAqIEIgLSA0ICogQSAqIEM7XG5cbiAgICAgICAgICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgICAgICAgICAgICB2YXIgSyA9IEIgLyBBO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1iIC8gYSArIEs7ICAvLyB0MSwgYSBpcyBub3QgemVyb1xuICAgICAgICAgICAgICAgIHZhciB0MiA9IC1LIC8gMjsgIC8vIHQyLCB0M1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciBZMSA9IEEgKiBiICsgMS41ICogYSAqICgtQiArIGRpc2NTcXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgWTIgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgLSBkaXNjU3FydCk7XG4gICAgICAgICAgICAgICAgaWYgKFkxIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBZMSA9IC1tYXRoUG93KC1ZMSwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFkxID0gbWF0aFBvdyhZMSwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFkyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBZMiA9IC1tYXRoUG93KC1ZMiwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFkyID0gbWF0aFBvdyhZMiwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iIC0gKFkxICsgWTIpKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIFQgPSAoMiAqIEEgKiBiIC0gMyAqIGEgKiBCKSAvICgyICogbWF0aFNxcnQoQSAqIEEgKiBBKSk7XG4gICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gTWF0aC5hY29zKFQpIC8gMztcbiAgICAgICAgICAgICAgICB2YXIgQVNxcnQgPSBtYXRoU3FydChBKTtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gTWF0aC5jb3ModGhldGEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iIC0gMiAqIEFTcXJ0ICogdG1wKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iICsgQVNxcnQgKiAodG1wICsgVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcbiAgICAgICAgICAgICAgICB2YXIgdDMgPSAoLWIgKyBBU3FydCAqICh0bXAgLSBUSFJFRV9TUVJUICogTWF0aC5zaW4odGhldGEpKSkgLyAoMyAqIGEpO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQzID49IDAgJiYgdDMgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S4ieasoei0neWhnuWwlOaWueeoi+aegemZkOWAvOeahOS9jee9rlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBleHRyZW1hXG4gICAgICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmlbDnm65cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY0V4dHJlbWEocDAsIHAxLCBwMiwgcDMsIGV4dHJlbWEpIHtcbiAgICAgICAgdmFyIGIgPSA2ICogcDIgLSAxMiAqIHAxICsgNiAqIHAwO1xuICAgICAgICB2YXIgYSA9IDkgKiBwMSArIDMgKiBwMyAtIDMgKiBwMCAtIDkgKiBwMjtcbiAgICAgICAgdmFyIGMgPSAzICogcDEgLSAzICogcDA7XG5cbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgICAgICAgICBpZiAoaXNOb3RBcm91bmRaZXJvKGIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gLWMgLyBiO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9MSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgICAgIGV4dHJlbWFbMF0gPSAtYiAvICgyICogYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbWFbbisrXSA9IHQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnu4bliIbkuInmrKHotJ3loZ7lsJTmm7Lnur9cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNTdWJkaXZpZGUocDAsIHAxLCBwMiwgcDMsIHQsIG91dCkge1xuICAgICAgICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICAgICAgICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICAgICAgICB2YXIgcDIzID0gKHAzIC0gcDIpICogdCArIHAyO1xuXG4gICAgICAgIHZhciBwMDEyID0gKHAxMiAtIHAwMSkgKiB0ICsgcDAxO1xuICAgICAgICB2YXIgcDEyMyA9IChwMjMgLSBwMTIpICogdCArIHAxMjtcblxuICAgICAgICB2YXIgcDAxMjMgPSAocDEyMyAtIHAwMTIpICogdCArIHAwMTI7XG4gICAgICAgIC8vIFNlZzBcbiAgICAgICAgb3V0WzBdID0gcDA7XG4gICAgICAgIG91dFsxXSA9IHAwMTtcbiAgICAgICAgb3V0WzJdID0gcDAxMjtcbiAgICAgICAgb3V0WzNdID0gcDAxMjM7XG4gICAgICAgIC8vIFNlZzFcbiAgICAgICAgb3V0WzRdID0gcDAxMjM7XG4gICAgICAgIG91dFs1XSA9IHAxMjM7XG4gICAgICAgIG91dFs2XSA9IHAyMztcbiAgICAgICAgb3V0WzddID0gcDM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5oqV5bCE54K55Yiw5LiJ5qyh6LSd5aGe5bCU5puy57q/5LiK77yM6L+U5Zue5oqV5bCE6Led56a744CCXG4gICAgICog5oqV5bCE54K55pyJ5Y+v6IO95Lya5pyJ5LiA5Liq5oiW6ICF5aSa5Liq77yM6L+Z6YeM5Y+q6L+U5Zue5YW25Lit6Led56a75pyA55+t55qE5LiA5Liq44CCXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIOaKleWwhOeCuVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY1Byb2plY3RQb2ludChcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLFxuICAgICAgICB4LCB5LCBvdXRcbiAgICApIHtcbiAgICAgICAgLy8gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNwcm9qZWN0aW9uc1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgdmFyIGludGVydmFsID0gMC4wMDU7XG4gICAgICAgIHZhciBkID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBwcmV2O1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgdmFyIGQxO1xuICAgICAgICB2YXIgZDI7XG5cbiAgICAgICAgX3YwWzBdID0geDtcbiAgICAgICAgX3YwWzFdID0geTtcblxuICAgICAgICAvLyDlhYjnspfnlaXkvLDorqHkuIDkuIvlj6/og73nmoTmnIDlsI/ot53nprvnmoQgdCDlgLxcbiAgICAgICAgLy8gUEVORElOR1xuICAgICAgICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgICAgICAgICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgX3QpO1xuICAgICAgICAgICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgX3QpO1xuICAgICAgICAgICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuICAgICAgICAgICAgaWYgKGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBfdDtcbiAgICAgICAgICAgICAgICBkID0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZCA9IEluZmluaXR5O1xuXG4gICAgICAgIC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgICAgICAgICAgbmV4dCA9IHQgKyBpbnRlcnZhbDtcbiAgICAgICAgICAgIC8vIHQgLSBpbnRlcnZhbFxuICAgICAgICAgICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgcHJldik7XG4gICAgICAgICAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBwcmV2KTtcblxuICAgICAgICAgICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgICAgICAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBwcmV2O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIF92MlswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIG5leHQpO1xuICAgICAgICAgICAgICAgIF92MlsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIG5leHQpO1xuICAgICAgICAgICAgICAgIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkID0gZDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRcbiAgICAgICAgaWYgKG91dCkge1xuICAgICAgICAgICAgb3V0WzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICBvdXRbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG4gICAgICAgIHJldHVybiBtYXRoU3FydChkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTlgLxcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljQXQocDAsIHAxLCBwMiwgdCkge1xuICAgICAgICB2YXIgb25ldCA9IDEgLSB0O1xuICAgICAgICByZXR1cm4gb25ldCAqIChvbmV0ICogcDAgKyAyICogdCAqIHAxKSArIHQgKiB0ICogcDI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5a+85pWw5YC8XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCB0KSB7XG4gICAgICAgIHJldHVybiAyICogKCgxIC0gdCkgKiAocDEgLSBwMCkgKyB0ICogKHAyIC0gcDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTmlrnnqIvmoLlcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcm9vdHNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1Jvb3RBdChwMCwgcDEsIHAyLCB2YWwsIHJvb3RzKSB7XG4gICAgICAgIHZhciBhID0gcDAgLSAyICogcDEgKyBwMjtcbiAgICAgICAgdmFyIGIgPSAyICogKHAxIC0gcDApO1xuICAgICAgICB2YXIgYyA9IHAwIC0gdmFsO1xuXG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgICAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1jIC8gYjtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1iIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S6jOasoei0neWhnuWwlOaWueeoi+aegemZkOWAvFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0V4dHJlbXVtKHAwLCBwMSwgcDIpIHtcbiAgICAgICAgdmFyIGRpdmlkZXIgPSBwMCArIHAyIC0gMiAqIHAxO1xuICAgICAgICBpZiAoZGl2aWRlciA9PT0gMCkge1xuICAgICAgICAgICAgLy8gcDEgaXMgY2VudGVyIG9mIHAwIGFuZCBwMlxuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAocDAgLSBwMSkgLyBkaXZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog57uG5YiG5LqM5qyh6LSd5aGe5bCU5puy57q/XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHQsIG91dCkge1xuICAgICAgICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICAgICAgICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICAgICAgICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTtcblxuICAgICAgICAvLyBTZWcwXG4gICAgICAgIG91dFswXSA9IHAwO1xuICAgICAgICBvdXRbMV0gPSBwMDE7XG4gICAgICAgIG91dFsyXSA9IHAwMTI7XG5cbiAgICAgICAgLy8gU2VnMVxuICAgICAgICBvdXRbM10gPSBwMDEyO1xuICAgICAgICBvdXRbNF0gPSBwMTI7XG4gICAgICAgIG91dFs1XSA9IHAyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaKleWwhOeCueWIsOS6jOasoei0neWhnuWwlOabsue6v+S4iu+8jOi/lOWbnuaKleWwhOi3neemu+OAglxuICAgICAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXQg5oqV5bCE54K5XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1Byb2plY3RQb2ludChcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgeCwgeSwgb3V0XG4gICAgKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICAgICAgICB2YXIgZCA9IEluZmluaXR5O1xuXG4gICAgICAgIF92MFswXSA9IHg7XG4gICAgICAgIF92MFsxXSA9IHk7XG5cbiAgICAgICAgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICAgICAgICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIF90KTtcbiAgICAgICAgICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIF90KTtcbiAgICAgICAgICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjAsIF92MSk7XG4gICAgICAgICAgICBpZiAoZDEgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IF90O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkID0gSW5maW5pdHk7XG5cbiAgICAgICAgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgICAgICAgICAgdmFyIG5leHQgPSB0ICsgaW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyB0IC0gaW50ZXJ2YWxcbiAgICAgICAgICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHByZXYpO1xuICAgICAgICAgICAgX3YxWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgcHJldik7XG5cbiAgICAgICAgICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2ID49IDAgJiYgZDEgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IHByZXY7XG4gICAgICAgICAgICAgICAgZCA9IGQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdCArIGludGVydmFsXG4gICAgICAgICAgICAgICAgX3YyWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgbmV4dCk7XG4gICAgICAgICAgICAgICAgX3YyWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgbmV4dCk7XG4gICAgICAgICAgICAgICAgdmFyIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0XG4gICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHQpO1xuICAgICAgICAgICAgb3V0WzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coaW50ZXJ2YWwsIGkpO1xuICAgICAgICByZXR1cm4gbWF0aFNxcnQoZCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgY3ViaWNBdDogY3ViaWNBdCxcblxuICAgICAgICBjdWJpY0Rlcml2YXRpdmVBdDogY3ViaWNEZXJpdmF0aXZlQXQsXG5cbiAgICAgICAgY3ViaWNSb290QXQ6IGN1YmljUm9vdEF0LFxuXG4gICAgICAgIGN1YmljRXh0cmVtYTogY3ViaWNFeHRyZW1hLFxuXG4gICAgICAgIGN1YmljU3ViZGl2aWRlOiBjdWJpY1N1YmRpdmlkZSxcblxuICAgICAgICBjdWJpY1Byb2plY3RQb2ludDogY3ViaWNQcm9qZWN0UG9pbnQsXG5cbiAgICAgICAgcXVhZHJhdGljQXQ6IHF1YWRyYXRpY0F0LFxuXG4gICAgICAgIHF1YWRyYXRpY0Rlcml2YXRpdmVBdDogcXVhZHJhdGljRGVyaXZhdGl2ZUF0LFxuXG4gICAgICAgIHF1YWRyYXRpY1Jvb3RBdDogcXVhZHJhdGljUm9vdEF0LFxuXG4gICAgICAgIHF1YWRyYXRpY0V4dHJlbXVtOiBxdWFkcmF0aWNFeHRyZW11bSxcblxuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGU6IHF1YWRyYXRpY1N1YmRpdmlkZSxcblxuICAgICAgICBxdWFkcmF0aWNQcm9qZWN0UG9pbnQ6IHF1YWRyYXRpY1Byb2plY3RQb2ludFxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9jdXJ2ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = __webpack_require__(26);\n    var curve = __webpack_require__(53);\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points 顶点数组\n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvYmJveC5qcz8xYjU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBhdXRob3IgWWkgU2hlbihodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpO1xuXG4gICAgdmFyIGJib3ggPSB7fTtcbiAgICB2YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgbWF0aENvcyA9IE1hdGguY29zO1xuXG4gICAgdmFyIHN0YXJ0ID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgZW5kID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgZXh0cmVtaXR5ID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICAvKipcbiAgICAgKiDku47pobbngrnmlbDnu4TkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gICAgICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9pbnRzIOmhtueCueaVsOe7hFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tUG9pbnRzID0gZnVuY3Rpb24ocG9pbnRzLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gcG9pbnRzWzBdO1xuICAgICAgICB2YXIgbGVmdCA9IHBbMF07XG4gICAgICAgIHZhciByaWdodCA9IHBbMF07XG4gICAgICAgIHZhciB0b3AgPSBwWzFdO1xuICAgICAgICB2YXIgYm90dG9tID0gcFsxXTtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGxlZnQgPSBtYXRoTWluKGxlZnQsIHBbMF0pO1xuICAgICAgICAgICAgcmlnaHQgPSBtYXRoTWF4KHJpZ2h0LCBwWzBdKTtcbiAgICAgICAgICAgIHRvcCA9IG1hdGhNaW4odG9wLCBwWzFdKTtcbiAgICAgICAgICAgIGJvdHRvbSA9IG1hdGhNYXgoYm90dG9tLCBwWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pblswXSA9IGxlZnQ7XG4gICAgICAgIG1pblsxXSA9IHRvcDtcbiAgICAgICAgbWF4WzBdID0gcmlnaHQ7XG4gICAgICAgIG1heFsxXSA9IGJvdHRvbTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbUxpbmUgPSBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIG1pbiwgbWF4KSB7XG4gICAgICAgIG1pblswXSA9IG1hdGhNaW4oeDAsIHgxKTtcbiAgICAgICAgbWluWzFdID0gbWF0aE1pbih5MCwgeTEpO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MSk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkxKTtcbiAgICB9O1xuXG4gICAgdmFyIHhEaW0gPSBbXTtcbiAgICB2YXIgeURpbSA9IFtdO1xuICAgIC8qKlxuICAgICAqIOS7juS4iemYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyLCBwMynkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbUN1YmljID0gZnVuY3Rpb24oXG4gICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbWluLCBtYXhcbiAgICApIHtcbiAgICAgICAgdmFyIGN1YmljRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYTtcbiAgICAgICAgdmFyIGN1YmljQXQgPSBjdXJ2ZS5jdWJpY0F0O1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG4gPSBjdWJpY0V4dHJlbWEoeDAsIHgxLCB4MiwgeDMsIHhEaW0pO1xuICAgICAgICBtaW5bMF0gPSBJbmZpbml0eTtcbiAgICAgICAgbWluWzFdID0gSW5maW5pdHk7XG4gICAgICAgIG1heFswXSA9IC1JbmZpbml0eTtcbiAgICAgICAgbWF4WzFdID0gLUluZmluaXR5O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgeERpbVtpXSk7XG4gICAgICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgsIG1pblswXSk7XG4gICAgICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgsIG1heFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgeURpbSk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgeURpbVtpXSk7XG4gICAgICAgICAgICBtaW5bMV0gPSBtYXRoTWluKHksIG1pblsxXSk7XG4gICAgICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHksIG1heFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgwLCBtaW5bMF0pO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgwLCBtYXhbMF0pO1xuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgzLCBtaW5bMF0pO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgzLCBtYXhbMF0pO1xuXG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTAsIG1pblsxXSk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTAsIG1heFsxXSk7XG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTMsIG1pblsxXSk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTMsIG1heFsxXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOS7juS6jOmYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tUXVhZHJhdGljID0gZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIHF1YWRyYXRpY0V4dHJlbXVtID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW07XG4gICAgICAgIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlLnF1YWRyYXRpY0F0O1xuICAgICAgICAvLyBGaW5kIGV4dHJlbWl0aWVzLCB3aGVyZSBkZXJpdmF0aXZlIGluIHggZGltIG9yIHkgZGltIGlzIHplcm9cbiAgICAgICAgdmFyIHR4ID1cbiAgICAgICAgICAgIG1hdGhNYXgoXG4gICAgICAgICAgICAgICAgbWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh4MCwgeDEsIHgyKSwgMSksIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIHZhciB0eSA9XG4gICAgICAgICAgICBtYXRoTWF4KFxuICAgICAgICAgICAgICAgIG1hdGhNaW4ocXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5MiksIDEpLCAwXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHZhciB4ID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgdHgpO1xuICAgICAgICB2YXIgeSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHR5KTtcblxuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgwLCB4MiwgeCk7XG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTAsIHkyLCB5KTtcbiAgICAgICAgbWF4WzBdID0gbWF0aE1heCh4MCwgeDIsIHgpO1xuICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHkwLCB5MiwgeSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOS7juWchuW8p+S4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcnhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRBbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRBbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbnRpY2xvY2t3aXNlXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tQXJjID0gZnVuY3Rpb24gKFxuICAgICAgICB4LCB5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBtaW4sIG1heFxuICAgICkge1xuICAgICAgICB2YXIgdmVjMk1pbiA9IHZlYzIubWluO1xuICAgICAgICB2YXIgdmVjMk1heCA9IHZlYzIubWF4O1xuXG4gICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcblxuXG4gICAgICAgIGlmIChkaWZmICUgUEkyIDwgMWUtNCAmJiBkaWZmID4gMWUtNCkge1xuICAgICAgICAgICAgLy8gSXMgYSBjaXJjbGVcbiAgICAgICAgICAgIG1pblswXSA9IHggLSByeDtcbiAgICAgICAgICAgIG1pblsxXSA9IHkgLSByeTtcbiAgICAgICAgICAgIG1heFswXSA9IHggKyByeDtcbiAgICAgICAgICAgIG1heFsxXSA9IHkgKyByeTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0WzBdID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgeDtcbiAgICAgICAgc3RhcnRbMV0gPSBtYXRoU2luKHN0YXJ0QW5nbGUpICogcnkgKyB5O1xuXG4gICAgICAgIGVuZFswXSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyB4O1xuICAgICAgICBlbmRbMV0gPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgeTtcblxuICAgICAgICB2ZWMyTWluKG1pbiwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHZlYzJNYXgobWF4LCBzdGFydCwgZW5kKTtcblxuICAgICAgICAvLyBUaHJlc2ggdG8gWzAsIE1hdGguUEkgKiAyXVxuICAgICAgICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSAlIChQSTIpO1xuICAgICAgICBpZiAoc3RhcnRBbmdsZSA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlICsgUEkyO1xuICAgICAgICB9XG4gICAgICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgJSAoUEkyKTtcbiAgICAgICAgaWYgKGVuZEFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBlbmRBbmdsZSArIFBJMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUgJiYgIWFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydEFuZ2xlIDwgZW5kQW5nbGUgJiYgYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgc3RhcnRBbmdsZSArPSBQSTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBlbmRBbmdsZTtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YXIgbnVtYmVyID0gMDtcbiAgICAgICAgLy8gdmFyIHN0ZXAgPSAoYW50aWNsb2Nrd2lzZSA/IC1NYXRoLlBJIDogTWF0aC5QSSkgLyAyO1xuICAgICAgICBmb3IgKHZhciBhbmdsZSA9IDA7IGFuZ2xlIDwgZW5kQW5nbGU7IGFuZ2xlICs9IE1hdGguUEkgLyAyKSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPiBzdGFydEFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgZXh0cmVtaXR5WzBdID0gbWF0aENvcyhhbmdsZSkgKiByeCArIHg7XG4gICAgICAgICAgICAgICAgZXh0cmVtaXR5WzFdID0gbWF0aFNpbihhbmdsZSkgKiByeSArIHk7XG5cbiAgICAgICAgICAgICAgICB2ZWMyTWluKG1pbiwgZXh0cmVtaXR5LCBtaW4pO1xuICAgICAgICAgICAgICAgIHZlYzJNYXgobWF4LCBleHRyZW1pdHksIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBiYm94O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9iYm94LmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var CMD = __webpack_require__(52).CMD;\n    var line = __webpack_require__(56);\n    var cubic = __webpack_require__(57);\n    var quadratic = __webpack_require__(58);\n    var arc = __webpack_require__(59);\n    var normalizeRadian = __webpack_require__(60).normalizeRadian;\n    var curve = __webpack_require__(53);\n\n    var windingLine = __webpack_require__(61);\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // 临时数组\n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // 分成三段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // 分成两段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc 旋转\n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                // 如果被任何一个 subpath 包含\n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                // 如果第一个命令是 L, C, Q\n                // 则 previous point 同绘制命令的第一个 point\n                //\n                // 第一个命令为 Arc 的情况下会在后面特殊处理\n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                    // 在 closePath 的时候使用\n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc 判断的开销比较大\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc 旋转\n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    // 不是直接使用 arc 命令\n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // 第一个命令起点还未定义\n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        // 如果被任何一个 subpath 包含\n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcGF0aC5qcz8yZTdmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBDTUQgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpLkNNRDtcbiAgICB2YXIgbGluZSA9IHJlcXVpcmUoJy4vbGluZScpO1xuICAgIHZhciBjdWJpYyA9IHJlcXVpcmUoJy4vY3ViaWMnKTtcbiAgICB2YXIgcXVhZHJhdGljID0gcmVxdWlyZSgnLi9xdWFkcmF0aWMnKTtcbiAgICB2YXIgYXJjID0gcmVxdWlyZSgnLi9hcmMnKTtcbiAgICB2YXIgbm9ybWFsaXplUmFkaWFuID0gcmVxdWlyZSgnLi91dGlsJykubm9ybWFsaXplUmFkaWFuO1xuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvY3VydmUnKTtcblxuICAgIHZhciB3aW5kaW5nTGluZSA9IHJlcXVpcmUoJy4vd2luZGluZ0xpbmUnKTtcblxuICAgIHZhciBjb250YWluU3Ryb2tlID0gbGluZS5jb250YWluU3Ryb2tlO1xuXG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuXG4gICAgdmFyIEVQU0lMT04gPSAxZS00O1xuXG4gICAgZnVuY3Rpb24gaXNBcm91bmRFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBFUFNJTE9OO1xuICAgIH1cblxuICAgIC8vIOS4tOaXtuaVsOe7hFxuICAgIHZhciByb290cyA9IFstMSwgLTEsIC0xXTtcbiAgICB2YXIgZXh0cmVtYSA9IFstMSwgLTFdO1xuXG4gICAgZnVuY3Rpb24gc3dhcEV4dHJlbWEoKSB7XG4gICAgICAgIHZhciB0bXAgPSBleHRyZW1hWzBdO1xuICAgICAgICBleHRyZW1hWzBdID0gZXh0cmVtYVsxXTtcbiAgICAgICAgZXh0cmVtYVsxXSA9IHRtcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aW5kaW5nQ3ViaWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5KSB7XG4gICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoeSA+IHkwICYmIHkgPiB5MSAmJiB5ID4geTIgJiYgeSA+IHkzKVxuICAgICAgICAgICAgfHwgKHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyICYmIHkgPCB5MylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgblJvb3RzID0gY3VydmUuY3ViaWNSb290QXQoeTAsIHkxLCB5MiwgeTMsIHksIHJvb3RzKTtcbiAgICAgICAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgICAgICB2YXIgbkV4dHJlbWEgPSAtMTtcbiAgICAgICAgICAgIHZhciB5MF8sIHkxXztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJvb3RzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHJvb3RzW2ldO1xuXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgd2luZGluZyBlcnJvciB3aGVuIGludGVyc2VjdGlvbiBwb2ludCBpcyB0aGUgY29ubmVjdCBwb2ludCBvZiB0d28gbGluZSBvZiBwb2x5Z29uXG4gICAgICAgICAgICAgICAgdmFyIHVuaXQgPSAodCA9PT0gMCB8fCB0ID09PSAxKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5jdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgICAgICAgICBpZiAoeF8gPCB4KSB7IC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5FeHRyZW1hIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBuRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyZW1hWzFdIDwgZXh0cmVtYVswXSAmJiBuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3YXBFeHRyZW1hKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeTBfID0gY3VydmUuY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYVswXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWIhuaIkOS4ieauteWNleiwg+WHveaVsFxuICAgICAgICAgICAgICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTBfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodCA8IGV4dHJlbWFbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTFfIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MyA8IHkxXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5YiG5oiQ5Lik5q615Y2V6LCD5Ye95pWwXG4gICAgICAgICAgICAgICAgICAgIGlmICh0IDwgZXh0cmVtYVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MF8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTMgPCB5MF8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpbmRpbmdRdWFkcmF0aWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyKVxuICAgICAgICAgICAgfHwgKHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuUm9vdHMgPSBjdXJ2ZS5xdWFkcmF0aWNSb290QXQoeTAsIHkxLCB5MiwgeSwgcm9vdHMpO1xuICAgICAgICBpZiAoblJvb3RzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0ID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5Mik7XG4gICAgICAgICAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgICAgICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgeV8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbmUgZW5kcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgIHZhciB1bml0ID0gKHJvb3RzW2ldID09PSAwIHx8IHJvb3RzW2ldID09PSAxKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeF8gPCB4KSB7ICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocm9vdHNbaV0gPCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHlfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkyIDwgeV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgICAgICAgICAgIHZhciB1bml0ID0gKHJvb3RzWzBdID09PSAwIHx8IHJvb3RzWzBdID09PSAxKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCByb290c1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKHhfIDwgeCkgeyAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHkyIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPXG4gICAgLy8gQXJjIOaXi+i9rFxuICAgIGZ1bmN0aW9uIHdpbmRpbmdBcmMoXG4gICAgICAgIGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHgsIHlcbiAgICApIHtcbiAgICAgICAgeSAtPSBjeTtcbiAgICAgICAgaWYgKHkgPiByIHx8IHkgPCAtcikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRtcCA9IE1hdGguc3FydChyICogciAtIHkgKiB5KTtcbiAgICAgICAgcm9vdHNbMF0gPSAtdG1wO1xuICAgICAgICByb290c1sxXSA9IHRtcDtcblxuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG4gICAgICAgIGlmIChkaWZmIDwgMWUtNCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpZmYgJSBQSTIgPCAxZS00KSB7XG4gICAgICAgICAgICAvLyBJcyBhIGNpcmNsZVxuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IDA7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IFBJMjtcbiAgICAgICAgICAgIHZhciBkaXIgPSBhbnRpY2xvY2t3aXNlID8gMSA6IC0xO1xuICAgICAgICAgICAgaWYgKHggPj0gcm9vdHNbMF0gKyBjeCAmJiB4IDw9IHJvb3RzWzFdICsgY3gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4odG1wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgICAgICAgICAgZW5kQW5nbGUgKz0gUEkyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgdmFyIHhfID0gcm9vdHNbaV07XG4gICAgICAgICAgICBpZiAoeF8gKyBjeCA+IHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHksIHhfKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gUEkyICsgYW5nbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUpXG4gICAgICAgICAgICAgICAgICAgIHx8IChhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJIC8gMiAmJiBhbmdsZSA8IE1hdGguUEkgKiAxLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpciA9IC1kaXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdyArPSBkaXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5QYXRoKGRhdGEsIGxpbmVXaWR0aCwgaXNTdHJva2UsIHgsIHkpIHtcbiAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICB2YXIgeGkgPSAwO1xuICAgICAgICB2YXIgeWkgPSAwO1xuICAgICAgICB2YXIgeDAgPSAwO1xuICAgICAgICB2YXIgeTAgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgLy8gQmVnaW4gYSBuZXcgc3VicGF0aFxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gQ01ELk0gJiYgaSA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzdWJwYXRoXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgICAgICAgLy8gaWYgKHcgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSArIDFdO1xuXG4gICAgICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgICAgICB5MCA9IHlpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgICAgICAgICAgICAgIC8vIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5L2/55SoXG4gICAgICAgICAgICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFIOWcqOesrOS4gOS4quWRveS7pOS4uiBMLCBDLCBRIOeahOaXtuWAmeS8muiuoeeul+WHuiBOYU5cbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgeCwgeSkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1YmljLmNvbnRhaW5TdHJva2UoeGksIHlpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdDdWJpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWFkcmF0aWMuY29udGFpblN0cm9rZSh4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nUXVhZHJhdGljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5Yik5pat55qE5byA6ZSA5q+U6L6D5aSnXG4gICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZFRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEFyYyDml4vovaxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSBNYXRoLmNvcyh0aGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTEgPSBNYXRoLnNpbih0aGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAvLyDkuI3mmK/nm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHgxO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB6ciDkvb/nlKhzY2FsZeadpeaooeaLn+akreWchiwg6L+Z6YeM5Lmf5a+5eOWBmuS4gOWumueahOe8qeaUvlxuICAgICAgICAgICAgICAgICAgICB2YXIgX3ggPSAoeCAtIGN4KSAqIHJ5IC8gcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJjLmNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCwgX3gsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0FyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3gsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBNYXRoLmNvcyh0aGV0YSArIGRUaGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICB5aSA9IE1hdGguc2luKHRoZXRhICsgZFRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHkwID0geWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0geDAgKyB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0geTAgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTAsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29udGFpblN0cm9rZSh4MSwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBjb250YWluU3Ryb2tlKHgxLCB5MSwgeDAsIHkxLCBsaW5lV2lkdGgsIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNvbnRhaW5TdHJva2UoeDAsIHkxLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgQ2xvY2t3aXNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDEsIHkwLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4MCwgeTEsIHgwLCB5MCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpblN0cm9rZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksIHgwLCB5MCwgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZSBhIHN1YnBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBzdWJwYXRocyBtYXkgb3ZlcmxhcFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHcgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzU3Ryb2tlICYmICFpc0Fyb3VuZEVxdWFsKHlpLCB5MCkpIHtcbiAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHcgIT09IDA7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uIChwYXRoRGF0YSwgeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCAwLCBmYWxzZSwgeCwgeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKHBhdGhEYXRhLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluUGF0aChwYXRoRGF0YSwgbGluZVdpZHRoLCB0cnVlLCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi9wYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports){eval("\n    module.exports = {\n        /**\n         * 线段包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vbGluZS5qcz80MzI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe6v+auteWMheWQq+WIpOaWrVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSkge1xuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgIHZhciBfYSA9IDA7XG4gICAgICAgICAgICB2YXIgX2IgPSB4MDtcbiAgICAgICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHgwICE9PSB4MSkge1xuICAgICAgICAgICAgICAgIF9hID0gKHkwIC0geTEpIC8gKHgwIC0geDEpO1xuICAgICAgICAgICAgICAgIF9iID0gKHgwICogeTEgLSB4MSAqIHkwKSAvICh4MCAtIHgxKSA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoeCAtIHgwKSA8PSBfbCAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG1wID0gX2EgKiB4IC0geSArIF9iO1xuICAgICAgICAgICAgdmFyIF9zID0gdG1wICogdG1wIC8gKF9hICogX2EgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiBfcyA8PSBfbCAvIDIgKiBfbCAvIDI7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vbGluZS5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\n\n    var curve = __webpack_require__(53);\n\n    module.exports = {\n        /**\n         * 三次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vY3ViaWMuanM/YjkwZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI1Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY29yZS9jdXJ2ZScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuInmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wgJiYgeSA+IHkzICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sICYmIHkgPCB5MyAtIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCAmJiB4ID4geDIgKyBfbCAmJiB4ID4geDMgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wgJiYgeCA8IHgzIC0gX2wpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZCA9IGN1cnZlLmN1YmljUHJvamVjdFBvaW50KFxuICAgICAgICAgICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MyxcbiAgICAgICAgICAgICAgICB4LCB5LCBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGQgPD0gX2wgLyAyO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluL2N1YmljLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n\n    var curve = __webpack_require__(53);\n\n    module.exports = {\n        /**\n         * 二次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzP2Y1ODkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvY3VydmUnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5LqM5qyh6LSd5aGe5bCU5puy57q/5o+P6L655YyF5ZCr5Yik5patXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5TdHJva2U6IGZ1bmN0aW9uICh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCAmJiB4ID4geDIgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZCA9IGN1cnZlLnF1YWRyYXRpY1Byb2plY3RQb2ludChcbiAgICAgICAgICAgICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgICAgIHgsIHksIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gZCA8PSBfbCAvIDI7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n\n    var normalizeRadian = __webpack_require__(60).normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * 圆弧描边包含判断\n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzPzczNjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjU5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgbm9ybWFsaXplUmFkaWFuID0gcmVxdWlyZSgnLi91dGlsJykubm9ybWFsaXplUmFkaWFuO1xuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5ZyG5byn5o+P6L655YyF5ZCr5Yik5patXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGN4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGN5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgc3RhcnRBbmdsZVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBlbmRBbmdsZVxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSAgYW50aWNsb2Nrd2lzZVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGxpbmVXaWR0aFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5TdHJva2U6IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsXG4gICAgICAgICAgICBsaW5lV2lkdGgsIHgsIHlcbiAgICAgICAgKSB7XG5cbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2wgPSBsaW5lV2lkdGg7XG5cbiAgICAgICAgICAgIHggLT0gY3g7XG4gICAgICAgICAgICB5IC09IGN5O1xuICAgICAgICAgICAgdmFyIGQgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cbiAgICAgICAgICAgIGlmICgoZCAtIF9sID4gcikgfHwgKGQgKyBfbCA8IHIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSkgJSBQSTIgPCAxZS00KSB7XG4gICAgICAgICAgICAgICAgLy8gSXMgYSBjaXJjbGVcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4odG1wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihzdGFydEFuZ2xlKTtcbiAgICAgICAgICAgICAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgZW5kQW5nbGUgKz0gUEkyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHksIHgpO1xuICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgIGFuZ2xlICs9IFBJMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoYW5nbGUgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSA8PSBlbmRBbmdsZSlcbiAgICAgICAgICAgICAgICB8fCAoYW5nbGUgKyBQSTIgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSArIFBJMiA8PSBlbmRBbmdsZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qcz8wMDMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgbm9ybWFsaXplUmFkaWFuOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICAgICAgYW5nbGUgJT0gUEkyO1xuICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgIGFuZ2xlICs9IFBJMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhbmdsZTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vd2luZGluZ0xpbmUuanM/NjI1YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSIsImZpbGUiOiI2MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2luZGluZ0xpbmUoeDAsIHkwLCB4MSwgeTEsIHgsIHkpIHtcbiAgICAgICAgaWYgKCh5ID4geTAgJiYgeSA+IHkxKSB8fCAoeSA8IHkwICYmIHkgPCB5MSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIElnbm9yZSBob3Jpem9udGFsIGxpbmVcbiAgICAgICAgaWYgKHkxID09PSB5MCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpciA9IHkxIDwgeTAgPyAxIDogLTE7XG4gICAgICAgIHZhciB0ID0gKHkgLSB5MCkgLyAoeTEgLSB5MCk7XG5cbiAgICAgICAgLy8gQXZvaWQgd2luZGluZyBlcnJvciB3aGVuIGludGVyc2VjdGlvbiBwb2ludCBpcyB0aGUgY29ubmVjdCBwb2ludCBvZiB0d28gbGluZSBvZiBwb2x5Z29uXG4gICAgICAgIGlmICh0ID09PSAxIHx8IHQgPT09IDApIHtcbiAgICAgICAgICAgIGRpciA9IHkxIDwgeTAgPyAwLjUgOiAtMC41O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhfID0gdCAqICh4MSAtIHgwKSArIHgwO1xuXG4gICAgICAgIHJldHVybiB4XyA+IHggPyBkaXIgOiAwO1xuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi93aW5kaW5nTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("\n\n    var Pattern = function (image, repeat) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {image: ...}`, where this constructor will not be called.\n\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n        return ctx.createPattern(this.image, this.repeat || 'repeat');\n    };\n\n    module.exports = Pattern;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0dGVybi5qcz9hOTdlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixXQUFXOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBQYXR0ZXJuID0gZnVuY3Rpb24gKGltYWdlLCByZXBlYXQpIHtcbiAgICAgICAgLy8gU2hvdWxkIGRvIG5vdGhpbmcgbW9yZSBpbiB0aGlzIGNvbnN0cnVjdG9yLiBCZWNhdXNlIGdyYWRpZW50IGNhbiBiZVxuICAgICAgICAvLyBkZWNsYXJkIGJ5IGBjb2xvcjoge2ltYWdlOiAuLi59YCwgd2hlcmUgdGhpcyBjb25zdHJ1Y3RvciB3aWxsIG5vdCBiZSBjYWxsZWQuXG5cbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICB0aGlzLnJlcGVhdCA9IHJlcGVhdDtcblxuICAgICAgICAvLyBDYW4gYmUgY2xvbmVkXG4gICAgICAgIHRoaXMudHlwZSA9ICdwYXR0ZXJuJztcbiAgICB9O1xuXG4gICAgUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybiA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRoaXMuaW1hZ2UsIHRoaXMucmVwZWF0IHx8ICdyZXBlYXQnKTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXR0ZXJuO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0dGVybi5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\n\n    var CMD = __webpack_require__(52).CMD;\n    var vec2 = __webpack_require__(26);\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i] *= sx;\n                    data[i++] += x;\n                    // cy\n                    data[i] *= sy;\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3Rvb2wvdHJhbnNmb3JtUGF0aC5qcz9kZGIyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjYzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgQ01EID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKS5DTUQ7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuLi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciB2MkFwcGx5VHJhbnNmb3JtID0gdmVjMi5hcHBseVRyYW5zZm9ybTtcblxuICAgIHZhciBwb2ludHMgPSBbW10sIFtdLCBbXV07XG4gICAgdmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBtYXRoQXRhbjIgPSBNYXRoLmF0YW4yO1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVBhdGgocGF0aCwgbSkge1xuICAgICAgICB2YXIgZGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgdmFyIGNtZDtcbiAgICAgICAgdmFyIG5Qb2ludDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBqO1xuICAgICAgICB2YXIgaztcbiAgICAgICAgdmFyIHA7XG5cbiAgICAgICAgdmFyIE0gPSBDTUQuTTtcbiAgICAgICAgdmFyIEMgPSBDTUQuQztcbiAgICAgICAgdmFyIEwgPSBDTUQuTDtcbiAgICAgICAgdmFyIFIgPSBDTUQuUjtcbiAgICAgICAgdmFyIEEgPSBDTUQuQTtcbiAgICAgICAgdmFyIFEgPSBDTUQuUTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgICAgICAgY21kID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgICBuUG9pbnQgPSAwO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgTTpcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBMOlxuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEM6XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUTpcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBOlxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IG1bNF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gbVs1XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4ID0gbWF0aFNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeSA9IG1hdGhTcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBtYXRoQXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3hcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpXSAqPSBzeDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IHg7XG4gICAgICAgICAgICAgICAgICAgIC8vIGN5XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaV0gKj0gc3k7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSB5O1xuICAgICAgICAgICAgICAgICAgICAvLyBTY2FsZSByeCBhbmQgcnlcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgQXNzdW1lIHBzaSBpcyAwIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICo9IHN4O1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKj0gc3k7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmQgYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBwc2lcbiAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgICAgICBqID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSOlxuICAgICAgICAgICAgICAgICAgICAvLyB4MCwgeTBcbiAgICAgICAgICAgICAgICAgICAgcFswXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcFsxXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgLy8geDEsIHkxXG4gICAgICAgICAgICAgICAgICAgIHBbMF0gKz0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBwWzFdICs9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG5Qb2ludDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwb2ludHNba107XG4gICAgICAgICAgICAgICAgcFswXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICBwWzFdID0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgICAgICAgICAvLyBXcml0ZSBiYWNrXG4gICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1QYXRoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3Rvb2wvdHJhbnNmb3JtUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("/**\n * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = __webpack_require__(20);\n    var Element = __webpack_require__(39);\n    var BoundingRect = __webpack_require__(25);\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * 所有子孙元素是否响应鼠标事件\n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         * 获取指定 index 的儿子节点\n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * 获取指定名字的儿子节点\n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * 添加子节点到最后\n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         * 添加子节点在 nextSibling 之前\n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToStorage(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * 移除子节点\n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromStorage(child);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * 移除所有子节点\n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromStorage(child);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * 遍历所有子节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * 深度优先遍历所有子孙节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToStorage(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromStorage(child);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cC5qcz84ZDU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiNjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdyb3Vw5piv5LiA5Liq5a655Zmo77yM5Y+v5Lul5o+S5YWl5a2Q6IqC54K577yMR3JvdXDnmoTlj5jmjaLkuZ/kvJrooqvlupTnlKjliLDlrZDoioLngrnkuIpcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL0dyb3VwXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBHcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cCcpO1xuICogICAgIHZhciBDaXJjbGUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZScpO1xuICogICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gKiAgICAgZy5wb3NpdGlvblswXSA9IDEwMDtcbiAqICAgICBnLnBvc2l0aW9uWzFdID0gMTAwO1xuICogICAgIGcuYWRkKG5ldyBDaXJjbGUoe1xuICogICAgICAgICBzdHlsZToge1xuICogICAgICAgICAgICAgeDogMTAwLFxuICogICAgICAgICAgICAgeTogMTAwLFxuICogICAgICAgICAgICAgcjogMjAsXG4gKiAgICAgICAgIH1cbiAqICAgICB9KSk7XG4gKiAgICAgenIuYWRkKGcpO1xuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4uL0VsZW1lbnQnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gICAgICovXG4gICAgdmFyIEdyb3VwID0gZnVuY3Rpb24gKG9wdHMpIHtcblxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBFbGVtZW50LmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdHMpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBvcHRzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgIHRoaXMuX19zdG9yYWdlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgIH07XG5cbiAgICBHcm91cC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEdyb3VwLFxuXG4gICAgICAgIGlzR3JvdXA6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnZ3JvdXAnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmiYDmnInlrZDlrZnlhYPntKDmmK/lkKblk43lupTpvKDmoIfkuovku7ZcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2NvbnRhaW5lci9Hcm91cCNzaWxlbnRcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaWxlbnQ6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvRWxlbWVudD59XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluaMh+WumiBpbmRleCDnmoTlhL/lrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBpZHhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkQXQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltpZHhdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmjIflrprlkI3lrZfnmoTlhL/lrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZE9mTmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbltpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlrZDoioLngrnliLDmnIDlkI5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5a2Q6IqC54K55ZyoIG5leHRTaWJsaW5nIOS5i+WJjVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gbmV4dFNpYmxpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFkZEJlZm9yZTogZnVuY3Rpb24gKGNoaWxkLCBuZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpc1xuICAgICAgICAgICAgICAgICYmIG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLnBhcmVudCA9PT0gdGhpcykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGNoaWxkcmVuLmluZGV4T2YobmV4dFNpYmxpbmcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDAsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvQWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlICYmIHN0b3JhZ2UgIT09IGNoaWxkLl9fc3RvcmFnZSkge1xuXG4gICAgICAgICAgICAgICAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOenu+mZpOWtkOiKgueCuVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICAgICAgICB2YXIgaWR4ID0genJVdGlsLmluZGV4T2YoY2hpbGRyZW4sIGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcblxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHN0b3JhZ2UpIHtcblxuICAgICAgICAgICAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHpyICYmIHpyLnJlZnJlc2goKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOenu+mZpOaJgOacieWtkOiKgueCuVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6YGN5Y6G5omA5pyJ5a2Q6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaENoaWxkOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3seW6puS8mOWFiOmBjeWOhuaJgOacieWtkOWtmeiKgueCuVxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRDaGlsZHJlblRvU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLmFkZFRvU3RvcmFnZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRlbENoaWxkcmVuRnJvbVN0b3JhZ2U6IGZ1bmN0aW9uIChzdG9yYWdlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKGluY2x1ZGVDaGlsZHJlbikge1xuICAgICAgICAgICAgLy8gVE9ETyBDYWNoaW5nXG4gICAgICAgICAgICB2YXIgcmVjdCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBpbmNsdWRlQ2hpbGRyZW4gfHwgdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgdG1wTWF0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaWdub3JlIHx8IGNoaWxkLmludmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRSZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGNoaWxkLmdldExvY2FsVHJhbnNmb3JtKHRtcE1hdCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgICAgIC8vIFRoZSBib3VuZGluZ1JlY3QgY2FjbHVhdGVkIGJ5IHRyYW5zZm9ybWluZyBvcmlnaW5hbFxuICAgICAgICAgICAgICAgIC8vIHJlY3QgbWF5IGJlIGJpZ2dlciB0aGFuIHRoZSBhY3R1YWwgYnVuZGluZ1JlY3Qgd2hlbiByb3RhdGlvblxuICAgICAgICAgICAgICAgIC8vIGlzIHVzZWQuIChDb25zaWRlciBhIGNpcmNsZSByb3RhdGVkIGFnaW5zdCBpdHMgY2VudGVyLCB3aGVyZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgYm91bmRpbmdSZWN0IHNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGF0IG5vdCBiZVxuICAgICAgICAgICAgICAgIC8vIHJvdGF0ZWQuKSBCdXQgd2UgY2FuIG5vdCBmaW5kIGJldHRlciBhcHByb2FjaCB0byBjYWxjdWxhdGVcbiAgICAgICAgICAgICAgICAvLyBhY3R1YWwgYm91bmRpbmdSZWN0IHlldCwgY29uc2lkZXJpbmcgcGVyZm9ybWFuY2UuXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0bXBSZWN0LmNvcHkoY2hpbGRSZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0gcmVjdCB8fCB0bXBSZWN0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QudW5pb24odG1wUmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0gcmVjdCB8fCBjaGlsZFJlY3QuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdC51bmlvbihjaGlsZFJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWN0IHx8IHRtcFJlY3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKEdyb3VwLCBFbGVtZW50KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JvdXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = __webpack_require__(37);\n    var BoundingRect = __webpack_require__(25);\n    var zrUtil = __webpack_require__(20);\n\n    var LRU = __webpack_require__(48);\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // 图片已经加载完成\n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // 图片加载失败\n                if (!image.width || !image.height) {\n                    return;\n                }\n                var width = style.width;\n                var height = style.height;\n                var aspect = image.width / image.height;\n                if (width == null && height != null) {\n                    // Keep image/height ratio\n                    width = height * aspect;\n                }\n                else if (height == null && width != null) {\n                    height = width / aspect;\n                }\n                else if (width == null && height == null) {\n                    width = image.width;\n                    height = image.height;\n                }\n\n                // 设置transform\n                this.setTransform(ctx);\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanM/YmYxYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUNBQWlDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjY1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbWFnZSBlbGVtZW50XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICovXG5cblxuXG4gICAgdmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZSgnLi9EaXNwbGF5YWJsZScpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBMUlUgPSByZXF1aXJlKCcuLi9jb3JlL0xSVScpO1xuICAgIHZhciBnbG9iYWxJbWFnZUNhY2hlID0gbmV3IExSVSg1MCk7XG4gICAgLyoqXG4gICAgICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFpJbWFnZShvcHRzKSB7XG4gICAgICAgIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfVxuXG4gICAgWkltYWdlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogWkltYWdlLFxuXG4gICAgICAgIHR5cGU6ICdpbWFnZScsXG5cbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBzcmMgPSBzdHlsZS5pbWFnZTtcbiAgICAgICAgICAgIHZhciBpbWFnZTtcblxuICAgICAgICAgICAgLy8gTXVzdCBiaW5kIGVhY2ggdGltZVxuICAgICAgICAgICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG4gICAgICAgICAgICAvLyBzdHlsZS5pbWFnZSBpcyBhIHVybCBzdHJpbmdcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGltYWdlID0gdGhpcy5faW1hZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdHlsZS5pbWFnZSBpcyBhbiBIVE1MSW1hZ2VFbGVtZW50IG9yIEhUTUxDYW52YXNFbGVtZW50IG9yIENhbnZhc1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBzcmM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGSVhNRSBDYXNlIGNyZWF0ZSBtYW55IGltYWdlcyB3aXRoIHNyY1xuICAgICAgICAgICAgaWYgKCFpbWFnZSAmJiBzcmMpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgZ2V0IGZyb20gZ2xvYmFsIGltYWdlIGNhY2hlXG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZEltZ09iaiA9IGdsb2JhbEltYWdlQ2FjaGUuZ2V0KHNyYyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZWRJbWdPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGltYWdlXG4gICAgICAgICAgICAgICAgICAgIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlZEltZ09iai5wZW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkSW1nT2JqLnBlbmRpbmdbaV0uZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkSW1nT2JqID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZzogW3RoaXNdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IHNyYztcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsSW1hZ2VDYWNoZS5wdXQoc3JjLCBjYWNoZWRJbWdPYmopO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IGNhY2hlZEltZ09iai5pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW1hZ2UgaXMgbm90IGNvbXBsZXRlIGZpbmlzaCwgYWRkIHRvIHBlbmRpbmcgbGlzdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWltYWdlLndpZHRoIHx8ICFpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZEltZ09iai5wZW5kaW5nLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICAgICAgICAgIC8vIOWbvueJh+W3sue7j+WKoOi9veWujOaIkFxuICAgICAgICAgICAgICAgIC8vIGlmIChpbWFnZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09ICdJTUcnKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGlmICghaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAvLyBFbHNlIGlzIGNhbnZhc1xuXG4gICAgICAgICAgICAgICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgICAgICAgICAgICAgLy8g5Zu+54mH5Yqg6L295aSx6LSlXG4gICAgICAgICAgICAgICAgaWYgKCFpbWFnZS53aWR0aCB8fCAhaW1hZ2UuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHN0eWxlLmhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgYXNwZWN0ID0gaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoID09IG51bGwgJiYgaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBpbWFnZS9oZWlnaHQgcmF0aW9cbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhlaWdodCA9PSBudWxsICYmIHdpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdpZHRoID09IG51bGwgJiYgaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIOiuvue9rnRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc1dpZHRoICYmIHN0eWxlLnNIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4ID0gc3R5bGUuc3ggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0gc3R5bGUuc3kgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCB3aWR0aCwgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlLnN4ICYmIHN0eWxlLnN5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IHN0eWxlLnN4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSBzdHlsZS5zeTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNXaWR0aCA9IHdpZHRoIC0gc3g7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzSGVpZ2h0ID0gaGVpZ2h0IC0gc3k7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN4LCBzeSwgc1dpZHRoLCBzSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeCwgeSwgd2lkdGgsIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgICAgICAvLyBEcmF3IHJlY3QgdGV4dFxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICBpZiAoISB0aGlzLl9yZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnggfHwgMCwgc3R5bGUueSB8fCAwLCBzdHlsZS53aWR0aCB8fCAwLCBzdHlsZS5oZWlnaHQgfHwgMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoWkltYWdlLCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFpJbWFnZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = __webpack_require__(37);\n    var zrUtil = __webpack_require__(20);\n    var textContain = __webpack_require__(24);\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                // FIXME in text contain default is top\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('国', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    // Fill after stroke so the outline will not cover the main part.\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (!this._rect) {\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                if (style.hasStroke()) {\n                    var w = style.lineWidth;\n                    rect.x -= w / 2;\n                    rect.y -= w / 2;\n                    rect.width += w;\n                    rect.height += w;\n                }\n                this._rect = rect;\n            }\n\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qcz8zMjQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiNjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRleHQgZWxlbWVudFxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvVGV4dFxuICpcbiAqIFRPRE8gV3JhcHBpbmdcbiAqXG4gKiBUZXh0IG5vdCBzdXBwb3J0IGdyYWRpZW50XG4gKi9cblxuXG5cbiAgICB2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKCcuL0Rpc3BsYXlhYmxlJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJy4uL2NvbnRhaW4vdGV4dCcpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9UZXh0XG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgdmFyIFRleHQgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIH07XG5cbiAgICBUZXh0LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogVGV4dCxcblxuICAgICAgICB0eXBlOiAndGV4dCcsXG5cbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciB4ID0gc3R5bGUueCB8fCAwO1xuICAgICAgICAgICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0O1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICAgICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcblxuICAgICAgICAgICAgLy8gQWx3YXlzIGJpbmQgc3R5bGVcbiAgICAgICAgICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuXG4gICAgICAgICAgICBpZiAodGV4dCkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbjtcbiAgICAgICAgICAgICAgICB2YXIgZm9udCA9IHN0eWxlLnRleHRGb250IHx8IHN0eWxlLmZvbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCwgZm9udCwgc3R5bGUudGV4dEFsaWduLCAndG9wJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGV4dEJhc2VsaW5lXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gcmVjdC5oZWlnaHQgLyAyIC0gcmVjdC5saW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSByZWN0LmhlaWdodCAtIHJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gcmVjdC5saW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gSW52YWxpZCBmb250XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250IHx8ICcxMnB4IHNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0ZXh0QWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgZGVmYXVsdCBsZWZ0IHRleHRBbGlnbi4gR2l2aW5nIGludmFsaWQgdmFsdWUgd2lsbCBjYXVzZSBzdGF0ZSBub3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgaWYgKGN0eC50ZXh0QWxpZ24gIT09IHRleHRBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBpbiB0ZXh0IGNvbnRhaW4gZGVmYXVsdCBpcyB0b3BcbiAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lIHx8ICdhbHBoYWJldGljJztcbiAgICAgICAgICAgICAgICAvLyBVc2UgY2FudmFzIGRlZmF1bHQgYWxwaGFiZXRpYyBiYXNlbGluZVxuICAgICAgICAgICAgICAgIGlmIChjdHgudGV4dEJhc2VsaW5lICE9PSB0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbGluZUhlaWdodCA9IHRleHRDb250YWluLm1lYXN1cmVUZXh0KCflm70nLCBjdHguZm9udCkud2lkdGg7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dExpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlsbCBhZnRlciBzdHJva2Ugc28gdGhlIG91dGxpbmUgd2lsbCBub3QgY292ZXIgdGhlIG1haW4gcGFydC5cbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaGFzU3Ryb2tlKCkgJiYgY3R4LnN0cm9rZVRleHQodGV4dExpbmVzW2ldLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaGFzRmlsbCgpICYmIGN0eC5maWxsVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB5ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ247XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnRleHQgKyAnJywgc3R5bGUudGV4dEZvbnQgfHwgc3R5bGUuZm9udCwgc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA/ICd0b3AnIDogc3R5bGUudGV4dEJhc2VsaW5lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnkgLT0gcmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnkgLT0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjdC54ICs9IHN0eWxlLnggfHwgMDtcbiAgICAgICAgICAgICAgICByZWN0LnkgKz0gc3R5bGUueSB8fCAwO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcmVjdC54IC09IHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICByZWN0LnkgLT0gdyAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Qud2lkdGggKz0gdztcbiAgICAgICAgICAgICAgICAgICAgcmVjdC5oZWlnaHQgKz0gdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhUZXh0LCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRleHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9UZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("'use strict';\n/**\n * 圆形\n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = __webpack_require__(36).extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // else {\n            //     if (ctx.allocate && !ctx.data.length) {\n            //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n            //     }\n            // }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzPzA3NmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyIsImZpbGUiOiI2Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog5ZyG5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvQ2lyY2xlXG4gKi9cblxuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdjaXJjbGUnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBjeDogMCxcbiAgICAgICAgICAgIGN5OiAwLFxuICAgICAgICAgICAgcjogMFxuICAgICAgICB9LFxuXG5cbiAgICAgICAgYnVpbGRQYXRoIDogZnVuY3Rpb24gKGN0eCwgc2hhcGUsIGluQnVuZGxlKSB7XG4gICAgICAgICAgICAvLyBCZXR0ZXIgc3Ryb2tpbmcgaW4gU2hhcGVCdW5kbGVcbiAgICAgICAgICAgIC8vIEFsd2F5cyBkbyBpdCBtYXkgaGF2ZSBwZXJmb3JtZW5jZSBpc3N1ZSAoIGZpbGwgbWF5IGJlIDJ4IG1vcmUgY29zdClcbiAgICAgICAgICAgIGlmIChpbkJ1bmRsZSkge1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc2hhcGUuY3ggKyBzaGFwZS5yLCBzaGFwZS5jeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlIHtcbiAgICAgICAgICAgIC8vICAgICBpZiAoY3R4LmFsbG9jYXRlICYmICFjdHguZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgY3R4LmFsbG9jYXRlKGN0eC5DTURfTUVNX1NJWkUuQSk7XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXG4gICAgICAgICAgICAvLyBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuICAgICAgICAgICAgY3R4LmFyYyhzaGFwZS5jeCwgc2hhcGUuY3ksIHNoYXBlLnIsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/**\n * 扇形\n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    var env = __webpack_require__(18);\n    var Path = __webpack_require__(36);\n\n    var shadowTemp = [\n        ['shadowBlur', 0],\n        ['shadowColor', '#000'],\n        ['shadowOffsetX', 0],\n        ['shadowOffsetY', 0]\n    ];\n\n    module.exports = Path.extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\n            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\n            // where exception \"unexpected call to method or property access\"\n            // might be thrown when calling ctx.fill after a path whose area size\n            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\n            // (e.g.,\n            //  ctx.moveTo(10, 10);\n            //  ctx.lineTo(20, 10);\n            //  ctx.closePath();\n            //  ctx.clip();\n            //  ctx.shadowBlur = 10;\n            //  ...\n            //  ctx.fill();\n            // )\n            ? function () {\n                var clipPaths = this.__clipPaths;\n                var style = this.style;\n                var modified;\n\n                if (clipPaths) {\n                    for (var i = 0; i < clipPaths.length; i++) {\n                        var shape = clipPaths[i] && clipPaths[i].shape;\n                        if (shape && shape.startAngle === shape.endAngle) {\n                            for (var j = 0; j < shadowTemp.length; j++) {\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n                            }\n                            modified = true;\n                            break;\n                        }\n                    }\n                }\n\n                Path.prototype.brush.apply(this, arguments);\n\n                if (modified) {\n                    for (var j = 0; j < shadowTemp.length; j++) {\n                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n                    }\n                }\n            }\n            : Path.prototype.brush,\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yLmpzPzk3NjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUNBQW1DLHVCQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLIiwiZmlsZSI6IjY4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDmiYflvaJcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1NlY3RvclxuICovXG5cblxuXG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZW52Jyk7XG4gICAgdmFyIFBhdGggPSByZXF1aXJlKCcuLi9QYXRoJyk7XG5cbiAgICB2YXIgc2hhZG93VGVtcCA9IFtcbiAgICAgICAgWydzaGFkb3dCbHVyJywgMF0sXG4gICAgICAgIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLFxuICAgICAgICBbJ3NoYWRvd09mZnNldFgnLCAwXSxcbiAgICAgICAgWydzaGFkb3dPZmZzZXRZJywgMF1cbiAgICBdO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXRoLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3NlY3RvcicsXG5cbiAgICAgICAgc2hhcGU6IHtcblxuICAgICAgICAgICAgY3g6IDAsXG5cbiAgICAgICAgICAgIGN5OiAwLFxuXG4gICAgICAgICAgICByMDogMCxcblxuICAgICAgICAgICAgcjogMCxcblxuICAgICAgICAgICAgc3RhcnRBbmdsZTogMCxcblxuICAgICAgICAgICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuXG4gICAgICAgICAgICBjbG9ja3dpc2U6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBicnVzaDogKGVudi5icm93c2VyLmllICYmIGVudi5icm93c2VyLnZlcnNpb24gPj0gMTEpIC8vIHZlcnNpb246ICcxMS4wJ1xuICAgICAgICAgICAgLy8gRml4IHdlaXJkIGJ1ZyBpbiBzb21lIHZlcnNpb24gb2YgSUUxMSAobGlrZSAxMS4wLjk2MDAuMTc4MDEpLFxuICAgICAgICAgICAgLy8gd2hlcmUgZXhjZXB0aW9uIFwidW5leHBlY3RlZCBjYWxsIHRvIG1ldGhvZCBvciBwcm9wZXJ0eSBhY2Nlc3NcIlxuICAgICAgICAgICAgLy8gbWlnaHQgYmUgdGhyb3duIHdoZW4gY2FsbGluZyBjdHguZmlsbCBhZnRlciBhIHBhdGggd2hvc2UgYXJlYSBzaXplXG4gICAgICAgICAgICAvLyBpcyB6ZXJvIGlzIGRyYXduIGFuZCBjdHguY2xpcCgpIGlzIGNhbGxlZCBhbmQgc2hhZG93Qmx1ciBpcyBzZXQuXG4gICAgICAgICAgICAvLyAoZS5nLixcbiAgICAgICAgICAgIC8vICBjdHgubW92ZVRvKDEwLCAxMCk7XG4gICAgICAgICAgICAvLyAgY3R4LmxpbmVUbygyMCwgMTApO1xuICAgICAgICAgICAgLy8gIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIC8vICBjdHguY2xpcCgpO1xuICAgICAgICAgICAgLy8gIGN0eC5zaGFkb3dCbHVyID0gMTA7XG4gICAgICAgICAgICAvLyAgLi4uXG4gICAgICAgICAgICAvLyAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIC8vIClcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjbGlwUGF0aHMgPSB0aGlzLl9fY2xpcFBhdGhzO1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gY2xpcFBhdGhzW2ldICYmIGNsaXBQYXRoc1tpXS5zaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5zdGFydEFuZ2xlID09PSBzaGFwZS5lbmRBbmdsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhZG93VGVtcC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dUZW1wW2pdWzJdID0gc3R5bGVbc2hhZG93VGVtcFtqXVswXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlW3NoYWRvd1RlbXBbal1bMF1dID0gc2hhZG93VGVtcFtqXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgUGF0aC5wcm90b3R5cGUuYnJ1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlW3NoYWRvd1RlbXBbal1bMF1dID0gc2hhZG93VGVtcFtqXVsyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogUGF0aC5wcm90b3R5cGUuYnJ1c2gsXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICAgICAgICAgIHZhciByMCA9IE1hdGgubWF4KHNoYXBlLnIwIHx8IDAsIDApO1xuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcbiAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcblxuICAgICAgICAgICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIwICsgeCwgdW5pdFkgKiByMCArIHkpO1xuXG4gICAgICAgICAgICBjdHgubGluZVRvKHVuaXRYICogciArIHgsIHVuaXRZICogciArIHkpO1xuXG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhY2xvY2t3aXNlKTtcblxuICAgICAgICAgICAgY3R4LmxpbmVUbyhcbiAgICAgICAgICAgICAgICBNYXRoLmNvcyhlbmRBbmdsZSkgKiByMCArIHgsXG4gICAgICAgICAgICAgICAgTWF0aC5zaW4oZW5kQW5nbGUpICogcjAgKyB5XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAocjAgIT09IDApIHtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHgsIHksIHIwLCBlbmRBbmdsZSwgc3RhcnRBbmdsZSwgY2xvY2t3aXNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("/**\n * 圆环\n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = __webpack_require__(36).extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZy5qcz9iNzFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLIiwiZmlsZSI6IjY5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDlnIbnjq9cbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1JpbmdcbiAqL1xuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdyaW5nJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgICByMDogMFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgICAgICAgICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUuciwgeSk7XG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHNoYXBlLnIsIDAsIFBJMiwgZmFsc2UpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUucjAsIHkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yMCwgMCwgUEkyLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("/**\n * 多边形\n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = __webpack_require__(71);\n\n    module.exports = __webpack_require__(36).extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbi5qcz9kMzdkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxLQUFLIiwiZmlsZSI6IjcwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDlpJrovrnlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9Qb2x5Z29uXG4gKi9cblxuXG4gICAgdmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvcG9seScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcbiAgICAgICAgXG4gICAgICAgIHR5cGU6ICdwb2x5Z29uJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgcG9pbnRzOiBudWxsLFxuXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxuXG4gICAgICAgICAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24uanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n    var smoothSpline = __webpack_require__(72);\n    var smoothBezier = __webpack_require__(73);\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3BvbHkuanM/Nzg4YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsaUNBQWlDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI3MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHNtb290aFNwbGluZSA9IHJlcXVpcmUoJy4vc21vb3RoU3BsaW5lJyk7XG4gICAgdmFyIHNtb290aEJlemllciA9IHJlcXVpcmUoJy4vc21vb3RoQmV6aWVyJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSwgY2xvc2VQYXRoKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgICAgICAgICAgdmFyIHNtb290aCA9IHNoYXBlLnNtb290aDtcbiAgICAgICAgICAgIGlmIChwb2ludHMgJiYgcG9pbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNtb290aCAmJiBzbW9vdGggIT09ICdzcGxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sUG9pbnRzID0gc21vb3RoQmV6aWVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLCBzbW9vdGgsIGNsb3NlUGF0aCwgc2hhcGUuc21vb3RoQ29uc3RyYWludFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoY2xvc2VQYXRoID8gbGVuIDogbGVuIC0gMSk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNwMSA9IGNvbnRyb2xQb2ludHNbaSAqIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNwMiA9IGNvbnRyb2xQb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3AxWzBdLCBjcDFbMV0sIGNwMlswXSwgY3AyWzFdLCBwWzBdLCBwWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc21vb3RoID09PSAnc3BsaW5lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gc21vb3RoU3BsaW5lKHBvaW50cywgY2xvc2VQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2xvc2VQYXRoICYmIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seS5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("/**\n * Catmull-Rom spline 插值折线\n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = __webpack_require__(26);\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points 线段顶点数组\n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aFNwbGluZS5qcz9hMTdjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjcyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDYXRtdWxsLVJvbSBzcGxpbmUg5o+S5YC85oqY57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhTcGxpbmVcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICogICAgICAgICBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi4vLi4vY29yZS92ZWN0b3InKTtcblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMpIHtcbiAgICAgICAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICAgICAgICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gICAgICAgIHJldHVybiAoMiAqIChwMSAtIHAyKSArIHYwICsgdjEpICogdDNcbiAgICAgICAgICAgICAgICArICgtMyAqIChwMSAtIHAyKSAtIDIgKiB2MCAtIHYxKSAqIHQyXG4gICAgICAgICAgICAgICAgKyB2MCAqIHQgKyBwMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhTcGxpbmVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMg57q/5q616aG254K55pWw57uEXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xvb3BcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2ludHMsIGlzTG9vcCkge1xuICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IHZlYzIuZGlzdGFuY2UocG9pbnRzW2kgLSAxXSwgcG9pbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWdzID0gZGlzdGFuY2UgLyAyO1xuICAgICAgICBzZWdzID0gc2VncyA8IGxlbiA/IGxlbiA6IHNlZ3M7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnczsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gaSAvIChzZWdzIC0gMSkgKiAoaXNMb29wID8gbGVuIDogbGVuIC0gMSk7XG4gICAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5mbG9vcihwb3MpO1xuXG4gICAgICAgICAgICB2YXIgdyA9IHBvcyAtIGlkeDtcblxuICAgICAgICAgICAgdmFyIHAwO1xuICAgICAgICAgICAgdmFyIHAxID0gcG9pbnRzW2lkeCAlIGxlbl07XG4gICAgICAgICAgICB2YXIgcDI7XG4gICAgICAgICAgICB2YXIgcDM7XG4gICAgICAgICAgICBpZiAoIWlzTG9vcCkge1xuICAgICAgICAgICAgICAgIHAwID0gcG9pbnRzW2lkeCA9PT0gMCA/IGlkeCA6IGlkeCAtIDFdO1xuICAgICAgICAgICAgICAgIHAyID0gcG9pbnRzW2lkeCA+IGxlbiAtIDIgPyBsZW4gLSAxIDogaWR4ICsgMV07XG4gICAgICAgICAgICAgICAgcDMgPSBwb2ludHNbaWR4ID4gbGVuIC0gMyA/IGxlbiAtIDEgOiBpZHggKyAyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHAwID0gcG9pbnRzWyhpZHggLSAxICsgbGVuKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgcDIgPSBwb2ludHNbKGlkeCArIDEpICUgbGVuXTtcbiAgICAgICAgICAgICAgICBwMyA9IHBvaW50c1soaWR4ICsgMikgJSBsZW5dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdzIgPSB3ICogdztcbiAgICAgICAgICAgIHZhciB3MyA9IHcgKiB3MjtcblxuICAgICAgICAgICAgcmV0LnB1c2goW1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlKHAwWzBdLCBwMVswXSwgcDJbMF0sIHAzWzBdLCB3LCB3MiwgdzMpLFxuICAgICAgICAgICAgICAgIGludGVycG9sYXRlKHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdLCB3LCB3MiwgdzMpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhTcGxpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/**\n * 贝塞尔平滑曲线\n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = __webpack_require__(26);\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * 贝塞尔平滑曲线\n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points 线段顶点数组\n     * @param {number} smooth 平滑等级, 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n     *                           整个折线的包围盒做一个并集用来约束控制点。\n     * @param {Array} 计算出来的控制点数组\n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // 与指定的包围盒做并集\n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aEJlemllci5qcz8yNzEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsU0FBUztBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIOi0neWhnuWwlOW5s+a7keabsue6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoQmV6aWVyXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqICAgICAgICAgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi4vLi4vY29yZS92ZWN0b3InKTtcbiAgICB2YXIgdjJNaW4gPSB2ZWMyLm1pbjtcbiAgICB2YXIgdjJNYXggPSB2ZWMyLm1heDtcbiAgICB2YXIgdjJTY2FsZSA9IHZlYzIuc2NhbGU7XG4gICAgdmFyIHYyRGlzdGFuY2UgPSB2ZWMyLmRpc3RhbmNlO1xuICAgIHZhciB2MkFkZCA9IHZlYzIuYWRkO1xuXG4gICAgLyoqXG4gICAgICog6LSd5aGe5bCU5bmz5ruR5puy57q/XG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoQmV6aWVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIOe6v+autemhtueCueaVsOe7hFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbW9vdGgg5bmz5ruR562J57qnLCAwLTFcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG9vcFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbnN0cmFpbnQg5bCG6K6h566X5Ye65p2l55qE5o6n5Yi254K557qm5p2f5Zyo5LiA5Liq5YyF5Zu055uS5YaFXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICDmr5TlpoIgW1swLCAwXSwgWzEwMCwgMTAwXV0sIOi/meS4quWMheWbtOebkuS8muS4jlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5pW05Liq5oqY57q/55qE5YyF5Zu055uS5YGa5LiA5Liq5bm26ZuG55So5p2l57qm5p2f5o6n5Yi254K544CCXG4gICAgICogQHBhcmFtIHtBcnJheX0g6K6h566X5Ye65p2l55qE5o6n5Yi254K55pWw57uEXG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocG9pbnRzLCBzbW9vdGgsIGlzTG9vcCwgY29uc3RyYWludCkge1xuICAgICAgICB2YXIgY3BzID0gW107XG5cbiAgICAgICAgdmFyIHYgPSBbXTtcbiAgICAgICAgdmFyIHYxID0gW107XG4gICAgICAgIHZhciB2MiA9IFtdO1xuICAgICAgICB2YXIgcHJldlBvaW50O1xuICAgICAgICB2YXIgbmV4dFBvaW50O1xuXG4gICAgICAgIHZhciBtaW4sIG1heDtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIG1pbiA9IFtJbmZpbml0eSwgSW5maW5pdHldO1xuICAgICAgICAgICAgbWF4ID0gWy1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2Mk1pbihtaW4sIG1pbiwgcG9pbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB2Mk1heChtYXgsIG1heCwgcG9pbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIOS4juaMh+WumueahOWMheWbtOebkuWBmuW5tumbhlxuICAgICAgICAgICAgdjJNaW4obWluLCBtaW4sIGNvbnN0cmFpbnRbMF0pO1xuICAgICAgICAgICAgdjJNYXgobWF4LCBtYXgsIGNvbnN0cmFpbnRbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgICAgICAgICBpZiAoaXNMb29wKSB7XG4gICAgICAgICAgICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgPyBpIC0gMSA6IGxlbiAtIDFdO1xuICAgICAgICAgICAgICAgIG5leHRQb2ludCA9IHBvaW50c1soaSArIDEpICUgbGVuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3BzLnB1c2godmVjMi5jbG9uZShwb2ludHNbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludHNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmVjMi5zdWIodiwgbmV4dFBvaW50LCBwcmV2UG9pbnQpO1xuXG4gICAgICAgICAgICAvLyB1c2UgZGVncmVlIHRvIHNjYWxlIHRoZSBoYW5kbGUgbGVuZ3RoXG4gICAgICAgICAgICB2MlNjYWxlKHYsIHYsIHNtb290aCk7XG5cbiAgICAgICAgICAgIHZhciBkMCA9IHYyRGlzdGFuY2UocG9pbnQsIHByZXZQb2ludCk7XG4gICAgICAgICAgICB2YXIgZDEgPSB2MkRpc3RhbmNlKHBvaW50LCBuZXh0UG9pbnQpO1xuICAgICAgICAgICAgdmFyIHN1bSA9IGQwICsgZDE7XG4gICAgICAgICAgICBpZiAoc3VtICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZDAgLz0gc3VtO1xuICAgICAgICAgICAgICAgIGQxIC89IHN1bTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdjJTY2FsZSh2MSwgdiwgLWQwKTtcbiAgICAgICAgICAgIHYyU2NhbGUodjIsIHYsIGQxKTtcbiAgICAgICAgICAgIHZhciBjcDAgPSB2MkFkZChbXSwgcG9pbnQsIHYxKTtcbiAgICAgICAgICAgIHZhciBjcDEgPSB2MkFkZChbXSwgcG9pbnQsIHYyKTtcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50KSB7XG4gICAgICAgICAgICAgICAgdjJNYXgoY3AwLCBjcDAsIG1pbik7XG4gICAgICAgICAgICAgICAgdjJNaW4oY3AwLCBjcDAsIG1heCk7XG4gICAgICAgICAgICAgICAgdjJNYXgoY3AxLCBjcDEsIG1pbik7XG4gICAgICAgICAgICAgICAgdjJNaW4oY3AxLCBjcDEsIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcHMucHVzaChjcDApO1xuICAgICAgICAgICAgY3BzLnB1c2goY3AxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0xvb3ApIHtcbiAgICAgICAgICAgIGNwcy5wdXNoKGNwcy5zaGlmdCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcHM7XG4gICAgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aEJlemllci5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = __webpack_require__(71);\n\n    module.exports = __webpack_require__(36).extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanM/M2NkYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiNzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1BvbHlsaW5lXG4gKi9cblxuXG4gICAgdmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvcG9seScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcbiAgICAgICAgXG4gICAgICAgIHR5cGU6ICdwb2x5bGluZScsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHBvaW50czogbnVsbCxcblxuICAgICAgICAgICAgc21vb3RoOiBmYWxzZSxcblxuICAgICAgICAgICAgc21vb3RoQ29uc3RyYWludDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcblxuICAgICAgICAgICAgZmlsbDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHBvbHlIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/**\n * 矩形\n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = __webpack_require__(76);\n\n    module.exports = __webpack_require__(36).extend({\n\n        type: 'rect',\n\n        shape: {\n            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n            // r缩写为1         相当于 [1, 1, 1, 1]\n            // r缩写为[1]       相当于 [1, 1, 1, 1]\n            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qcz8zYjNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiNzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIOefqeW9olxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmVjdFxuICovXG5cblxuICAgIHZhciByb3VuZFJlY3RIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvcm91bmRSZWN0Jyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdyZWN0JyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgLy8g5bem5LiK44CB5Y+z5LiK44CB5Y+z5LiL44CB5bem5LiL6KeS55qE5Y2K5b6E5L6d5qyh5Li6cjHjgIFyMuOAgXIz44CBcjRcbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLoxICAgICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ulsxXSAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6WzEsIDJdICAgIOebuOW9k+S6jiBbMSwgMiwgMSwgMl1cbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLpbMSwgMiwgM10g55u45b2T5LqOIFsxLCAyLCAzLCAyXVxuICAgICAgICAgICAgcjogMCxcblxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgICAgICAgICAgIGlmICghc2hhcGUucikge1xuICAgICAgICAgICAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm91bmRSZWN0SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qcz80MThkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ijc2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHIgPSBzaGFwZS5yO1xuICAgICAgICAgICAgdmFyIHIxO1xuICAgICAgICAgICAgdmFyIHIyO1xuICAgICAgICAgICAgdmFyIHIzO1xuICAgICAgICAgICAgdmFyIHI0O1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHdpZHRoIGFuZCBoZWlnaHQgdG8gcG9zaXRpdmUgZm9yIGJldHRlciBib3JkZXJSYWRpdXNcbiAgICAgICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgICAgICB4ID0geCArIHdpZHRoO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICB5ID0geSArIGhlaWdodDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAociBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gclswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoci5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcjEgPSByMyA9IHJbMF07XG4gICAgICAgICAgICAgICAgICAgIHIyID0gcjQgPSByWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICByMSA9IHJbMF07XG4gICAgICAgICAgICAgICAgICAgIHIyID0gcjQgPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICByMyA9IHJbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByMSA9IHJbMF07XG4gICAgICAgICAgICAgICAgICAgIHIyID0gclsxXTtcbiAgICAgICAgICAgICAgICAgICAgcjMgPSByWzJdO1xuICAgICAgICAgICAgICAgICAgICByNCA9IHJbM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG90YWw7XG4gICAgICAgICAgICBpZiAocjEgKyByMiA+IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSByMSArIHIyO1xuICAgICAgICAgICAgICAgIHIxICo9IHdpZHRoIC8gdG90YWw7XG4gICAgICAgICAgICAgICAgcjIgKj0gd2lkdGggLyB0b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyMyArIHI0ID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHIzICsgcjQ7XG4gICAgICAgICAgICAgICAgcjMgKj0gd2lkdGggLyB0b3RhbDtcbiAgICAgICAgICAgICAgICByNCAqPSB3aWR0aCAvIHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIyICsgcjMgPiBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHIyICsgcjM7XG4gICAgICAgICAgICAgICAgcjIgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgICAgICAgICAgICAgcjMgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocjEgKyByNCA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gcjEgKyByNDtcbiAgICAgICAgICAgICAgICByMSAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICAgICAgICAgICAgICByNCAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHIxLCB5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcjIsIHkpO1xuICAgICAgICAgICAgcjIgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByMlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcjMpO1xuICAgICAgICAgICAgcjMgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByMywgeSArIGhlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHI0LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIHI0ICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByNFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSArIHIxKTtcbiAgICAgICAgICAgIHIxICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByMSwgeSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("/**\n * 直线\n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = __webpack_require__(36).extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qcz83NzI4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyIsImZpbGUiOiI3Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog55u057q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9MaW5lXG4gKi9cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2xpbmUnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAvLyBTdGFydCBwb2ludFxuICAgICAgICAgICAgeDE6IDAsXG4gICAgICAgICAgICB5MTogMCxcbiAgICAgICAgICAgIC8vIEVuZCBwb2ludFxuICAgICAgICAgICAgeDI6IDAsXG4gICAgICAgICAgICB5MjogMCxcblxuICAgICAgICAgICAgcGVyY2VudDogMVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcbiAgICAgICAgICAgIGZpbGw6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeDEgPSBzaGFwZS54MTtcbiAgICAgICAgICAgIHZhciB5MSA9IHNoYXBlLnkxO1xuICAgICAgICAgICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgICAgICAgICB2YXIgeTIgPSBzaGFwZS55MjtcbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcblxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgeDIgPSB4MSAqICgxIC0gcGVyY2VudCkgKyB4MiAqIHBlcmNlbnQ7XG4gICAgICAgICAgICAgICAgeTIgPSB5MSAqICgxIC0gcGVyY2VudCkgKyB5MiAqIHBlcmNlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBwb2ludCBhdCBwZXJjZW50XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHBvaW50QXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBzaGFwZS54MSAqICgxIC0gcCkgKyBzaGFwZS54MiAqIHAsXG4gICAgICAgICAgICAgICAgc2hhcGUueTEgKiAoMSAtIHApICsgc2hhcGUueTIgKiBwXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("'use strict';\n/**\n * 贝塞尔曲线\n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = __webpack_require__(53);\n    var vec2 = __webpack_require__(26);\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = __webpack_require__(36).extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanM/ZjVjNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiNzguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIOi0neWhnuWwlOabsue6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL0JlemllckN1cnZlXG4gKi9cblxuXG4gICAgdmFyIGN1cnZlVG9vbCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY3VydmUnKTtcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIHF1YWRyYXRpY1N1YmRpdmlkZSA9IGN1cnZlVG9vbC5xdWFkcmF0aWNTdWJkaXZpZGU7XG4gICAgdmFyIGN1YmljU3ViZGl2aWRlID0gY3VydmVUb29sLmN1YmljU3ViZGl2aWRlO1xuICAgIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlVG9vbC5xdWFkcmF0aWNBdDtcbiAgICB2YXIgY3ViaWNBdCA9IGN1cnZlVG9vbC5jdWJpY0F0O1xuICAgIHZhciBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgPSBjdXJ2ZVRvb2wucXVhZHJhdGljRGVyaXZhdGl2ZUF0O1xuICAgIHZhciBjdWJpY0Rlcml2YXRpdmVBdCA9IGN1cnZlVG9vbC5jdWJpY0Rlcml2YXRpdmVBdDtcblxuICAgIHZhciBvdXQgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHNvbWVWZWN0b3JBdChzaGFwZSwgdCwgaXNUYW5nZW50KSB7XG4gICAgICAgIHZhciBjcHgyID0gc2hhcGUuY3B4MjtcbiAgICAgICAgdmFyIGNweTIgPSBzaGFwZS5jcHkyO1xuICAgICAgICBpZiAoY3B4MiA9PT0gbnVsbCB8fCBjcHkyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBjdWJpY0Rlcml2YXRpdmVBdCA6IGN1YmljQXQpKHNoYXBlLngxLCBzaGFwZS5jcHgxLCBzaGFwZS5jcHgyLCBzaGFwZS54MiwgdCksXG4gICAgICAgICAgICAgICAgKGlzVGFuZ2VudCA/IGN1YmljRGVyaXZhdGl2ZUF0IDogY3ViaWNBdCkoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLmNweTIsIHNoYXBlLnkyLCB0KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgKGlzVGFuZ2VudCA/IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA6IHF1YWRyYXRpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUueDIsIHQpLFxuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLnkyLCB0KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdiZXppZXItY3VydmUnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICB4MTogMCxcbiAgICAgICAgICAgIHkxOiAwLFxuICAgICAgICAgICAgeDI6IDAsXG4gICAgICAgICAgICB5MjogMCxcbiAgICAgICAgICAgIGNweDE6IDAsXG4gICAgICAgICAgICBjcHkxOiAwLFxuICAgICAgICAgICAgLy8gY3B4MjogMCxcbiAgICAgICAgICAgIC8vIGNweTI6IDBcblxuICAgICAgICAgICAgLy8gQ3VydmUgc2hvdyBwZXJjZW50LCBmb3IgYW5pbWF0aW5nXG4gICAgICAgICAgICBwZXJjZW50OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuICAgICAgICAgICAgZmlsbDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4MSA9IHNoYXBlLngxO1xuICAgICAgICAgICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgICAgICAgICB2YXIgeDIgPSBzaGFwZS54MjtcbiAgICAgICAgICAgIHZhciB5MiA9IHNoYXBlLnkyO1xuICAgICAgICAgICAgdmFyIGNweDEgPSBzaGFwZS5jcHgxO1xuICAgICAgICAgICAgdmFyIGNweTEgPSBzaGFwZS5jcHkxO1xuICAgICAgICAgICAgdmFyIGNweDIgPSBzaGFwZS5jcHgyO1xuICAgICAgICAgICAgdmFyIGNweTIgPSBzaGFwZS5jcHkyO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblxuICAgICAgICAgICAgaWYgKGNweDIgPT0gbnVsbCB8fCBjcHkyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeDEsIGNweDEsIHgyLCBwZXJjZW50LCBvdXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3B4MSA9IG91dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBvdXRbMl07XG4gICAgICAgICAgICAgICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxLCBjcHkxLCB5MiwgcGVyY2VudCwgb3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgICAgICAgICAgICAgIHkyID0gb3V0WzJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICBjcHgxLCBjcHkxLFxuICAgICAgICAgICAgICAgICAgICB4MiwgeTJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1YmljU3ViZGl2aWRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeDEsIGNweDEsIGNweDIsIHgyLCBwZXJjZW50LCBvdXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3B4MSA9IG91dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgY3B4MiA9IG91dFsyXTtcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBvdXRbM107XG4gICAgICAgICAgICAgICAgICAgIGN1YmljU3ViZGl2aWRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeTEsIGNweTEsIGNweTIsIHkyLCBwZXJjZW50LCBvdXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3B5MSA9IG91dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgY3B5MiA9IG91dFsyXTtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBvdXRbM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICBjcHgxLCBjcHkxLFxuICAgICAgICAgICAgICAgICAgICBjcHgyLCBjcHkyLFxuICAgICAgICAgICAgICAgICAgICB4MiwgeTJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcG9pbnQgYXQgcGVyY2VudFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBwb2ludEF0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHNvbWVWZWN0b3JBdCh0aGlzLnNoYXBlLCB0LCBmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0YW5nZW50IGF0IHBlcmNlbnRcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGFuZ2VudEF0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIHAgPSBzb21lVmVjdG9yQXQodGhpcy5zaGFwZSwgdCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmVjMi5ub3JtYWxpemUocCwgcCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/**\n * 圆弧\n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = __webpack_require__(36).extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjLmpzPzI5OTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyIsImZpbGUiOiI3OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog5ZyG5bynXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9BcmNcbiAqL1xuIFxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnYXJjJyxcblxuICAgICAgICBzaGFwZToge1xuXG4gICAgICAgICAgICBjeDogMCxcblxuICAgICAgICAgICAgY3k6IDAsXG5cbiAgICAgICAgICAgIHI6IDAsXG5cbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IDAsXG5cbiAgICAgICAgICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMixcblxuICAgICAgICAgICAgY2xvY2t3aXNlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcblxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG5cbiAgICAgICAgICAgIGZpbGw6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG5cbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcbiAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcblxuICAgICAgICAgICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIgKyB4LCB1bml0WSAqIHIgKyB5KTtcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFjbG9ja3dpc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("// CompoundPath to improve performance\n\n\n    var Path = __webpack_require__(36);\n\n    module.exports = Path.extend({\n\n        type: 'compound',\n\n        shape: {\n\n            paths: null\n        },\n\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                if (!paths[i].path) {\n                    paths[i].createPathProxy();\n                }\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvQ29tcG91bmRQYXRoLmpzPzg2MzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyIsImZpbGUiOiI4MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvbXBvdW5kUGF0aCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlXG5cblxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnLi9QYXRoJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhdGguZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnY29tcG91bmQnLFxuXG4gICAgICAgIHNoYXBlOiB7XG5cbiAgICAgICAgICAgIHBhdGhzOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZVBhdGhEaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRpcnR5UGF0aCA9IHRoaXMuX19kaXJ0eVBhdGg7XG4gICAgICAgICAgICB2YXIgcGF0aHMgPSB0aGlzLnNoYXBlLnBhdGhzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIE1hcmsgYXMgZGlydHkgaWYgYW55IHN1YnBhdGggaXMgZGlydHlcbiAgICAgICAgICAgICAgICBkaXJ0eVBhdGggPSBkaXJ0eVBhdGggfHwgcGF0aHNbaV0uX19kaXJ0eVBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZGlydHlQYXRoO1xuICAgICAgICAgICAgdGhpcy5fX2RpcnR5ID0gdGhpcy5fX2RpcnR5IHx8IGRpcnR5UGF0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUGF0aERpcnR5KCk7XG4gICAgICAgICAgICB2YXIgcGF0aHMgPSB0aGlzLnNoYXBlLnBhdGhzIHx8IFtdO1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRHbG9iYWxTY2FsZSgpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHBhdGggc2NhbGVcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGhzW2ldLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aHNbaV0uY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGhzW2ldLnBhdGguc2V0U2NhbGUoc2NhbGVbMF0sIHNjYWxlWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgcGF0aHMgPSBzaGFwZS5wYXRocyB8fCBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXRoc1tpXS5idWlsZFBhdGgoY3R4LCBwYXRoc1tpXS5zaGFwZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJCcnVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5zaGFwZS5wYXRocztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXRoc1tpXS5fX2RpcnR5UGF0aCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUGF0aERpcnR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUGF0aC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdSZWN0LmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0NvbXBvdW5kUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var zrUtil = __webpack_require__(20);\n\n    var Gradient = __webpack_require__(82);\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'linear', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanM/NDI1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiI4MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIEdyYWRpZW50ID0gcmVxdWlyZSgnLi9HcmFkaWVudCcpO1xuXG4gICAgLyoqXG4gICAgICogeCwgeSwgeDIsIHkyIGFyZSBhbGwgcGVyY2VudCBmcm9tIDAgdG8gMVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeDI9MV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3kyPTBdXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gY29sb3JTdG9wc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbENvb3JkPWZhbHNlXVxuICAgICAqL1xuICAgIHZhciBMaW5lYXJHcmFkaWVudCA9IGZ1bmN0aW9uICh4LCB5LCB4MiwgeTIsIGNvbG9yU3RvcHMsIGdsb2JhbENvb3JkKSB7XG4gICAgICAgIC8vIFNob3VsZCBkbyBub3RoaW5nIG1vcmUgaW4gdGhpcyBjb25zdHJ1Y3Rvci4gQmVjYXVzZSBncmFkaWVudCBjYW4gYmVcbiAgICAgICAgLy8gZGVjbGFyZCBieSBgY29sb3I6IHt0eXBlOiAnbGluZWFyJywgY29sb3JTdG9wczogLi4ufWAsIHdoZXJlXG4gICAgICAgIC8vIHRoaXMgY29uc3RydWN0b3Igd2lsbCBub3QgYmUgY2FsbGVkLlxuXG4gICAgICAgIHRoaXMueCA9IHggPT0gbnVsbCA/IDAgOiB4O1xuXG4gICAgICAgIHRoaXMueSA9IHkgPT0gbnVsbCA/IDAgOiB5O1xuXG4gICAgICAgIHRoaXMueDIgPSB4MiA9PSBudWxsID8gMSA6IHgyO1xuXG4gICAgICAgIHRoaXMueTIgPSB5MiA9PSBudWxsID8gMCA6IHkyO1xuXG4gICAgICAgIC8vIENhbiBiZSBjbG9uZWRcbiAgICAgICAgdGhpcy50eXBlID0gJ2xpbmVhcic7XG5cbiAgICAgICAgLy8gSWYgdXNlIGdsb2JhbCBjb29yZFxuICAgICAgICB0aGlzLmdsb2JhbCA9IGdsb2JhbENvb3JkIHx8IGZhbHNlO1xuXG4gICAgICAgIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG4gICAgfTtcblxuICAgIExpbmVhckdyYWRpZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogTGluZWFyR3JhZGllbnRcbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKExpbmVhckdyYWRpZW50LCBHcmFkaWVudCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExpbmVhckdyYWRpZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQuanM/NTE2NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEiLCJmaWxlIjoiODIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAgICAgKi9cbiAgICB2YXIgR3JhZGllbnQgPSBmdW5jdGlvbiAoY29sb3JTdG9wcykge1xuXG4gICAgICAgIHRoaXMuY29sb3JTdG9wcyA9IGNvbG9yU3RvcHMgfHwgW107XG4gICAgfTtcblxuICAgIEdyYWRpZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogR3JhZGllbnQsXG5cbiAgICAgICAgYWRkQ29sb3JTdG9wOiBmdW5jdGlvbiAob2Zmc2V0LCBjb2xvcikge1xuICAgICAgICAgICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG5cbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JhZGllbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var zrUtil = __webpack_require__(20);\n\n    var Gradient = __webpack_require__(82);\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'radial', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQuanM/ODk1ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjgzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG5cbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCcuL0dyYWRpZW50Jyk7XG5cbiAgICAvKipcbiAgICAgKiB4LCB5LCByIGFyZSBhbGwgcGVyY2VudCBmcm9tIDAgdG8gMVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wLjVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTAuNV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3I9MC41XVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtjb2xvclN0b3BzXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbENvb3JkPWZhbHNlXVxuICAgICAqL1xuICAgIHZhciBSYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uICh4LCB5LCByLCBjb2xvclN0b3BzLCBnbG9iYWxDb29yZCkge1xuICAgICAgICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gICAgICAgIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7dHlwZTogJ3JhZGlhbCcsIGNvbG9yU3RvcHM6IC4uLn1gLCB3aGVyZVxuICAgICAgICAvLyB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cblxuICAgICAgICB0aGlzLnggPSB4ID09IG51bGwgPyAwLjUgOiB4O1xuXG4gICAgICAgIHRoaXMueSA9IHkgPT0gbnVsbCA/IDAuNSA6IHk7XG5cbiAgICAgICAgdGhpcy5yID0gciA9PSBudWxsID8gMC41IDogcjtcblxuICAgICAgICAvLyBDYW4gYmUgY2xvbmVkXG4gICAgICAgIHRoaXMudHlwZSA9ICdyYWRpYWwnO1xuXG4gICAgICAgIC8vIElmIHVzZSBnbG9iYWwgY29vcmRcbiAgICAgICAgdGhpcy5nbG9iYWwgPSBnbG9iYWxDb29yZCB8fCBmYWxzZTtcblxuICAgICAgICBHcmFkaWVudC5jYWxsKHRoaXMsIGNvbG9yU3RvcHMpO1xuICAgIH07XG5cbiAgICBSYWRpYWxHcmFkaWVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFJhZGlhbEdyYWRpZW50XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhSYWRpYWxHcmFkaWVudCwgR3JhZGllbnQpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSYWRpYWxHcmFkaWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n    var getItemStyle = __webpack_require__(31)(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor'],\n            ['textPosition'],\n            ['textAlign']\n        ]\n    );\n    module.exports = {\n        getItemStyle: function (excludes, includes) {\n            var style = getItemStyle.call(this, excludes, includes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL21vZGVsL21peGluL2l0ZW1TdHlsZS5qcz85MDExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiODQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICB2YXIgZ2V0SXRlbVN0eWxlID0gcmVxdWlyZSgnLi9tYWtlU3R5bGVNYXBwZXInKShcbiAgICAgICAgW1xuICAgICAgICAgICAgWydmaWxsJywgJ2NvbG9yJ10sXG4gICAgICAgICAgICBbJ3N0cm9rZScsICdib3JkZXJDb2xvciddLFxuICAgICAgICAgICAgWydsaW5lV2lkdGgnLCAnYm9yZGVyV2lkdGgnXSxcbiAgICAgICAgICAgIFsnb3BhY2l0eSddLFxuICAgICAgICAgICAgWydzaGFkb3dCbHVyJ10sXG4gICAgICAgICAgICBbJ3NoYWRvd09mZnNldFgnXSxcbiAgICAgICAgICAgIFsnc2hhZG93T2Zmc2V0WSddLFxuICAgICAgICAgICAgWydzaGFkb3dDb2xvciddLFxuICAgICAgICAgICAgWyd0ZXh0UG9zaXRpb24nXSxcbiAgICAgICAgICAgIFsndGV4dEFsaWduJ11cbiAgICAgICAgXVxuICAgICk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGdldEl0ZW1TdHlsZTogZnVuY3Rpb24gKGV4Y2x1ZGVzLCBpbmNsdWRlcykge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZ2V0SXRlbVN0eWxlLmNhbGwodGhpcywgZXhjbHVkZXMsIGluY2x1ZGVzKTtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuZ2V0Qm9yZGVyTGluZURhc2goKTtcbiAgICAgICAgICAgIGxpbmVEYXNoICYmIChzdHlsZS5saW5lRGFzaCA9IGxpbmVEYXNoKTtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3JkZXJMaW5lRGFzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxpbmVUeXBlID0gdGhpcy5nZXQoJ2JvcmRlclR5cGUnKTtcbiAgICAgICAgICAgIHJldHVybiAobGluZVR5cGUgPT09ICdzb2xpZCcgfHwgbGluZVR5cGUgPT0gbnVsbCkgPyBudWxsXG4gICAgICAgICAgICAgICAgOiAobGluZVR5cGUgPT09ICdkYXNoZWQnID8gWzUsIDVdIDogWzEsIDFdKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vaXRlbVN0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\n\n    var Model = __webpack_require__(28);\n    var zrUtil = __webpack_require__(20);\n    var arrayPush = Array.prototype.push;\n    var componentUtil = __webpack_require__(86);\n    var clazzUtil = __webpack_require__(29);\n    var layout = __webpack_require__(87);\n\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n\n        type: 'component',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        id: '',\n\n        /**\n         * @readOnly\n         */\n        name: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        mainType: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        subType: '',\n\n        /**\n         * @readOnly\n         * @type {number}\n         */\n        componentIndex: 0,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        ecModel: null,\n\n        /**\n         * key: componentType\n         * value:  Component model list, can not be null.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @readOnly\n         */\n        dependentModels: [],\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        uid: null,\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        $constructor: function (option, parentModel, ecModel, extraOpt) {\n            Model.call(this, option, parentModel, ecModel, extraOpt);\n\n            this.uid = componentUtil.getUID('componentModel');\n        },\n\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n            this.mergeDefaultAndTheme(option, ecModel);\n        },\n\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            var themeModel = ecModel.getTheme();\n            zrUtil.merge(option, themeModel.get(this.mainType));\n            zrUtil.merge(option, this.getDefaultOption());\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (option, extraOpt) {\n            zrUtil.merge(this.option, option, true);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, option, layoutMode);\n            }\n        },\n\n        // Hooker after init or mergeOption\n        optionUpdated: function (newCptOption, isInit) {},\n\n        getDefaultOption: function () {\n            if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n                var optList = [];\n                var Class = this.constructor;\n                while (Class) {\n                    var opt = Class.prototype.defaultOption;\n                    opt && optList.push(opt);\n                    Class = Class.superClass;\n                }\n\n                var defaultOption = {};\n                for (var i = optList.length - 1; i >= 0; i--) {\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                }\n                clazzUtil.set(this, '__defaultOption', defaultOption);\n            }\n            return clazzUtil.get(this, '__defaultOption');\n        },\n\n        getReferringComponents: function (mainType) {\n            return this.ecModel.queryComponents({\n                mainType: mainType,\n                index: this.get(mainType + 'Index', true),\n                id: this.get(mainType + 'Id', true)\n            });\n        }\n\n    });\n\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n\n    //         this.uid = componentUtil.getUID('componentModel');\n\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(\n        ComponentModel, {registerWhenExtend: true}\n    );\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n\n    zrUtil.mixin(ComponentModel, __webpack_require__(88));\n\n    module.exports = ComponentModel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL21vZGVsL0NvbXBvbmVudC5qcz8wZTAyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSwyQkFBMkI7QUFDMUMsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBIiwiZmlsZSI6Ijg1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb21wb25lbnQgbW9kZWxcbiAqXG4gKiBAbW9kdWxlIGVjaGFydHMvbW9kZWwvQ29tcG9uZW50XG4gKi9cblxuXG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgYXJyYXlQdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG4gICAgdmFyIGNvbXBvbmVudFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2NvbXBvbmVudCcpO1xuICAgIHZhciBjbGF6elV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2NsYXp6Jyk7XG4gICAgdmFyIGxheW91dCA9IHJlcXVpcmUoJy4uL3V0aWwvbGF5b3V0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IHBhcmVudE1vZGVsXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gZWNNb2RlbFxuICAgICAqL1xuICAgIHZhciBDb21wb25lbnRNb2RlbCA9IE1vZGVsLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2NvbXBvbmVudCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgaWQ6ICcnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIG5hbWU6ICcnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIG1haW5UeXBlOiAnJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBzdWJUeXBlOiAnJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnRJbmRleDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdE9wdGlvbjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBlY01vZGVsOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBrZXk6IGNvbXBvbmVudFR5cGVcbiAgICAgICAgICogdmFsdWU6ICBDb21wb25lbnQgbW9kZWwgbGlzdCwgY2FuIG5vdCBiZSBudWxsLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIEFycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD4+fVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGRlcGVuZGVudE1vZGVsczogW10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdWlkOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdXBwb3J0IG1lcmdlIGxheW91dCBwYXJhbXMuXG4gICAgICAgICAqIE9ubHkgc3VwcG9ydCAnYm94JyBub3cgKGxlZnQvcmlnaHQvdG9wL2JvdHRvbS93aWR0aC9oZWlnaHQpLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfE9iamVjdH0gT2JqZWN0IGNhbiBiZSB7aWdub3JlU2l6ZTogdHJ1ZX1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXRNb2RlOiBudWxsLFxuXG4gICAgICAgICRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KSB7XG4gICAgICAgICAgICBNb2RlbC5jYWxsKHRoaXMsIG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KTtcblxuICAgICAgICAgICAgdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgnY29tcG9uZW50TW9kZWwnKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuICAgICAgICAgICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1lcmdlRGVmYXVsdEFuZFRoZW1lOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgbGF5b3V0TW9kZSA9IHRoaXMubGF5b3V0TW9kZTtcbiAgICAgICAgICAgIHZhciBpbnB1dFBvc2l0aW9uUGFyYW1zID0gbGF5b3V0TW9kZVxuICAgICAgICAgICAgICAgID8gbGF5b3V0LmdldExheW91dFBhcmFtcyhvcHRpb24pIDoge307XG5cbiAgICAgICAgICAgIHZhciB0aGVtZU1vZGVsID0gZWNNb2RlbC5nZXRUaGVtZSgpO1xuICAgICAgICAgICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhlbWVNb2RlbC5nZXQodGhpcy5tYWluVHlwZSkpO1xuICAgICAgICAgICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhpcy5nZXREZWZhdWx0T3B0aW9uKCkpO1xuXG4gICAgICAgICAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgICAgICAgICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtKG9wdGlvbiwgaW5wdXRQb3NpdGlvblBhcmFtcywgbGF5b3V0TW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24sIGV4dHJhT3B0KSB7XG4gICAgICAgICAgICB6clV0aWwubWVyZ2UodGhpcy5vcHRpb24sIG9wdGlvbiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgICAgICAgICAgaWYgKGxheW91dE1vZGUpIHtcbiAgICAgICAgICAgICAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbSh0aGlzLm9wdGlvbiwgb3B0aW9uLCBsYXlvdXRNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBIb29rZXIgYWZ0ZXIgaW5pdCBvciBtZXJnZU9wdGlvblxuICAgICAgICBvcHRpb25VcGRhdGVkOiBmdW5jdGlvbiAobmV3Q3B0T3B0aW9uLCBpc0luaXQpIHt9LFxuXG4gICAgICAgIGdldERlZmF1bHRPcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghY2xhenpVdGlsLmhhc093bih0aGlzLCAnX19kZWZhdWx0T3B0aW9uJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBDbGFzcyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgd2hpbGUgKENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHQgPSBDbGFzcy5wcm90b3R5cGUuZGVmYXVsdE9wdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgb3B0ICYmIG9wdExpc3QucHVzaChvcHQpO1xuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IENsYXNzLnN1cGVyQ2xhc3M7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRPcHRpb24gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gb3B0TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0T3B0aW9uID0genJVdGlsLm1lcmdlKGRlZmF1bHRPcHRpb24sIG9wdExpc3RbaV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGF6elV0aWwuc2V0KHRoaXMsICdfX2RlZmF1bHRPcHRpb24nLCBkZWZhdWx0T3B0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbGF6elV0aWwuZ2V0KHRoaXMsICdfX2RlZmF1bHRPcHRpb24nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRSZWZlcnJpbmdDb21wb25lbnRzOiBmdW5jdGlvbiAobWFpblR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgICAgICAgICBtYWluVHlwZTogbWFpblR5cGUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuZ2V0KG1haW5UeXBlICsgJ0luZGV4JywgdHJ1ZSksXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0KG1haW5UeXBlICsgJ0lkJywgdHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIFJlc2V0IENvbXBvbmVudE1vZGVsLmV4dGVuZCwgYWRkIHByZUNvbnN0cnVjdC5cbiAgICAvLyBjbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoXG4gICAgLy8gICAgIENvbXBvbmVudE1vZGVsLFxuICAgIC8vICAgICBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpIHtcbiAgICAvLyAgICAgICAgIC8vIFNldCBkZXBlbmRlbnRNb2RlbHMsIGNvbXBvbmVudEluZGV4LCBuYW1lLCBpZCwgbWFpblR5cGUsIHN1YlR5cGUuXG4gICAgLy8gICAgICAgICB6clV0aWwuZXh0ZW5kKHRoaXMsIGV4dHJhT3B0KTtcblxuICAgIC8vICAgICAgICAgdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgnY29tcG9uZW50TW9kZWwnKTtcblxuICAgIC8vICAgICAgICAgLy8gdGhpcy5zZXRSZWFkT25seShbXG4gICAgLy8gICAgICAgICAvLyAgICAgJ3R5cGUnLCAnaWQnLCAndWlkJywgJ25hbWUnLCAnbWFpblR5cGUnLCAnc3ViVHlwZScsXG4gICAgLy8gICAgICAgICAvLyAgICAgJ2RlcGVuZGVudE1vZGVscycsICdjb21wb25lbnRJbmRleCdcbiAgICAvLyAgICAgICAgIC8vIF0pO1xuICAgIC8vICAgICB9XG4gICAgLy8gKTtcblxuICAgIC8vIEFkZCBjYXBhYmlsaXR5IG9mIHJlZ2lzdGVyQ2xhc3MsIGdldENsYXNzLCBoYXNDbGFzcywgcmVnaXN0ZXJTdWJUeXBlRGVmYXVsdGVyIGFuZCBzbyBvbi5cbiAgICBjbGF6elV0aWwuZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KFxuICAgICAgICBDb21wb25lbnRNb2RlbCwge3JlZ2lzdGVyV2hlbkV4dGVuZDogdHJ1ZX1cbiAgICApO1xuICAgIGNvbXBvbmVudFV0aWwuZW5hYmxlU3ViVHlwZURlZmF1bHRlcihDb21wb25lbnRNb2RlbCk7XG5cbiAgICAvLyBBZGQgY2FwYWJpbGl0eSBvZiBDb21wb25lbnRNb2RlbC50b3BvbG9naWNhbFRyYXZlbC5cbiAgICBjb21wb25lbnRVdGlsLmVuYWJsZVRvcG9sb2dpY2FsVHJhdmVsKENvbXBvbmVudE1vZGVsLCBnZXREZXBlbmRlbmNpZXMpO1xuXG4gICAgZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgdmFyIGRlcHMgPSBbXTtcbiAgICAgICAgenJVdGlsLmVhY2goQ29tcG9uZW50TW9kZWwuZ2V0Q2xhc3Nlc0J5TWFpblR5cGUoY29tcG9uZW50VHlwZSksIGZ1bmN0aW9uIChDbGF6eikge1xuICAgICAgICAgICAgYXJyYXlQdXNoLmFwcGx5KGRlcHMsIENsYXp6LnByb3RvdHlwZS5kZXBlbmRlbmNpZXMgfHwgW10pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRW5zdXJlIG1haW4gdHlwZVxuICAgICAgICByZXR1cm4genJVdGlsLm1hcChkZXBzLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXp6VXRpbC5wYXJzZUNsYXNzVHlwZSh0eXBlKS5tYWluO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB6clV0aWwubWl4aW4oQ29tcG9uZW50TW9kZWwsIHJlcXVpcmUoJy4vbWl4aW4vYm94TGF5b3V0JykpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnRNb2RlbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9tb2RlbC9Db21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n    var clazz = __webpack_require__(29);\n\n    var parseClassType = clazz.parseClassType;\n\n    var base = 0;\n\n    var componentUtil = {};\n\n    var DELIMITER = '_';\n\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [(type || ''), base++, Math.random()].join(DELIMITER);\n    };\n\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n\n        var subTypeDefaulters = {};\n\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n\n        return entity;\n    };\n\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(\n                    currVertex.successor,\n                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n                );\n            }\n\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n\n            zrUtil.each(fullNameList, function (name) {\n\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n\n            return {graph: graph, noEntryList: noEntryList};\n        }\n\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {predecessor: [], successor: []};\n            }\n            return graph[name];\n        }\n\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n\n    module.exports = componentUtil;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3V0aWwvY29tcG9uZW50LmpzP2NjNzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYixvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ijg2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGNsYXp6ID0gcmVxdWlyZSgnLi9jbGF6eicpO1xuXG4gICAgdmFyIHBhcnNlQ2xhc3NUeXBlID0gY2xhenoucGFyc2VDbGFzc1R5cGU7XG5cbiAgICB2YXIgYmFzZSA9IDA7XG5cbiAgICB2YXIgY29tcG9uZW50VXRpbCA9IHt9O1xuXG4gICAgdmFyIERFTElNSVRFUiA9ICdfJztcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBjb21wb25lbnRVdGlsLmdldFVJRCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIC8vIENvbnNpZGVyaW5nIHRoZSBjYXNlIG9mIGNyb3NzaW5nIGpzIGNvbnRleHQsXG4gICAgICAgIC8vIHVzZSBNYXRoLnJhbmRvbSB0byBtYWtlIGlkIGFzIHVuaXF1ZSBhcyBwb3NzaWJsZS5cbiAgICAgICAgcmV0dXJuIFsodHlwZSB8fCAnJyksIGJhc2UrKywgTWF0aC5yYW5kb20oKV0uam9pbihERUxJTUlURVIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBjb21wb25lbnRVdGlsLmVuYWJsZVN1YlR5cGVEZWZhdWx0ZXIgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG5cbiAgICAgICAgdmFyIHN1YlR5cGVEZWZhdWx0ZXJzID0ge307XG5cbiAgICAgICAgZW50aXR5LnJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlciA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBkZWZhdWx0ZXIpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgIHN1YlR5cGVEZWZhdWx0ZXJzW2NvbXBvbmVudFR5cGUubWFpbl0gPSBkZWZhdWx0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgZW50aXR5LmRldGVybWluZVN1YlR5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgb3B0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IG9wdGlvbi50eXBlO1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudFR5cGVNYWluID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSkubWFpbjtcbiAgICAgICAgICAgICAgICBpZiAoZW50aXR5Lmhhc1N1YlR5cGVzKGNvbXBvbmVudFR5cGUpICYmIHN1YlR5cGVEZWZhdWx0ZXJzW2NvbXBvbmVudFR5cGVNYWluXSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gc3ViVHlwZURlZmF1bHRlcnNbY29tcG9uZW50VHlwZU1haW5dKG9wdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVG9wb2xvZ2ljYWwgdHJhdmVsIG9uIEFjdGl2aXR5IE5ldHdvcmsgKEFjdGl2aXR5IE9uIFZlcnRpY2VzKS5cbiAgICAgKiBEZXBlbmRlbmNpZXMgaXMgZGVmaW5lZCBpbiBNb2RlbC5wcm90b3R5cGUuZGVwZW5kZW5jaWVzLCBsaWtlIFsneEF4aXMnLCAneUF4aXMnXS5cbiAgICAgKlxuICAgICAqIElmICd4QXhpcycgb3IgJ3lBeGlzJyBpcyBhYnNlbnQgaW4gY29tcG9uZW50VHlwZUxpc3QsIGp1c3QgaWdub3JlIGl0IGluIHRvcG9sb2d5LlxuICAgICAqXG4gICAgICogSWYgdGhlcmUgaXMgY2lyY2xlIGRlcGVuZGVuY2V5LCBFcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbXBvbmVudFV0aWwuZW5hYmxlVG9wb2xvZ2ljYWxUcmF2ZWwgPSBmdW5jdGlvbiAoZW50aXR5LCBkZXBlbmRlbmN5R2V0dGVyKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gdGFyZ2V0TmFtZUxpc3QgVGFyZ2V0IENvbXBvbmVudCB0eXBlIGxpc3QuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSBbJ2FhJywgJ2JiJywgJ2FhLnh4J11cbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gZnVsbE5hbWVMaXN0IEJ5IHdoaWNoIHdlIGNhbiBidWlsZCBkZXBlbmRlbmN5IGdyYXBoLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBQYXJhbXM6IGNvbXBvbmVudFR5cGUsIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgU2NvcGUgb2YgY2FsbGJhY2suXG4gICAgICAgICAqL1xuICAgICAgICBlbnRpdHkudG9wb2xvZ2ljYWxUcmF2ZWwgPSBmdW5jdGlvbiAodGFyZ2V0TmFtZUxpc3QsIGZ1bGxOYW1lTGlzdCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0TmFtZUxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbWFrZURlcG5kZW5jeUdyYXBoKGZ1bGxOYW1lTGlzdCk7XG4gICAgICAgICAgICB2YXIgZ3JhcGggPSByZXN1bHQuZ3JhcGg7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSByZXN1bHQubm9FbnRyeUxpc3Q7XG5cbiAgICAgICAgICAgIHZhciB0YXJnZXROYW1lU2V0ID0ge307XG4gICAgICAgICAgICB6clV0aWwuZWFjaCh0YXJnZXROYW1lTGlzdCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXROYW1lU2V0W25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJDb21wb25lbnRUeXBlID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJWZXJ0ZXggPSBncmFwaFtjdXJyQ29tcG9uZW50VHlwZV07XG4gICAgICAgICAgICAgICAgdmFyIGlzSW5UYXJnZXROYW1lU2V0ID0gISF0YXJnZXROYW1lU2V0W2N1cnJDb21wb25lbnRUeXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNJblRhcmdldE5hbWVTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBjdXJyQ29tcG9uZW50VHlwZSwgY3VyclZlcnRleC5vcmlnaW5hbERlcHMuc2xpY2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXROYW1lU2V0W2N1cnJDb21wb25lbnRUeXBlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2goXG4gICAgICAgICAgICAgICAgICAgIGN1cnJWZXJ0ZXguc3VjY2Vzc29yLFxuICAgICAgICAgICAgICAgICAgICBpc0luVGFyZ2V0TmFtZVNldCA/IHJlbW92ZUVkZ2VBbmRBZGQgOiByZW1vdmVFZGdlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgenJVdGlsLmVhY2godGFyZ2V0TmFtZVNldCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2lyY2xlIGRlcGVuZGVuY3kgbWF5IGV4aXN0cycpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZUVkZ2Uoc3VjY0NvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBncmFwaFtzdWNjQ29tcG9uZW50VHlwZV0uZW50cnlDb3VudC0tO1xuICAgICAgICAgICAgICAgIGlmIChncmFwaFtzdWNjQ29tcG9uZW50VHlwZV0uZW50cnlDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHN1Y2NDb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnNpZGVyIHRoaXMgY2FzZTogbGVnZW5kIGRlcGVuZHMgb24gc2VyaWVzLCBhbmQgd2UgY2FsbFxuICAgICAgICAgICAgLy8gY2hhcnQuc2V0T3B0aW9uKHtzZXJpZXM6IFsuLi5dfSksIHdoZXJlIG9ubHkgc2VyaWVzIGlzIGluIG9wdGlvbi5cbiAgICAgICAgICAgIC8vIElmIHdlIGRvIG5vdCBoYXZlICdyZW1vdmVFZGdlQW5kQWRkJywgbGVnZW5kTW9kZWwubWVyZ2VPcHRpb24gd2lsbFxuICAgICAgICAgICAgLy8gbm90IGJlIGNhbGxlZCwgYnV0IG9ubHkgc2VyZWlzLm1lcmdlT3B0aW9uIGlzIGNhbGxlZC4gVGh1cyBsZWdlbmRcbiAgICAgICAgICAgIC8vIGhhdmUgbm8gY2hhbmNlIHRvIHVwZGF0ZSBpdHMgbG9jYWwgcmVjb3JkIGFib3V0IHNlcmllcyAobGlrZSB3aGljaFxuICAgICAgICAgICAgLy8gbmFtZSBvZiBzZXJpZXMgaXMgYXZhaWxhYmxlIGluIGxlZ2VuZCkuXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVFZGdlQW5kQWRkKHN1Y2NDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0TmFtZVNldFtzdWNjQ29tcG9uZW50VHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlbW92ZUVkZ2Uoc3VjY0NvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXBuZGVuY3lHcmFwaDoge09iamVjdH1cbiAgICAgICAgICoga2V5OiBjb25wb25lbnRUeXBlLFxuICAgICAgICAgKiB2YWx1ZToge1xuICAgICAgICAgKiAgICAgc3VjY2Vzc29yOiBbY29ucG9uZW50VHlwZXMuLi5dLFxuICAgICAgICAgKiAgICAgb3JpZ2luYWxEZXBzOiBbY29ucG9uZW50VHlwZXMuLi5dLFxuICAgICAgICAgKiAgICAgZW50cnlDb3VudDoge251bWJlcn1cbiAgICAgICAgICogfVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gbWFrZURlcG5kZW5jeUdyYXBoKGZ1bGxOYW1lTGlzdCkge1xuICAgICAgICAgICAgdmFyIGdyYXBoID0ge307XG4gICAgICAgICAgICB2YXIgbm9FbnRyeUxpc3QgPSBbXTtcblxuICAgICAgICAgICAgenJVdGlsLmVhY2goZnVsbE5hbWVMaXN0LCBmdW5jdGlvbiAobmFtZSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHRoaXNJdGVtID0gY3JlYXRlRGVwZW5kZW5jeUdyYXBoSXRlbShncmFwaCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsRGVwcyA9IHRoaXNJdGVtLm9yaWdpbmFsRGVwcyA9IGRlcGVuZGVuY3lHZXR0ZXIobmFtZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXZhaWxhYmxlRGVwcyA9IGdldEF2YWlsYWJsZURlcGVuZGVuY2llcyhvcmlnaW5hbERlcHMsIGZ1bGxOYW1lTGlzdCk7XG4gICAgICAgICAgICAgICAgdGhpc0l0ZW0uZW50cnlDb3VudCA9IGF2YWlsYWJsZURlcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzSXRlbS5lbnRyeUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vRW50cnlMaXN0LnB1c2gobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2goYXZhaWxhYmxlRGVwcywgZnVuY3Rpb24gKGRlcGVuZGVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHpyVXRpbC5pbmRleE9mKHRoaXNJdGVtLnByZWRlY2Vzc29yLCBkZXBlbmRlbnROYW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNJdGVtLnByZWRlY2Vzc29yLnB1c2goZGVwZW5kZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXRJdGVtID0gY3JlYXRlRGVwZW5kZW5jeUdyYXBoSXRlbShncmFwaCwgZGVwZW5kZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh6clV0aWwuaW5kZXhPZih0aGF0SXRlbS5zdWNjZXNzb3IsIGRlcGVuZGVudE5hbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdEl0ZW0uc3VjY2Vzc29yLnB1c2gobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4ge2dyYXBoOiBncmFwaCwgbm9FbnRyeUxpc3Q6IG5vRW50cnlMaXN0fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZURlcGVuZGVuY3lHcmFwaEl0ZW0oZ3JhcGgsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmICghZ3JhcGhbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBncmFwaFtuYW1lXSA9IHtwcmVkZWNlc3NvcjogW10sIHN1Y2Nlc3NvcjogW119O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdyYXBoW25hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0QXZhaWxhYmxlRGVwZW5kZW5jaWVzKG9yaWdpbmFsRGVwcywgZnVsbE5hbWVMaXN0KSB7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlRGVwcyA9IFtdO1xuICAgICAgICAgICAgenJVdGlsLmVhY2gob3JpZ2luYWxEZXBzLCBmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmluZGV4T2YoZnVsbE5hbWVMaXN0LCBkZXApID49IDAgJiYgYXZhaWxhYmxlRGVwcy5wdXNoKGRlcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGVEZXBzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gY29tcG9uZW50VXRpbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi91dGlsL2NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("'use strict';\n// Layout helpers for each component positioning\n\n\n    var zrUtil = __webpack_require__(20);\n    var BoundingRect = __webpack_require__(25);\n    var numberUtil = __webpack_require__(23);\n    var formatUtil = __webpack_require__(22);\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n\n    var layout = {};\n\n    /**\n     * @public\n     */\n    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [\n        'left', 'right', 'top', 'bottom', 'width', 'height'\n    ];\n\n    /**\n     * @public\n     */\n    var HV_NAMES = layout.HV_NAMES = [\n        ['width', 'left', 'right'],\n        ['height', 'top', 'bottom']\n    ];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            }\n            else {\n                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n\n            if (child.newline) {\n                return;\n            }\n\n            position[0] = x;\n            position[1] = y;\n\n            orient === 'horizontal'\n                ? (x = nextX + gap)\n                : (y = nextY + gap);\n        });\n    }\n\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (\n        positionInfo, containerRect, margin\n    ) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            }\n            else {\n                height = containerHeight * 0.8;\n            }\n        }\n\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n            case 'center':\n                left = containerWidth / 2 - width / 2 - margin[3];\n                break;\n            case 'right':\n                left = containerWidth - width - horizontalMargin;\n                break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n            case 'middle':\n            case 'center':\n                top = containerHeight / 2 - height / 2 - margin[0];\n                break;\n            case 'bottom':\n                top = containerHeight - height - verticalMargin;\n                break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n\n\n    /**\n     * Position a zr element in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * Logic:\n     *     1. Scale (against origin point in parent coord)\n     *     2. Rotate (against origin point in parent coord)\n     *     3. Traslate (with el.position by this method)\n     * So this method only fixes the last step 'Traslate', which does not affect\n     * scaling and rotating.\n     *\n     * If be called repeatly with the same input el, the same result will be gotten.\n     *\n     * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @param {Object} [opt]\n     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n     * @param {Array.<number>} [opt.boundingMode='all']\n     *        Specify how to calculate boundingRect when locating.\n     *        'all': Position the boundingRect that is transformed and uioned\n     *               both itself and its descendants.\n     *               This mode simplies confine the elements in the bounding\n     *               of their container (e.g., using 'right: 0').\n     *        'raw': Position the boundingRect that is not transformed and only itself.\n     *               This mode is useful when you want a element can overflow its\n     *               container. (Consider a rotated circle needs to be located in a corner.)\n     *               In this mode positionInfo.width/height can only be number.\n     */\n    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\n        var h = !opt || !opt.hv || opt.hv[0];\n        var v = !opt || !opt.hv || opt.hv[1];\n        var boundingMode = opt && opt.boundingMode || 'all';\n\n        if (!h && !v) {\n            return;\n        }\n\n        var rect;\n        if (boundingMode === 'raw') {\n            rect = el.type === 'group'\n                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n                : el.getBoundingRect();\n        }\n        else {\n            rect = el.getBoundingRect();\n            if (el.needLocalTransform()) {\n                var transform = el.getLocalTransform();\n                // Notice: raw rect may be inner object of el,\n                // which should not be modified.\n                rect = rect.clone();\n                rect.applyTransform(transform);\n            }\n        }\n\n        positionInfo = layout.getLayoutRect(\n            zrUtil.defaults(\n                {width: rect.width, height: rect.height},\n                positionInfo\n            ),\n            containerRect,\n            margin\n        );\n\n        // Because 'tranlate' is the last step in transform\n        // (see zrender/core/Transformable#getLocalTransfrom),\n        // we can just only modify el.position to get final result.\n        var elPos = el.position;\n        var dx = h ? positionInfo.x - rect.x : 0;\n        var dy = v ? positionInfo.y - rect.y : 0;\n\n        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n    };\n\n    /**\n     * @param {Object} option Contains some of the properties in HV_NAMES.\n     * @param {number} hvIdx 0: horizontal; 1: vertical.\n     */\n    layout.sizeCalculable = function (option, hvIdx) {\n        return option[HV_NAMES[hvIdx][0]] != null\n            || (option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null);\n    };\n\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n\n        var ignoreSize = opt.ignoreSize;\n        !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n\n        var hResult = merge(HV_NAMES[0], 0);\n        var vResult = merge(HV_NAMES[1], 1);\n\n        copy(HV_NAMES[0], targetOption, hResult);\n        copy(HV_NAMES[1], targetOption, vResult);\n\n        function merge(names, hvIdx) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = 2;\n\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n\n            if (ignoreSize[hvIdx]) {\n                // Only one of left/right is premitted to exist.\n                if (hasValue(newOption, names[1])) {\n                    merged[names[2]] = null;\n                }\n                else if (hasValue(newOption, names[2])) {\n                    merged[names[1]] = null;\n                }\n                return merged;\n            }\n\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }\n            // Case: newOption: {width: ..., right: ...},\n            // Than we can make sure user only want those two, and ignore\n            // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            }\n            else {\n                // Chose another param from targetOption by priority.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n\n    module.exports = layout;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3V0aWwvbGF5b3V0LmpzPzJiMWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLE9BQU8sRUFBRTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsY0FBYztBQUM3QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVSxHQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLE9BQU87QUFDdEIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQix1Q0FBdUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU8scUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0IsY0FBYztBQUNsRTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHVCQUF1QjtBQUN4RCxpQ0FBaUMsV0FBVyxpQkFBaUIsV0FBVztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSIsImZpbGUiOiI4Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIExheW91dCBoZWxwZXJzIGZvciBlYWNoIGNvbXBvbmVudCBwb3NpdGlvbmluZ1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuL251bWJlcicpO1xuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcbiAgICB2YXIgcGFyc2VQZXJjZW50ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQ7XG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcblxuICAgIHZhciBsYXlvdXQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB2YXIgTE9DQVRJT05fUEFSQU1TID0gbGF5b3V0LkxPQ0FUSU9OX1BBUkFNUyA9IFtcbiAgICAgICAgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbScsICd3aWR0aCcsICdoZWlnaHQnXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB2YXIgSFZfTkFNRVMgPSBsYXlvdXQuSFZfTkFNRVMgPSBbXG4gICAgICAgIFsnd2lkdGgnLCAnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBbJ2hlaWdodCcsICd0b3AnLCAnYm90dG9tJ11cbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gYm94TGF5b3V0KG9yaWVudCwgZ3JvdXAsIGdhcCwgbWF4V2lkdGgsIG1heEhlaWdodCkge1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgaWYgKG1heFdpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgIG1heFdpZHRoID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heEhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudExpbmVNYXhTaXplID0gMDtcbiAgICAgICAgZ3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBjaGlsZC5wb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciByZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICB2YXIgbmV4dENoaWxkID0gZ3JvdXAuY2hpbGRBdChpZHggKyAxKTtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hpbGRSZWN0ID0gbmV4dENoaWxkICYmIG5leHRDaGlsZC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHZhciBuZXh0WDtcbiAgICAgICAgICAgIHZhciBuZXh0WTtcbiAgICAgICAgICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgICAgIHZhciBtb3ZlWCA9IHJlY3Qud2lkdGggKyAobmV4dENoaWxkUmVjdCA/ICgtbmV4dENoaWxkUmVjdC54ICsgcmVjdC54KSA6IDApO1xuICAgICAgICAgICAgICAgIG5leHRYID0geCArIG1vdmVYO1xuICAgICAgICAgICAgICAgIC8vIFdyYXAgd2hlbiB3aWR0aCBleGNlZWRzIG1heFdpZHRoIG9yIG1lZXQgYSBgbmV3bGluZWAgZ3JvdXBcbiAgICAgICAgICAgICAgICBpZiAobmV4dFggPiBtYXhXaWR0aCB8fCBjaGlsZC5uZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgICAgICBuZXh0WCA9IG1vdmVYO1xuICAgICAgICAgICAgICAgICAgICB5ICs9IGN1cnJlbnRMaW5lTWF4U2l6ZSArIGdhcDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZU1heFNpemUgPSBNYXRoLm1heChjdXJyZW50TGluZU1heFNpemUsIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbW92ZVkgPSByZWN0LmhlaWdodCArIChuZXh0Q2hpbGRSZWN0ID8gKC1uZXh0Q2hpbGRSZWN0LnkgKyByZWN0LnkpIDogMCk7XG4gICAgICAgICAgICAgICAgbmV4dFkgPSB5ICsgbW92ZVk7XG4gICAgICAgICAgICAgICAgLy8gV3JhcCB3aGVuIHdpZHRoIGV4Y2VlZHMgbWF4SGVpZ2h0IG9yIG1lZXQgYSBgbmV3bGluZWAgZ3JvdXBcbiAgICAgICAgICAgICAgICBpZiAobmV4dFkgPiBtYXhIZWlnaHQgfHwgY2hpbGQubmV3bGluZSkge1xuICAgICAgICAgICAgICAgICAgICB4ICs9IGN1cnJlbnRMaW5lTWF4U2l6ZSArIGdhcDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG5leHRZID0gbW92ZVk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZU1heFNpemUgPSBNYXRoLm1heChjdXJyZW50TGluZU1heFNpemUsIHJlY3Qud2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoaWxkLm5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvc2l0aW9uWzBdID0geDtcbiAgICAgICAgICAgIHBvc2l0aW9uWzFdID0geTtcblxuICAgICAgICAgICAgb3JpZW50ID09PSAnaG9yaXpvbnRhbCdcbiAgICAgICAgICAgICAgICA/ICh4ID0gbmV4dFggKyBnYXApXG4gICAgICAgICAgICAgICAgOiAoeSA9IG5leHRZICsgZ2FwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVkJveCBvciBIQm94IGxheW91dGluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmllbnRcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2FwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD1JbmZpbml0eV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD1JbmZpbml0eV1cbiAgICAgKi9cbiAgICBsYXlvdXQuYm94ID0gYm94TGF5b3V0O1xuXG4gICAgLyoqXG4gICAgICogVkJveCBsYXlvdXRpbmdcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2FwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD1JbmZpbml0eV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD1JbmZpbml0eV1cbiAgICAgKi9cbiAgICBsYXlvdXQudmJveCA9IHpyVXRpbC5jdXJyeShib3hMYXlvdXQsICd2ZXJ0aWNhbCcpO1xuXG4gICAgLyoqXG4gICAgICogSEJveCBsYXlvdXRpbmdcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2FwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD1JbmZpbml0eV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD1JbmZpbml0eV1cbiAgICAgKi9cbiAgICBsYXlvdXQuaGJveCA9IHpyVXRpbC5jdXJyeShib3hMYXlvdXQsICdob3Jpem9udGFsJyk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB4IG9yIHgyIGlzIG5vdCBzcGVjaWZpZWQgb3IgJ2NlbnRlcicgJ2xlZnQnICdyaWdodCcsXG4gICAgICogdGhlIHdpZHRoIHdvdWxkIGJlIGFzIGxvbmcgYXMgcG9zc2libGUuXG4gICAgICogSWYgeSBvciB5MiBpcyBub3Qgc3BlY2lmaWVkIG9yICdtaWRkbGUnICd0b3AnICdib3R0b20nLFxuICAgICAqIHRoZSBoZWlnaHQgd291bGQgYmUgYXMgbG9uZyBhcyBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbkluZm9cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ueF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ueV1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ueDJdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnkyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJSZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBtYXJnaW5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHt3aWR0aCwgaGVpZ2h0fVxuICAgICAqL1xuICAgIGxheW91dC5nZXRBdmFpbGFibGVTaXplID0gZnVuY3Rpb24gKHBvc2l0aW9uSW5mbywgY29udGFpbmVyUmVjdCwgbWFyZ2luKSB7XG4gICAgICAgIHZhciBjb250YWluZXJXaWR0aCA9IGNvbnRhaW5lclJlY3Qud2lkdGg7XG4gICAgICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBjb250YWluZXJSZWN0LmhlaWdodDtcblxuICAgICAgICB2YXIgeCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ueCwgY29udGFpbmVyV2lkdGgpO1xuICAgICAgICB2YXIgeSA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ueSwgY29udGFpbmVySGVpZ2h0KTtcbiAgICAgICAgdmFyIHgyID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby54MiwgY29udGFpbmVyV2lkdGgpO1xuICAgICAgICB2YXIgeTIgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLnkyLCBjb250YWluZXJIZWlnaHQpO1xuXG4gICAgICAgIChpc05hTih4KSB8fCBpc05hTihwYXJzZUZsb2F0KHBvc2l0aW9uSW5mby54KSkpICYmICh4ID0gMCk7XG4gICAgICAgIChpc05hTih4MikgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8ueDIpKSkgJiYgKHgyID0gY29udGFpbmVyV2lkdGgpO1xuICAgICAgICAoaXNOYU4oeSkgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8ueSkpKSAmJiAoeSA9IDApO1xuICAgICAgICAoaXNOYU4oeTIpIHx8IGlzTmFOKHBhcnNlRmxvYXQocG9zaXRpb25JbmZvLnkyKSkpICYmICh5MiA9IGNvbnRhaW5lckhlaWdodCk7XG5cbiAgICAgICAgbWFyZ2luID0gZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheShtYXJnaW4gfHwgMCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1heCh4MiAtIHggLSBtYXJnaW5bMV0gLSBtYXJnaW5bM10sIDApLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heCh5MiAtIHkgLSBtYXJnaW5bMF0gLSBtYXJnaW5bMl0sIDApXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHBvc2l0aW9uIGluZm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb25JbmZvXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmxlZnRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnRvcF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ucmlnaHRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmJvdHRvbV1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ud2lkdGhdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8uYXNwZWN0XSBBc3BlY3QgaXMgd2lkdGggLyBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyUmVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW21hcmdpbl1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAqL1xuICAgIGxheW91dC5nZXRMYXlvdXRSZWN0ID0gZnVuY3Rpb24gKFxuICAgICAgICBwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpblxuICAgICkge1xuICAgICAgICBtYXJnaW4gPSBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KG1hcmdpbiB8fCAwKTtcblxuICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSBjb250YWluZXJSZWN0LndpZHRoO1xuICAgICAgICB2YXIgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyUmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGxlZnQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmxlZnQsIGNvbnRhaW5lcldpZHRoKTtcbiAgICAgICAgdmFyIHRvcCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8udG9wLCBjb250YWluZXJIZWlnaHQpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLnJpZ2h0LCBjb250YWluZXJXaWR0aCk7XG4gICAgICAgIHZhciBib3R0b20gPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmJvdHRvbSwgY29udGFpbmVySGVpZ2h0KTtcbiAgICAgICAgdmFyIHdpZHRoID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby53aWR0aCwgY29udGFpbmVyV2lkdGgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby5oZWlnaHQsIGNvbnRhaW5lckhlaWdodCk7XG5cbiAgICAgICAgdmFyIHZlcnRpY2FsTWFyZ2luID0gbWFyZ2luWzJdICsgbWFyZ2luWzBdO1xuICAgICAgICB2YXIgaG9yaXpvbnRhbE1hcmdpbiA9IG1hcmdpblsxXSArIG1hcmdpblszXTtcbiAgICAgICAgdmFyIGFzcGVjdCA9IHBvc2l0aW9uSW5mby5hc3BlY3Q7XG5cbiAgICAgICAgLy8gSWYgd2lkdGggaXMgbm90IHNwZWNpZmllZCwgY2FsY3VsYXRlIHdpZHRoIGZyb20gbGVmdCBhbmQgcmlnaHRcbiAgICAgICAgaWYgKGlzTmFOKHdpZHRoKSkge1xuICAgICAgICAgICAgd2lkdGggPSBjb250YWluZXJXaWR0aCAtIHJpZ2h0IC0gaG9yaXpvbnRhbE1hcmdpbiAtIGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKGhlaWdodCkpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbnRhaW5lckhlaWdodCAtIGJvdHRvbSAtIHZlcnRpY2FsTWFyZ2luIC0gdG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2lkdGggYW5kIGhlaWdodCBhcmUgbm90IGdpdmVuXG4gICAgICAgIC8vIDEuIEdyYXBoIHNob3VsZCBub3QgZXhjZWVkcyB0aGUgY29udGFpbmVyXG4gICAgICAgIC8vIDIuIEFzcGVjdCBtdXN0IGJlIGtlZXBlZFxuICAgICAgICAvLyAzLiBHcmFwaCBzaG91bGQgdGFrZSB0aGUgc3BhY2UgYXMgbW9yZSBhcyBwb3NzaWJsZVxuICAgICAgICBpZiAoaXNOYU4od2lkdGgpICYmIGlzTmFOKGhlaWdodCkpIHtcbiAgICAgICAgICAgIGlmIChhc3BlY3QgPiBjb250YWluZXJXaWR0aCAvIGNvbnRhaW5lckhlaWdodCkge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gY29udGFpbmVyV2lkdGggKiAwLjg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQgKiAwLjg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXNwZWN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB3aWR0aCBvciBoZWlnaHQgd2l0aCBnaXZlbiBhc3BlY3RcbiAgICAgICAgICAgIGlmIChpc05hTih3aWR0aCkpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGFzcGVjdCAqIGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05hTihoZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBsZWZ0IGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSBsZWZ0IGZyb20gcmlnaHQgYW5kIHdpZHRoXG4gICAgICAgIGlmIChpc05hTihsZWZ0KSkge1xuICAgICAgICAgICAgbGVmdCA9IGNvbnRhaW5lcldpZHRoIC0gcmlnaHQgLSB3aWR0aCAtIGhvcml6b250YWxNYXJnaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKHRvcCkpIHtcbiAgICAgICAgICAgIHRvcCA9IGNvbnRhaW5lckhlaWdodCAtIGJvdHRvbSAtIGhlaWdodCAtIHZlcnRpY2FsTWFyZ2luO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxpZ24gbGVmdCBhbmQgdG9wXG4gICAgICAgIHN3aXRjaCAocG9zaXRpb25JbmZvLmxlZnQgfHwgcG9zaXRpb25JbmZvLnJpZ2h0KSB7XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAvIDIgLSB3aWR0aCAvIDIgLSBtYXJnaW5bM107XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IGNvbnRhaW5lcldpZHRoIC0gd2lkdGggLSBob3Jpem9udGFsTWFyZ2luO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb25JbmZvLnRvcCB8fCBwb3NpdGlvbkluZm8uYm90dG9tKSB7XG4gICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICB0b3AgPSBjb250YWluZXJIZWlnaHQgLyAyIC0gaGVpZ2h0IC8gMiAtIG1hcmdpblswXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgdG9wID0gY29udGFpbmVySGVpZ2h0IC0gaGVpZ2h0IC0gdmVydGljYWxNYXJnaW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgc29tZXRoaW5nIGlzIHdyb25nIGFuZCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgYXJlIGNhbGN1bGF0ZWQgYXMgTmFOXG4gICAgICAgIGxlZnQgPSBsZWZ0IHx8IDA7XG4gICAgICAgIHRvcCA9IHRvcCB8fCAwO1xuICAgICAgICBpZiAoaXNOYU4od2lkdGgpKSB7XG4gICAgICAgICAgICAvLyBXaWR0aCBtYXkgYmUgTmFOIGlmIG9ubHkgb25lIHZhbHVlIGlzIGdpdmVuIGV4Y2VwdCB3aWR0aFxuICAgICAgICAgICAgd2lkdGggPSBjb250YWluZXJXaWR0aCAtIGxlZnQgLSAocmlnaHQgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKGhlaWdodCkpIHtcbiAgICAgICAgICAgIC8vIEhlaWdodCBtYXkgYmUgTmFOIGlmIG9ubHkgb25lIHZhbHVlIGlzIGdpdmVuIGV4Y2VwdCBoZWlnaHRcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbnRhaW5lckhlaWdodCAtIHRvcCAtIChib3R0b20gfHwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QobGVmdCArIG1hcmdpblszXSwgdG9wICsgbWFyZ2luWzBdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcmVjdC5tYXJnaW4gPSBtYXJnaW47XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIGEgenIgZWxlbWVudCBpbiB2aWV3cG9ydFxuICAgICAqICBHcm91cCBwb3NpdGlvbiBpcyBzcGVjaWZpZWQgYnkgZWl0aGVyXG4gICAgICogIHtsZWZ0LCB0b3B9LCB7cmlnaHQsIGJvdHRvbX1cbiAgICAgKiAgSWYgYWxsIHByb3BlcnRpZXMgZXhpc3RzLCByaWdodCBhbmQgYm90dG9tIHdpbGwgYmUgaWdvbnJlZC5cbiAgICAgKlxuICAgICAqIExvZ2ljOlxuICAgICAqICAgICAxLiBTY2FsZSAoYWdhaW5zdCBvcmlnaW4gcG9pbnQgaW4gcGFyZW50IGNvb3JkKVxuICAgICAqICAgICAyLiBSb3RhdGUgKGFnYWluc3Qgb3JpZ2luIHBvaW50IGluIHBhcmVudCBjb29yZClcbiAgICAgKiAgICAgMy4gVHJhc2xhdGUgKHdpdGggZWwucG9zaXRpb24gYnkgdGhpcyBtZXRob2QpXG4gICAgICogU28gdGhpcyBtZXRob2Qgb25seSBmaXhlcyB0aGUgbGFzdCBzdGVwICdUcmFzbGF0ZScsIHdoaWNoIGRvZXMgbm90IGFmZmVjdFxuICAgICAqIHNjYWxpbmcgYW5kIHJvdGF0aW5nLlxuICAgICAqXG4gICAgICogSWYgYmUgY2FsbGVkIHJlcGVhdGx5IHdpdGggdGhlIHNhbWUgaW5wdXQgZWwsIHRoZSBzYW1lIHJlc3VsdCB3aWxsIGJlIGdvdHRlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWwgU2hvdWxkIGhhdmUgYGdldEJvdW5kaW5nUmVjdGAgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbkluZm9cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ubGVmdF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8udG9wXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5yaWdodF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8uYm90dG9tXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJSZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBtYXJnaW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3B0Lmh2PVsxLDFdXSBPbmx5IGhvcml6b250YWwgb3Igb25seSB2ZXJ0aWNhbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3B0LmJvdW5kaW5nTW9kZT0nYWxsJ11cbiAgICAgKiAgICAgICAgU3BlY2lmeSBob3cgdG8gY2FsY3VsYXRlIGJvdW5kaW5nUmVjdCB3aGVuIGxvY2F0aW5nLlxuICAgICAqICAgICAgICAnYWxsJzogUG9zaXRpb24gdGhlIGJvdW5kaW5nUmVjdCB0aGF0IGlzIHRyYW5zZm9ybWVkIGFuZCB1aW9uZWRcbiAgICAgKiAgICAgICAgICAgICAgIGJvdGggaXRzZWxmIGFuZCBpdHMgZGVzY2VuZGFudHMuXG4gICAgICogICAgICAgICAgICAgICBUaGlzIG1vZGUgc2ltcGxpZXMgY29uZmluZSB0aGUgZWxlbWVudHMgaW4gdGhlIGJvdW5kaW5nXG4gICAgICogICAgICAgICAgICAgICBvZiB0aGVpciBjb250YWluZXIgKGUuZy4sIHVzaW5nICdyaWdodDogMCcpLlxuICAgICAqICAgICAgICAncmF3JzogUG9zaXRpb24gdGhlIGJvdW5kaW5nUmVjdCB0aGF0IGlzIG5vdCB0cmFuc2Zvcm1lZCBhbmQgb25seSBpdHNlbGYuXG4gICAgICogICAgICAgICAgICAgICBUaGlzIG1vZGUgaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgYSBlbGVtZW50IGNhbiBvdmVyZmxvdyBpdHNcbiAgICAgKiAgICAgICAgICAgICAgIGNvbnRhaW5lci4gKENvbnNpZGVyIGEgcm90YXRlZCBjaXJjbGUgbmVlZHMgdG8gYmUgbG9jYXRlZCBpbiBhIGNvcm5lci4pXG4gICAgICogICAgICAgICAgICAgICBJbiB0aGlzIG1vZGUgcG9zaXRpb25JbmZvLndpZHRoL2hlaWdodCBjYW4gb25seSBiZSBudW1iZXIuXG4gICAgICovXG4gICAgbGF5b3V0LnBvc2l0aW9uRWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgcG9zaXRpb25JbmZvLCBjb250YWluZXJSZWN0LCBtYXJnaW4sIG9wdCkge1xuICAgICAgICB2YXIgaCA9ICFvcHQgfHwgIW9wdC5odiB8fCBvcHQuaHZbMF07XG4gICAgICAgIHZhciB2ID0gIW9wdCB8fCAhb3B0Lmh2IHx8IG9wdC5odlsxXTtcbiAgICAgICAgdmFyIGJvdW5kaW5nTW9kZSA9IG9wdCAmJiBvcHQuYm91bmRpbmdNb2RlIHx8ICdhbGwnO1xuXG4gICAgICAgIGlmICghaCAmJiAhdikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3Q7XG4gICAgICAgIGlmIChib3VuZGluZ01vZGUgPT09ICdyYXcnKSB7XG4gICAgICAgICAgICByZWN0ID0gZWwudHlwZSA9PT0gJ2dyb3VwJ1xuICAgICAgICAgICAgICAgID8gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCArcG9zaXRpb25JbmZvLndpZHRoIHx8IDAsICtwb3NpdGlvbkluZm8uaGVpZ2h0IHx8IDApXG4gICAgICAgICAgICAgICAgOiBlbC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlY3QgPSBlbC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIGlmIChlbC5uZWVkTG9jYWxUcmFuc2Zvcm0oKSkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBlbC5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgIC8vIE5vdGljZTogcmF3IHJlY3QgbWF5IGJlIGlubmVyIG9iamVjdCBvZiBlbCxcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBzaG91bGQgbm90IGJlIG1vZGlmaWVkLlxuICAgICAgICAgICAgICAgIHJlY3QgPSByZWN0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgcmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcG9zaXRpb25JbmZvID0gbGF5b3V0LmdldExheW91dFJlY3QoXG4gICAgICAgICAgICB6clV0aWwuZGVmYXVsdHMoXG4gICAgICAgICAgICAgICAge3dpZHRoOiByZWN0LndpZHRoLCBoZWlnaHQ6IHJlY3QuaGVpZ2h0fSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkluZm9cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjb250YWluZXJSZWN0LFxuICAgICAgICAgICAgbWFyZ2luXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQmVjYXVzZSAndHJhbmxhdGUnIGlzIHRoZSBsYXN0IHN0ZXAgaW4gdHJhbnNmb3JtXG4gICAgICAgIC8vIChzZWUgenJlbmRlci9jb3JlL1RyYW5zZm9ybWFibGUjZ2V0TG9jYWxUcmFuc2Zyb20pLFxuICAgICAgICAvLyB3ZSBjYW4ganVzdCBvbmx5IG1vZGlmeSBlbC5wb3NpdGlvbiB0byBnZXQgZmluYWwgcmVzdWx0LlxuICAgICAgICB2YXIgZWxQb3MgPSBlbC5wb3NpdGlvbjtcbiAgICAgICAgdmFyIGR4ID0gaCA/IHBvc2l0aW9uSW5mby54IC0gcmVjdC54IDogMDtcbiAgICAgICAgdmFyIGR5ID0gdiA/IHBvc2l0aW9uSW5mby55IC0gcmVjdC55IDogMDtcblxuICAgICAgICBlbC5hdHRyKCdwb3NpdGlvbicsIGJvdW5kaW5nTW9kZSA9PT0gJ3JhdycgPyBbZHgsIGR5XSA6IFtlbFBvc1swXSArIGR4LCBlbFBvc1sxXSArIGR5XSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb24gQ29udGFpbnMgc29tZSBvZiB0aGUgcHJvcGVydGllcyBpbiBIVl9OQU1FUy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaHZJZHggMDogaG9yaXpvbnRhbDsgMTogdmVydGljYWwuXG4gICAgICovXG4gICAgbGF5b3V0LnNpemVDYWxjdWxhYmxlID0gZnVuY3Rpb24gKG9wdGlvbiwgaHZJZHgpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbltIVl9OQU1FU1todklkeF1bMF1dICE9IG51bGxcbiAgICAgICAgICAgIHx8IChvcHRpb25bSFZfTkFNRVNbaHZJZHhdWzFdXSAhPSBudWxsICYmIG9wdGlvbltIVl9OQU1FU1todklkeF1bMl1dICE9IG51bGwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb25zaWRlciBDYXNlOlxuICAgICAqIFdoZW4gZGVmdWxhdCBvcHRpb24gaGFzIHtsZWZ0OiAwLCB3aWR0aDogMTAwfSwgYW5kIHdlIHNldCB7cmlnaHQ6IDB9XG4gICAgICogdGhyb3VnaCBzZXRPcHRpb24gb3IgbWVkaWEgcXVlcnksIHVzaW5nIG5vcm1hbCB6clV0aWwubWVyZ2Ugd2lsbCBjYXVzZVxuICAgICAqIHtyaWdodDogMH0gZG9lcyBub3QgdGFrZSBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIENvbXBvbmVudE1vZGVsLmV4dGVuZCh7XG4gICAgICogICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgKiAgICAgICAgIC4uLlxuICAgICAqICAgICAgICAgdmFyIGlucHV0UG9zaXRpb25QYXJhbXMgPSBsYXlvdXQuZ2V0TGF5b3V0UGFyYW1zKG9wdGlvbik7XG4gICAgICogICAgICAgICB0aGlzLm1lcmdlT3B0aW9uKGlucHV0UG9zaXRpb25QYXJhbXMpO1xuICAgICAqICAgICB9LFxuICAgICAqICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG5ld09wdGlvbikge1xuICAgICAqICAgICAgICAgbmV3T3B0aW9uICYmIHpyVXRpbC5tZXJnZSh0aGlzT3B0aW9uLCBuZXdPcHRpb24sIHRydWUpO1xuICAgICAqICAgICAgICAgbGF5b3V0Lm1lcmdlTGF5b3V0UGFyYW0odGhpc09wdGlvbiwgbmV3T3B0aW9uKTtcbiAgICAgKiAgICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldE9wdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdPcHRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRdXG4gICAgICogQHBhcmFtIHtib29sZWFufEFycmF5Ljxib29sZWFuPn0gW29wdC5pZ25vcmVTaXplPWZhbHNlXSBTb21lIGNvbXBvbmVudCBtdXN0IGhhcyB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtID0gZnVuY3Rpb24gKHRhcmdldE9wdGlvbiwgbmV3T3B0aW9uLCBvcHQpIHtcbiAgICAgICAgIXpyVXRpbC5pc09iamVjdChvcHQpICYmIChvcHQgPSB7fSk7XG5cbiAgICAgICAgdmFyIGlnbm9yZVNpemUgPSBvcHQuaWdub3JlU2l6ZTtcbiAgICAgICAgIXpyVXRpbC5pc0FycmF5KGlnbm9yZVNpemUpICYmIChpZ25vcmVTaXplID0gW2lnbm9yZVNpemUsIGlnbm9yZVNpemVdKTtcblxuICAgICAgICB2YXIgaFJlc3VsdCA9IG1lcmdlKEhWX05BTUVTWzBdLCAwKTtcbiAgICAgICAgdmFyIHZSZXN1bHQgPSBtZXJnZShIVl9OQU1FU1sxXSwgMSk7XG5cbiAgICAgICAgY29weShIVl9OQU1FU1swXSwgdGFyZ2V0T3B0aW9uLCBoUmVzdWx0KTtcbiAgICAgICAgY29weShIVl9OQU1FU1sxXSwgdGFyZ2V0T3B0aW9uLCB2UmVzdWx0KTtcblxuICAgICAgICBmdW5jdGlvbiBtZXJnZShuYW1lcywgaHZJZHgpIHtcbiAgICAgICAgICAgIHZhciBuZXdQYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBtZXJnZWQgPSB7fTtcbiAgICAgICAgICAgIHZhciBtZXJnZWRWYWx1ZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBlbm91Z2hQYXJhbU51bWJlciA9IDI7XG5cbiAgICAgICAgICAgIGVhY2gobmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW25hbWVdID0gdGFyZ2V0T3B0aW9uW25hbWVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlYWNoKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIGNhc2U6IG5ld09wdGlvbi53aWR0aCBpcyBudWxsLCB3aGljaCBpc1xuICAgICAgICAgICAgICAgIC8vIHNldCBieSB1c2VyIGZvciByZW1vdmluZyB3aWR0aCBzZXR0aW5nLlxuICAgICAgICAgICAgICAgIGhhc1Byb3AobmV3T3B0aW9uLCBuYW1lKSAmJiAobmV3UGFyYW1zW25hbWVdID0gbWVyZ2VkW25hbWVdID0gbmV3T3B0aW9uW25hbWVdKTtcbiAgICAgICAgICAgICAgICBoYXNWYWx1ZShuZXdQYXJhbXMsIG5hbWUpICYmIG5ld1ZhbHVlQ291bnQrKztcbiAgICAgICAgICAgICAgICBoYXNWYWx1ZShtZXJnZWQsIG5hbWUpICYmIG1lcmdlZFZhbHVlQ291bnQrKztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaWdub3JlU2l6ZVtodklkeF0pIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IG9uZSBvZiBsZWZ0L3JpZ2h0IGlzIHByZW1pdHRlZCB0byBleGlzdC5cbiAgICAgICAgICAgICAgICBpZiAoaGFzVmFsdWUobmV3T3B0aW9uLCBuYW1lc1sxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkW25hbWVzWzJdXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc1ZhbHVlKG5ld09wdGlvbiwgbmFtZXNbMl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFtuYW1lc1sxXV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYXNlOiBuZXdPcHRpb246IHt3aWR0aDogLi4uLCByaWdodDogLi4ufSxcbiAgICAgICAgICAgIC8vIG9yIHRhcmdldE9wdGlvbjoge3JpZ2h0OiAuLi59IGFuZCBuZXdPcHRpb246IHt3aWR0aDogLi4ufSxcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGNvbmZsaWN0IHdoZW4gbWVyZ2VkIG9ubHkgaGFzIHBhcmFtcyBjb3VudFxuICAgICAgICAgICAgLy8gbGl0dGxlIHRoYW4gZW5vdWdoUGFyYW1OdW1iZXIuXG4gICAgICAgICAgICBpZiAobWVyZ2VkVmFsdWVDb3VudCA9PT0gZW5vdWdoUGFyYW1OdW1iZXIgfHwgIW5ld1ZhbHVlQ291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FzZTogbmV3T3B0aW9uOiB7d2lkdGg6IC4uLiwgcmlnaHQ6IC4uLn0sXG4gICAgICAgICAgICAvLyBUaGFuIHdlIGNhbiBtYWtlIHN1cmUgdXNlciBvbmx5IHdhbnQgdGhvc2UgdHdvLCBhbmQgaWdub3JlXG4gICAgICAgICAgICAvLyBhbGwgb3JpZ2luIHBhcmFtcyBpbiB0YXJnZXRPcHRpb24uXG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZUNvdW50ID49IGVub3VnaFBhcmFtTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENob3NlIGFub3RoZXIgcGFyYW0gZnJvbSB0YXJnZXRPcHRpb24gYnkgcHJpb3JpdHkuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc1Byb3AobmV3UGFyYW1zLCBuYW1lKSAmJiBoYXNQcm9wKHRhcmdldE9wdGlvbiwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcmFtc1tuYW1lXSA9IHRhcmdldE9wdGlvbltuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoYXNQcm9wKG9iaiwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhc1ZhbHVlKG9iaiwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtuYW1lXSAhPSBudWxsICYmIG9ialtuYW1lXSAhPT0gJ2F1dG8nO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29weShuYW1lcywgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgICAgIGVhY2gobmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbScsICd3aWR0aCcsICdoZWlnaHQnIGZyb20gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJlc3VsdCBjb250YWlucyB0aG9zZSBwcm9wcy5cbiAgICAgKi9cbiAgICBsYXlvdXQuZ2V0TGF5b3V0UGFyYW1zID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbGF5b3V0LmNvcHlMYXlvdXRQYXJhbXMoe30sIHNvdXJjZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nLCAnd2lkdGgnLCAnaGVpZ2h0JyBmcm9tIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBSZXN1bHQgY29udGFpbnMgdGhvc2UgcHJvcHMuXG4gICAgICovXG4gICAgbGF5b3V0LmNvcHlMYXlvdXRQYXJhbXMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgc291cmNlICYmIHRhcmdldCAmJiBlYWNoKExPQ0FUSU9OX1BBUkFNUywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAodGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gbGF5b3V0O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvdXRpbC9sYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports){eval("\n\n    module.exports = {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL21vZGVsL21peGluL2JveExheW91dC5qcz85MmQ3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ijg4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZ2V0Qm94TGF5b3V0UGFyYW1zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuZ2V0KCdsZWZ0JyksXG4gICAgICAgICAgICAgICAgdG9wOiB0aGlzLmdldCgndG9wJyksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRoaXMuZ2V0KCdyaWdodCcpLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogdGhpcy5nZXQoJ2JvdHRvbScpLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLmdldCgnd2lkdGgnKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuZ2V0KCdoZWlnaHQnKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vYm94TGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    module.exports = {\n        // 全图默认背景\n        // backgroundColor: 'rgba(0,0,0,0)',\n\n        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n        // 浅色\n        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n        // 深色\n        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n        // 默认需要 Grid 配置项\n        // grid: {},\n        // 主题，主题\n        textStyle: {\n            // color: '#000',\n            // decoration: 'none',\n            // PENDING\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            // fontFamily: 'Arial, Verdana, sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n\n        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n        // Default is source-over\n        blendMode: null,\n\n        animation: 'auto',\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n\n        animationThreshold: 2000,\n        // Configuration for progressive/incremental rendering\n        progressiveThreshold: 3000,\n        progressive: 400,\n\n        // Threshold of if use single hover layer to optimize.\n        // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n        // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n        // which is unexpected.\n        // see example <echarts/test/heatmap-large.html>.\n        hoverLayerThreshold: 3000,\n\n        // See: module:echarts/scale/Time\n        useUTC: false\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL21vZGVsL2dsb2JhbERlZmF1bHQuanM/ZmQ1NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Ijg5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgdmFyIHBsYXRmb3JtID0gJyc7XG4gICAgLy8gTmF2aWdhdG9yIG5vdCBleGlzdHMgaW4gbm9kZVxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwbGF0Zm9ybSA9IG5hdmlnYXRvci5wbGF0Zm9ybSB8fCAnJztcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8vIOWFqOWbvum7mOiupOiDjOaZr1xuICAgICAgICAvLyBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcblxuICAgICAgICAvLyBodHRwczovL2RyaWJiYmxlLmNvbS9zaG90cy8xMDY1OTYwLUluZm9ncmFwaGljLVBpZS1jaGFydC12aXN1YWxpemF0aW9uXG4gICAgICAgIC8vIGNvbG9yOiBbJyM1NzkzZjMnLCAnI2QxNGE2MScsICcjZmQ5YzM1JywgJyM2NzViYmEnLCAnI2ZlYzQyYycsICcjZGQ0NDQ0JywgJyNkNGRmNWEnLCAnI2NkNDg3MCddLFxuICAgICAgICAvLyDmtYXoibJcbiAgICAgICAgLy8gY29sb3I6IFsnI2JjZDNiYicsICcjZTg4ZjcwJywgJyNlZGMxYTUnLCAnIzlkYzVjOCcsICcjZTFlOGM4JywgJyM3YjdjNjgnLCAnI2U1YjViNScsICcjZjBiNDg5JywgJyM5MjhlYTgnLCAnI2JkYTI5YSddLFxuICAgICAgICAvLyBjb2xvcjogWycjY2M1NjY0JywgJyM5YmQ2ZWMnLCAnI2VhOTQ2ZScsICcjOGFjYWFhJywgJyNmMWVjNjQnLCAnI2VlODY4NicsICcjYTQ4ZGMxJywgJyM1ZGE2YmMnLCAnI2I5ZGNhZSddLFxuICAgICAgICAvLyDmt7HoibJcbiAgICAgICAgY29sb3I6IFsnI2MyMzUzMScsJyMyZjQ1NTQnLCAnIzYxYTBhOCcsICcjZDQ4MjY1JywgJyM5MWM3YWUnLCcjNzQ5ZjgzJywgICcjY2E4NjIyJywgJyNiZGEyOWEnLCcjNmU3MDc0JywgJyM1NDY1NzAnLCAnI2M0Y2NkMyddLFxuXG4gICAgICAgIC8vIOm7mOiupOmcgOimgSBHcmlkIOmFjee9rumhuVxuICAgICAgICAvLyBncmlkOiB7fSxcbiAgICAgICAgLy8g5Li76aKY77yM5Li76aKYXG4gICAgICAgIHRleHRTdHlsZToge1xuICAgICAgICAgICAgLy8gY29sb3I6ICcjMDAwJyxcbiAgICAgICAgICAgIC8vIGRlY29yYXRpb246ICdub25lJyxcbiAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHBsYXRmb3JtLm1hdGNoKC9eV2luLykgPyAnTWljcm9zb2Z0IFlhSGVpJyA6ICdzYW5zLXNlcmlmJyxcbiAgICAgICAgICAgIC8vIGZvbnRGYW1pbHk6ICdBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsXG4gICAgICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgICAgICBmb250U3R5bGU6ICdub3JtYWwnLFxuICAgICAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCdcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBodHRwOi8vYmxvZ3MuYWRvYmUuY29tL3dlYnBsYXRmb3JtLzIwMTQvMDIvMjQvdXNpbmctYmxlbmQtbW9kZXMtaW4taHRtbC1jYW52YXMvXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAgICAgIC8vIERlZmF1bHQgaXMgc291cmNlLW92ZXJcbiAgICAgICAgYmxlbmRNb2RlOiBudWxsLFxuXG4gICAgICAgIGFuaW1hdGlvbjogJ2F1dG8nLFxuICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogMTAwMCxcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGU6IDMwMCxcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nOiAnZXhwb25lbnRpYWxPdXQnLFxuICAgICAgICBhbmltYXRpb25FYXNpbmdVcGRhdGU6ICdjdWJpY091dCcsXG5cbiAgICAgICAgYW5pbWF0aW9uVGhyZXNob2xkOiAyMDAwLFxuICAgICAgICAvLyBDb25maWd1cmF0aW9uIGZvciBwcm9ncmVzc2l2ZS9pbmNyZW1lbnRhbCByZW5kZXJpbmdcbiAgICAgICAgcHJvZ3Jlc3NpdmVUaHJlc2hvbGQ6IDMwMDAsXG4gICAgICAgIHByb2dyZXNzaXZlOiA0MDAsXG5cbiAgICAgICAgLy8gVGhyZXNob2xkIG9mIGlmIHVzZSBzaW5nbGUgaG92ZXIgbGF5ZXIgdG8gb3B0aW1pemUuXG4gICAgICAgIC8vIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgYGhvdmVyTGF5ZXJUaHJlc2hvbGRgIGlzIGVxdWl2YWxlbnQgdG8gb3IgbGVzcyB0aGFuXG4gICAgICAgIC8vIGBwcm9ncmVzc2l2ZVRocmVzaG9sZGAsIG90aGVyd2lzZSBob3ZlciB3aWxsIGNhdXNlIHJlc3RhcnQgb2YgcHJvZ3Jlc3NpdmUsXG4gICAgICAgIC8vIHdoaWNoIGlzIHVuZXhwZWN0ZWQuXG4gICAgICAgIC8vIHNlZSBleGFtcGxlIDxlY2hhcnRzL3Rlc3QvaGVhdG1hcC1sYXJnZS5odG1sPi5cbiAgICAgICAgaG92ZXJMYXllclRocmVzaG9sZDogMzAwMCxcblxuICAgICAgICAvLyBTZWU6IG1vZHVsZTplY2hhcnRzL3NjYWxlL1RpbWVcbiAgICAgICAgdXNlVVRDOiBmYWxzZVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvbW9kZWwvZ2xvYmFsRGVmYXVsdC5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\n\n    var classUtil = __webpack_require__(29);\n    var set = classUtil.set;\n    var get = classUtil.get;\n\n    module.exports = {\n        clearColorPalette: function () {\n            set(this, 'colorIdx', 0);\n            set(this, 'colorNameMap', {});\n        },\n\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = get(scope, 'colorIdx') || 0;\n            var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {});\n            // Use `hasOwnProperty` to avoid conflict with Object.prototype.\n            if (colorNameMap.hasOwnProperty(name)) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n\n            return color;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL21vZGVsL21peGluL2NvbG9yUGFsZXR0ZS5qcz9iNDU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjkwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgY2xhc3NVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jbGF6eicpO1xuICAgIHZhciBzZXQgPSBjbGFzc1V0aWwuc2V0O1xuICAgIHZhciBnZXQgPSBjbGFzc1V0aWwuZ2V0O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGNsZWFyQ29sb3JQYWxldHRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXQodGhpcywgJ2NvbG9ySWR4JywgMCk7XG4gICAgICAgICAgICBzZXQodGhpcywgJ2NvbG9yTmFtZU1hcCcsIHt9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb2xvckZyb21QYWxldHRlOiBmdW5jdGlvbiAobmFtZSwgc2NvcGUpIHtcbiAgICAgICAgICAgIHNjb3BlID0gc2NvcGUgfHwgdGhpcztcbiAgICAgICAgICAgIHZhciBjb2xvcklkeCA9IGdldChzY29wZSwgJ2NvbG9ySWR4JykgfHwgMDtcbiAgICAgICAgICAgIHZhciBjb2xvck5hbWVNYXAgPSBnZXQoc2NvcGUsICdjb2xvck5hbWVNYXAnKSB8fCBzZXQoc2NvcGUsICdjb2xvck5hbWVNYXAnLCB7fSk7XG4gICAgICAgICAgICAvLyBVc2UgYGhhc093blByb3BlcnR5YCB0byBhdm9pZCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUuXG4gICAgICAgICAgICBpZiAoY29sb3JOYW1lTWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yTmFtZU1hcFtuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb2xvclBhbGV0dGUgPSB0aGlzLmdldCgnY29sb3InLCB0cnVlKSB8fCBbXTtcbiAgICAgICAgICAgIGlmICghY29sb3JQYWxldHRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvbG9yID0gY29sb3JQYWxldHRlW2NvbG9ySWR4XTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgY29sb3JOYW1lTWFwW25hbWVdID0gY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXQoc2NvcGUsICdjb2xvcklkeCcsIChjb2xvcklkeCArIDEpICUgY29sb3JQYWxldHRlLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vY29sb3JQYWxldHRlLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var zrUtil = __webpack_require__(20);\n\n    var echartsAPIList = [\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed',\n        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',\n        'getViewOfComponentModel', 'getViewOfSeriesModel'\n    ];\n    // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js\n\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n\n    module.exports = ExtensionAPI;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL0V4dGVuc2lvbkFQSS5qcz9lMjgzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBIiwiZmlsZSI6IjkxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgZWNoYXJ0c0FQSUxpc3QgPSBbXG4gICAgICAgICdnZXREb20nLCAnZ2V0WnInLCAnZ2V0V2lkdGgnLCAnZ2V0SGVpZ2h0JywgJ2dldERldmljZVBpeGVsUmF0aW8nLCAnZGlzcGF0Y2hBY3Rpb24nLCAnaXNEaXNwb3NlZCcsXG4gICAgICAgICdvbicsICdvZmYnLCAnZ2V0RGF0YVVSTCcsICdnZXRDb25uZWN0ZWREYXRhVVJMJywgJ2dldE1vZGVsJywgJ2dldE9wdGlvbicsXG4gICAgICAgICdnZXRWaWV3T2ZDb21wb25lbnRNb2RlbCcsICdnZXRWaWV3T2ZTZXJpZXNNb2RlbCdcbiAgICBdO1xuICAgIC8vIEFuZCBgZ2V0Q29vcmRpbmF0ZVN5c3RlbXNgIGFuZCBgZ2V0Q29tcG9uZW50QnlFbGVtZW50YCB3aWxsIGJlIGluamVjdGVkIGluIGVjaGFydHMuanNcblxuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkFQSShjaGFydEluc3RhbmNlKSB7XG4gICAgICAgIHpyVXRpbC5lYWNoKGVjaGFydHNBUElMaXN0LCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHpyVXRpbC5iaW5kKGNoYXJ0SW5zdGFuY2VbbmFtZV0sIGNoYXJ0SW5zdGFuY2UpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV4dGVuc2lvbkFQSTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9FeHRlbnNpb25BUEkuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var zrUtil = __webpack_require__(20);\n\n    var coordinateSystemCreators = {};\n\n    function CoordinateSystemManager() {\n\n        this._coordinateSystems = [];\n    }\n\n    CoordinateSystemManager.prototype = {\n\n        constructor: CoordinateSystemManager,\n\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n                var list = creater.create(ecModel, api);\n                coordinateSystems = coordinateSystems.concat(list || []);\n            });\n\n            this._coordinateSystems = coordinateSystems;\n        },\n\n        update: function (ecModel, api) {\n            zrUtil.each(this._coordinateSystems, function (coordSys) {\n                // FIXME MUST have\n                coordSys.update && coordSys.update(ecModel, api);\n            });\n        },\n\n        getCoordinateSystems: function () {\n            return this._coordinateSystems.slice();\n        }\n    };\n\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n\n    module.exports = CoordinateSystemManager;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL0Nvb3JkaW5hdGVTeXN0ZW0uanM/MmIzMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjkyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3JzID0ge307XG5cbiAgICBmdW5jdGlvbiBDb29yZGluYXRlU3lzdGVtTWFuYWdlcigpIHtcblxuICAgICAgICB0aGlzLl9jb29yZGluYXRlU3lzdGVtcyA9IFtdO1xuICAgIH1cblxuICAgIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIsXG5cbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZVN5c3RlbXMgPSBbXTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGNvb3JkaW5hdGVTeXN0ZW1DcmVhdG9ycywgZnVuY3Rpb24gKGNyZWF0ZXIsIHR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IGNyZWF0ZXIuY3JlYXRlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZVN5c3RlbXMgPSBjb29yZGluYXRlU3lzdGVtcy5jb25jYXQobGlzdCB8fCBbXSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fY29vcmRpbmF0ZVN5c3RlbXMgPSBjb29yZGluYXRlU3lzdGVtcztcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zLCBmdW5jdGlvbiAoY29vcmRTeXMpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBNVVNUIGhhdmVcbiAgICAgICAgICAgICAgICBjb29yZFN5cy51cGRhdGUgJiYgY29vcmRTeXMudXBkYXRlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb29yZGluYXRlU3lzdGVtczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIucmVnaXN0ZXIgPSBmdW5jdGlvbiAodHlwZSwgY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3IpIHtcbiAgICAgICAgY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3JzW3R5cGVdID0gY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3I7XG4gICAgfTtcblxuICAgIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLmdldCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnNbdHlwZV07XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvQ29vcmRpbmF0ZVN5c3RlbS5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\n\n    var zrUtil = __webpack_require__(20);\n    var modelUtil = __webpack_require__(21);\n    var ComponentModel = __webpack_require__(85);\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n    OptionManager.prototype = {\n\n        constructor: OptionManager,\n\n        /**\n         * @public\n         * @param {Object} rawOption Raw option.\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Array.<Function>} optionPreprocessorFuncs\n         * @return {Object} Init option\n         */\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n\n            // FIXME\n            // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。\n\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(\n                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n            );\n            this._newBaseOption = newParsedOption.baseOption;\n\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            }\n            else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n\n        /**\n         * @param {boolean} isRecreate\n         * @return {Object}\n         */\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n\n            // TODO\n            // 如果没有reset功能则不clone。\n\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n\n            return clone(isRecreate\n                // this._optionBackup.baseOption, which is created at the first `setOption`\n                // called, and is merged into every new option by inner method `mergeOption`\n                // each time `setOption` called, can be only used in `isRecreate`, because\n                // its reliability is under suspicion. In other cases option merge is\n                // performed by `model.mergeOption`.\n                ? optionBackup.baseOption : this._newBaseOption\n            );\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object}\n         */\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(\n                        timelineOptions[timelineModel.getCurrentIndex()],\n                        true\n                    );\n                }\n            }\n\n            return option;\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Array.<Object>}\n         */\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n\n            // FIXME\n            // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(\n                        index === -1 ? mediaDefault.option : mediaList[index].option\n                    );\n                });\n            }\n            // Otherwise return nothing.\n\n            this._currentMediaIndices = indices;\n\n            return result;\n        }\n    };\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    }\n                    else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n\n        // Preprocess.\n        each([baseOption].concat(timelineOptions)\n            .concat(zrUtil.map(mediaList, function (media) {\n                return media.option;\n            })),\n            function (option) {\n                each(optionPreprocessorFuncs, function (preProcess) {\n                    preProcess(option, isNew);\n                });\n            }\n        );\n\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n            width: ecWidth,\n            height: ecHeight,\n            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n        };\n\n        var applicatable = true;\n\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n\n        return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        }\n        else if (operator === 'max') {\n            return real <= expect;\n        }\n        else { // Equals\n            return real === expect;\n        }\n    }\n\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n\n            var oldCptOpt = oldOption[mainType];\n\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            }\n            else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return (item.option && item.exist)\n                        ? merge(item.exist, item.option, true)\n                        : (item.exist || item.option);\n                });\n            }\n        });\n    }\n\n    module.exports = OptionManager;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL21vZGVsL09wdGlvbk1hbmFnZXIuanM/YTdhNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixJQUFJO0FBQzNCLHdCQUF3QixJQUFJO0FBQzVCLDJCQUEyQixJQUFJO0FBQy9CO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQiw0QkFBNEIsSUFBSTtBQUNoQztBQUNBLHdCQUF3QixZQUFZO0FBQ3BDLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsMEJBQTBCLElBQUk7QUFDOUI7QUFDQSxvQkFBb0IsUUFBUSxJQUFJLFdBQVcsYUFBYTtBQUN4RCxvQkFBb0IsUUFBUSxJQUFJLFdBQVcsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDLGdDQUFnQyxTQUFTLE1BQU0sY0FBYztBQUM3RCxvQkFBb0I7QUFDcEI7QUFDQSwrQkFBK0IsNkJBQTZCO0FBQzVELGdDQUFnQyxTQUFTLE9BQU8sY0FBYztBQUM5RCxvQkFBb0I7QUFDcEI7QUFDQSxnQ0FBZ0MsU0FBUyxRQUFRLGNBQWM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXLGdCQUFnQixNQUFNO0FBQ2pFLGdDQUFnQyxXQUFXLGVBQWUsTUFBTTs7QUFFaEU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLGlCQUFpQjtBQUNwQyxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdUJBQXVCO0FBQ3JEO0FBQ0E7QUFDQSw4QkFBOEIsdUJBQXVCO0FBQ3JELDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUOztBQUVBIiwiZmlsZSI6IjkzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFQ2hhcnRzIG9wdGlvbiBtYW5hZ2VyXG4gKlxuICogQG1vZHVsZSB7ZWNoYXJ0cy9tb2RlbC9PcHRpb25NYW5hZ2VyfVxuICovXG5cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZSgnLi9Db21wb25lbnQnKTtcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciBjbG9uZSA9IHpyVXRpbC5jbG9uZTtcbiAgICB2YXIgbWFwID0genJVdGlsLm1hcDtcbiAgICB2YXIgbWVyZ2UgPSB6clV0aWwubWVyZ2U7XG5cbiAgICB2YXIgUVVFUllfUkVHID0gL14obWlufG1heCk/KC4rKSQvO1xuXG4gICAgLyoqXG4gICAgICogVEVSTSBFWFBMQU5BVElPTlM6XG4gICAgICpcbiAgICAgKiBbb3B0aW9uXTpcbiAgICAgKlxuICAgICAqICAgICBBbiBvYmplY3QgdGhhdCBjb250YWlucyBkZWZpbml0aW9ucyBvZiBjb21wb25lbnRzLiBGb3IgZXhhbXBsZTpcbiAgICAgKiAgICAgdmFyIG9wdGlvbiA9IHtcbiAgICAgKiAgICAgICAgIHRpdGxlOiB7Li4ufSxcbiAgICAgKiAgICAgICAgIGxlZ2VuZDogey4uLn0sXG4gICAgICogICAgICAgICB2aXN1YWxNYXA6IHsuLi59LFxuICAgICAqICAgICAgICAgc2VyaWVzOiBbXG4gICAgICogICAgICAgICAgICAge2RhdGE6IFsuLi5dfSxcbiAgICAgKiAgICAgICAgICAgICB7ZGF0YTogWy4uLl19LFxuICAgICAqICAgICAgICAgICAgIC4uLlxuICAgICAqICAgICAgICAgXVxuICAgICAqICAgICB9O1xuICAgICAqXG4gICAgICogW3Jhd09wdGlvbl06XG4gICAgICpcbiAgICAgKiAgICAgQW4gb2JqZWN0IGlucHV0IHRvIGVjaGFydHMuc2V0T3B0aW9uLiAncmF3T3B0aW9uJyBtYXkgYmUgYW5cbiAgICAgKiAgICAgJ29wdGlvbicsIG9yIG1heSBiZSBhbiBvYmplY3QgY29udGFpbnMgbXVsdGktb3B0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAgICogICAgIHZhciBvcHRpb24gPSB7XG4gICAgICogICAgICAgICBiYXNlT3B0aW9uOiB7XG4gICAgICogICAgICAgICAgICAgdGl0bGU6IHsuLi59LFxuICAgICAqICAgICAgICAgICAgIGxlZ2VuZDogey4uLn0sXG4gICAgICogICAgICAgICAgICAgc2VyaWVzOiBbXG4gICAgICogICAgICAgICAgICAgICAgIHtkYXRhOiBbLi4uXX0sXG4gICAgICogICAgICAgICAgICAgICAgIHtkYXRhOiBbLi4uXX0sXG4gICAgICogICAgICAgICAgICAgICAgIC4uLlxuICAgICAqICAgICAgICAgICAgIF1cbiAgICAgKiAgICAgICAgIH0sXG4gICAgICogICAgICAgICB0aW1lbGluZTogey4uLn0sXG4gICAgICogICAgICAgICBvcHRpb25zOiBbXG4gICAgICogICAgICAgICAgICAge3RpdGxlOiB7Li4ufSwgc2VyaWVzOiB7ZGF0YTogWy4uLl19fSxcbiAgICAgKiAgICAgICAgICAgICB7dGl0bGU6IHsuLi59LCBzZXJpZXM6IHtkYXRhOiBbLi4uXX19LFxuICAgICAqICAgICAgICAgICAgIC4uLlxuICAgICAqICAgICAgICAgXSxcbiAgICAgKiAgICAgICAgIG1lZGlhOiBbXG4gICAgICogICAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgICAgICBxdWVyeToge21heFdpZHRoOiAzMjB9LFxuICAgICAqICAgICAgICAgICAgICAgICBvcHRpb246IHtzZXJpZXM6IHt4OiAyMH0sIHZpc3VhbE1hcDoge3Nob3c6IGZhbHNlfX1cbiAgICAgKiAgICAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgcXVlcnk6IHttaW5XaWR0aDogMzIwLCBtYXhXaWR0aDogNzIwfSxcbiAgICAgKiAgICAgICAgICAgICAgICAgb3B0aW9uOiB7c2VyaWVzOiB7eDogNTAwfSwgdmlzdWFsTWFwOiB7c2hvdzogdHJ1ZX19XG4gICAgICogICAgICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgICAgIG9wdGlvbjoge3Nlcmllczoge3g6IDEyMDB9LCB2aXN1YWxNYXA6IHtzaG93OiB0cnVlfX1cbiAgICAgKiAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICBdXG4gICAgICogICAgIH07XG4gICAgICpcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvbW9kZWwvT3B0aW9uTWFuYWdlclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPcHRpb25NYW5hZ2VyKGFwaSkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYXBpID0gYXBpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90aW1lbGluZU9wdGlvbnMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWVkaWFMaXN0ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tZWRpYURlZmF1bHQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIC0xLCBtZWFucyBkZWZhdWx0LlxuICAgICAgICAgKiBlbXB0eSBtZWFucyBubyBtZWRpYS5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3VycmVudE1lZGlhSW5kaWNlcyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb3B0aW9uQmFja3VwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmV3QmFzZU9wdGlvbjtcbiAgICB9XG5cbiAgICAvLyB0aW1lbGluZS5ub3RNZXJnZSBpcyBub3Qgc3VwcG9ydGVkIGluIGVjMy4gRmlyc3RseSB0aGVyZSBpcyByZWFybHlcbiAgICAvLyBjYXNlIHRoYXQgbm90TWVyZ2UgaXMgbmVlZGVkLiBTZWNvbmRseSBzdXBwb3J0aW5nICdub3RNZXJnZScgcmVxdWlyZXNcbiAgICAvLyByYXdPcHRpb24gY2xvbmVkIGFuZCBiYWNrdXBlZCB3aGVuIHRpbWVsaW5lIGNoYW5nZWQsIHdoaWNoIGRvZXMgbm9cbiAgICAvLyBnb29kIHRvIHBlcmZvcm1hbmNlLiBXaGF0J3MgbW9yZSwgdGhhdCBib3RoIHRpbWVsaW5lIGFuZCBzZXRPcHRpb25cbiAgICAvLyBtZXRob2Qgc3VwcGx5ICdub3RNZXJnZScgYnJpbmdzIGNvbXBsZXggYW5kIHNvbWUgcHJvYmxlbXMuXG4gICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOlxuICAgIC8vIChzdGVwMSkgY2hhcnQuc2V0T3B0aW9uKHt0aW1lbGluZToge25vdE1lcmdlOiBmYWxzZX0sIC4uLn0sIGZhbHNlKTtcbiAgICAvLyAoc3RlcDIpIGNoYXJ0LnNldE9wdGlvbih7dGltZWxpbmU6IHtub3RNZXJnZTogdHJ1ZX0sIC4uLn0sIGZhbHNlKTtcblxuICAgIE9wdGlvbk1hbmFnZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBPcHRpb25NYW5hZ2VyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByYXdPcHRpb24gUmF3IG9wdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48RnVuY3Rpb24+fSBvcHRpb25QcmVwcm9jZXNzb3JGdW5jc1xuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEluaXQgb3B0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzZXRPcHRpb246IGZ1bmN0aW9uIChyYXdPcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzKSB7XG4gICAgICAgICAgICByYXdPcHRpb24gPSBjbG9uZShyYXdPcHRpb24sIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgLy8g5aaC5p6cIHRpbWVsaW5lIG9wdGlvbnMg5oiW6ICFIG1lZGlhIOS4reiuvue9ruS6huafkOS4quWxnuaAp++8jOiAjGJhc2VPcHRpb27kuK3msqHmnInorr7nva7vvIzliJnov5vooYzorablkYrjgIJcblxuICAgICAgICAgICAgdmFyIG9sZE9wdGlvbkJhY2t1cCA9IHRoaXMuX29wdGlvbkJhY2t1cDtcbiAgICAgICAgICAgIHZhciBuZXdQYXJzZWRPcHRpb24gPSBwYXJzZVJhd09wdGlvbi5jYWxsKFxuICAgICAgICAgICAgICAgIHRoaXMsIHJhd09wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MsICFvbGRPcHRpb25CYWNrdXBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9uZXdCYXNlT3B0aW9uID0gbmV3UGFyc2VkT3B0aW9uLmJhc2VPcHRpb247XG5cbiAgICAgICAgICAgIC8vIEZvciBzZXRPcHRpb24gYXQgc2Vjb25kIHRpbWUgKHVzaW5nIG1lcmdlIG1vZGUpO1xuICAgICAgICAgICAgaWYgKG9sZE9wdGlvbkJhY2t1cCkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYmFzZU9wdGlvbiBjYW4gYmUgbWVyZ2VkLlxuICAgICAgICAgICAgICAgIG1lcmdlT3B0aW9uKG9sZE9wdGlvbkJhY2t1cC5iYXNlT3B0aW9uLCBuZXdQYXJzZWRPcHRpb24uYmFzZU9wdGlvbik7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgdGltZWxpbmUgb3B0aW9ucyBhbmQgbWVkaWEgb3B0aW9ucyBkbyBub3Qgc3VwcG9ydCBtZXJnZSxcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGlzLCBpZiB5b3UgYHNldE9wdGlvbmAgdHdpY2UgYW5kIGJvdGggaGFzIHRpbWVsaW5lIG9wdGlvbnMsIHRoZSBsYXR0ZXJcbiAgICAgICAgICAgICAgICAvLyB0aW1lbGluZSBvcGl0b25zIHdpbGwgbm90IGJlIG1lcmdlZCB0byB0aGUgZm9ybWVycywgYnV0IGp1c3Qgc3Vic3RpdHVkZSB0aGVtLlxuICAgICAgICAgICAgICAgIGlmIChuZXdQYXJzZWRPcHRpb24udGltZWxpbmVPcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRPcHRpb25CYWNrdXAudGltZWxpbmVPcHRpb25zID0gbmV3UGFyc2VkT3B0aW9uLnRpbWVsaW5lT3B0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld1BhcnNlZE9wdGlvbi5tZWRpYUxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZE9wdGlvbkJhY2t1cC5tZWRpYUxpc3QgPSBuZXdQYXJzZWRPcHRpb24ubWVkaWFMaXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3UGFyc2VkT3B0aW9uLm1lZGlhRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRPcHRpb25CYWNrdXAubWVkaWFEZWZhdWx0ID0gbmV3UGFyc2VkT3B0aW9uLm1lZGlhRGVmYXVsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25CYWNrdXAgPSBuZXdQYXJzZWRPcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSZWNyZWF0ZVxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBtb3VudE9wdGlvbjogZnVuY3Rpb24gKGlzUmVjcmVhdGUpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25CYWNrdXAgPSB0aGlzLl9vcHRpb25CYWNrdXA7XG5cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIC8vIOWmguaenOayoeaciXJlc2V05Yqf6IO95YiZ5LiNY2xvbmXjgIJcblxuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmVPcHRpb25zID0gbWFwKG9wdGlvbkJhY2t1cC50aW1lbGluZU9wdGlvbnMsIGNsb25lKTtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhTGlzdCA9IG1hcChvcHRpb25CYWNrdXAubWVkaWFMaXN0LCBjbG9uZSk7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYURlZmF1bHQgPSBjbG9uZShvcHRpb25CYWNrdXAubWVkaWFEZWZhdWx0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMgPSBbXTtcblxuICAgICAgICAgICAgcmV0dXJuIGNsb25lKGlzUmVjcmVhdGVcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9vcHRpb25CYWNrdXAuYmFzZU9wdGlvbiwgd2hpY2ggaXMgY3JlYXRlZCBhdCB0aGUgZmlyc3QgYHNldE9wdGlvbmBcbiAgICAgICAgICAgICAgICAvLyBjYWxsZWQsIGFuZCBpcyBtZXJnZWQgaW50byBldmVyeSBuZXcgb3B0aW9uIGJ5IGlubmVyIG1ldGhvZCBgbWVyZ2VPcHRpb25gXG4gICAgICAgICAgICAgICAgLy8gZWFjaCB0aW1lIGBzZXRPcHRpb25gIGNhbGxlZCwgY2FuIGJlIG9ubHkgdXNlZCBpbiBgaXNSZWNyZWF0ZWAsIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBpdHMgcmVsaWFiaWxpdHkgaXMgdW5kZXIgc3VzcGljaW9uLiBJbiBvdGhlciBjYXNlcyBvcHRpb24gbWVyZ2UgaXNcbiAgICAgICAgICAgICAgICAvLyBwZXJmb3JtZWQgYnkgYG1vZGVsLm1lcmdlT3B0aW9uYC5cbiAgICAgICAgICAgICAgICA/IG9wdGlvbkJhY2t1cC5iYXNlT3B0aW9uIDogdGhpcy5fbmV3QmFzZU9wdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGltZWxpbmVPcHRpb246IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uO1xuICAgICAgICAgICAgdmFyIHRpbWVsaW5lT3B0aW9ucyA9IHRoaXMuX3RpbWVsaW5lT3B0aW9ucztcblxuICAgICAgICAgICAgaWYgKHRpbWVsaW5lT3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXRUaW1lbGluZU9wdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgZWNNb2RlbCBpbml0ZWQsXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgY2FuIGdldCBjdXJyZW50SW5kZXggZnJvbSB0aW1lbGluZU1vZGVsLlxuICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZU1vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ3RpbWVsaW5lJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVsaW5lTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gY2xvbmUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZU9wdGlvbnNbdGltZWxpbmVNb2RlbC5nZXRDdXJyZW50SW5kZXgoKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIGdldE1lZGlhT3B0aW9uOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGVjV2lkdGggPSB0aGlzLl9hcGkuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIHZhciBlY0hlaWdodCA9IHRoaXMuX2FwaS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIHZhciBtZWRpYUxpc3QgPSB0aGlzLl9tZWRpYUxpc3Q7XG4gICAgICAgICAgICB2YXIgbWVkaWFEZWZhdWx0ID0gdGhpcy5fbWVkaWFEZWZhdWx0O1xuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgLy8gTm8gbWVkaWEgZGVmaW5lZC5cbiAgICAgICAgICAgIGlmICghbWVkaWFMaXN0Lmxlbmd0aCAmJiAhbWVkaWFEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTXVsdGkgbWVkaWEgbWF5IGJlIGFwcGxpZWQsIHRoZSBsYXR0ZXIgZGVmaW5lZCBtZWRpYSBoYXMgaGlnaGVyIHByaW9yaXR5LlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1lZGlhTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcHBseU1lZGlhUXVlcnkobWVkaWFMaXN0W2ldLnF1ZXJ5LCBlY1dpZHRoLCBlY0hlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIC8vIOaYr+WQpm1lZGlhRGVmYXVsdOW6lOivpeW8uuWItueUqOaIt+iuvue9ru+8jOWQpuWImeWPr+iDveS/ruaUueS4jeiDveWbnuW9kuOAglxuICAgICAgICAgICAgaWYgKCFpbmRpY2VzLmxlbmd0aCAmJiBtZWRpYURlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2VzID0gWy0xXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluZGljZXMubGVuZ3RoICYmICFpbmRpY2VzRXF1YWxzKGluZGljZXMsIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWFwKGluZGljZXMsIGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmUoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9PT0gLTEgPyBtZWRpYURlZmF1bHQub3B0aW9uIDogbWVkaWFMaXN0W2luZGV4XS5vcHRpb25cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gbm90aGluZy5cblxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE1lZGlhSW5kaWNlcyA9IGluZGljZXM7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VSYXdPcHRpb24ocmF3T3B0aW9uLCBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcywgaXNOZXcpIHtcbiAgICAgICAgdmFyIHRpbWVsaW5lT3B0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgbWVkaWFMaXN0ID0gW107XG4gICAgICAgIHZhciBtZWRpYURlZmF1bHQ7XG4gICAgICAgIHZhciBiYXNlT3B0aW9uO1xuXG4gICAgICAgIC8vIENvbXBhdGlibGUgd2l0aCBlYzIuXG4gICAgICAgIHZhciB0aW1lbGluZU9wdCA9IHJhd09wdGlvbi50aW1lbGluZTtcblxuICAgICAgICBpZiAocmF3T3B0aW9uLmJhc2VPcHRpb24pIHtcbiAgICAgICAgICAgIGJhc2VPcHRpb24gPSByYXdPcHRpb24uYmFzZU9wdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciB0aW1lbGluZVxuICAgICAgICBpZiAodGltZWxpbmVPcHQgfHwgcmF3T3B0aW9uLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGJhc2VPcHRpb24gPSBiYXNlT3B0aW9uIHx8IHt9O1xuICAgICAgICAgICAgdGltZWxpbmVPcHRpb25zID0gKHJhd09wdGlvbi5vcHRpb25zIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIG1lZGlhIHF1ZXJ5XG4gICAgICAgIGlmIChyYXdPcHRpb24ubWVkaWEpIHtcbiAgICAgICAgICAgIGJhc2VPcHRpb24gPSBiYXNlT3B0aW9uIHx8IHt9O1xuICAgICAgICAgICAgdmFyIG1lZGlhID0gcmF3T3B0aW9uLm1lZGlhO1xuICAgICAgICAgICAgZWFjaChtZWRpYSwgZnVuY3Rpb24gKHNpbmdsZU1lZGlhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZU1lZGlhICYmIHNpbmdsZU1lZGlhLm9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlTWVkaWEucXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhTGlzdC5wdXNoKHNpbmdsZU1lZGlhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghbWVkaWFEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IG1lZGlhIGRlZmF1bHQuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYURlZmF1bHQgPSBzaW5nbGVNZWRpYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIG5vcm1hbCBvcHRpb25cbiAgICAgICAgaWYgKCFiYXNlT3B0aW9uKSB7XG4gICAgICAgICAgICBiYXNlT3B0aW9uID0gcmF3T3B0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRpbWVsaW5lT3B0IHRvIGJhc2VPcHRpb24gaW4gZWMzLFxuICAgICAgICAvLyB3aGljaCBpcyBjb252ZW5pZW50IGZvciBtZXJnZSBvcHRpb24uXG4gICAgICAgIGlmICghYmFzZU9wdGlvbi50aW1lbGluZSkge1xuICAgICAgICAgICAgYmFzZU9wdGlvbi50aW1lbGluZSA9IHRpbWVsaW5lT3B0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJlcHJvY2Vzcy5cbiAgICAgICAgZWFjaChbYmFzZU9wdGlvbl0uY29uY2F0KHRpbWVsaW5lT3B0aW9ucylcbiAgICAgICAgICAgIC5jb25jYXQoenJVdGlsLm1hcChtZWRpYUxpc3QsIGZ1bmN0aW9uIChtZWRpYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZWRpYS5vcHRpb247XG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgZWFjaChvcHRpb25QcmVwcm9jZXNzb3JGdW5jcywgZnVuY3Rpb24gKHByZVByb2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlUHJvY2VzcyhvcHRpb24sIGlzTmV3KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFzZU9wdGlvbjogYmFzZU9wdGlvbixcbiAgICAgICAgICAgIHRpbWVsaW5lT3B0aW9uczogdGltZWxpbmVPcHRpb25zLFxuICAgICAgICAgICAgbWVkaWFEZWZhdWx0OiBtZWRpYURlZmF1bHQsXG4gICAgICAgICAgICBtZWRpYUxpc3Q6IG1lZGlhTGlzdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgPGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtbWVkaWFxdWVyaWVzLyNtZWRpYTE+XG4gICAgICogU3VwcG9ydDogd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW9cbiAgICAgKiBDYW4gdXNlIG1heCBvciBtaW4gYXMgcHJlZml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFwcGx5TWVkaWFRdWVyeShxdWVyeSwgZWNXaWR0aCwgZWNIZWlnaHQpIHtcbiAgICAgICAgdmFyIHJlYWxNYXAgPSB7XG4gICAgICAgICAgICB3aWR0aDogZWNXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogZWNIZWlnaHQsXG4gICAgICAgICAgICBhc3BlY3RyYXRpbzogZWNXaWR0aCAvIGVjSGVpZ2h0IC8vIGxvd3NlciBjYXNlIGZvciBjb252ZW5pZW50Y2UuXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFwcGxpY2F0YWJsZSA9IHRydWU7XG5cbiAgICAgICAgenJVdGlsLmVhY2gocXVlcnksIGZ1bmN0aW9uICh2YWx1ZSwgYXR0cikge1xuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBhdHRyLm1hdGNoKFFVRVJZX1JFRyk7XG5cbiAgICAgICAgICAgIGlmICghbWF0Y2hlZCB8fCAhbWF0Y2hlZFsxXSB8fCAhbWF0Y2hlZFsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gbWF0Y2hlZFsxXTtcbiAgICAgICAgICAgIHZhciByZWFsQXR0ciA9IG1hdGNoZWRbMl0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKCFjb21wYXJlKHJlYWxNYXBbcmVhbEF0dHJdLCB2YWx1ZSwgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgYXBwbGljYXRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcHBsaWNhdGFibGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGFyZShyZWFsLCBleHBlY3QsIG9wZXJhdG9yKSB7XG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ21pbicpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFsID49IGV4cGVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRvciA9PT0gJ21heCcpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFsIDw9IGV4cGVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gRXF1YWxzXG4gICAgICAgICAgICByZXR1cm4gcmVhbCA9PT0gZXhwZWN0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5kaWNlc0VxdWFscyhpbmRpY2VzMSwgaW5kaWNlczIpIHtcbiAgICAgICAgLy8gaW5kaWNlcyBpcyBhbHdheXMgb3JkZXIgYnkgYXNjIGFuZCBoYXMgb25seSBmaW5pdGUgbnVtYmVyLlxuICAgICAgICByZXR1cm4gaW5kaWNlczEuam9pbignLCcpID09PSBpbmRpY2VzMi5qb2luKCcsJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc2lkZXIgY2FzZTpcbiAgICAgKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDEpO2BcbiAgICAgKiBUaGVuIHVzZXIgZG8gc29tZSBpbnRlcmFjdGlvbiBsaWtlIGRhdGFab29tLCBkYXRhVmlldyBjaGFuZ2luZy5cbiAgICAgKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDIpO2BcbiAgICAgKiBUaGVuIHVzZXIgcHJlc3MgJ3Jlc2V0IGJ1dHRvbicgaW4gdG9vbGJveC5cbiAgICAgKlxuICAgICAqIEFmdGVyIGRvaW5nIHRoYXQgYWxsIG9mIHRoZSBpbnRlcmFjdGlvbiBlZmZlY3RzIHNob3VsZCBiZSByZXNldCwgdGhlXG4gICAgICogY2hhcnQgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoZSByZXN1bHQgb2YgaW52b2tlXG4gICAgICogYGNoYXJ0LnNldE9wdGlvbihvcHQxKTsgY2hhcnQuc2V0T3B0aW9uKG9wdDIpO2AuXG4gICAgICpcbiAgICAgKiBBbHRob3VnaCBpdCBpcyBub3QgYWJsZSBlbnN1cmUgdGhhdFxuICAgICAqIGBjaGFydC5zZXRPcHRpb24ob3B0MSk7IGNoYXJ0LnNldE9wdGlvbihvcHQyKTtgIGlzIGVxdWl2YWxlbnRzIHRvXG4gICAgICogYGNoYXJ0LnNldE9wdGlvbihtZXJnZShvcHQxLCBvcHQyKSk7YCBleGFjdGx5LFxuICAgICAqIHRoaXMgbWlnaHQgYmUgdGhlIG9ubHkgc2ltcGxlIHdheSB0byBpbXBsZW1lbnQgdGhhdCBmZWF0dXJlLlxuICAgICAqXG4gICAgICogTUVNTzogV2UndmUgY29uc2lkZXJlZCBzb21lIG90aGVyIGFwcHJvYWNoZXM6XG4gICAgICogMS4gRWFjaCBtb2RlbCBoYW5kbGUgaXRzIHNlbGYgcmVzdG9yYXRpb24gYnV0IG5vdCB1bmlmb3JtIHRyZWF0bWVudC5cbiAgICAgKiAgICAgKFRvbyBjb21wbGV4IGluIGxvZ2ljIGFuZCBlcnJvci1wcm9uZSlcbiAgICAgKiAyLiBVc2UgYSBzaGFkb3cgZWNNb2RlbC4gKFBlcmZvcm1hY2UgZXhwZW5zaXZlKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlT3B0aW9uKG9sZE9wdGlvbiwgbmV3T3B0aW9uKSB7XG4gICAgICAgIG5ld09wdGlvbiA9IG5ld09wdGlvbiB8fCB7fTtcblxuICAgICAgICBlYWNoKG5ld09wdGlvbiwgZnVuY3Rpb24gKG5ld0NwdE9wdCwgbWFpblR5cGUpIHtcbiAgICAgICAgICAgIGlmIChuZXdDcHRPcHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9sZENwdE9wdCA9IG9sZE9wdGlvblttYWluVHlwZV07XG5cbiAgICAgICAgICAgIGlmICghQ29tcG9uZW50TW9kZWwuaGFzQ2xhc3MobWFpblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgb2xkT3B0aW9uW21haW5UeXBlXSA9IG1lcmdlKG9sZENwdE9wdCwgbmV3Q3B0T3B0LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0NwdE9wdCA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KG5ld0NwdE9wdCk7XG4gICAgICAgICAgICAgICAgb2xkQ3B0T3B0ID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkob2xkQ3B0T3B0KTtcblxuICAgICAgICAgICAgICAgIHZhciBtYXBSZXN1bHQgPSBtb2RlbFV0aWwubWFwcGluZ1RvRXhpc3RzKG9sZENwdE9wdCwgbmV3Q3B0T3B0KTtcblxuICAgICAgICAgICAgICAgIG9sZE9wdGlvblttYWluVHlwZV0gPSBtYXAobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGl0ZW0ub3B0aW9uICYmIGl0ZW0uZXhpc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG1lcmdlKGl0ZW0uZXhpc3QsIGl0ZW0ub3B0aW9uLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoaXRlbS5leGlzdCB8fCBpdGVtLm9wdGlvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gT3B0aW9uTWFuYWdlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9tb2RlbC9PcHRpb25NYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var zrUtil = __webpack_require__(20);\n    var formatUtil = __webpack_require__(22);\n    var classUtil = __webpack_require__(29);\n    var modelUtil = __webpack_require__(21);\n    var ComponentModel = __webpack_require__(85);\n    var colorPaletteMixin = __webpack_require__(90);\n    var env = __webpack_require__(18);\n    var layout = __webpack_require__(87);\n\n    var set = classUtil.set;\n    var get = classUtil.get;\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            var data = this.getInitialData(option, ecModel);\n            if (__DEV__) {\n                zrUtil.assert(data, 'getInitialData returned invalid data.');\n            }\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            set(this, 'dataBeforeProcessed', data);\n\n            // If we reverse the order (make data firstly, and then make\n            // dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause data.graph.data !== data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this.restoreData();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `position` and `show`\n            // FIXME Set label in mergeOption\n            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\n            this.fillDataTextStyle(option.data);\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n            }\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                set(this, 'data', data);\n                set(this, 'dataBeforeProcessed', data.cloneShallow());\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `position` and `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            var data = get(this, 'data');\n            return dataType == null ? data : data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            set(this, 'data', data);\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return get(this, 'dataBeforeProcessed');\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return modelUtil.coordDimToDataDim(this.getData(), coordDim);\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return modelUtil.dataDimToCoordDim(this.getData(), dataDim);\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var vertially = zrUtil.reduce(value, function (vertially, val, idx) {\n                    var dimItem = data.getDimensionInfo(idx);\n                    return vertially |= dimItem && dimItem.tooltip !== false && dimItem.tooltipName != null;\n                }, 0);\n\n                var result = [];\n                var tooltipDims = modelUtil.otherDimToDataDim(data, 'tooltip');\n\n                tooltipDims.length\n                    ? zrUtil.each(tooltipDims, function (dimIdx) {\n                        setEachItem(data.get(dimIdx, dataIndex), dimIdx);\n                    })\n                    // By default, all dims is used on tooltip.\n                    : zrUtil.each(value, setEachItem);\n\n                function setEachItem(val, dimIdx) {\n                    var dimInfo = data.getDimensionInfo(dimIdx);\n                    // If `dimInfo.tooltip` is not set, show tooltip.\n                    if (!dimInfo || dimInfo.otherDims.tooltip === false) {\n                        return;\n                    }\n                    var dimType = dimInfo.type;\n                    var valStr = (vertially ? '- ' + (dimInfo.tooltipName || dimInfo.name) + ': ' : '')\n                        + (dimType === 'ordinal'\n                            ? val + ''\n                            : dimType === 'time'\n                            ? (multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val))\n                            : addCommas(val)\n                        );\n                    valStr && result.push(encodeHTML(valStr));\n                }\n\n                return (vertially ? '<br/>' : '') + result.join(vertially ? '<br/>' : ', ');\n            }\n\n            var data = get(this, 'data');\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = zrUtil.isArray(value)\n                ? formatArrayValue(value) : encodeHTML(addCommas(value));\n            var name = data.getName(dataIndex);\n\n            var color = data.getItemVisual(dataIndex, 'color');\n            if (zrUtil.isObject(color) && color.colorStops) {\n                color = (color.colorStops[0] || {}).color;\n            }\n            color = color || 'transparent';\n\n            var colorEl = formatUtil.getTooltipMarker(color);\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            seriesName = seriesName\n                ? encodeHTML(seriesName) + (!multipleSeries ? '<br/>' : ': ')\n                : '';\n            return !multipleSeries\n                ? seriesName + colorEl\n                    + (name\n                        ? encodeHTML(name) + ': ' + formattedValue\n                        : formattedValue\n                    )\n                : colorEl + seriesName + formattedValue;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        isAnimationEnabled: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Object} {dataIndices, nestestValue}.\n         */\n        getAxisTooltipData: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL21vZGVsL1Nlcmllcy5qcz8xODZjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLGVBQWU7QUFDbEMsbUJBQW1CLHVDQUF1QztBQUMxRCxvQkFBb0IsT0FBTyxFQUFFLDBCQUEwQjtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEiLCJmaWxlIjoiOTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvZm9ybWF0Jyk7XG4gICAgdmFyIGNsYXNzVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhenonKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50Jyk7XG4gICAgdmFyIGNvbG9yUGFsZXR0ZU1peGluID0gcmVxdWlyZSgnLi9taXhpbi9jb2xvclBhbGV0dGUnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9lbnYnKTtcbiAgICB2YXIgbGF5b3V0ID0gcmVxdWlyZSgnLi4vdXRpbC9sYXlvdXQnKTtcblxuICAgIHZhciBzZXQgPSBjbGFzc1V0aWwuc2V0O1xuICAgIHZhciBnZXQgPSBjbGFzc1V0aWwuZ2V0O1xuICAgIHZhciBlbmNvZGVIVE1MID0gZm9ybWF0VXRpbC5lbmNvZGVIVE1MO1xuICAgIHZhciBhZGRDb21tYXMgPSBmb3JtYXRVdGlsLmFkZENvbW1hcztcblxuICAgIHZhciBTZXJpZXNNb2RlbCA9IENvbXBvbmVudE1vZGVsLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3Nlcmllcy5fX2Jhc2VfXycsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgc2VyaWVzSW5kZXg6IDAsXG5cbiAgICAgICAgLy8gY29vZGluYXRlU3lzdGVtIHdpbGwgYmUgaW5qZWN0ZWQgaW4gdGhlIGVjaGFydHMvQ29vcmRpbmF0ZVN5c3RlbVxuICAgICAgICBjb29yZGluYXRlU3lzdGVtOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0T3B0aW9uOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhIHByb3ZpZGVkIGZvciBsZWdlbmRcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gUEVORElOR1xuICAgICAgICBsZWdlbmREYXRhUHJvdmlkZXI6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjY2VzcyBwYXRoIG9mIGNvbG9yIGZvciB2aXN1YWxcbiAgICAgICAgICovXG4gICAgICAgIHZpc3VhbENvbG9yQWNjZXNzUGF0aDogJ2l0ZW1TdHlsZS5ub3JtYWwuY29sb3InLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdXBwb3J0IG1lcmdlIGxheW91dCBwYXJhbXMuXG4gICAgICAgICAqIE9ubHkgc3VwcG9ydCAnYm94JyBub3cgKGxlZnQvcmlnaHQvdG9wL2JvdHRvbS93aWR0aC9oZWlnaHQpLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfE9iamVjdH0gT2JqZWN0IGNhbiBiZSB7aWdub3JlU2l6ZTogdHJ1ZX1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXRNb2RlOiBudWxsLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zZXJpZXNJbmRleCA9IHRoaXMuY29tcG9uZW50SW5kZXg7XG5cbiAgICAgICAgICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcblxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldEluaXRpYWxEYXRhKG9wdGlvbiwgZWNNb2RlbCk7XG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoZGF0YSwgJ2dldEluaXRpYWxEYXRhIHJldHVybmVkIGludmFsaWQgZGF0YS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdHxtb2R1bGU6ZWNoYXJ0cy9kYXRhL1RyZWV8bW9kdWxlOmVjaGFydHMvZGF0YS9HcmFwaH1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldCh0aGlzLCAnZGF0YUJlZm9yZVByb2Nlc3NlZCcsIGRhdGEpO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSByZXZlcnNlIHRoZSBvcmRlciAobWFrZSBkYXRhIGZpcnN0bHksIGFuZCB0aGVuIG1ha2VcbiAgICAgICAgICAgIC8vIGRhdGFCZWZvcmVQcm9jZXNzZWQgYnkgY2xvbmVTaGFsbG93KSwgY2xvbmVTaGFsbG93IHdpbGxcbiAgICAgICAgICAgIC8vIGNhdXNlIGRhdGEuZ3JhcGguZGF0YSAhPT0gZGF0YSB3aGVuIHVzaW5nXG4gICAgICAgICAgICAvLyBtb2R1bGU6ZWNoYXJ0cy9kYXRhL0dyYXBoIG9yIG1vZHVsZTplY2hhcnRzL2RhdGEvVHJlZS5cbiAgICAgICAgICAgIC8vIFNlZSBtb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9saW5rTGlzdFxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlRGF0YSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVdGlsIGZvciBtZXJnZSBkZWZhdWx0IGFuZCB0aGVtZSB0byBvcHRpb25cbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25cbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqL1xuICAgICAgICBtZXJnZURlZmF1bHRBbmRUaGVtZTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGxheW91dE1vZGUgPSB0aGlzLmxheW91dE1vZGU7XG4gICAgICAgICAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGxheW91dE1vZGVcbiAgICAgICAgICAgICAgICA/IGxheW91dC5nZXRMYXlvdXRQYXJhbXMob3B0aW9uKSA6IHt9O1xuXG4gICAgICAgICAgICB6clV0aWwubWVyZ2UoXG4gICAgICAgICAgICAgICAgb3B0aW9uLFxuICAgICAgICAgICAgICAgIGVjTW9kZWwuZ2V0VGhlbWUoKS5nZXQodGhpcy5zdWJUeXBlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCBsYWJlbCBlbXBoYXNpcyBgcG9zaXRpb25gIGFuZCBgc2hvd2BcbiAgICAgICAgICAgIC8vIEZJWE1FIFNldCBsYWJlbCBpbiBtZXJnZU9wdGlvblxuICAgICAgICAgICAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyhvcHRpb24ubGFiZWwsIG1vZGVsVXRpbC5MQUJFTF9PUFRJT05TKTtcblxuICAgICAgICAgICAgdGhpcy5maWxsRGF0YVRleHRTdHlsZShvcHRpb24uZGF0YSk7XG5cbiAgICAgICAgICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0Lm1lcmdlTGF5b3V0UGFyYW0ob3B0aW9uLCBpbnB1dFBvc2l0aW9uUGFyYW1zLCBsYXlvdXRNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG5ld1Nlcmllc09wdGlvbiwgZWNNb2RlbCkge1xuICAgICAgICAgICAgbmV3U2VyaWVzT3B0aW9uID0genJVdGlsLm1lcmdlKHRoaXMub3B0aW9uLCBuZXdTZXJpZXNPcHRpb24sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5maWxsRGF0YVRleHRTdHlsZShuZXdTZXJpZXNPcHRpb24uZGF0YSk7XG5cbiAgICAgICAgICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgICAgICAgICAgaWYgKGxheW91dE1vZGUpIHtcbiAgICAgICAgICAgICAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbSh0aGlzLm9wdGlvbiwgbmV3U2VyaWVzT3B0aW9uLCBsYXlvdXRNb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldEluaXRpYWxEYXRhKG5ld1Nlcmllc09wdGlvbiwgZWNNb2RlbCk7XG4gICAgICAgICAgICAvLyBUT0RPIE1lcmdlIGRhdGE/XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHNldCh0aGlzLCAnZGF0YScsIGRhdGEpO1xuICAgICAgICAgICAgICAgIHNldCh0aGlzLCAnZGF0YUJlZm9yZVByb2Nlc3NlZCcsIGRhdGEuY2xvbmVTaGFsbG93KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZpbGxEYXRhVGV4dFN0eWxlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBkYXRhIGxhYmVsIGVtcGhhc2lzIGBwb3NpdGlvbmAgYW5kIGBzaG93YFxuICAgICAgICAgICAgLy8gRklYTUUgVHJlZSBzdHJ1Y3R1cmUgZGF0YSA/XG4gICAgICAgICAgICAvLyBGSVhNRSBQZXJmb3JtYW5jZSA/XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSAmJiBkYXRhW2ldLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFV0aWwuZGVmYXVsdEVtcGhhc2lzKGRhdGFbaV0ubGFiZWwsIG1vZGVsVXRpbC5MQUJFTF9PUFRJT05TKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdCBhIGRhdGEgc3RydWN0dXJlIGZyb20gZGF0YSByZWxhdGVkIG9wdGlvbiBpbiBzZXJpZXNcbiAgICAgICAgICogTXVzdCBiZSBvdmVyd3JpdHRlblxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SW5pdGlhbERhdGE6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGFUeXBlXVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXREYXRhOiBmdW5jdGlvbiAoZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZ2V0KHRoaXMsICdkYXRhJyk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVR5cGUgPT0gbnVsbCA/IGRhdGEgOiBkYXRhLmdldExpbmtlZERhdGEoZGF0YVR5cGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHNldCh0aGlzLCAnZGF0YScsIGRhdGEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZGF0YSBiZWZvcmUgcHJvY2Vzc2VkXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFJhd0RhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgJ2RhdGFCZWZvcmVQcm9jZXNzZWQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29vcmQgZGltZW5zaW9uIHRvIGRhdGEgZGltZW5zaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0IHRoZSByZXN1bHQgaXMgdGhlIHNhbWUgYXMgZGltZW5zaW9ucyBvZiBzZXJpZXMgZGF0YS5cbiAgICAgICAgICogQnV0IGluIHNvbWUgc2VyaWVzIGRhdGEgZGltZW5zaW9ucyBhcmUgZGlmZmVyZW50IGZyb20gY29vcmQgZGltZW5zaW9ucyAoaS5lLlxuICAgICAgICAgKiBjYW5kbGVzdGljayBhbmQgYm94cGxvdCkuIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGhhbmRsZSB0aG9zZSBjYXNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQ29vcmQgZGltZW5zaW9uIHRvIGRhdGEgZGltZW5zaW9uIGNhbiBiZSBvbmUtdG8tbWFueVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29vcmREaW1cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IGRpbWVuc2lvbnMgb24gdGhlIGF4aXMuXG4gICAgICAgICAqL1xuICAgICAgICBjb29yZERpbVRvRGF0YURpbTogZnVuY3Rpb24gKGNvb3JkRGltKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWxVdGlsLmNvb3JkRGltVG9EYXRhRGltKHRoaXMuZ2V0RGF0YSgpLCBjb29yZERpbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgZGF0YSBkaW1lbnNpb24gdG8gY29vcmQgZGltZW5zaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRhdGFEaW1cbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YURpbVRvQ29vcmREaW06IGZ1bmN0aW9uIChkYXRhRGltKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWxVdGlsLmRhdGFEaW1Ub0Nvb3JkRGltKHRoaXMuZ2V0RGF0YSgpLCBkYXRhRGltKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGJhc2UgYXhpcyBpZiBoYXMgY29vcmRpbmF0ZSBzeXN0ZW0gYW5kIGhhcyBheGlzLlxuICAgICAgICAgKiBCeSBkZWZhdWx0IHVzZSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgICAgKiBDYW4gYmUgb3ZlcnJpZGVkIGZvciBzb21lIGNoYXJ0LlxuICAgICAgICAgKiBAcmV0dXJuIHt0eXBlfSBkZXNjcmlwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QmFzZUF4aXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIHJldHVybiBjb29yZFN5cyAmJiBjb29yZFN5cy5nZXRCYXNlQXhpcyAmJiBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IHRvb2x0aXAgZm9ybWF0dGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbbXVsdGlwbGVTZXJpZXM9ZmFsc2VdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YVR5cGVdXG4gICAgICAgICAqL1xuICAgICAgICBmb3JtYXRUb29sdGlwOiBmdW5jdGlvbiAoZGF0YUluZGV4LCBtdWx0aXBsZVNlcmllcywgZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdEFycmF5VmFsdWUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmVydGlhbGx5ID0genJVdGlsLnJlZHVjZSh2YWx1ZSwgZnVuY3Rpb24gKHZlcnRpYWxseSwgdmFsLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpbUl0ZW0gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlcnRpYWxseSB8PSBkaW1JdGVtICYmIGRpbUl0ZW0udG9vbHRpcCAhPT0gZmFsc2UgJiYgZGltSXRlbS50b29sdGlwTmFtZSAhPSBudWxsO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciB0b29sdGlwRGltcyA9IG1vZGVsVXRpbC5vdGhlckRpbVRvRGF0YURpbShkYXRhLCAndG9vbHRpcCcpO1xuXG4gICAgICAgICAgICAgICAgdG9vbHRpcERpbXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8genJVdGlsLmVhY2godG9vbHRpcERpbXMsIGZ1bmN0aW9uIChkaW1JZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVhY2hJdGVtKGRhdGEuZ2V0KGRpbUlkeCwgZGF0YUluZGV4KSwgZGltSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgYWxsIGRpbXMgaXMgdXNlZCBvbiB0b29sdGlwLlxuICAgICAgICAgICAgICAgICAgICA6IHpyVXRpbC5lYWNoKHZhbHVlLCBzZXRFYWNoSXRlbSk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRFYWNoSXRlbSh2YWwsIGRpbUlkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGltSW5mbyA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1JZHgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBgZGltSW5mby50b29sdGlwYCBpcyBub3Qgc2V0LCBzaG93IHRvb2x0aXAuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGltSW5mbyB8fCBkaW1JbmZvLm90aGVyRGltcy50b29sdGlwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaW1UeXBlID0gZGltSW5mby50eXBlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsU3RyID0gKHZlcnRpYWxseSA/ICctICcgKyAoZGltSW5mby50b29sdGlwTmFtZSB8fCBkaW1JbmZvLm5hbWUpICsgJzogJyA6ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoZGltVHlwZSA9PT0gJ29yZGluYWwnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWwgKyAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGltVHlwZSA9PT0gJ3RpbWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAobXVsdGlwbGVTZXJpZXMgPyAnJyA6IGZvcm1hdFV0aWwuZm9ybWF0VGltZSgneXl5eS9NTS9kZCBoaDptbTpzcycsIHZhbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhZGRDb21tYXModmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsU3RyICYmIHJlc3VsdC5wdXNoKGVuY29kZUhUTUwodmFsU3RyKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICh2ZXJ0aWFsbHkgPyAnPGJyLz4nIDogJycpICsgcmVzdWx0LmpvaW4odmVydGlhbGx5ID8gJzxici8+JyA6ICcsICcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGdldCh0aGlzLCAnZGF0YScpO1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFJhd1ZhbHVlKGRhdGFJbmRleCk7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSB6clV0aWwuaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgICAgICA/IGZvcm1hdEFycmF5VmFsdWUodmFsdWUpIDogZW5jb2RlSFRNTChhZGRDb21tYXModmFsdWUpKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCk7XG5cbiAgICAgICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdjb2xvcicpO1xuICAgICAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChjb2xvcikgJiYgY29sb3IuY29sb3JTdG9wcykge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gKGNvbG9yLmNvbG9yU3RvcHNbMF0gfHwge30pLmNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sb3IgPSBjb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuXG4gICAgICAgICAgICB2YXIgY29sb3JFbCA9IGZvcm1hdFV0aWwuZ2V0VG9vbHRpcE1hcmtlcihjb2xvcik7XG5cbiAgICAgICAgICAgIHZhciBzZXJpZXNOYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIGlmIChzZXJpZXNOYW1lID09PSAnXFwwLScpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3Qgc2hvdyAnLSdcbiAgICAgICAgICAgICAgICBzZXJpZXNOYW1lID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXJpZXNOYW1lID0gc2VyaWVzTmFtZVxuICAgICAgICAgICAgICAgID8gZW5jb2RlSFRNTChzZXJpZXNOYW1lKSArICghbXVsdGlwbGVTZXJpZXMgPyAnPGJyLz4nIDogJzogJylcbiAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuICFtdWx0aXBsZVNlcmllc1xuICAgICAgICAgICAgICAgID8gc2VyaWVzTmFtZSArIGNvbG9yRWxcbiAgICAgICAgICAgICAgICAgICAgKyAobmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBlbmNvZGVIVE1MKG5hbWUpICsgJzogJyArIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGNvbG9yRWwgKyBzZXJpZXNOYW1lICsgZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc0FuaW1hdGlvbkVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChlbnYubm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkVuYWJsZWQgPSB0aGlzLmdldFNoYWxsb3coJ2FuaW1hdGlvbicpO1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXREYXRhKCkuY291bnQoKSA+IHRoaXMuZ2V0U2hhbGxvdygnYW5pbWF0aW9uVGhyZXNob2xkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25FbmFibGVkO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXQodGhpcywgJ2RhdGEnLCBnZXQodGhpcywgJ2RhdGFCZWZvcmVQcm9jZXNzZWQnKS5jbG9uZVNoYWxsb3coKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q29sb3JGcm9tUGFsZXR0ZTogZnVuY3Rpb24gKG5hbWUsIHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgIHZhciBjb2xvciA9IGNvbG9yUGFsZXR0ZU1peGluLmdldENvbG9yRnJvbVBhbGV0dGUuY2FsbCh0aGlzLCBuYW1lLCBzY29wZSk7XG4gICAgICAgICAgICBpZiAoIWNvbG9yKSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBlY01vZGVsLmdldENvbG9yRnJvbVBhbGV0dGUobmFtZSwgc2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZGF0YSBpbmRpY2VzIGZvciBzaG93IHRvb2x0aXAgY29udGVudC4gU2VlIHRvb2x0aXAuXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fHN0cmluZ30gZGltXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvc2luZ2xlL1NpbmdsZUF4aXN9IGJhc2VBeGlzXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0ge2RhdGFJbmRpY2VzLCBuZXN0ZXN0VmFsdWV9LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXhpc1Rvb2x0aXBEYXRhOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgdG9vbHRpcC5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFBvaW50IG9mIHRvb2x0aXAuIG51bGwvdW5kZWZpbmVkIGNhbiBiZSByZXR1cm5lZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldFRvb2x0aXBQb3NpdGlvbjogbnVsbFxuICAgIH0pO1xuXG4gICAgenJVdGlsLm1peGluKFNlcmllc01vZGVsLCBtb2RlbFV0aWwuZGF0YUZvcm1hdE1peGluKTtcbiAgICB6clV0aWwubWl4aW4oU2VyaWVzTW9kZWwsIGNvbG9yUGFsZXR0ZU1peGluKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gU2VyaWVzTW9kZWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvbW9kZWwvU2VyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n\n    var Group = __webpack_require__(64);\n    var componentUtil = __webpack_require__(86);\n    var clazzUtil = __webpack_require__(29);\n\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n\n    Component.prototype = {\n\n        constructor: Component,\n\n        init: function (ecModel, api) {},\n\n        render: function (componentModel, ecModel, api, payload) {},\n\n        dispose: function () {}\n\n    };\n\n    var componentProto = Component.prototype;\n    componentProto.updateView\n        = componentProto.updateLayout\n        = componentProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            // Do nothing;\n        };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\n    module.exports = Component;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3ZpZXcvQ29tcG9uZW50LmpzPzQxNWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDOztBQUV4QyxtRUFBbUU7O0FBRW5FOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCx5QkFBeUI7O0FBRXpFIiwiZmlsZSI6Ijk1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAnKTtcbiAgICB2YXIgY29tcG9uZW50VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvY29tcG9uZW50Jyk7XG4gICAgdmFyIGNsYXp6VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhenonKTtcblxuICAgIHZhciBDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JvdXAgPSBuZXcgR3JvdXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVpZCA9IGNvbXBvbmVudFV0aWwuZ2V0VUlEKCd2aWV3Q29tcG9uZW50Jyk7XG4gICAgfTtcblxuICAgIENvbXBvbmVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IENvbXBvbmVudCxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7fSxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChjb21wb25lbnRNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7fSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fVxuXG4gICAgfTtcblxuICAgIHZhciBjb21wb25lbnRQcm90byA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gICAgY29tcG9uZW50UHJvdG8udXBkYXRlVmlld1xuICAgICAgICA9IGNvbXBvbmVudFByb3RvLnVwZGF0ZUxheW91dFxuICAgICAgICA9IGNvbXBvbmVudFByb3RvLnVwZGF0ZVZpc3VhbFxuICAgICAgICA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nO1xuICAgICAgICB9O1xuICAgIC8vIEVuYWJsZSBDb21wb25lbnQuZXh0ZW5kLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChDb21wb25lbnQpO1xuXG4gICAgLy8gRW5hYmxlIGNhcGFiaWxpdHkgb2YgcmVnaXN0ZXJDbGFzcywgZ2V0Q2xhc3MsIGhhc0NsYXNzLCByZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIgYW5kIHNvIG9uLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoQ29tcG9uZW50LCB7cmVnaXN0ZXJXaGVuRXh0ZW5kOiB0cnVlfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi92aWV3L0NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("\n\n    var Group = __webpack_require__(64);\n    var componentUtil = __webpack_require__(86);\n    var clazzUtil = __webpack_require__(29);\n    var modelUtil = __webpack_require__(21);\n    var zrUtil = __webpack_require__(20);\n\n    function Chart() {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n\n    Chart.prototype = {\n\n        type: 'chart',\n\n        /**\n         * Init the chart\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        init: function (ecModel, api) {},\n\n        /**\n         * Render the chart\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        render: function (seriesModel, ecModel, api, payload) {},\n\n        /**\n         * Highlight series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n\n        /**\n         * Downplay series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n\n        /**\n         * Remove self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n\n        /**\n         * Dispose self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        dispose: function () {}\n\n        /**\n         * The view contains the given point.\n         * @interface\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        // containPoint: function () {}\n\n    };\n\n    var chartProto = Chart.prototype;\n    chartProto.updateView\n        = chartProto.updateLayout\n        = chartProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            this.render(seriesModel, ecModel, api, payload);\n        };\n\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n        if (dataIndex != null) {\n            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n                elSetState(data.getItemGraphicEl(dataIdx), state);\n            });\n        }\n        else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\n    module.exports = Chart;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3ZpZXcvQ2hhcnQuanM/NzJmMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hELG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hELG9CQUFvQiw0QkFBNEI7QUFDaEQsb0JBQW9CLDRCQUE0QjtBQUNoRCxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQsb0JBQW9CLDRCQUE0QjtBQUNoRCxvQkFBb0IsNEJBQTRCO0FBQ2hELG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQsb0JBQW9CLDRCQUE0QjtBQUNoRCxvQkFBb0IsNEJBQTRCO0FBQ2hELG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hELG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMseUJBQXlCOztBQUVyRSIsImZpbGUiOiI5Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIEdyb3VwID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwJyk7XG4gICAgdmFyIGNvbXBvbmVudFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2NvbXBvbmVudCcpO1xuICAgIHZhciBjbGF6elV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2NsYXp6Jyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICBmdW5jdGlvbiBDaGFydCgpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyb3VwID0gbmV3IEdyb3VwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgndmlld0NoYXJ0Jyk7XG4gICAgfVxuXG4gICAgQ2hhcnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIHR5cGU6ICdjaGFydCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXQgdGhlIGNoYXJ0XG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlciB0aGUgY2hhcnRcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGlnaGxpZ2h0IHNlcmllcyBvciBzcGVjaWZpZWQgZGF0YSBpdGVtXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgdG9nZ2xlSGlnaGxpZ2h0KHNlcmllc01vZGVsLmdldERhdGEoKSwgcGF5bG9hZCwgJ2VtcGhhc2lzJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERvd25wbGF5IHNlcmllcyBvciBzcGVjaWZpZWQgZGF0YSBpdGVtXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgZG93bnBsYXk6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB0b2dnbGVIaWdobGlnaHQoc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLCBwYXlsb2FkLCAnbm9ybWFsJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBzZWxmXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwb3NlIHNlbGZcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmlldyBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAgICAgICAqIEBpbnRlcmZhY2VcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcG9pbnRcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIC8vIGNvbnRhaW5Qb2ludDogZnVuY3Rpb24gKCkge31cblxuICAgIH07XG5cbiAgICB2YXIgY2hhcnRQcm90byA9IENoYXJ0LnByb3RvdHlwZTtcbiAgICBjaGFydFByb3RvLnVwZGF0ZVZpZXdcbiAgICAgICAgPSBjaGFydFByb3RvLnVwZGF0ZUxheW91dFxuICAgICAgICA9IGNoYXJ0UHJvdG8udXBkYXRlVmlzdWFsXG4gICAgICAgID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHN0YXRlIG9mIHNpbmdsZSBlbGVtZW50XG4gICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZWxTZXRTdGF0ZShlbCwgc3RhdGUpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBlbC50cmlnZ2VyKHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChlbC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbC5jaGlsZENvdW50KCk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBlbFNldFN0YXRlKGVsLmNoaWxkQXQoaSksIHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBzdGF0ZSAnbm9ybWFsJ3wnZW1waGFzaXMnXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9nZ2xlSGlnaGxpZ2h0KGRhdGEsIHBheWxvYWQsIHN0YXRlKSB7XG4gICAgICAgIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgcGF5bG9hZCk7XG5cbiAgICAgICAgaWYgKGRhdGFJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShkYXRhSW5kZXgpLCBmdW5jdGlvbiAoZGF0YUlkeCkge1xuICAgICAgICAgICAgICAgIGVsU2V0U3RhdGUoZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJZHgpLCBzdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgZWxTZXRTdGF0ZShlbCwgc3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbmFibGUgQ2hhcnQuZXh0ZW5kLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChDaGFydCwgWydkaXNwb3NlJ10pO1xuXG4gICAgLy8gQWRkIGNhcGFiaWxpdHkgb2YgcmVnaXN0ZXJDbGFzcywgZ2V0Q2xhc3MsIGhhc0NsYXNzLCByZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIgYW5kIHNvIG9uLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoQ2hhcnQsIHtyZWdpc3RlcldoZW5FeHRlbmQ6IHRydWV9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2hhcnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvdmlldy9DaGFydC5qc1xuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("\n\n    var lib = {};\n\n    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n    var RATE = '\\0__throttleRate';\n    var THROTTLE_TYPE = '\\0__throttleType';\n\n    /**\n     * @public\n     * @param {(Function)} fn\n     * @param {number} [delay=0] Unit: ms.\n     * @param {boolean} [debounce=false]\n     *        true: If call interval less than `delay`, only the last call works.\n     *        false: If call interval less than `delay, call works on fixed rate.\n     * @return {(Function)} throttled fn.\n     */\n    lib.throttle = function (fn, delay, debounce) {\n\n        var currCall;\n        var lastCall = 0;\n        var lastExec = 0;\n        var timer = null;\n        var diff;\n        var scope;\n        var args;\n        var debounceNextCall;\n\n        delay = delay || 0;\n\n        function exec() {\n            lastExec = (new Date()).getTime();\n            timer = null;\n            fn.apply(scope, args || []);\n        }\n\n        var cb = function () {\n            currCall = (new Date()).getTime();\n            scope = this;\n            args = arguments;\n            var thisDelay = debounceNextCall || delay;\n            var thisDebounce = debounceNextCall || debounce;\n            debounceNextCall = null;\n            diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;\n\n            clearTimeout(timer);\n\n            if (thisDebounce) {\n                timer = setTimeout(exec, thisDelay);\n            }\n            else {\n                if (diff >= 0) {\n                    exec();\n                }\n                else {\n                    timer = setTimeout(exec, -diff);\n                }\n            }\n\n            lastCall = currCall;\n        };\n\n        /**\n         * Clear throttle.\n         * @public\n         */\n        cb.clear = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n\n        /**\n         * Enable debounce once.\n         */\n        cb.debounceNextCall = function (debounceDelay) {\n            debounceNextCall = debounceDelay;\n        };\n\n        return cb;\n    };\n\n    /**\n     * Create throttle method or update throttle rate.\n     *\n     * @example\n     * ComponentView.prototype.render = function () {\n     *     ...\n     *     throttle.createOrUpdate(\n     *         this,\n     *         '_dispatchAction',\n     *         this.model.get('throttle'),\n     *         'fixRate'\n     *     );\n     * };\n     * ComponentView.prototype.remove = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     * ComponentView.prototype.dispose = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     * @param {number} [rate]\n     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n     * @return {Function} throttled function.\n     */\n    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n        var fn = obj[fnAttr];\n\n        if (!fn) {\n            return;\n        }\n\n        var originFn = fn[ORIGIN_METHOD] || fn;\n        var lastThrottleType = fn[THROTTLE_TYPE];\n        var lastRate = fn[RATE];\n\n        if (lastRate !== rate || lastThrottleType !== throttleType) {\n            if (rate == null || !throttleType) {\n                return (obj[fnAttr] = originFn);\n            }\n\n            fn = obj[fnAttr] = lib.throttle(\n                originFn, rate, throttleType === 'debounce'\n            );\n            fn[ORIGIN_METHOD] = originFn;\n            fn[THROTTLE_TYPE] = throttleType;\n            fn[RATE] = rate;\n        }\n\n        return fn;\n    };\n\n    /**\n     * Clear throttle. Example see throttle.createOrUpdate.\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     */\n    lib.clear = function (obj, fnAttr) {\n        var fn = obj[fnAttr];\n        if (fn && fn[ORIGIN_METHOD]) {\n            obj[fnAttr] = fn[ORIGIN_METHOD];\n        }\n    };\n\n    module.exports = lib;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3V0aWwvdGhyb3R0bGUuanM/NTZiMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI5Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGxpYiA9IHt9O1xuXG4gICAgdmFyIE9SSUdJTl9NRVRIT0QgPSAnXFwwX190aHJvdHRsZU9yaWdpbk1ldGhvZCc7XG4gICAgdmFyIFJBVEUgPSAnXFwwX190aHJvdHRsZVJhdGUnO1xuICAgIHZhciBUSFJPVFRMRV9UWVBFID0gJ1xcMF9fdGhyb3R0bGVUeXBlJztcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0geyhGdW5jdGlvbil9IGZuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXSBVbml0OiBtcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWJvdW5jZT1mYWxzZV1cbiAgICAgKiAgICAgICAgdHJ1ZTogSWYgY2FsbCBpbnRlcnZhbCBsZXNzIHRoYW4gYGRlbGF5YCwgb25seSB0aGUgbGFzdCBjYWxsIHdvcmtzLlxuICAgICAqICAgICAgICBmYWxzZTogSWYgY2FsbCBpbnRlcnZhbCBsZXNzIHRoYW4gYGRlbGF5LCBjYWxsIHdvcmtzIG9uIGZpeGVkIHJhdGUuXG4gICAgICogQHJldHVybiB7KEZ1bmN0aW9uKX0gdGhyb3R0bGVkIGZuLlxuICAgICAqL1xuICAgIGxpYi50aHJvdHRsZSA9IGZ1bmN0aW9uIChmbiwgZGVsYXksIGRlYm91bmNlKSB7XG5cbiAgICAgICAgdmFyIGN1cnJDYWxsO1xuICAgICAgICB2YXIgbGFzdENhbGwgPSAwO1xuICAgICAgICB2YXIgbGFzdEV4ZWMgPSAwO1xuICAgICAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgICAgICB2YXIgZGlmZjtcbiAgICAgICAgdmFyIHNjb3BlO1xuICAgICAgICB2YXIgYXJncztcbiAgICAgICAgdmFyIGRlYm91bmNlTmV4dENhbGw7XG5cbiAgICAgICAgZGVsYXkgPSBkZWxheSB8fCAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgICBsYXN0RXhlYyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICBmbi5hcHBseShzY29wZSwgYXJncyB8fCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjdXJyQ2FsbCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBzY29wZSA9IHRoaXM7XG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdmFyIHRoaXNEZWxheSA9IGRlYm91bmNlTmV4dENhbGwgfHwgZGVsYXk7XG4gICAgICAgICAgICB2YXIgdGhpc0RlYm91bmNlID0gZGVib3VuY2VOZXh0Q2FsbCB8fCBkZWJvdW5jZTtcbiAgICAgICAgICAgIGRlYm91bmNlTmV4dENhbGwgPSBudWxsO1xuICAgICAgICAgICAgZGlmZiA9IGN1cnJDYWxsIC0gKHRoaXNEZWJvdW5jZSA/IGxhc3RDYWxsIDogbGFzdEV4ZWMpIC0gdGhpc0RlbGF5O1xuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgICAgICBpZiAodGhpc0RlYm91bmNlKSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWMsIHRoaXNEZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChleGVjLCAtZGlmZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0Q2FsbCA9IGN1cnJDYWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhciB0aHJvdHRsZS5cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgY2IuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlIGRlYm91bmNlIG9uY2UuXG4gICAgICAgICAqL1xuICAgICAgICBjYi5kZWJvdW5jZU5leHRDYWxsID0gZnVuY3Rpb24gKGRlYm91bmNlRGVsYXkpIHtcbiAgICAgICAgICAgIGRlYm91bmNlTmV4dENhbGwgPSBkZWJvdW5jZURlbGF5O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBjYjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRocm90dGxlIG1ldGhvZCBvciB1cGRhdGUgdGhyb3R0bGUgcmF0ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogQ29tcG9uZW50Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgICAuLi5cbiAgICAgKiAgICAgdGhyb3R0bGUuY3JlYXRlT3JVcGRhdGUoXG4gICAgICogICAgICAgICB0aGlzLFxuICAgICAqICAgICAgICAgJ19kaXNwYXRjaEFjdGlvbicsXG4gICAgICogICAgICAgICB0aGlzLm1vZGVsLmdldCgndGhyb3R0bGUnKSxcbiAgICAgKiAgICAgICAgICdmaXhSYXRlJ1xuICAgICAqICAgICApO1xuICAgICAqIH07XG4gICAgICogQ29tcG9uZW50Vmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgICB0aHJvdHRsZS5jbGVhcih0aGlzLCAnX2Rpc3BhdGNoQWN0aW9uJyk7XG4gICAgICogfTtcbiAgICAgKiBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgICB0aHJvdHRsZS5jbGVhcih0aGlzLCAnX2Rpc3BhdGNoQWN0aW9uJyk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZuQXR0clxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmF0ZV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3Rocm90dGxlVHlwZT0nZml4UmF0ZSddICdmaXhSYXRlJyBvciAnZGVib3VuY2UnXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBsaWIuY3JlYXRlT3JVcGRhdGUgPSBmdW5jdGlvbiAob2JqLCBmbkF0dHIsIHJhdGUsIHRocm90dGxlVHlwZSkge1xuICAgICAgICB2YXIgZm4gPSBvYmpbZm5BdHRyXTtcblxuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3JpZ2luRm4gPSBmbltPUklHSU5fTUVUSE9EXSB8fCBmbjtcbiAgICAgICAgdmFyIGxhc3RUaHJvdHRsZVR5cGUgPSBmbltUSFJPVFRMRV9UWVBFXTtcbiAgICAgICAgdmFyIGxhc3RSYXRlID0gZm5bUkFURV07XG5cbiAgICAgICAgaWYgKGxhc3RSYXRlICE9PSByYXRlIHx8IGxhc3RUaHJvdHRsZVR5cGUgIT09IHRocm90dGxlVHlwZSkge1xuICAgICAgICAgICAgaWYgKHJhdGUgPT0gbnVsbCB8fCAhdGhyb3R0bGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChvYmpbZm5BdHRyXSA9IG9yaWdpbkZuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm4gPSBvYmpbZm5BdHRyXSA9IGxpYi50aHJvdHRsZShcbiAgICAgICAgICAgICAgICBvcmlnaW5GbiwgcmF0ZSwgdGhyb3R0bGVUeXBlID09PSAnZGVib3VuY2UnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZm5bT1JJR0lOX01FVEhPRF0gPSBvcmlnaW5GbjtcbiAgICAgICAgICAgIGZuW1RIUk9UVExFX1RZUEVdID0gdGhyb3R0bGVUeXBlO1xuICAgICAgICAgICAgZm5bUkFURV0gPSByYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aHJvdHRsZS4gRXhhbXBsZSBzZWUgdGhyb3R0bGUuY3JlYXRlT3JVcGRhdGUuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmbkF0dHJcbiAgICAgKi9cbiAgICBsaWIuY2xlYXIgPSBmdW5jdGlvbiAob2JqLCBmbkF0dHIpIHtcbiAgICAgICAgdmFyIGZuID0gb2JqW2ZuQXR0cl07XG4gICAgICAgIGlmIChmbiAmJiBmbltPUklHSU5fTUVUSE9EXSkge1xuICAgICAgICAgICAgb2JqW2ZuQXR0cl0gPSBmbltPUklHSU5fTUVUSE9EXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGxpYjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3V0aWwvdGhyb3R0bGUuanNcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = __webpack_require__(40);\n    var env = __webpack_require__(18);\n    var zrUtil = __webpack_require__(20);\n\n    var Handler = __webpack_require__(99);\n    var Storage = __webpack_require__(101);\n    var Animation = __webpack_require__(103);\n    var HandlerProxy = __webpack_require__(106);\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: __webpack_require__(108)\n    };\n\n    var instances = {};    // ZRender实例map索引\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.5.2';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        // TODO WebGL\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        // 修改 storage.delFromStorage, 每次删除元素之前删除动画\n        // FIXME 有点ugly\n        var oldDelFromStorage = storage.delFromStorage;\n        var oldAddToStorage = storage.addToStorage;\n\n        storage.delFromStorage = function (el) {\n            oldDelFromStorage.call(storage, el);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToStorage = function (el) {\n            oldAddToStorage.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * 获取实例唯一标识\n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * 添加元素\n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * 删除元素\n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, dpr) {\n            return this.painter.pathToImage(e, dpr);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default'] 例如 crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Find hovered element\n         * @param {number} x\n         * @param {number} y\n         * @return {Object} {target, topTarget}\n         */\n        findHover: function (x, y) {\n            return this.handler.findHover(x, y);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3pyZW5kZXIuanM/NWRjZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQyxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixjQUFjO0FBQ2pDLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CLE9BQU8sRUFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI5OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogWlJlbmRlciwgYSBoaWdoIHBlcmZvcm1hbmNlIDJkIGRyYXdpbmcgbGlicmFyeS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJhaWR1IEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4gKi9cbi8vIEdsb2JhbCBkZWZpbmVzXG5cbiAgICB2YXIgZ3VpZCA9IHJlcXVpcmUoJy4vY29yZS9ndWlkJyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJy4vY29yZS9lbnYnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBIYW5kbGVyID0gcmVxdWlyZSgnLi9IYW5kbGVyJyk7XG4gICAgdmFyIFN0b3JhZ2UgPSByZXF1aXJlKCcuL1N0b3JhZ2UnKTtcbiAgICB2YXIgQW5pbWF0aW9uID0gcmVxdWlyZSgnLi9hbmltYXRpb24vQW5pbWF0aW9uJyk7XG4gICAgdmFyIEhhbmRsZXJQcm94eSA9IHJlcXVpcmUoJy4vZG9tL0hhbmRsZXJQcm94eScpO1xuXG4gICAgdmFyIHVzZVZNTCA9ICFlbnYuY2FudmFzU3VwcG9ydGVkO1xuXG4gICAgdmFyIHBhaW50ZXJDdG9ycyA9IHtcbiAgICAgICAgY2FudmFzOiByZXF1aXJlKCcuL1BhaW50ZXInKVxuICAgIH07XG5cbiAgICB2YXIgaW5zdGFuY2VzID0ge307ICAgIC8vIFpSZW5kZXLlrp7kvottYXDntKLlvJVcblxuICAgIHZhciB6cmVuZGVyID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHpyZW5kZXIudmVyc2lvbiA9ICczLjUuMic7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXppbmcgYSB6cmVuZGVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAgICovXG4gICAgenJlbmRlci5pbml0ID0gZnVuY3Rpb24oZG9tLCBvcHRzKSB7XG4gICAgICAgIHZhciB6ciA9IG5ldyBaUmVuZGVyKGd1aWQoKSwgZG9tLCBvcHRzKTtcbiAgICAgICAgaW5zdGFuY2VzW3pyLmlkXSA9IHpyO1xuICAgICAgICByZXR1cm4genI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgenJlbmRlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICAgKi9cbiAgICB6cmVuZGVyLmRpc3Bvc2UgPSBmdW5jdGlvbiAoenIpIHtcbiAgICAgICAgaWYgKHpyKSB7XG4gICAgICAgICAgICB6ci5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlc1trZXldLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB6cmVuZGVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgenJlbmRlciBpbnN0YW5jZSBieSBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCB6cmVuZGVyIGluc3RhbmNlIGlkXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAgICAgKi9cbiAgICB6cmVuZGVyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZXNbaWRdO1xuICAgIH07XG5cbiAgICB6cmVuZGVyLnJlZ2lzdGVyUGFpbnRlciA9IGZ1bmN0aW9uIChuYW1lLCBDdG9yKSB7XG4gICAgICAgIHBhaW50ZXJDdG9yc1tuYW1lXSA9IEN0b3I7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRlbEluc3RhbmNlKGlkKSB7XG4gICAgICAgIGRlbGV0ZSBpbnN0YW5jZXNbaWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgenJlbmRlci9aUmVuZGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL1pSZW5kZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge0hUTUxEb21FbGVtZW50fSBkb21cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2ZydcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpb11cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMud2lkdGhdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAqL1xuICAgIHZhciBaUmVuZGVyID0gZnVuY3Rpb24oaWQsIGRvbSwgb3B0cykge1xuXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SFRNTERvbUVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzdG9yYWdlID0gbmV3IFN0b3JhZ2UoKTtcblxuICAgICAgICB2YXIgcmVuZGVyZXJUeXBlID0gb3B0cy5yZW5kZXJlcjtcbiAgICAgICAgLy8gVE9ETyBXZWJHTFxuICAgICAgICBpZiAodXNlVk1MKSB7XG4gICAgICAgICAgICBpZiAoIXBhaW50ZXJDdG9ycy52bWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHJlcXVpcmUgXFwnenJlbmRlci92bWwvdm1sXFwnIHRvIHN1cHBvcnQgSUU4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJlclR5cGUgPSAndm1sJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcmVuZGVyZXJUeXBlIHx8ICFwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXSkge1xuICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gJ2NhbnZhcyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhaW50ZXIgPSBuZXcgcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0oZG9tLCBzdG9yYWdlLCBvcHRzKTtcblxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgICAgICB0aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuXG4gICAgICAgIHZhciBoYW5kZXJQcm94eSA9ICFlbnYubm9kZSA/IG5ldyBIYW5kbGVyUHJveHkocGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkgOiBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBuZXcgSGFuZGxlcihzdG9yYWdlLCBwYWludGVyLCBoYW5kZXJQcm94eSwgcGFpbnRlci5yb290KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oe1xuICAgICAgICAgICAgc3RhZ2U6IHtcbiAgICAgICAgICAgICAgICB1cGRhdGU6IHpyVXRpbC5iaW5kKHRoaXMuZmx1c2gsIHRoaXMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbi5zdGFydCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaDtcblxuICAgICAgICAvLyDkv67mlLkgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZSwg5q+P5qyh5Yig6Zmk5YWD57Sg5LmL5YmN5Yig6Zmk5Yqo55S7XG4gICAgICAgIC8vIEZJWE1FIOacieeCuXVnbHlcbiAgICAgICAgdmFyIG9sZERlbEZyb21TdG9yYWdlID0gc3RvcmFnZS5kZWxGcm9tU3RvcmFnZTtcbiAgICAgICAgdmFyIG9sZEFkZFRvU3RvcmFnZSA9IHN0b3JhZ2UuYWRkVG9TdG9yYWdlO1xuXG4gICAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIG9sZERlbEZyb21TdG9yYWdlLmNhbGwoc3RvcmFnZSwgZWwpO1xuXG4gICAgICAgICAgICBlbCAmJiBlbC5yZW1vdmVTZWxmRnJvbVpyKHNlbGYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0b3JhZ2UuYWRkVG9TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBvbGRBZGRUb1N0b3JhZ2UuY2FsbChzdG9yYWdlLCBlbCk7XG5cbiAgICAgICAgICAgIGVsLmFkZFNlbGZUb1pyKHNlbGYpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBaUmVuZGVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogWlJlbmRlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluWunuS+i+WUr+S4gOagh+ivhlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWFg+e0oFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5hZGRSb290KGVsKTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIoOmZpOWFg+e0oFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5kZWxSb290KGVsKTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYW5nZSBjb25maWd1cmF0aW9uIG9mIGxheWVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB6TGV2ZWxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5jbGVhckNvbG9yPTBdIENsZWFyIGNvbG9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIElmIGVuYWJsZSBtb3Rpb24gYmx1clxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddIE1vdGlvbiBibHVyIGZhY3Rvci4gTGFyZ2VyIHZhbHVlIGNhdXNlIGxvbmdlciB0cmFpbGVyXG4gICAgICAgICovXG4gICAgICAgIGNvbmZpZ0xheWVyOiBmdW5jdGlvbiAoekxldmVsLCBjb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5jb25maWdMYXllcih6TGV2ZWwsIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXBhaW50IHRoZSBjYW52YXMgaW1tZWRpYXRlbHlcbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2hJbW1lZGlhdGVseTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgbmVlZHNSZWZyZXNoIGFoZWFkIHRvIGF2b2lkIHNvbWV0aGluZyB3cm9uZyBoYXBwZW5zIGluIHJlZnJlc2hcbiAgICAgICAgICAgIC8vIE9yIGl0IHdpbGwgY2F1c2UgenJlbmRlciByZWZyZXNoZXMgYWdhaW4gYW5kIGFnYWluLlxuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIucmVmcmVzaCgpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBdm9pZCB0cmlnZ2VyIHpyLnJlZnJlc2ggaW4gRWxlbWVudCNiZWZvcmVVcGRhdGUgaG9va1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFyayBhbmQgcmVwYWludCB0aGUgY2FudmFzIGluIHRoZSBuZXh0IGZyYW1lIG9mIGJyb3dzZXJcbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybSBhbGwgcmVmcmVzaFxuICAgICAgICAgKi9cbiAgICAgICAgZmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hJbW1lZGlhdGVseSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSG92ZXJJbW1lZGlhdGVseSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgZWxlbWVudCB0byBob3ZlciBsYXllclxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgICAgICovXG4gICAgICAgIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYWludGVyLmFkZEhvdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyLmFkZEhvdmVyKGVsLCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGVsZW1lbnQgZnJvbSBob3ZlciBsYXllclxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFpbnRlci5yZW1vdmVIb3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRlci5yZW1vdmVIb3ZlcihlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXIgYWxsIGhvdmVyIGVsZW1lbnRzIGluIGhvdmVyIGxheWVyXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYWludGVyLmNsZWFySG92ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIuY2xlYXJIb3ZlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZnJlc2ggaG92ZXIgaW4gbmV4dCBmcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2hIb3ZlciA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZnJlc2ggaG92ZXIgaW1tZWRpYXRlbHlcbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2hIb3ZlckltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2hIb3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlciAmJiB0aGlzLnBhaW50ZXIucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZSB0aGUgY2FudmFzLlxuICAgICAgICAgKiBTaG91bGQgYmUgaW52b2tlZCB3aGVuIGNvbnRhaW5lciBzaXplIGlzIGNoYW5nZWRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbihvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5yZXNpemUob3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnJlc2l6ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wIGFuZCBjbGVhciBhbGwgYW5pbWF0aW9uIGltbWVkaWF0ZWx5XG4gICAgICAgICAqL1xuICAgICAgICBjbGVhckFuaW1hdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uY2xlYXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGNvbnRhaW5lciB3aWR0aFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRXaWR0aCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY29udGFpbmVyIGhlaWdodFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cG9ydCB0aGUgY2FudmFzIGFzIEJhc2U2NCBVUkxcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtiYWNrZ3JvdW5kQ29sb3I9JyNmZmYnXVxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2U2NCBVUkxcbiAgICAgICAgICovXG4gICAgICAgIC8vIHRvRGF0YVVSTDogZnVuY3Rpb24odHlwZSwgYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIC8vICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFJlbmRlcmVkQ2FudmFzKHtcbiAgICAgICAgLy8gICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAgICAgICAvLyAgICAgfSkudG9EYXRhVVJMKHR5cGUpO1xuICAgICAgICAvLyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0aW5nIGEgcGF0aCB0byBpbWFnZS5cbiAgICAgICAgICogSXQgaGFzIG11Y2ggYmV0dGVyIHBlcmZvcm1hbmNlIG9mIGRyYXdpbmcgaW1hZ2UgcmF0aGVyIHRoYW4gZHJhd2luZyBhIHZlY3RvciBwYXRoLlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAgICAgKi9cbiAgICAgICAgcGF0aFRvSW1hZ2U6IGZ1bmN0aW9uKGUsIGRwcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5wYXRoVG9JbWFnZShlLCBkcHIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgZGVmYXVsdCBjdXJzb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JTdHlsZT0nZGVmYXVsdCddIOS+i+WmgiBjcm9zc2hhaXJcbiAgICAgICAgICovXG4gICAgICAgIHNldEN1cnNvclN0eWxlOiBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5zZXRDdXJzb3JTdHlsZShjdXJzb3JTdHlsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmQgaG92ZXJlZCBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0ge3RhcmdldCwgdG9wVGFyZ2V0fVxuICAgICAgICAgKi9cbiAgICAgICAgZmluZEhvdmVyOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5maW5kSG92ZXIoeCwgeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmQgZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50SGFuZGxlciBIYW5kbGVyIGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIG9uOiBmdW5jdGlvbihldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLm9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5iaW5kIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXZlbnRIYW5kbGVyXSBIYW5kbGVyIGZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBvZmY6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIub2ZmKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZ2dlciBldmVudCBtYW51YWxseVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtldmVudD19IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnQpO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFyIGFsbCBvYmplY3RzIGFuZCB0aGUgY2FudmFzLlxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5kZWxSb290KCk7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIuY2xlYXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcG9zZSBzZWxmLlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uc3RvcCgpO1xuXG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID1cbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIgPVxuICAgICAgICAgICAgdGhpcy5oYW5kbGVyID0gbnVsbDtcblxuICAgICAgICAgICAgZGVsSW5zdGFuY2UodGhpcy5pZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB6cmVuZGVyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvenJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("'use strict';\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = __webpack_require__(20);\n    var Draggable = __webpack_require__(100);\n\n    var Eventful = __webpack_require__(41);\n\n    var SILENT = 'silent';\n\n    function makeEventPacket(eveType, targetInfo, event) {\n        return {\n            type: eveType,\n            event: event,\n            // target can only be an element that is not silent.\n            target: targetInfo.target,\n            // topTarget can be a silent element.\n            topTarget: targetInfo.topTarget,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * {target, topTarget}\n         * @private\n         * @type {Object}\n         */\n        this._hovered = {};\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var lastHovered = this._hovered;\n            var hovered = this._hovered = this.findHover(x, y);\n            var hoveredTarget = hovered.target;\n            var lastHoveredTarget = lastHovered.target;\n\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget && lastHoveredTarget.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = {};\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * 设置默认的cursor style\n         * @param {string} [cursorStyle='default'] 例如 crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * 事件分发代理\n         *\n         * @private\n         * @param {Object} targetInfo {target, topTarget} 目标图形元素\n         * @param {string} eventName 事件名称\n         * @param {Object} event 事件对象\n         */\n        dispatchToElement: function (targetInfo, eventName, event) {\n            targetInfo = targetInfo || {};\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n            var el = targetInfo.target;\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                // 冒泡到顶级 zrender 对象\n                this.trigger(eventName, eventPacket);\n                // 分发事件到用户自定义层\n                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @return {model:zrender/Element}\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            var out = {};\n\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                var hoverCheckResult;\n                if (list[i] !== exclude\n                    // getDisplayList may include ignored item in VML mode\n                    && !list[i].ignore\n                    && (hoverCheckResult = isHover(list[i], x, y))\n                ) {\n                    !out.topTarget && (out.topTarget = list[i]);\n                    if (hoverCheckResult !== SILENT) {\n                        out.target = list[i];\n                        break;\n                    }\n                }\n            }\n\n            return out;\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY);\n            var hoveredTarget = hovered.target;\n\n            if (name === 'mousedown') {\n                this._downel = hoveredTarget;\n                // In case click triggered before mouseup\n                this._upel = hoveredTarget;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hoveredTarget;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            var isSilent;\n            while (el) {\n                // If clipped by ancestor.\n                // FIXME: If clipPath has neither stroke nor fill,\n                // el.clipPath.contain(x, y) will always return false.\n                if (el.clipPath && !el.clipPath.contain(x, y))  {\n                    return false;\n                }\n                if (el.silent) {\n                    isSilent = true;\n                }\n                el = el.parent;\n            }\n            return isSilent ? SILENT : true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL0hhbmRsZXIuanM/ZmJlYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsZ0NBQWdDO0FBQy9DLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9ELGFBQWE7QUFDakUsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPLGFBQWEsa0JBQWtCO0FBQ3pELG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLG1DQUFtQztBQUN0RCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiOTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIEhhbmRsZXJcbiAqIEBtb2R1bGUgenJlbmRlci9IYW5kbGVyXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoc2hlbnlpLjkxNEBnbWFpbC5jb20pXG4gKi9cblxuXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuICAgIHZhciBEcmFnZ2FibGUgPSByZXF1aXJlKCcuL21peGluL0RyYWdnYWJsZScpO1xuXG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi9taXhpbi9FdmVudGZ1bCcpO1xuXG4gICAgdmFyIFNJTEVOVCA9ICdzaWxlbnQnO1xuXG4gICAgZnVuY3Rpb24gbWFrZUV2ZW50UGFja2V0KGV2ZVR5cGUsIHRhcmdldEluZm8sIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBldmVUeXBlLFxuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgLy8gdGFyZ2V0IGNhbiBvbmx5IGJlIGFuIGVsZW1lbnQgdGhhdCBpcyBub3Qgc2lsZW50LlxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRJbmZvLnRhcmdldCxcbiAgICAgICAgICAgIC8vIHRvcFRhcmdldCBjYW4gYmUgYSBzaWxlbnQgZWxlbWVudC5cbiAgICAgICAgICAgIHRvcFRhcmdldDogdGFyZ2V0SW5mby50b3BUYXJnZXQsXG4gICAgICAgICAgICBjYW5jZWxCdWJibGU6IGZhbHNlLFxuICAgICAgICAgICAgb2Zmc2V0WDogZXZlbnQuenJYLFxuICAgICAgICAgICAgb2Zmc2V0WTogZXZlbnQuenJZLFxuICAgICAgICAgICAgZ2VzdHVyZUV2ZW50OiBldmVudC5nZXN0dXJlRXZlbnQsXG4gICAgICAgICAgICBwaW5jaFg6IGV2ZW50LnBpbmNoWCxcbiAgICAgICAgICAgIHBpbmNoWTogZXZlbnQucGluY2hZLFxuICAgICAgICAgICAgcGluY2hTY2FsZTogZXZlbnQucGluY2hTY2FsZSxcbiAgICAgICAgICAgIHdoZWVsRGVsdGE6IGV2ZW50LnpyRGVsdGEsXG4gICAgICAgICAgICB6ckJ5VG91Y2g6IGV2ZW50LnpyQnlUb3VjaFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEVtcHR5UHJveHkgKCkge31cbiAgICBFbXB0eVByb3h5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XG5cbiAgICB2YXIgaGFuZGxlck5hbWVzID0gW1xuICAgICAgICAnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V3aGVlbCcsICdtb3VzZW91dCcsXG4gICAgICAgICdtb3VzZXVwJywgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnY29udGV4dG1lbnUnXG4gICAgXTtcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvSGFuZGxlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfSBzdG9yYWdlIFN0b3JhZ2UgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9QYWludGVyfSBwYWludGVyIFBhaW50ZXIgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9kb20vSGFuZGxlclByb3h5fSBwcm94eSBIYW5kbGVyUHJveHkgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFpbnRlclJvb3QgcGFpbnRlci5yb290IChub3QgcGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkuXG4gICAgICovXG4gICAgdmFyIEhhbmRsZXIgPSBmdW5jdGlvbihzdG9yYWdlLCBwYWludGVyLCBwcm94eSwgcGFpbnRlclJvb3QpIHtcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuXG4gICAgICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG5cbiAgICAgICAgdGhpcy5wYWludGVyUm9vdCA9IHBhaW50ZXJSb290O1xuXG4gICAgICAgIHByb3h5ID0gcHJveHkgfHwgbmV3IEVtcHR5UHJveHkoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJveHkgb2YgZXZlbnQuIGNhbiBiZSBEb20sIFdlYkdMU3VyZmFjZSwgZXRjLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm94eSA9IHByb3h5O1xuXG4gICAgICAgIC8vIEF0dGFjaCBoYW5kbGVyXG4gICAgICAgIHByb3h5LmhhbmRsZXIgPSB0aGlzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB7dGFyZ2V0LCB0b3BUYXJnZXR9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ob3ZlcmVkID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtEYXRlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoTW9tZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGFzdFg7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXN0WTtcblxuXG4gICAgICAgIERyYWdnYWJsZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHV0aWwuZWFjaChoYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBwcm94eS5vbiAmJiBwcm94eS5vbihuYW1lLCB0aGlzW25hbWVdLCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAgIEhhbmRsZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBIYW5kbGVyLFxuXG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgeCA9IGV2ZW50LnpyWDtcbiAgICAgICAgICAgIHZhciB5ID0gZXZlbnQuenJZO1xuXG4gICAgICAgICAgICB2YXIgbGFzdEhvdmVyZWQgPSB0aGlzLl9ob3ZlcmVkO1xuICAgICAgICAgICAgdmFyIGhvdmVyZWQgPSB0aGlzLl9ob3ZlcmVkID0gdGhpcy5maW5kSG92ZXIoeCwgeSk7XG4gICAgICAgICAgICB2YXIgaG92ZXJlZFRhcmdldCA9IGhvdmVyZWQudGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGxhc3RIb3ZlcmVkVGFyZ2V0ID0gbGFzdEhvdmVyZWQudGFyZ2V0O1xuXG4gICAgICAgICAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgICAgICAgICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihob3ZlcmVkVGFyZ2V0ID8gaG92ZXJlZFRhcmdldC5jdXJzb3IgOiAnZGVmYXVsdCcpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBvdXQgb24gcHJldmlvdXMgaG92ZXJlZCBlbGVtZW50XG4gICAgICAgICAgICBpZiAobGFzdEhvdmVyZWRUYXJnZXQgJiYgaG92ZXJlZFRhcmdldCAhPT0gbGFzdEhvdmVyZWRUYXJnZXQgJiYgbGFzdEhvdmVyZWRUYXJnZXQuX196cikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQobGFzdEhvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTW91c2UgbW92aW5nIG9uIG9uZSBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW1vdmUnLCBldmVudCk7XG5cbiAgICAgICAgICAgIC8vIE1vdXNlIG92ZXIgb24gYSBuZXcgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGhvdmVyZWRUYXJnZXQgJiYgaG92ZXJlZFRhcmdldCAhPT0gbGFzdEhvdmVyZWRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW92ZXInLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudCh0aGlzLl9ob3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7XG5cbiAgICAgICAgICAgIC8vIFRoZXJlIG1pZ2h0IGJlIHNvbWUgZG9tcyBjcmVhdGVkIGJ5IHVwcGVyIGxheWVyIGFwcGxpY2F0aW9uXG4gICAgICAgICAgICAvLyBhdCB0aGUgc2FtZSBsZXZlbCBvZiBwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpIChlLmcuLCB0b29sdGlwXG4gICAgICAgICAgICAvLyBkb20gY3JlYXRlZCBieSBlY2hhcnRzKSwgd2hlcmUgJ2dsb2JhbG91dCcgZXZlbnQgc2hvdWxkIG5vdFxuICAgICAgICAgICAgLy8gYmUgdHJpZ2dlcmVkIHdoZW4gbW91c2UgZW50ZXJzIHRoZXNlIGRvbXMuIChCdXQgJ21vdXNlb3V0J1xuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHRyaWdnZXJlZCBhdCB0aGUgb3JpZ2luYWwgaG92ZXJlZCBlbGVtZW50IGFzIHVzdWFsKS5cbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZXZlbnQudG9FbGVtZW50IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgICAgICB2YXIgaW5uZXJEb207XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPSA5ICYmICEoXG4gICAgICAgICAgICAgICAgaW5uZXJEb20gPSBlbGVtZW50ID09PSB0aGlzLnBhaW50ZXJSb290XG4gICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgIWlubmVyRG9tICYmIHRoaXMudHJpZ2dlcignZ2xvYmFsb3V0Jywge2V2ZW50OiBldmVudH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNpemVcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9ob3ZlcmVkID0ge307XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BhdGNoIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICAgICAgICogQHBhcmFtIHtldmVudD19IGV2ZW50QXJnc1xuICAgICAgICAgKi9cbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJncykge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICBoYW5kbGVyICYmIGhhbmRsZXIuY2FsbCh0aGlzLCBldmVudEFyZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHRoaXMucHJveHkuZGlzcG9zZSgpO1xuXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPVxuICAgICAgICAgICAgdGhpcy5wcm94eSA9XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7pu5jorqTnmoRjdXJzb3Igc3R5bGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JTdHlsZT0nZGVmYXVsdCddIOS+i+WmgiBjcm9zc2hhaXJcbiAgICAgICAgICovXG4gICAgICAgIHNldEN1cnNvclN0eWxlOiBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICAgICAgICAgIHZhciBwcm94eSA9IHRoaXMucHJveHk7XG4gICAgICAgICAgICBwcm94eS5zZXRDdXJzb3IgJiYgcHJveHkuc2V0Q3Vyc29yKGN1cnNvclN0eWxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5LqL5Lu25YiG5Y+R5Luj55CGXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRJbmZvIHt0YXJnZXQsIHRvcFRhcmdldH0g55uu5qCH5Zu+5b2i5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUg5LqL5Lu25ZCN56ewXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIGRpc3BhdGNoVG9FbGVtZW50OiBmdW5jdGlvbiAodGFyZ2V0SW5mbywgZXZlbnROYW1lLCBldmVudCkge1xuICAgICAgICAgICAgdGFyZ2V0SW5mbyA9IHRhcmdldEluZm8gfHwge307XG4gICAgICAgICAgICB2YXIgZXZlbnRIYW5kbGVyID0gJ29uJyArIGV2ZW50TmFtZTtcbiAgICAgICAgICAgIHZhciBldmVudFBhY2tldCA9IG1ha2VFdmVudFBhY2tldChldmVudE5hbWUsIHRhcmdldEluZm8sIGV2ZW50KTtcblxuICAgICAgICAgICAgdmFyIGVsID0gdGFyZ2V0SW5mby50YXJnZXQ7XG4gICAgICAgICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgICAgICAgICBlbFtldmVudEhhbmRsZXJdXG4gICAgICAgICAgICAgICAgICAgICYmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUgPSBlbFtldmVudEhhbmRsZXJdLmNhbGwoZWwsIGV2ZW50UGFja2V0KSk7XG5cbiAgICAgICAgICAgICAgICBlbC50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuXG4gICAgICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgICAgICAgICAvLyDlhpLms6HliLDpobbnuqcgenJlbmRlciDlr7nosaFcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG4gICAgICAgICAgICAgICAgLy8g5YiG5Y+R5LqL5Lu25Yiw55So5oi36Ieq5a6a5LmJ5bGCXG4gICAgICAgICAgICAgICAgLy8g55So5oi35pyJ5Y+v6IO95Zyo5YWo5bGAIGNsaWNrIOS6i+S7tuS4rSBkaXNwb3Nl77yM5omA5Lul6ZyA6KaB5Yik5pat5LiLIHBhaW50ZXIg5piv5ZCm5a2Y5ZyoXG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyICYmIHRoaXMucGFpbnRlci5lYWNoT3RoZXJMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihsYXllcltldmVudEhhbmRsZXJdKSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcltldmVudEhhbmRsZXJdLmNhbGwobGF5ZXIsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXIudHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGV9IGV4Y2x1ZGVcbiAgICAgICAgICogQHJldHVybiB7bW9kZWw6enJlbmRlci9FbGVtZW50fVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqL1xuICAgICAgICBmaW5kSG92ZXI6IGZ1bmN0aW9uKHgsIHksIGV4Y2x1ZGUpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCk7XG4gICAgICAgICAgICB2YXIgb3V0ID0ge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMCA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBob3ZlckNoZWNrUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChsaXN0W2ldICE9PSBleGNsdWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldERpc3BsYXlMaXN0IG1heSBpbmNsdWRlIGlnbm9yZWQgaXRlbSBpbiBWTUwgbW9kZVxuICAgICAgICAgICAgICAgICAgICAmJiAhbGlzdFtpXS5pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgJiYgKGhvdmVyQ2hlY2tSZXN1bHQgPSBpc0hvdmVyKGxpc3RbaV0sIHgsIHkpKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAhb3V0LnRvcFRhcmdldCAmJiAob3V0LnRvcFRhcmdldCA9IGxpc3RbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaG92ZXJDaGVja1Jlc3VsdCAhPT0gU0lMRU5UKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQudGFyZ2V0ID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIENvbW1vbiBoYW5kbGVyc1xuICAgIHV0aWwuZWFjaChbJ2NsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNld2hlZWwnLCAnZGJsY2xpY2snLCAnY29udGV4dG1lbnUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgSGFuZGxlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgaG92ZXIgYWdhaW4gdG8gYXZvaWQgY2xpY2sgZXZlbnQgaXMgZGlzcGF0Y2hlZCBtYW51YWxseS4gT3IgY2xpY2sgaXMgdHJpZ2dlcmVkIHdpdGhvdXQgbW91c2VvdmVyXG4gICAgICAgICAgICB2YXIgaG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKGV2ZW50LnpyWCwgZXZlbnQuenJZKTtcbiAgICAgICAgICAgIHZhciBob3ZlcmVkVGFyZ2V0ID0gaG92ZXJlZC50YXJnZXQ7XG5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rvd25lbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBjbGljayB0cmlnZ2VyZWQgYmVmb3JlIG1vdXNldXBcbiAgICAgICAgICAgICAgICB0aGlzLl91cGVsID0gaG92ZXJlZFRhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdtb3N1ZXVwJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZWwgPSBob3ZlcmVkVGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kb3duZWwgIT09IHRoaXMuX3VwZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCBuYW1lLCBldmVudCk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBpc0hvdmVyKGRpc3BsYXlhYmxlLCB4LCB5KSB7XG4gICAgICAgIGlmIChkaXNwbGF5YWJsZVtkaXNwbGF5YWJsZS5yZWN0SG92ZXIgPyAncmVjdENvbnRhaW4nIDogJ2NvbnRhaW4nXSh4LCB5KSkge1xuICAgICAgICAgICAgdmFyIGVsID0gZGlzcGxheWFibGU7XG4gICAgICAgICAgICB2YXIgaXNTaWxlbnQ7XG4gICAgICAgICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBjbGlwcGVkIGJ5IGFuY2VzdG9yLlxuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBJZiBjbGlwUGF0aCBoYXMgbmVpdGhlciBzdHJva2Ugbm9yIGZpbGwsXG4gICAgICAgICAgICAgICAgLy8gZWwuY2xpcFBhdGguY29udGFpbih4LCB5KSB3aWxsIGFsd2F5cyByZXR1cm4gZmFsc2UuXG4gICAgICAgICAgICAgICAgaWYgKGVsLmNsaXBQYXRoICYmICFlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpKSAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbC5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNTaWxlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1NpbGVudCA/IFNJTEVOVCA6IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdXRpbC5taXhpbihIYW5kbGVyLCBFdmVudGZ1bCk7XG4gICAgdXRpbC5taXhpbihIYW5kbGVyLCBEcmFnZ2FibGUpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW5kbGVyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvSGFuZGxlci5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget).target;\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    function param(target, e) {\n        return {target: target, topTarget: e && e.topTarget};\n    }\n\n    module.exports = Draggable;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qcz9mYmNhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEiLCJmaWxlIjoiMTAwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETyBEcmFnZ2FibGUgZm9yIGdyb3VwXG4vLyBGSVhNRSBEcmFnZ2FibGUgb24gZWxlbWVudCB3aGljaCBoYXMgcGFyZW50IHJvdGF0aW9uIG9yIHNjYWxlXG5cbiAgICBmdW5jdGlvbiBEcmFnZ2FibGUoKSB7XG5cbiAgICAgICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5fZHJhZ1N0YXJ0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbignbW91c2Vtb3ZlJywgdGhpcy5fZHJhZywgdGhpcyk7XG4gICAgICAgIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbignZ2xvYmFsb3V0JywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7XG4gICAgICAgIC8vIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICAvLyB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG5cbiAgICAgICAgLy8gdGhpcy5feCA9IDA7XG4gICAgICAgIC8vIHRoaXMuX3kgPSAwO1xuICAgIH1cblxuICAgIERyYWdnYWJsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IERyYWdnYWJsZSxcblxuICAgICAgICBfZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQgJiYgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBkcmFnZ2luZ1RhcmdldDtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gZS5vZmZzZXRZO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcmFnZ2luZ1RhcmdldCwgZSksICdkcmFnc3RhcnQnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IHRoaXMuX2RyYWdnaW5nVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGUub2Zmc2V0WTtcblxuICAgICAgICAgICAgICAgIHZhciBkeCA9IHggLSB0aGlzLl94O1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IHkgLSB0aGlzLl95O1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJpZnQoZHgsIGR5LCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWcnLCBlLmV2ZW50KTtcblxuICAgICAgICAgICAgICAgIHZhciBkcm9wVGFyZ2V0ID0gdGhpcy5maW5kSG92ZXIoeCwgeSwgZHJhZ2dpbmdUYXJnZXQpLnRhcmdldDtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdERyb3BUYXJnZXQgPSB0aGlzLl9kcm9wVGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICE9PSBkcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0RHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShsYXN0RHJvcFRhcmdldCwgZSksICdkcmFnbGVhdmUnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcm9wVGFyZ2V0LCBlKSwgJ2RyYWdlbnRlcicsIGUuZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gdGhpcy5fZHJhZ2dpbmdUYXJnZXQ7XG5cbiAgICAgICAgICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nVGFyZ2V0LmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZ2VuZCcsIGUuZXZlbnQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0odGhpcy5fZHJvcFRhcmdldCwgZSksICdkcm9wJywgZS5ldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGFyYW0odGFyZ2V0LCBlKSB7XG4gICAgICAgIHJldHVybiB7dGFyZ2V0OiB0YXJnZXQsIHRvcFRhcmdldDogZSAmJiBlLnRvcFRhcmdldH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEcmFnZ2FibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("'use strict';\n/**\n * Storage内容仓库模块\n * @module zrender/Storage\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = __webpack_require__(20);\n    var env = __webpack_require__(18);\n\n    var Group = __webpack_require__(64);\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = __webpack_require__(102);\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     * 内容仓库 (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * 返回所有图形的绘制队列\n         * @param {boolean} [update=false] 是否在返回前更新该数组\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n         *\n         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * 更新图形的绘制队列。\n         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var userSetClipPath = el.clipPath;\n            if (userSetClipPath) {\n\n                // FIXME 效率影响\n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                // Recursively add clip path\n                while (currentClipPath) {\n                    // clipPath 的变换是基于使用这个 clipPath 的元素\n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n\n                    clipPaths.push(currentClipPath);\n\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.clipPath;\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * 添加图形(Shape)或者组(Group)到根节点\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            if (el.__storage === this) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToStorage(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * 删除指定的图形(Shape)或者组(Group)\n         * @param {string|Array.<string>} [el] 如果为空清空整个Storage\n         */\n        delRoot: function (el) {\n            if (el == null) {\n                // 不指定el清空\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (el instanceof Array) {\n                for (var i = 0, l = el.length; i < l; i++) {\n                    this.delRoot(el[i]);\n                }\n                return;\n            }\n\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromStorage(el);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToStorage: function (el) {\n            el.__storage = this;\n            el.dirty(false);\n\n            return this;\n        },\n\n        delFromStorage: function (el) {\n            if (el) {\n                el.__storage = null;\n            }\n\n            return this;\n        },\n\n        /**\n         * 清空并且释放Storage\n         */\n        dispose: function () {\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL1N0b3JhZ2UuanM/N2U5MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxjQUFjO0FBQ2Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdELFNBQVM7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtCQUErQixxQkFBcUI7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQSIsImZpbGUiOiIxMDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIFN0b3JhZ2XlhoXlrrnku5PlupPmqKHlnZdcbiAqIEBtb2R1bGUgenJlbmRlci9TdG9yYWdlXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqIEBhdXRob3IgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly9naXRodWIuY29tL3Bpc3NhbmcvKVxuICovXG5cblxuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi9jb3JlL2VudicpO1xuXG4gICAgdmFyIEdyb3VwID0gcmVxdWlyZSgnLi9jb250YWluZXIvR3JvdXAnKTtcblxuICAgIC8vIFVzZSB0aW1zb3J0IGJlY2F1c2UgaW4gbW9zdCBjYXNlIGVsZW1lbnRzIGFyZSBwYXJ0aWFsbHkgc29ydGVkXG4gICAgLy8gaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvcGlzc2FuZy9qcjR4N21kbS84L1xuICAgIHZhciB0aW1zb3J0ID0gcmVxdWlyZSgnLi9jb3JlL3RpbXNvcnQnKTtcblxuICAgIGZ1bmN0aW9uIHNoYXBlQ29tcGFyZUZ1bmMoYSwgYikge1xuICAgICAgICBpZiAoYS56bGV2ZWwgPT09IGIuemxldmVsKSB7XG4gICAgICAgICAgICBpZiAoYS56ID09PSBiLnopIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAoYS56MiA9PT0gYi56Mikge1xuICAgICAgICAgICAgICAgIC8vICAgICAvLyBGSVhNRSBTbG93IGhhcyByZW5kZXJpZHggY29tcGFyZVxuICAgICAgICAgICAgICAgIC8vICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwODgzNDIxL3NvcnRpbmctaW4tamF2YXNjcmlwdC1zaG91bGQtZXZlcnktY29tcGFyZS1mdW5jdGlvbi1oYXZlLWEtcmV0dXJuLTAtc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgLy8gICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92OC92OC9ibG9iLzQ3Y2NlNTQ0YTMxZWQ1NTc3ZmZlMjk2M2Y2N2FjYjQxNDRlZTAyMzIvc3JjL2pzL2FycmF5LmpzI0wxMDEyXG4gICAgICAgICAgICAgICAgLy8gICAgIHJldHVybiBhLl9fcmVuZGVyaWR4IC0gYi5fX3JlbmRlcmlkeDtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuejIgLSBiLnoyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGEueiAtIGIuejtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS56bGV2ZWwgLSBiLnpsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5YaF5a655LuT5bqTIChNKVxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9TdG9yYWdlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Jvb3RzID0gW107XG5cbiAgICAgICAgdGhpcy5fZGlzcGxheUxpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgfTtcblxuICAgIFN0b3JhZ2UucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBTdG9yYWdlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290c1tpXS50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi/lOWbnuaJgOacieWbvuW9oueahOe7mOWItumYn+WIl1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGU9ZmFsc2VdIOaYr+WQpuWcqOi/lOWbnuWJjeabtOaWsOivpeaVsOe7hFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSWdub3JlPWZhbHNlXSDmmK/lkKbljIXlkKsgaWdub3JlIOeahOaVsOe7hCwg5ZyoIHVwZGF0ZSDkuLogdHJ1ZSDnmoTml7blgJnmnInmlYhcbiAgICAgICAgICpcbiAgICAgICAgICog6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUucHJvdG90eXBlLnVwZGF0ZURpc3BsYXlMaXN0fVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZT59XG4gICAgICAgICAqL1xuICAgICAgICBnZXREaXNwbGF5TGlzdDogZnVuY3Rpb24gKHVwZGF0ZSwgaW5jbHVkZUlnbm9yZSkge1xuICAgICAgICAgICAgaW5jbHVkZUlnbm9yZSA9IGluY2x1ZGVJZ25vcmUgfHwgZmFsc2U7XG4gICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5TGlzdChpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5TGlzdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5pu05paw5Zu+5b2i55qE57uY5Yi26Zif5YiX44CCXG4gICAgICAgICAqIOavj+asoee7mOWItuWJjemDveS8muiwg+eUqO+8jOivpeaWueazleS8muWFiOa3seW6puS8mOWFiOmBjeWOhuaVtOS4quagke+8jOabtOaWsOaJgOaciUdyb3Vw5ZKMU2hhcGXnmoTlj5jmjaLlubbkuJTmiormiYDmnInlj6/op4HnmoRTaGFwZeS/neWtmOWIsOaVsOe7hOS4re+8jFxuICAgICAgICAgKiDmnIDlkI7moLnmja7nu5jliLbnmoTkvJjlhYjnuqfvvIh6bGV2ZWwgPiB6ID4g5o+S5YWl6aG65bqP77yJ5o6S5bqP5b6X5Yiw57uY5Yi26Zif5YiXXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uEXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVEaXNwbGF5TGlzdDogZnVuY3Rpb24gKGluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICAgICAgICAgIHZhciByb290cyA9IHRoaXMuX3Jvb3RzO1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5fZGlzcGxheUxpc3Q7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm9vdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShyb290c1tpXSwgbnVsbCwgaW5jbHVkZUlnbm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwbGF5TGlzdC5sZW5ndGggPSB0aGlzLl9kaXNwbGF5TGlzdExlbjtcblxuICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyAgICAgZGlzcGxheUxpc3RbaV0uX19yZW5kZXJpZHggPSBpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAvLyBkaXNwbGF5TGlzdC5zb3J0KHNoYXBlQ29tcGFyZUZ1bmMpO1xuICAgICAgICAgICAgZW52LmNhbnZhc1N1cHBvcnRlZCAmJiB0aW1zb3J0KGRpc3BsYXlMaXN0LCBzaGFwZUNvbXBhcmVGdW5jKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlQW5kQWRkRGlzcGxheWFibGU6IGZ1bmN0aW9uIChlbCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKSB7XG5cbiAgICAgICAgICAgIGlmIChlbC5pZ25vcmUgJiYgIWluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLmJlZm9yZVVwZGF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuXG4gICAgICAgICAgICAgICAgZWwudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWwuYWZ0ZXJVcGRhdGUoKTtcblxuICAgICAgICAgICAgdmFyIHVzZXJTZXRDbGlwUGF0aCA9IGVsLmNsaXBQYXRoO1xuICAgICAgICAgICAgaWYgKHVzZXJTZXRDbGlwUGF0aCkge1xuXG4gICAgICAgICAgICAgICAgLy8gRklYTUUg5pWI546H5b2x5ZONXG4gICAgICAgICAgICAgICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aHMgPSBjbGlwUGF0aHMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRocyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q2xpcFBhdGggPSB1c2VyU2V0Q2xpcFBhdGg7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudENsaXBQYXRoID0gZWw7XG4gICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgYWRkIGNsaXAgcGF0aFxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50Q2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpcFBhdGgg55qE5Y+Y5o2i5piv5Z+65LqO5L2/55So6L+Z5LiqIGNsaXBQYXRoIOeahOWFg+e0oFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2xpcFBhdGgucGFyZW50ID0gcGFyZW50Q2xpcFBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDbGlwUGF0aC51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aHMucHVzaChjdXJyZW50Q2xpcFBhdGgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENsaXBQYXRoID0gY3VycmVudENsaXBQYXRoO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2xpcFBhdGggPSBjdXJyZW50Q2xpcFBhdGguY2xpcFBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWwuaXNHcm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGVsLl9jaGlsZHJlbjtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgdG8gbWFyayBhcyBkaXJ0eSBpZiBncm91cCBpcyBkaXJ0eVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBfX2RpcnR5UGF0aCA/XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlKGNoaWxkLCBjbGlwUGF0aHMsIGluY2x1ZGVJZ25vcmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1hcmsgZ3JvdXAgY2xlYW4gaGVyZVxuICAgICAgICAgICAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwuX19jbGlwUGF0aHMgPSBjbGlwUGF0aHM7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdFt0aGlzLl9kaXNwbGF5TGlzdExlbisrXSA9IGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlm77lvaIoU2hhcGUp5oiW6ICF57uEKEdyb3VwKeWIsOagueiKgueCuVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICBhZGRSb290OiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbC5fX3N0b3JhZ2UgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgZWwuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2UodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYWRkVG9TdG9yYWdlKGVsKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RzLnB1c2goZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTmjIflrprnmoTlm77lvaIoU2hhcGUp5oiW6ICF57uEKEdyb3VwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2VsXSDlpoLmnpzkuLrnqbrmuIXnqbrmlbTkuKpTdG9yYWdlXG4gICAgICAgICAqL1xuICAgICAgICBkZWxSb290OiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8g5LiN5oyH5a6aZWzmuIXnqbpcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5fcm9vdHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290IGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxSb290KGVsW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fcm9vdHMsIGVsKTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsRnJvbVN0b3JhZ2UoZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2UodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFRvU3RvcmFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBlbC5fX3N0b3JhZ2UgPSB0aGlzO1xuICAgICAgICAgICAgZWwuZGlydHkoZmFsc2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxGcm9tU3RvcmFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5fX3N0b3JhZ2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF56m65bm25LiU6YeK5pS+U3RvcmFnZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTGlzdCA9XG4gICAgICAgICAgICB0aGlzLl9yb290cyA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcGxheWFibGVTb3J0RnVuYzogc2hhcGVDb21wYXJlRnVuY1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFN0b3JhZ2U7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9TdG9yYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdGltc29ydC5qcz8wYTc0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsWUFBWTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTAyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL216aWNjYXJkL25vZGUtdGltc29ydFxuXG4gICAgdmFyIERFRkFVTFRfTUlOX01FUkdFID0gMzI7XG5cbiAgICB2YXIgREVGQVVMVF9NSU5fR0FMTE9QSU5HID0gNztcblxuICAgIHZhciBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCA9IDI1NjtcblxuICAgIGZ1bmN0aW9uIG1pblJ1bkxlbmd0aChuKSB7XG4gICAgICAgIHZhciByID0gMDtcblxuICAgICAgICB3aGlsZSAobiA+PSBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgICAgICAgICAgciB8PSBuICYgMTtcbiAgICAgICAgICAgIG4gPj49IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbiArIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKSB7XG4gICAgICAgIHZhciBydW5IaSA9IGxvICsgMTtcblxuICAgICAgICBpZiAocnVuSGkgPT09IGhpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJlKGFycmF5W3J1bkhpKytdLCBhcnJheVtsb10pIDwgMCkge1xuICAgICAgICAgICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pIDwgMCkge1xuICAgICAgICAgICAgICAgIHJ1bkhpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldmVyc2VSdW4oYXJyYXksIGxvLCBydW5IaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bkhpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnVuSGkgLSBsbztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXZlcnNlUnVuKGFycmF5LCBsbywgaGkpIHtcbiAgICAgICAgaGktLTtcblxuICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgICAgdmFyIHQgPSBhcnJheVtsb107XG4gICAgICAgICAgICBhcnJheVtsbysrXSA9IGFycmF5W2hpXTtcbiAgICAgICAgICAgIGFycmF5W2hpLS1dID0gdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgc3RhcnQsIGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBsbykge1xuICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBzdGFydCA8IGhpOyBzdGFydCsrKSB7XG4gICAgICAgICAgICB2YXIgcGl2b3QgPSBhcnJheVtzdGFydF07XG5cbiAgICAgICAgICAgIHZhciBsZWZ0ID0gbG87XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBzdGFydDtcbiAgICAgICAgICAgIHZhciBtaWQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICBtaWQgPSBsZWZ0ICsgcmlnaHQgPj4+IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShwaXZvdCwgYXJyYXlbbWlkXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbiA9IHN0YXJ0IC0gbGVmdDtcblxuICAgICAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBhcnJheVtsZWZ0ICsgM10gPSBhcnJheVtsZWZ0ICsgMl07XG5cbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2xlZnQgKyAyXSA9IGFycmF5W2xlZnQgKyAxXTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIDFdID0gYXJyYXlbbGVmdF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIG5dID0gYXJyYXlbbGVmdCArIG4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJheVtsZWZ0XSA9IHBpdm90O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2FsbG9wTGVmdCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pID4gMCkge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RPZmZzZXQgKz0gaGludDtcbiAgICAgICAgICAgIG9mZnNldCArPSBoaW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCAtIG9mZnNldF0pIDw9IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RPZmZzZXQrKztcbiAgICAgICAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pID4gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnYWxsb3BSaWdodCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pIDwgMCkge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG5cbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGhpbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0T2Zmc2V0Kys7XG5cbiAgICAgICAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pIDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIG1pbkdhbGxvcCA9IERFRkFVTFRfTUlOX0dBTExPUElORztcbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgIHZhciB0bXBTdG9yYWdlTGVuZ3RoID0gREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEg7XG4gICAgICAgIHZhciBzdGFja0xlbmd0aCA9IDA7XG4gICAgICAgIHZhciBydW5TdGFydDtcbiAgICAgICAgdmFyIHJ1bkxlbmd0aDtcbiAgICAgICAgdmFyIHN0YWNrU2l6ZSA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW5ndGggPCAyICogREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRtcFN0b3JhZ2VMZW5ndGggPSBsZW5ndGggPj4+IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1wID0gW107XG5cbiAgICAgICAgc3RhY2tMZW5ndGggPSBsZW5ndGggPCAxMjAgPyA1IDogbGVuZ3RoIDwgMTU0MiA/IDEwIDogbGVuZ3RoIDwgMTE5MTUxID8gMTkgOiA0MDtcblxuICAgICAgICBydW5TdGFydCA9IFtdO1xuICAgICAgICBydW5MZW5ndGggPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBwdXNoUnVuKF9ydW5TdGFydCwgX3J1bkxlbmd0aCkge1xuICAgICAgICAgICAgcnVuU3RhcnRbc3RhY2tTaXplXSA9IF9ydW5TdGFydDtcbiAgICAgICAgICAgIHJ1bkxlbmd0aFtzdGFja1NpemVdID0gX3J1bkxlbmd0aDtcbiAgICAgICAgICAgIHN0YWNrU2l6ZSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VSdW5zKCkge1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgICAgICAgICAgICBpZiAobiA+PSAxICYmIHJ1bkxlbmd0aFtuIC0gMV0gPD0gcnVuTGVuZ3RoW25dICsgcnVuTGVuZ3RoW24gKyAxXSB8fCBuID49IDIgJiYgcnVuTGVuZ3RoW24gLSAyXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydW5MZW5ndGhbbiAtIDFdIDwgcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bkxlbmd0aFtuXSA+IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lcmdlQXQobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmb3JjZU1lcmdlUnVucygpIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFja1NpemUgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBzdGFja1NpemUgLSAyO1xuXG4gICAgICAgICAgICAgICAgaWYgKG4gPiAwICYmIHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZXJnZUF0KG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VBdChpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQxID0gcnVuU3RhcnRbaV07XG4gICAgICAgICAgICB2YXIgbGVuZ3RoMSA9IHJ1bkxlbmd0aFtpXTtcbiAgICAgICAgICAgIHZhciBzdGFydDIgPSBydW5TdGFydFtpICsgMV07XG4gICAgICAgICAgICB2YXIgbGVuZ3RoMiA9IHJ1bkxlbmd0aFtpICsgMV07XG5cbiAgICAgICAgICAgIHJ1bkxlbmd0aFtpXSA9IGxlbmd0aDEgKyBsZW5ndGgyO1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gc3RhY2tTaXplIC0gMykge1xuICAgICAgICAgICAgICAgIHJ1blN0YXJ0W2kgKyAxXSA9IHJ1blN0YXJ0W2kgKyAyXTtcbiAgICAgICAgICAgICAgICBydW5MZW5ndGhbaSArIDFdID0gcnVuTGVuZ3RoW2kgKyAyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhY2tTaXplLS07XG5cbiAgICAgICAgICAgIHZhciBrID0gZ2FsbG9wUmlnaHQoYXJyYXlbc3RhcnQyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG4gICAgICAgICAgICBzdGFydDEgKz0gaztcbiAgICAgICAgICAgIGxlbmd0aDEgLT0gaztcblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlbmd0aDIgPSBnYWxsb3BMZWZ0KGFycmF5W3N0YXJ0MSArIGxlbmd0aDEgLSAxXSwgYXJyYXksIHN0YXJ0MiwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPD0gbGVuZ3RoMikge1xuICAgICAgICAgICAgICAgIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQxICsgaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjdXJzb3IxID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJzb3IyID0gc3RhcnQyO1xuICAgICAgICAgICAgdmFyIGRlc3QgPSBzdGFydDE7XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfbWluR2FsbG9wID0gbWluR2FsbG9wO1xuICAgICAgICAgICAgdmFyIGNvdW50MSwgY291bnQyLCBleGl0O1xuXG4gICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgIGNvdW50MSA9IDA7XG4gICAgICAgICAgICAgICAgY291bnQyID0gMDtcbiAgICAgICAgICAgICAgICBleGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGFycmF5W2N1cnNvcjJdLCB0bXBbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IGdhbGxvcFJpZ2h0KGFycmF5W2N1cnNvcjJdLCB0bXAsIGN1cnNvcjEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3QgKz0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yMSArPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGgxIC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb3VudDIgPSBnYWxsb3BMZWZ0KHRtcFtjdXJzb3IxXSwgYXJyYXksIGN1cnNvcjIsIGxlbmd0aDIsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCArPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IyICs9IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuXG4gICAgICAgICAgICBtaW5HYWxsb3AgPCAxICYmIChtaW5HYWxsb3AgPSAxKTtcblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcignbWVyZ2VMb3cgcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZUhpZ2ggKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDIgKyBpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnNvcjEgPSBzdGFydDEgKyBsZW5ndGgxIC0gMTtcbiAgICAgICAgICAgIHZhciBjdXJzb3IyID0gbGVuZ3RoMiAtIDE7XG4gICAgICAgICAgICB2YXIgZGVzdCA9IHN0YXJ0MiArIGxlbmd0aDIgLSAxO1xuICAgICAgICAgICAgdmFyIGN1c3RvbUN1cnNvciA9IDA7XG4gICAgICAgICAgICB2YXIgY3VzdG9tRGVzdCA9IDA7XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICAgICAgICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfbWluR2FsbG9wID0gbWluR2FsbG9wO1xuXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb3VudDEgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudDIgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBleGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKHRtcFtjdXJzb3IyXSwgYXJyYXlbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICgoY291bnQxIHwgY291bnQyKSA8IF9taW5HYWxsb3ApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDEgPSBsZW5ndGgxIC0gZ2FsbG9wUmlnaHQodG1wW2N1cnNvcjJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCBsZW5ndGgxIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCAtPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IxIC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGNvdW50MSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvdW50MiA9IGxlbmd0aDIgLSBnYWxsb3BMZWZ0KGFycmF5W2N1cnNvcjFdLCB0bXAsIDAsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0IC09IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjIgLT0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IyICsgMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gdG1wW2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuXG4gICAgICAgICAgICBpZiAobWluR2FsbG9wIDwgMSkge1xuICAgICAgICAgICAgICAgIG1pbkdhbGxvcCA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgICAgICAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUhpZ2ggcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tZXJnZVJ1bnMgPSBtZXJnZVJ1bnM7XG4gICAgICAgIHRoaXMuZm9yY2VNZXJnZVJ1bnMgPSBmb3JjZU1lcmdlUnVucztcbiAgICAgICAgdGhpcy5wdXNoUnVuID0gcHVzaFJ1bjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzb3J0KGFycmF5LCBjb21wYXJlLCBsbywgaGkpIHtcbiAgICAgICAgaWYgKCFsbykge1xuICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGkpIHtcbiAgICAgICAgICAgIGhpID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGhpIC0gbG87XG5cbiAgICAgICAgaWYgKHJlbWFpbmluZyA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBydW5MZW5ndGggPSAwO1xuXG4gICAgICAgIGlmIChyZW1haW5pbmcgPCBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgICAgICAgICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcbiAgICAgICAgICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRzID0gbmV3IFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpO1xuXG4gICAgICAgIHZhciBtaW5SdW4gPSBtaW5SdW5MZW5ndGgocmVtYWluaW5nKTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuICAgICAgICAgICAgaWYgKHJ1bkxlbmd0aCA8IG1pblJ1bikge1xuICAgICAgICAgICAgICAgIHZhciBmb3JjZSA9IHJlbWFpbmluZztcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2UgPiBtaW5SdW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2UgPSBtaW5SdW47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGxvICsgZm9yY2UsIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICAgICAgICAgICAgICBydW5MZW5ndGggPSBmb3JjZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHMucHVzaFJ1bihsbywgcnVuTGVuZ3RoKTtcbiAgICAgICAgICAgIHRzLm1lcmdlUnVucygpO1xuXG4gICAgICAgICAgICByZW1haW5pbmcgLT0gcnVuTGVuZ3RoO1xuICAgICAgICAgICAgbG8gKz0gcnVuTGVuZ3RoO1xuICAgICAgICB9IHdoaWxlIChyZW1haW5pbmcgIT09IDApO1xuXG4gICAgICAgIHRzLmZvcmNlTWVyZ2VSdW5zKCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzb3J0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvdGltc29ydC5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("'use strict';\n/**\n * 动画主类, 调度和管理所有动画控制器\n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = __webpack_require__(20);\n    var Dispatcher = __webpack_require__(104).Dispatcher;\n\n    var requestAnimationFrame = __webpack_require__(105);\n\n    var Animator = __webpack_require__(44);\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         * 添加 clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         * 添加 animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time, delta);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * 开始运行动画\n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * 停止运行动画\n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * 清除所有动画片段\n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] 是否循环播放动画\n         * @param  {Function} [options.getter=null]\n         *         如果指定getter函数，会通过getter函数取属性值\n         * @param  {Function} [options.setter=null]\n         *         如果指定setter函数，会通过setter函数设置属性值\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            this.addAnimator(animator);\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanM/ODc0MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsa0JBQWtCLFNBQVM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUE4QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQixrQ0FBa0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLGtDQUFrQztBQUNyRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiIxMDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIOWKqOeUu+S4u+exuywg6LCD5bqm5ZKM566h55CG5omA5pyJ5Yqo55S75o6n5Yi25ZmoXG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25cbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuLy8gVE9ETyBBZGRpdGl2ZSBhbmltYXRpb25cbi8vIGh0dHA6Ly9pb3NvdGVyaWMuY29tL2FkZGl0aXZlLWFuaW1hdGlvbnMtYW5pbWF0ZXdpdGhkdXJhdGlvbi1pbi1pb3MtOC9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS92aWRlb3Mvd3dkYzIwMTQvIzIzNlxuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpLkRpc3BhdGNoZXI7XG5cbiAgICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgnLi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcblxuICAgIHZhciBBbmltYXRvciA9IHJlcXVpcmUoJy4vQW5pbWF0b3InKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBJWlJlbmRlclN0YWdlXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXBkYXRlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbmZyYW1lXVxuICAgICAqIEBwYXJhbSB7SVpSZW5kZXJTdGFnZX0gW29wdGlvbnMuc3RhZ2VdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgdmFyIGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oKTtcbiAgICAgKiAgICAgdmFyIG9iaiA9IHtcbiAgICAgKiAgICAgICAgIHg6IDEwMCxcbiAgICAgKiAgICAgICAgIHk6IDEwMFxuICAgICAqICAgICB9O1xuICAgICAqICAgICBhbmltYXRpb24uYW5pbWF0ZShub2RlLnBvc2l0aW9uKVxuICAgICAqICAgICAgICAgLndoZW4oMTAwMCwge1xuICAgICAqICAgICAgICAgICAgIHg6IDUwMCxcbiAgICAgKiAgICAgICAgICAgICB5OiA1MDBcbiAgICAgKiAgICAgICAgIH0pXG4gICAgICogICAgICAgICAud2hlbigyMDAwLCB7XG4gICAgICogICAgICAgICAgICAgeDogMTAwLFxuICAgICAqICAgICAgICAgICAgIHk6IDEwMFxuICAgICAqICAgICAgICAgfSlcbiAgICAgKiAgICAgICAgIC5zdGFydCgnc3BsaW5lJyk7XG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5zdGFnZSA9IG9wdGlvbnMuc3RhZ2UgfHwge307XG5cbiAgICAgICAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICAgICAgLy8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMuX2NsaXBzID0gW107XG5cbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3RpbWU7XG5cbiAgICAgICAgdGhpcy5fcGF1c2VkVGltZTtcblxuICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0O1xuXG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIERpc3BhdGNoZXIuY2FsbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQW5pbWF0aW9uLFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75YqgIGNsaXBcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQ2xpcDogZnVuY3Rpb24gKGNsaXApIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaXBzLnB1c2goY2xpcCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqAgYW5pbWF0b3JcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9IGFuaW1hdG9yXG4gICAgICAgICAqL1xuICAgICAgICBhZGRBbmltYXRvcjogZnVuY3Rpb24gKGFuaW1hdG9yKSB7XG4gICAgICAgICAgICBhbmltYXRvci5hbmltYXRpb24gPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNsaXBzID0gYW5pbWF0b3IuZ2V0Q2xpcHMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENsaXAoY2xpcHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXB9IGNsaXBcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNsaXA6IGZ1bmN0aW9uKGNsaXApIHtcbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fY2xpcHMsIGNsaXApO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpcHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIoOmZpOWKqOeUu+eJh+autVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICAgICAgICAgIHZhciBjbGlwcyA9IGFuaW1hdG9yLmdldENsaXBzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDbGlwKGNsaXBzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHZhciB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9wYXVzZWRUaW1lO1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gdGltZSAtIHRoaXMuX3RpbWU7XG4gICAgICAgICAgICB2YXIgY2xpcHMgPSB0aGlzLl9jbGlwcztcbiAgICAgICAgICAgIHZhciBsZW4gPSBjbGlwcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHZhciBkZWZlcnJlZEV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkQ2xpcHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IGNsaXBzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBlID0gY2xpcC5zdGVwKHRpbWUsIGRlbHRhKTtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBvdXQgdGhlIGV2ZW50cyBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlclxuICAgICAgICAgICAgICAgIC8vIHN0YWdlLnVwZGF0ZSwgbGlrZSBkZXN0cm95XG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRFdmVudHMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDbGlwcy5wdXNoKGNsaXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBmaW5pc2hlZCBjbGlwXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xpcHNbaV0uX25lZWRzUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBzW2ldID0gY2xpcHNbbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGNsaXBzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlbiA9IGRlZmVycmVkRXZlbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZENsaXBzW2ldLmZpcmUoZGVmZXJyZWRFdmVudHNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl90aW1lID0gdGltZTtcblxuICAgICAgICAgICAgdGhpcy5vbmZyYW1lKGRlbHRhKTtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdmcmFtZScsIGRlbHRhKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhZ2UudXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfc3RhcnRMb29wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9ydW5uaW5nKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLl9wYXVzZWQgJiYgc2VsZi5fdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8gOWni+i/kOihjOWKqOeUu1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdGhpcy5fdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0TG9vcCgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5YGc5q2i6L+Q6KGM5Yqo55S7XG4gICAgICAgICAqL1xuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhdXNlXG4gICAgICAgICAqL1xuICAgICAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzdW1lXG4gICAgICAgICAqL1xuICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZWRUaW1lICs9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSkgLSB0aGlzLl9wYXVzZVN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaTmiYDmnInliqjnlLvniYfmrrVcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGlwcyA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5a+55LiA5Liq55uu5qCH5Yib5bu65LiA5LiqYW5pbWF0b3Llr7nosaHvvIzlj6/ku6XmjIflrprnm67moIfkuK3nmoTlsZ7mgKfkvb/nlKjliqjnlLtcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmxvb3A9ZmFsc2VdIOaYr+WQpuW+queOr+aSreaUvuWKqOeUu1xuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2V0dGVyPW51bGxdXG4gICAgICAgICAqICAgICAgICAg5aaC5p6c5oyH5a6aZ2V0dGVy5Ye95pWw77yM5Lya6YCa6L+HZ2V0dGVy5Ye95pWw5Y+W5bGe5oCn5YC8XG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb3B0aW9ucy5zZXR0ZXI9bnVsbF1cbiAgICAgICAgICogICAgICAgICDlpoLmnpzmjIflrppzZXR0ZXLlh73mlbDvvIzkvJrpgJrov4dzZXR0ZXLlh73mlbDorr7nva7lsZ7mgKflgLxcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvbn5BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE8gR2FwXG4gICAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9vcCxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmdldHRlcixcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNldHRlclxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5hZGRBbmltYXRvcihhbmltYXRvcik7XG5cbiAgICAgICAgICAgIHJldHVybiBhbmltYXRvcjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB1dGlsLm1peGluKEFuaW1hdGlvbiwgRGlzcGF0Y2hlcik7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGlvbjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("'use strict';\n/**\n * 事件辅助类\n * @module zrender/core/event\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = __webpack_require__(41);\n    var env = __webpack_require__(18);\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * preventDefault and stopPropagation.\n     * Notice: do not do that in zrender. Upper application\n     * do that if necessary.\n     *\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event对象\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // 做向上兼容\n        Dispatcher: Eventful\n    };\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZXZlbnQuanM/MjRmZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIOS6i+S7tui+heWKqeexu1xuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvZXZlbnRcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICovXG5cblxuICAgIHZhciBFdmVudGZ1bCA9IHJlcXVpcmUoJy4uL21peGluL0V2ZW50ZnVsJyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJy4vZW52Jyk7XG5cbiAgICB2YXIgaXNEb21MZXZlbDIgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpICYmICEhd2luZG93LmFkZEV2ZW50TGlzdGVuZXI7XG5cbiAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpIHtcbiAgICAgICAgLy8gQmxhY2tCZXJyeSA1LCBpT1MgMyAob3JpZ2luYWwgaVBob25lKSBkb24ndCBoYXZlIGdldEJvdW5kaW5nUmVjdFxuICAgICAgICByZXR1cm4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID8gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7bGVmdDogMCwgdG9wOiAwfTtcbiAgICB9XG5cbiAgICAvLyBgY2FsY3VsYXRlYCBpcyBvcHRpb25hbCwgZGVmYXVsdCBmYWxzZVxuICAgIGZ1bmN0aW9uIGNsaWVudFRvTG9jYWwoZWwsIGUsIG91dCwgY2FsY3VsYXRlKSB7XG4gICAgICAgIG91dCA9IG91dCB8fCB7fTtcblxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIFczQyBXb3JraW5nIERyYWZ0LCBvZmZzZXRYIGFuZCBvZmZzZXRZIHNob3VsZCBiZSByZWxhdGl2ZVxuICAgICAgICAvLyB0byB0aGUgcGFkZGluZyBlZGdlIG9mIHRoZSB0YXJnZXQgZWxlbWVudC4gVGhlIG9ubHkgYnJvd3NlciB1c2luZyB0aGlzIGNvbnZlbnRpb25cbiAgICAgICAgLy8gaXMgSUUuIFdlYmtpdCB1c2VzIHRoZSBib3JkZXIgZWRnZSwgT3BlcmEgdXNlcyB0aGUgY29udGVudCBlZGdlLCBhbmQgRmlyZUZveCBkb2VzXG4gICAgICAgIC8vIG5vdCBzdXBwb3J0IHRoZSBwcm9wZXJ0aWVzLlxuICAgICAgICAvLyAoc2VlIGh0dHA6Ly93d3cuamFja2xtb29yZS5jb20vbm90ZXMvbW91c2UtcG9zaXRpb24vKVxuICAgICAgICAvLyBJbiB6ciBwYWludGVyLmRvbSwgcGFkZGluZyBlZGdlIGVxdWFscyB0byBib3JkZXIgZWRnZS5cblxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBXaGVuIG1vdXNlbW92ZSBldmVudCB0cmlnZ2VyZWQgb24gZWMgdG9vbHRpcCwgdGFyZ2V0IGlzIG5vdCB6ciBwYWludGVyLmRvbSwgYW5kXG4gICAgICAgIC8vIG9mZnNldFgvWSBpcyByZWxhdGl2ZSB0byBlLnRhcmdldCwgd2hlcmUgdGhlIGNhbGN1bGF0aW9uIG9mIHpyWC9ZIHZpYSBvZmZzZXRYL1lcbiAgICAgICAgLy8gaXMgdG9vIGNvbXBsZXguIFNvIGNzcy10cmFuc2Zyb20gZG9udCBzdXBwb3J0IGluIHRoaXMgY2FzZSB0ZW1wb3JhcmlseS5cbiAgICAgICAgaWYgKGNhbGN1bGF0ZSB8fCAhZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2F1dGlvbjogSW4gRmlyZUZveCwgbGF5ZXJYL2xheWVyWSBNb3VzZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgY2xvc2VzdCBwb3NpdGlvbmVkXG4gICAgICAgIC8vIGFuY2VzdG9yIGVsZW1lbnQsIHNvIHdlIHNob3VsZCBtYWtlIHN1cmUgZWwgaXMgcG9zaXRpb25lZCAoZS5nLiwgbm90IHBvc2l0aW9uOnN0YXRpYykuXG4gICAgICAgIC8vIEJUVzEsIFdlYmtpdCBkb24ndCByZXR1cm4gdGhlIHNhbWUgcmVzdWx0cyBhcyBGRiBpbiBub24tc2ltcGxlIGNhc2VzIChsaWtlIGFkZFxuICAgICAgICAvLyB6b29tLWZhY3Rvciwgb3ZlcmZsb3cgLyBvcGFjaXR5IGxheWVycywgdHJhbnNmb3JtcyAuLi4pXG4gICAgICAgIC8vIEJUVzIsIChldi5vZmZzZXRZIHx8IGV2LnBhZ2VZIC0gJChldi50YXJnZXQpLm9mZnNldCgpLnRvcCkgaXMgbm90IGNvcnJlY3QgaW4gcHJlc2VydmUtM2QuXG4gICAgICAgIC8vIDxodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvODUyMyNjb21tZW50OjE0PlxuICAgICAgICAvLyBCVFczLCBJbiBmZiwgb2Zmc2V0WC9vZmZzZXRZIGlzIGFsd2F5cyAwLlxuICAgICAgICBlbHNlIGlmIChlbnYuYnJvd3Nlci5maXJlZm94ICYmIGUubGF5ZXJYICE9IG51bGwgJiYgZS5sYXllclggIT09IGUub2Zmc2V0WCkge1xuICAgICAgICAgICAgb3V0LnpyWCA9IGUubGF5ZXJYO1xuICAgICAgICAgICAgb3V0LnpyWSA9IGUubGF5ZXJZO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBJRTYrLCBjaHJvbWUsIHNhZmFyaSwgb3BlcmEuIChXaGVuIHdpbGwgZmYgc3VwcG9ydCBvZmZzZXRYPylcbiAgICAgICAgZWxzZSBpZiAoZS5vZmZzZXRYICE9IG51bGwpIHtcbiAgICAgICAgICAgIG91dC56clggPSBlLm9mZnNldFg7XG4gICAgICAgICAgICBvdXQuenJZID0gZS5vZmZzZXRZO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBzb21lIG90aGVyIGRldmljZSwgZS5nLiwgSU9TIHNhZmFyaS5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0R2V0WnJYWShlbCwgZSwgb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCkge1xuICAgICAgICAvLyBUaGlzIHdlbGwta25vd24gbWV0aG9kIGJlbG93IGRvZXMgbm90IHN1cHBvcnQgY3NzIHRyYW5zZm9ybS5cbiAgICAgICAgdmFyIGJveCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbCk7XG4gICAgICAgIG91dC56clggPSBlLmNsaWVudFggLSBib3gubGVmdDtcbiAgICAgICAgb3V0LnpyWSA9IGUuY2xpZW50WSAtIGJveC50b3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5aaC5p6c5a2Y5Zyo56ys5LiJ5pa55bWM5YWl55qE5LiA5LqbZG9t6Kem5Y+R55qE5LqL5Lu277yM5oiWdG91Y2jkuovku7bvvIzpnIDopoHovazmjaLkuIDkuIvkuovku7blnZDmoIcuXG4gICAgICogYGNhbGN1bGF0ZWAgaXMgb3B0aW9uYWwsIGRlZmF1bHQgZmFsc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplRXZlbnQoZWwsIGUsIGNhbGN1bGF0ZSkge1xuXG4gICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICAgICAgICBpZiAoZS56clggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXZlbnRUeXBlID0gZS50eXBlO1xuICAgICAgICB2YXIgaXNUb3VjaCA9IGV2ZW50VHlwZSAmJiBldmVudFR5cGUuaW5kZXhPZigndG91Y2gnKSA+PSAwO1xuXG4gICAgICAgIGlmICghaXNUb3VjaCkge1xuICAgICAgICAgICAgY2xpZW50VG9Mb2NhbChlbCwgZSwgZSwgY2FsY3VsYXRlKTtcbiAgICAgICAgICAgIGUuenJEZWx0YSA9IChlLndoZWVsRGVsdGEpID8gZS53aGVlbERlbHRhIC8gMTIwIDogLShlLmRldGFpbCB8fCAwKSAvIDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdG91Y2ggPSBldmVudFR5cGUgIT0gJ3RvdWNoZW5kJ1xuICAgICAgICAgICAgICAgID8gZS50YXJnZXRUb3VjaGVzWzBdXG4gICAgICAgICAgICAgICAgOiBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgdG91Y2ggJiYgY2xpZW50VG9Mb2NhbChlbCwgdG91Y2gsIGUsIGNhbGN1bGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChpc0RvbUxldmVsMikge1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJldmVudERlZmF1bHQgYW5kIHN0b3BQcm9wYWdhdGlvbi5cbiAgICAgKiBOb3RpY2U6IGRvIG5vdCBkbyB0aGF0IGluIHpyZW5kZXIuIFVwcGVyIGFwcGxpY2F0aW9uXG4gICAgICogZG8gdGhhdCBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9ldmVudFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIDogZXZlbnTlr7nosaFcbiAgICAgKi9cbiAgICB2YXIgc3RvcCA9IGlzRG9tTGV2ZWwyXG4gICAgICAgID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGNsaWVudFRvTG9jYWw6IGNsaWVudFRvTG9jYWwsXG4gICAgICAgIG5vcm1hbGl6ZUV2ZW50OiBub3JtYWxpemVFdmVudCxcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogYWRkRXZlbnRMaXN0ZW5lcixcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogcmVtb3ZlRXZlbnRMaXN0ZW5lcixcblxuICAgICAgICBzdG9wOiBzdG9wLFxuICAgICAgICAvLyDlgZrlkJHkuIrlhbzlrrlcbiAgICAgICAgRGlzcGF0Y2hlcjogRXZlbnRmdWxcbiAgICB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9ldmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("\n\n    module.exports = (typeof window !== 'undefined' &&\n                ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window))\n                // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\n                || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))\n                || window.mozRequestAnimationFrame\n                || window.webkitRequestAnimationFrame)\n            )\n            || function (func) {\n                setTimeout(func, 16);\n            };\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanM/NmQ4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEwNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAoKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykpXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2lzc3Vlcy8xODkjaXNzdWVjb21tZW50LTIyNDkxOTgwOVxuICAgICAgICAgICAgICAgIHx8ICh3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSlcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHx8IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jLCAxNik7XG4gICAgICAgICAgICB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("\n\n    var eventTool = __webpack_require__(104);\n    var zrUtil = __webpack_require__(20);\n    var Eventful = __webpack_require__(41);\n    var env = __webpack_require__(18);\n    var GestureMgr = __webpack_require__(107);\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerEventNames = {\n        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n    };\n\n    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n        var nm = name.replace('mouse', 'pointer');\n        return pointerEventNames[nm] ? nm : name;\n    });\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null).target,\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        // Do not do any preventDefault here. Upper application do that if necessary.\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement({target: gestureInfo.target}, type, gestureInfo.event);\n        }\n    }\n\n    // function onMSGestureChange(proxy, event) {\n    //     if (event.translationX || event.translationY) {\n    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n    //     }\n    //     if (event.scale !== 1) {\n    //         event.pinchX = event.offsetX;\n    //         event.pinchY = event.offsetY;\n    //         event.pinchScale = event.scale;\n    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n    //     }\n    // }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // 忽略包含在root中的dom引起的mouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch开始响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered, and must before `mousedown` triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch移动响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch结束响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        },\n\n        pointerdown: function (event) {\n            domHandlers.mousedown.call(this, event);\n\n            // if (useMSGuesture(this, event)) {\n            //     this._msGesture.addPointer(event.pointerId);\n            // }\n        },\n\n        pointermove: function (event) {\n            // FIXME\n            // pointermove is so sensitive that it always triggered when\n            // tap(click) on touch screen, which affect some judgement in\n            // upper application. So, we dont support mousemove on MS touch\n            // device yet.\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mousemove.call(this, event);\n            }\n        },\n\n        pointerup: function (event) {\n            domHandlers.mouseup.call(this, event);\n        },\n\n        pointerout: function (event) {\n            // pointerout will be triggered when tap on touch screen\n            // (IE11+/Edge on MS Surface) after click event triggered,\n            // which is inconsistent with the mousout behavior we defined\n            // in touchend. So we unify them.\n            // (check domHandlers.touchend for detailed explanation)\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n\n    // function useMSGuesture(handlerProxy, event) {\n    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n    // }\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * 为控制类实例初始化dom 事件处理函数\n     *\n     * @inner\n     * @param {module:zrender/Handler} instance 控制类实例\n     */\n    function initDomHandler(instance) {\n        zrUtil.each(touchHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(pointerHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(mouseHandlerNames, function (name) {\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        });\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (env.pointerEventsSupported) { // Only IE11+/Edge\n            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n            // at the same time.\n            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n            // screen, which do not occurs in pointer event.\n            // So we use pointer event to both detect touch gesture and mouse behavior.\n            mountHandlers(pointerHandlerNames, this);\n\n            // FIXME\n            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n            // which does not prevent defuault behavior occasionally (which may cause view port\n            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n            // touch screen. And we only support click behavior on MS touch screen now.\n\n            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n            // We dont support touch on IE on win7.\n            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n            // if (typeof MSGesture === 'function') {\n            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n            // }\n        }\n        else {\n            if (env.touchEventsSupported) {\n                mountHandlers(touchHandlerNames, this);\n                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n            }\n\n            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n            // mouse event can not be handle in those devices.\n            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n            // mouseevent after touch event triggered, see `setTouchTimer`.\n            mountHandlers(mouseHandlerNames, this);\n        }\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanM/MmZjNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QywyQkFBMkI7QUFDeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjEwNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi4vbWl4aW4vRXZlbnRmdWwnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi4vY29yZS9lbnYnKTtcbiAgICB2YXIgR2VzdHVyZU1nciA9IHJlcXVpcmUoJy4uL2NvcmUvR2VzdHVyZU1ncicpO1xuXG4gICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBldmVudFRvb2wuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGV2ZW50VG9vbC5yZW1vdmVFdmVudExpc3RlbmVyO1xuICAgIHZhciBub3JtYWxpemVFdmVudCA9IGV2ZW50VG9vbC5ub3JtYWxpemVFdmVudDtcblxuICAgIHZhciBUT1VDSF9DTElDS19ERUxBWSA9IDMwMDtcblxuICAgIHZhciBtb3VzZUhhbmRsZXJOYW1lcyA9IFtcbiAgICAgICAgJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLFxuICAgICAgICAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J1xuICAgIF07XG5cbiAgICB2YXIgdG91Y2hIYW5kbGVyTmFtZXMgPSBbXG4gICAgICAgICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZSdcbiAgICBdO1xuXG4gICAgdmFyIHBvaW50ZXJFdmVudE5hbWVzID0ge1xuICAgICAgICBwb2ludGVyZG93bjogMSwgcG9pbnRlcnVwOiAxLCBwb2ludGVybW92ZTogMSwgcG9pbnRlcm91dDogMVxuICAgIH07XG5cbiAgICB2YXIgcG9pbnRlckhhbmRsZXJOYW1lcyA9IHpyVXRpbC5tYXAobW91c2VIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBubSA9IG5hbWUucmVwbGFjZSgnbW91c2UnLCAncG9pbnRlcicpO1xuICAgICAgICByZXR1cm4gcG9pbnRlckV2ZW50TmFtZXNbbm1dID8gbm0gOiBuYW1lO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZXZlbnROYW1lRml4KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIChuYW1lID09PSAnbW91c2V3aGVlbCcgJiYgZW52LmJyb3dzZXIuZmlyZWZveCkgPyAnRE9NTW91c2VTY3JvbGwnIDogbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzR2VzdHVyZShwcm94eSwgZXZlbnQsIHN0YWdlKSB7XG4gICAgICAgIHZhciBnZXN0dXJlTWdyID0gcHJveHkuX2dlc3R1cmVNZ3I7XG5cbiAgICAgICAgc3RhZ2UgPT09ICdzdGFydCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpO1xuXG4gICAgICAgIHZhciBnZXN0dXJlSW5mbyA9IGdlc3R1cmVNZ3IucmVjb2duaXplKFxuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBwcm94eS5oYW5kbGVyLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbCkudGFyZ2V0LFxuICAgICAgICAgICAgcHJveHkuZG9tXG4gICAgICAgICk7XG5cbiAgICAgICAgc3RhZ2UgPT09ICdlbmQnICYmIGdlc3R1cmVNZ3IuY2xlYXIoKTtcblxuICAgICAgICAvLyBEbyBub3QgZG8gYW55IHByZXZlbnREZWZhdWx0IGhlcmUuIFVwcGVyIGFwcGxpY2F0aW9uIGRvIHRoYXQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAoZ2VzdHVyZUluZm8pIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZ2VzdHVyZUluZm8udHlwZTtcbiAgICAgICAgICAgIGV2ZW50Lmdlc3R1cmVFdmVudCA9IHR5cGU7XG5cbiAgICAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoe3RhcmdldDogZ2VzdHVyZUluZm8udGFyZ2V0fSwgdHlwZSwgZ2VzdHVyZUluZm8uZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24gb25NU0dlc3R1cmVDaGFuZ2UocHJveHksIGV2ZW50KSB7XG4gICAgLy8gICAgIGlmIChldmVudC50cmFuc2xhdGlvblggfHwgZXZlbnQudHJhbnNsYXRpb25ZKSB7XG4gICAgLy8gICAgICAgICAvLyBtb3VzZW1vdmUgaXMgY2FycmllZCBieSBNU0dlc3R1cmUgdG8gcmVkdWNlIHRoZSBzZW5zaXRpdml0eS5cbiAgICAvLyAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoZXZlbnQudGFyZ2V0LCAnbW91c2Vtb3ZlJywgZXZlbnQpO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmIChldmVudC5zY2FsZSAhPT0gMSkge1xuICAgIC8vICAgICAgICAgZXZlbnQucGluY2hYID0gZXZlbnQub2Zmc2V0WDtcbiAgICAvLyAgICAgICAgIGV2ZW50LnBpbmNoWSA9IGV2ZW50Lm9mZnNldFk7XG4gICAgLy8gICAgICAgICBldmVudC5waW5jaFNjYWxlID0gZXZlbnQuc2NhbGU7XG4gICAgLy8gICAgICAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KGV2ZW50LnRhcmdldCwgJ3BpbmNoJywgZXZlbnQpO1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gICAgLyoqXG4gICAgICogUHJldmVudCBtb3VzZSBldmVudCBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgYWZ0ZXIgVG91Y2ggRXZlbnRzIGFjdGlvblxuICAgICAqIEBzZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9kZWx0YWtvc2gvaGFuZGpzL2Jsb2IvbWFzdGVyL3NyYy9oYW5kLmJhc2UuanM+XG4gICAgICogMS4gTW9iaWxlIGJyb3dzZXJzIGRpc3BhdGNoIG1vdXNlIGV2ZW50cyAzMDBtcyBhZnRlciB0b3VjaGVuZC5cbiAgICAgKiAyLiBDaHJvbWUgZm9yIEFuZHJvaWQgZGlzcGF0Y2ggbW91c2Vkb3duIGZvciBsb25nLXRvdWNoIGFib3V0IDY1MG1zXG4gICAgICogUmVzdWx0OiBCbG9ja2luZyBNb3VzZSBFdmVudHMgZm9yIDcwMG1zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFRvdWNoVGltZXIoaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UuX3RvdWNoaW5nID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGluc3RhbmNlLl90b3VjaFRpbWVyKTtcbiAgICAgICAgaW5zdGFuY2UuX3RvdWNoVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl90b3VjaGluZyA9IGZhbHNlO1xuICAgICAgICB9LCA3MDApO1xuICAgIH1cblxuXG4gICAgdmFyIGRvbUhhbmRsZXJzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogTW91c2UgbW92ZSBoYW5kbGVyXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdtb3VzZW1vdmUnLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIG91dCBoYW5kbGVyXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5b+955Wl5YyF5ZCr5Zyocm9vdOS4reeahGRvbeW8lei1t+eahG1vdXNlT3V0XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2VvdXQnLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvdWNo5byA5aeL5ZON5bqU5Ye95pWwXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hzdGFydDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IG1vdXNlIGJlaGF2aW91ciBzaG91bGQgbm90IGJlIGRpc2FibGVkIGhlcmUuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgcGFnZSBtYXkgbmVlZHMgdG8gYmUgc2xpZGVkLlxuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgICAgICAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cbiAgICAgICAgICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnc3RhcnQnKTtcblxuICAgICAgICAgICAgLy8gSW4gdG91Y2ggZGV2aWNlLCB0cmlnZ2VyIGBtb3VzZW1vdmVgKGBtb3VzZW92ZXJgKSBzaG91bGRcbiAgICAgICAgICAgIC8vIGJlIHRyaWdnZXJlZCwgYW5kIG11c3QgYmVmb3JlIGBtb3VzZWRvd25gIHRyaWdnZXJlZC5cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOenu+WKqOWTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgICAgICAgICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG4gICAgICAgICAgICBldmVudC56ckJ5VG91Y2ggPSB0cnVlO1xuXG4gICAgICAgICAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ2NoYW5nZScpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBtb3ZlIHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBnZXN0cnVlIGV2ZW50LCBiZWNhdXNlIG1vdXNlIG1vdmUgYW5kIHBpbmNoIG1heVxuICAgICAgICAgICAgLy8gYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOe7k+adn+WTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoZW5kOiBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgICAgICAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cbiAgICAgICAgICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG5cbiAgICAgICAgICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnZW5kJyk7XG5cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNldXAuY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICAgICAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIGBtb3VzZW91dGAgaGVyZSwgaW4gc3BpdGUgb2YgYG1vdXNlbW92ZWAoYG1vdXNlb3ZlcmApIGlzXG4gICAgICAgICAgICAvLyB0cmlnZ2VyZWQgaW4gYHRvdWNoc3RhcnRgLiBUaGlzIHNlZW1zIHRvIGJlIGlsbG9naWNhbCwgYnV0IGJ5IHRoaXMgbWVjaGFuaXNtLFxuICAgICAgICAgICAgLy8gd2UgY2FuIGNvbnZlbmllbnRseSBpbXBsZW1lbnQgXCJob3ZlciBzdHlsZVwiIGluIGJvdGggUEMgYW5kIHRvdWNoIGRldmljZSBqdXN0XG4gICAgICAgICAgICAvLyBieSBsaXN0ZW5pbmcgdG8gYG1vdXNlb3ZlcmAgdG8gYWRkIFwiaG92ZXIgc3R5bGVcIiBhbmQgbGlzdGVuaW5nIHRvIGBtb3VzZW91dGBcbiAgICAgICAgICAgIC8vIHRvIHJlbW92ZSBcImhvdmVyIHN0eWxlXCIgb24gYW4gZWxlbWVudCwgd2l0aG91dCBhbnkgYWRkaXRpb25hbCBjb2RlIGZvclxuICAgICAgICAgICAgLy8gY29tcGF0aWJpbGl0eS4gKGBtb3VzZW91dGAgd2lsbCBub3QgYmUgdHJpZ2dlcmVkIGluIGB0b3VjaGVuZGAsIHNvIFwiaG92ZXJcbiAgICAgICAgICAgIC8vIHN0eWxlXCIgd2lsbCByZW1haW4gZm9yIHVzZXIgdmlldylcblxuICAgICAgICAgICAgLy8gY2xpY2sgZXZlbnQgc2hvdWxkIGFsd2F5cyBiZSB0cmlnZ2VyZWQgbm8gbWF0dGVyIHdoZXRoZXJcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQuIFN5c3RlbSBjbGljayBjYW4gbm90IGJlIHByZXZlbnRlZC5cbiAgICAgICAgICAgIGlmICgrbmV3IERhdGUoKSAtIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA8IFRPVUNIX0NMSUNLX0RFTEFZKSB7XG4gICAgICAgICAgICAgICAgZG9tSGFuZGxlcnMuY2xpY2suY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9pbnRlcmRvd246IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBpZiAodXNlTVNHdWVzdHVyZSh0aGlzLCBldmVudCkpIHtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLl9tc0dlc3R1cmUuYWRkUG9pbnRlcihldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyBwb2ludGVybW92ZSBpcyBzbyBzZW5zaXRpdmUgdGhhdCBpdCBhbHdheXMgdHJpZ2dlcmVkIHdoZW5cbiAgICAgICAgICAgIC8vIHRhcChjbGljaykgb24gdG91Y2ggc2NyZWVuLCB3aGljaCBhZmZlY3Qgc29tZSBqdWRnZW1lbnQgaW5cbiAgICAgICAgICAgIC8vIHVwcGVyIGFwcGxpY2F0aW9uLiBTbywgd2UgZG9udCBzdXBwb3J0IG1vdXNlbW92ZSBvbiBNUyB0b3VjaFxuICAgICAgICAgICAgLy8gZGV2aWNlIHlldC5cbiAgICAgICAgICAgIGlmICghaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludGVydXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludGVyb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIHBvaW50ZXJvdXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0YXAgb24gdG91Y2ggc2NyZWVuXG4gICAgICAgICAgICAvLyAoSUUxMSsvRWRnZSBvbiBNUyBTdXJmYWNlKSBhZnRlciBjbGljayBldmVudCB0cmlnZ2VyZWQsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgbW91c291dCBiZWhhdmlvciB3ZSBkZWZpbmVkXG4gICAgICAgICAgICAvLyBpbiB0b3VjaGVuZC4gU28gd2UgdW5pZnkgdGhlbS5cbiAgICAgICAgICAgIC8vIChjaGVjayBkb21IYW5kbGVycy50b3VjaGVuZCBmb3IgZGV0YWlsZWQgZXhwbGFuYXRpb24pXG4gICAgICAgICAgICBpZiAoIWlzUG9pbnRlckZyb21Ub3VjaChldmVudCkpIHtcbiAgICAgICAgICAgICAgICBkb21IYW5kbGVycy5tb3VzZW91dC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICAgIHJldHVybiBwb2ludGVyVHlwZSA9PT0gJ3BlbicgfHwgcG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24gdXNlTVNHdWVzdHVyZShoYW5kbGVyUHJveHksIGV2ZW50KSB7XG4gICAgLy8gICAgIHJldHVybiBpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpICYmICEhaGFuZGxlclByb3h5Ll9tc0dlc3R1cmU7XG4gICAgLy8gfVxuXG4gICAgLy8gQ29tbW9uIGhhbmRsZXJzXG4gICAgenJVdGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJywgJ2NvbnRleHRtZW51J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGRvbUhhbmRsZXJzW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobmFtZSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICog5Li65o6n5Yi257G75a6e5L6L5Yid5aeL5YyWZG9tIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAqXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9IYW5kbGVyfSBpbnN0YW5jZSDmjqfliLbnsbvlrp7kvotcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0RG9tSGFuZGxlcihpbnN0YW5jZSkge1xuICAgICAgICB6clV0aWwuZWFjaCh0b3VjaEhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IHpyVXRpbC5iaW5kKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHpyVXRpbC5lYWNoKHBvaW50ZXJIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSB6clV0aWwuYmluZChkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICB6clV0aWwuZWFjaChtb3VzZUhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IG1ha2VNb3VzZUhhbmRsZXIoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZU1vdXNlSGFuZGxlcihmbiwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLl90b3VjaGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIEhhbmRsZXJEb21Qcm94eShkb20pIHtcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90b3VjaGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdG91Y2hUaW1lcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvR2VzdHVyZU1ncn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2dlc3R1cmVNZ3IgPSBuZXcgR2VzdHVyZU1ncigpO1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XG5cbiAgICAgICAgaW5pdERvbUhhbmRsZXIodGhpcyk7XG5cbiAgICAgICAgaWYgKGVudi5wb2ludGVyRXZlbnRzU3VwcG9ydGVkKSB7IC8vIE9ubHkgSUUxMSsvRWRnZVxuICAgICAgICAgICAgLy8gMS4gT24gZGV2aWNlcyB0aGF0IGJvdGggZW5hYmxlIHRvdWNoIGFuZCBtb3VzZSAoZS5nLiwgTVMgU3VyZmFjZSBhbmQgbGVub3ZvIFgyNDApLFxuICAgICAgICAgICAgLy8gSUUxMSsvRWRnZSBkbyBub3QgdHJpZ2dlciB0b3VjaCBldmVudCwgYnV0IHRyaWdnZXIgcG9pbnRlciBldmVudCBhbmQgbW91c2UgZXZlbnRcbiAgICAgICAgICAgIC8vIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgICAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBpdCBwcm9iYWJsZWx5IG9ubHkgdHJpZ2dlciBtb3VzZWRvd24gYnV0IG5vIG1vdXNldXAgd2hlbiB0YXAgb25cbiAgICAgICAgICAgIC8vIHNjcmVlbiwgd2hpY2ggZG8gbm90IG9jY3VycyBpbiBwb2ludGVyIGV2ZW50LlxuICAgICAgICAgICAgLy8gU28gd2UgdXNlIHBvaW50ZXIgZXZlbnQgdG8gYm90aCBkZXRlY3QgdG91Y2ggZ2VzdHVyZSBhbmQgbW91c2UgYmVoYXZpb3IuXG4gICAgICAgICAgICBtb3VudEhhbmRsZXJzKHBvaW50ZXJIYW5kbGVyTmFtZXMsIHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgLy8gTm90ZTogTVMgR2VzdHVyZSByZXF1aXJlIENTUyB0b3VjaC1hY3Rpb24gc2V0LiBCdXQgdG91Y2gtYWN0aW9uIGlzIG5vdCByZWxpYWJsZSxcbiAgICAgICAgICAgIC8vIHdoaWNoIGRvZXMgbm90IHByZXZlbnQgZGVmdWF1bHQgYmVoYXZpb3Igb2NjYXNpb25hbGx5ICh3aGljaCBtYXkgY2F1c2UgdmlldyBwb3J0XG4gICAgICAgICAgICAvLyB6b29tZWQgaW4gYnV0IHVzZSBjYW4gbm90IHpvb20gaXQgYmFjaykuIEFuZCBldmVudC5wcmV2ZW50RGVmYXVsdCgpIGRvZXMgbm90IHdvcmsuXG4gICAgICAgICAgICAvLyBTbyB3ZSBoYXZlIHRvIG5vdCB0byB1c2UgTVNHZXN0dXJlIGFuZCBub3QgdG8gc3VwcG9ydCB0b3VjaG1vdmUgYW5kIHBpbmNoIG9uIE1TXG4gICAgICAgICAgICAvLyB0b3VjaCBzY3JlZW4uIEFuZCB3ZSBvbmx5IHN1cHBvcnQgY2xpY2sgYmVoYXZpb3Igb24gTVMgdG91Y2ggc2NyZWVuIG5vdy5cblxuICAgICAgICAgICAgLy8gTVMgR2VzdHVyZSBFdmVudCBpcyBvbmx5IHN1cHBvcnRlZCBvbiBJRTExKy9FZGdlIGFuZCBvbiBXaW5kb3dzIDgrLlxuICAgICAgICAgICAgLy8gV2UgZG9udCBzdXBwb3J0IHRvdWNoIG9uIElFIG9uIHdpbjcuXG4gICAgICAgICAgICAvLyBTZWUgPGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDModj12cy44NSkuYXNweD5cbiAgICAgICAgICAgIC8vIGlmICh0eXBlb2YgTVNHZXN0dXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyAgICAgKHRoaXMuX21zR2VzdHVyZSA9IG5ldyBNU0dlc3R1cmUoKSkudGFyZ2V0ID0gZG9tOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgIC8vICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignTVNHZXN0dXJlQ2hhbmdlJywgb25NU0dlc3R1cmVDaGFuZ2UpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVudi50b3VjaEV2ZW50c1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIG1vdW50SGFuZGxlcnModG91Y2hIYW5kbGVyTmFtZXMsIHRoaXMpO1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZXIgb2YgJ21vdXNlb3V0JyBldmVudCBpcyBuZWVkZWQgaW4gdG91Y2ggbW9kZSwgd2hpY2ggd2lsbCBiZSBtb3VudGVkIGJlbG93LlxuICAgICAgICAgICAgICAgIC8vIGFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ21vdXNlb3V0JywgdGhpcy5fbW91c2VvdXRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMS4gQ29uc2lkZXJpbmcgc29tZSBkZXZpY2VzIHRoYXQgYm90aCBlbmFibGUgdG91Y2ggYW5kIG1vdXNlIGV2ZW50IChsaWtlIG9uIE1TIFN1cmZhY2VcbiAgICAgICAgICAgIC8vIGFuZCBsZW5vdm8gWDI0MCwgQHNlZSAjMjM1MCksIHdlIG1ha2UgbW91c2UgZXZlbnQgYmUgYWx3YXlzIGxpc3RlbmVkLCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIG1vdXNlIGV2ZW50IGNhbiBub3QgYmUgaGFuZGxlIGluIHRob3NlIGRldmljZXMuXG4gICAgICAgICAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBDaHJvbWUgd2lsbCB0cmlnZ2VyIGJvdGggdG91Y2ggZXZlbnQgYW5kIG1vdXNlIGV2ZW50LiBIb3cgdG8gcHJldmVudFxuICAgICAgICAgICAgLy8gbW91c2VldmVudCBhZnRlciB0b3VjaCBldmVudCB0cmlnZ2VyZWQsIHNlZSBgc2V0VG91Y2hUaW1lcmAuXG4gICAgICAgICAgICBtb3VudEhhbmRsZXJzKG1vdXNlSGFuZGxlck5hbWVzLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1vdW50SGFuZGxlcnMoaGFuZGxlck5hbWVzLCBpbnN0YW5jZSkge1xuICAgICAgICAgICAgenJVdGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZG9tLCBldmVudE5hbWVGaXgobmFtZSksIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSk7XG4gICAgICAgICAgICB9LCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlckRvbVByb3h5UHJvdG8gPSBIYW5kbGVyRG9tUHJveHkucHJvdG90eXBlO1xuICAgIGhhbmRsZXJEb21Qcm94eVByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYW5kbGVyTmFtZXMgPSBtb3VzZUhhbmRsZXJOYW1lcy5jb25jYXQodG91Y2hIYW5kbGVyTmFtZXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGhhbmRsZXJOYW1lc1tpXTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5kb20sIGV2ZW50TmFtZUZpeChuYW1lKSwgdGhpcy5faGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGhhbmRsZXJEb21Qcm94eVByb3RvLnNldEN1cnNvciA9IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS5jdXJzb3IgPSBjdXJzb3JTdHlsZSB8fCAnZGVmYXVsdCc7XG4gICAgfTtcblxuICAgIHpyVXRpbC5taXhpbihIYW5kbGVyRG9tUHJveHksIEV2ZW50ZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlckRvbVByb3h5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("'use strict';\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = __webpack_require__(104);\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvR2VzdHVyZU1nci5qcz8wMGZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFEO0FBQ3JELHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTA3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBPbmx5IGltcGxlbWVudHMgbmVlZGVkIGdlc3R1cmVzIGZvciBtb2JpbGUuXG4gKi9cblxuXG4gICAgdmFyIGV2ZW50VXRpbCA9IHJlcXVpcmUoJy4vZXZlbnQnKTtcblxuICAgIHZhciBHZXN0dXJlTWdyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90cmFjayA9IFtdO1xuICAgIH07XG5cbiAgICBHZXN0dXJlTWdyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogR2VzdHVyZU1ncixcblxuICAgICAgICByZWNvZ25pemU6IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0LCByb290KSB7XG4gICAgICAgICAgICB0aGlzLl9kb1RyYWNrKGV2ZW50LCB0YXJnZXQsIHJvb3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29nbml6ZShldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBfZG9UcmFjazogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICAgICAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcztcblxuICAgICAgICAgICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdHJhY2tJdGVtID0ge1xuICAgICAgICAgICAgICAgIHBvaW50czogW10sXG4gICAgICAgICAgICAgICAgdG91Y2hlczogW10sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG91Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IGV2ZW50VXRpbC5jbGllbnRUb0xvY2FsKHJvb3QsIHRvdWNoLCB7fSk7XG4gICAgICAgICAgICAgICAgdHJhY2tJdGVtLnBvaW50cy5wdXNoKFtwb3MuenJYLCBwb3MuenJZXSk7XG4gICAgICAgICAgICAgICAgdHJhY2tJdGVtLnRvdWNoZXMucHVzaCh0b3VjaCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3RyYWNrLnB1c2godHJhY2tJdGVtKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcmVjb2duaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiByZWNvZ25pemVycykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNvZ25pemVycy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXN0dXJlSW5mbyA9IHJlY29nbml6ZXJzW2V2ZW50TmFtZV0odGhpcy5fdHJhY2ssIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlc3R1cmVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VzdHVyZUluZm87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZGlzdChwb2ludFBhaXIpIHtcbiAgICAgICAgdmFyIGR4ID0gcG9pbnRQYWlyWzFdWzBdIC0gcG9pbnRQYWlyWzBdWzBdO1xuICAgICAgICB2YXIgZHkgPSBwb2ludFBhaXJbMV1bMV0gLSBwb2ludFBhaXJbMF1bMV07XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2VudGVyKHBvaW50UGFpcikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKHBvaW50UGFpclswXVswXSArIHBvaW50UGFpclsxXVswXSkgLyAyLFxuICAgICAgICAgICAgKHBvaW50UGFpclswXVsxXSArIHBvaW50UGFpclsxXVsxXSkgLyAyXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgdmFyIHJlY29nbml6ZXJzID0ge1xuXG4gICAgICAgIHBpbmNoOiBmdW5jdGlvbiAodHJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tMZW4gPSB0cmFjay5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICghdHJhY2tMZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwaW5jaEVuZCA9ICh0cmFja1t0cmFja0xlbiAtIDFdIHx8IHt9KS5wb2ludHM7XG4gICAgICAgICAgICB2YXIgcGluY2hQcmUgPSAodHJhY2tbdHJhY2tMZW4gLSAyXSB8fCB7fSkucG9pbnRzIHx8IHBpbmNoRW5kO1xuXG4gICAgICAgICAgICBpZiAocGluY2hQcmVcbiAgICAgICAgICAgICAgICAmJiBwaW5jaFByZS5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgJiYgcGluY2hFbmRcbiAgICAgICAgICAgICAgICAmJiBwaW5jaEVuZC5sZW5ndGggPiAxXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgcGluY2hTY2FsZSA9IGRpc3QocGluY2hFbmQpIC8gZGlzdChwaW5jaFByZSk7XG4gICAgICAgICAgICAgICAgIWlzRmluaXRlKHBpbmNoU2NhbGUpICYmIChwaW5jaFNjYWxlID0gMSk7XG5cbiAgICAgICAgICAgICAgICBldmVudC5waW5jaFNjYWxlID0gcGluY2hTY2FsZTtcblxuICAgICAgICAgICAgICAgIHZhciBwaW5jaENlbnRlciA9IGNlbnRlcihwaW5jaEVuZCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucGluY2hYID0gcGluY2hDZW50ZXJbMF07XG4gICAgICAgICAgICAgICAgZXZlbnQucGluY2hZID0gcGluY2hDZW50ZXJbMV07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGluY2gnLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRyYWNrWzBdLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgcGluY2ggY3VycmVudGx5LlxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdlc3R1cmVNZ3I7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("'use strict';\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = __webpack_require__(50);\n    var util = __webpack_require__(20);\n    var log = __webpack_require__(49);\n    var BoundingRect = __webpack_require__(25);\n    var timsort = __webpack_require__(102);\n\n    var Layer = __webpack_require__(109);\n\n    var requestAnimationFrame = __webpack_require__(105);\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.__builtin__) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n\n            clipPath.setTransform(ctx);\n            ctx.beginPath();\n            clipPath.buildPath(ctx, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root 绘图容器\n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * 绘图容器\n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            if (opts.width != null) {\n                root.width = opts.width;\n            }\n            if (opts.height != null) {\n                root.height = opts.height;\n            }\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n\n            this._domRoot = root;\n        }\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._domRoot;\n        },\n\n        /**\n         * 刷新\n         * @param {boolean} [paintAll=false] 强制绘制所有displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.__builtin__ && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuiltinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuiltinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.__builtin__) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.__builtin__ = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            layersMap[zlevel] = layer;\n\n            // Vitual layer will not directly show on the screen.\n            // (It can be a WebGL layer and assigned to a ZImage element)\n            // But it still under management of zrender.\n            if (!layer.virtual) {\n                if (prevLayer) {\n                    var prevDom = prevLayer.dom;\n                    if (prevDom.nextSibling) {\n                        domRoot.insertBefore(\n                            layer.dom,\n                            prevDom.nextSibling\n                        );\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n                else {\n                    if (domRoot.firstChild) {\n                        domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n            }\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuiltinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (!layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * 获取所有已创建的层\n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuiltinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // 层中的元素数量有发生变化\n            this.eachBuiltinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * 清除hover层外所有内容\n         */\n        clear: function () {\n            this.eachBuiltinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * 修改指定zlevel的绘制参数\n         *\n         * @param {string} zlevel\n         * @param {Object} config 配置对象\n         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * 删除指定层\n         * @param {number} zlevel 层所在的zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * 区域大小变化后重绘\n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // 优化没有实际改变的resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * 清除单独的一个层\n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * 释放\n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            var zlevel;\n\n            var self = this;\n            function findAndDrawOtherLayer(smaller, larger) {\n                var zlevelList = self._zlevelList;\n                if (smaller == null) {\n                    smaller = -Infinity;\n                }\n                var intermediateLayer;\n                for (var i = 0; i < zlevelList.length; i++) {\n                    var z = zlevelList[i];\n                    var layer = self._layers[z];\n                    if (!layer.__builtin__ && z > smaller && z < larger) {\n                        intermediateLayer = layer;\n                        break;\n                    }\n                }\n                if (intermediateLayer && intermediateLayer.renderToCanvas) {\n                    imageLayer.ctx.save();\n                    intermediateLayer.renderToCanvas(imageLayer.ctx);\n                    imageLayer.ctx.restore();\n                }\n            }\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n\n                if (el.zlevel !== zlevel) {\n                    findAndDrawOtherLayer(zlevel, el.zlevel);\n                    zlevel = el.zlevel;\n                }\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            findAndDrawOtherLayer(zlevel, Infinity);\n\n            return imageLayer.dom;\n        },\n        /**\n         * 获取绘图区域宽度\n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * 获取绘图区域高度\n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        pathToImage: function (path, dpr) {\n            dpr = dpr || this.dpr;\n\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            var rect = path.getBoundingRect();\n            var style = path.style;\n            var shadowBlurSize = style.shadowBlur;\n            var shadowOffsetX = style.shadowOffsetX;\n            var shadowOffsetY = style.shadowOffsetY;\n            var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\n            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n            var width = rect.width + leftMargin + rightMargin;\n            var height = rect.height + topMargin + bottomMargin;\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.scale(dpr, dpr);\n            ctx.clearRect(0, 0, width, height);\n            ctx.dpr = dpr;\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [leftMargin - rect.x, topMargin - rect.y];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            path.updateTransform();\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = __webpack_require__(65);\n            var imgShape = new ImageShape({\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        }\n    };\n\n    module.exports = Painter;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL1BhaW50ZXIuanM/ZWU5OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxZQUFZOztBQUV0RDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjEwOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogRGVmYXVsdCBjYW52YXMgcGFpbnRlclxuICogQG1vZHVsZSB6cmVuZGVyL1BhaW50ZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbiBcblxuICAgIHZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbG9nID0gcmVxdWlyZSgnLi9jb3JlL2xvZycpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIHRpbXNvcnQgPSByZXF1aXJlKCcuL2NvcmUvdGltc29ydCcpO1xuXG4gICAgdmFyIExheWVyID0gcmVxdWlyZSgnLi9MYXllcicpO1xuXG4gICAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xuXG4gICAgLy8gUEVORElHTlxuICAgIC8vIExheWVyIGV4Y2VlZHMgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiBtYXkgaGF2ZSBzb21lIHByb2JsZW0gd2hlbiBmbHVzaCBkaXJlY3RseSBzZWNvbmQgdGltZS5cbiAgICAvL1xuICAgIC8vIE1heGltdW0gcHJvZ3Jlc3NpdmUgbGF5ZXIuIFdoZW4gZXhjZWVkaW5nIHRoaXMgbnVtYmVyLiBBbGwgZWxlbWVudHMgd2lsbCBiZSBkcmF3ZWQgaW4gdGhlIGxhc3QgbGF5ZXIuXG4gICAgdmFyIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgPSA1O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQxMCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGF5ZXJWYWxpZChsYXllcikge1xuICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihsYXllci5yZXNpemUpICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICB8fCB0eXBlb2YobGF5ZXIucmVmcmVzaCkgIT09ICdmdW5jdGlvbidcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuX191bnVzZWRDb3VudCsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc3RQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgaWYgKGxheWVyLl9fdW51c2VkQ291bnQgPT0gMSkge1xuICAgICAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICB2YXIgdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgIGZ1bmN0aW9uIGlzRGlzcGxheWFibGVDdWxsZWQoZWwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KGVsLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgaWYgKGVsLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHZpZXdSZWN0LndpZHRoID0gd2lkdGg7XG4gICAgICAgIHZpZXdSZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuICF0bXBSZWN0LmludGVyc2VjdCh2aWV3UmVjdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBwcmV2Q2xpcFBhdGhzKSB7XG4gICAgICAgIGlmIChjbGlwUGF0aHMgPT0gcHJldkNsaXBQYXRocykgeyAvLyBDYW4gYm90aCBiZSBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjbGlwUGF0aHMgfHwgIXByZXZDbGlwUGF0aHMgfHwgKGNsaXBQYXRocy5sZW5ndGggIT09IHByZXZDbGlwUGF0aHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvQ2xpcChjbGlwUGF0aHMsIGN0eCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gY2xpcFBhdGhzW2ldO1xuXG4gICAgICAgICAgICBjbGlwUGF0aC5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNsaXBQYXRoLmJ1aWxkUGF0aChjdHgsIGNsaXBQYXRoLnNoYXBlKTtcbiAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gYmFja1xuICAgICAgICAgICAgY2xpcFBhdGgucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUm9vdCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBkb21Sb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgLy8gZG9tUm9vdC5vbnNlbGVjdHN0YXJ0ID0gcmV0dXJuRmFsc2U7IC8vIOmBv+WFjemhtemdoumAieS4reeahOWwtOWwrFxuICAgICAgICBkb21Sb290LnN0eWxlLmNzc1RleHQgPSBbXG4gICAgICAgICAgICAncG9zaXRpb246cmVsYXRpdmUnLFxuICAgICAgICAgICAgJ292ZXJmbG93OmhpZGRlbicsXG4gICAgICAgICAgICAnd2lkdGg6JyArIHdpZHRoICsgJ3B4JyxcbiAgICAgICAgICAgICdoZWlnaHQ6JyArIGhlaWdodCArICdweCcsXG4gICAgICAgICAgICAncGFkZGluZzowJyxcbiAgICAgICAgICAgICdtYXJnaW46MCcsXG4gICAgICAgICAgICAnYm9yZGVyLXdpZHRoOjAnXG4gICAgICAgIF0uam9pbignOycpICsgJzsnO1xuXG4gICAgICAgIHJldHVybiBkb21Sb290O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9QYWludGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcm9vdCDnu5jlm77lrrnlmahcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2VcbiAgICAgKiBAcGFyYW0ge09qYmVjdH0gb3B0c1xuICAgICAqL1xuICAgIHZhciBQYWludGVyID0gZnVuY3Rpb24gKHJvb3QsIHN0b3JhZ2UsIG9wdHMpIHtcbiAgICAgICAgLy8gSW4gbm9kZSBlbnZpcm9ubWVudCB1c2luZyBub2RlLWNhbnZhc1xuICAgICAgICB2YXIgc2luZ2xlQ2FudmFzID0gIXJvb3Qubm9kZU5hbWUgLy8gSW4gbm9kZSA/XG4gICAgICAgICAgICB8fCByb290Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdDQU5WQVMnO1xuXG4gICAgICAgIHRoaXMuX29wdHMgPSBvcHRzID0gdXRpbC5leHRlbmQoe30sIG9wdHMgfHwge30pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcHIgPSBvcHRzLmRldmljZVBpeGVsUmF0aW8gfHwgY29uZmlnLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NpbmdsZUNhbnZhcyA9IHNpbmdsZUNhbnZhcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe7mOWbvuWuueWZqFxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuXG4gICAgICAgIHZhciByb290U3R5bGUgPSByb290LnN0eWxlO1xuXG4gICAgICAgIGlmIChyb290U3R5bGUpIHtcbiAgICAgICAgICAgIHJvb3RTdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgcm9vdFN0eWxlWyctd2Via2l0LXVzZXItc2VsZWN0J10gPVxuICAgICAgICAgICAgcm9vdFN0eWxlWyd1c2VyLXNlbGVjdCddID1cbiAgICAgICAgICAgIHJvb3RTdHlsZVsnLXdlYmtpdC10b3VjaC1jYWxsb3V0J10gPSAnbm9uZSc7XG5cbiAgICAgICAgICAgIHJvb3QuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3QgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6enJlbmRlci9MYXllcj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgT2JqZWN0Pn1cbiAgICAgICAgICogQHR5cGUge3ByaXZhdGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXllckNvbmZpZyA9IHt9O1xuXG4gICAgICAgIGlmICghc2luZ2xlQ2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLl9nZXRTaXplKDEpO1xuXG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3QgPSBjcmVhdGVSb290KFxuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByb290LmFwcGVuZENoaWxkKGRvbVJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdHMud2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJvb3Qud2lkdGggPSBvcHRzLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByb290LmhlaWdodCA9IG9wdHMuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0IGRpcmVjdGx5XG4gICAgICAgICAgICB2YXIgd2lkdGggPSByb290LndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHJvb3QuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGxheWVyIGlmIG9ubHkgb25lIGdpdmVuIGNhbnZhc1xuICAgICAgICAgICAgLy8gRGV2aWNlIHBpeGVsIHJhdGlvIGlzIGZpeGVkIHRvIDEgYmVjYXVzZSBnaXZlbiBjYW52YXMgaGFzIGl0cyBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgdmFyIG1haW5MYXllciA9IG5ldyBMYXllcihyb290LCB0aGlzLCAxKTtcbiAgICAgICAgICAgIG1haW5MYXllci5pbml0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gRklYTUUgVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgICAvLyBtYWluTGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgbGF5ZXJzWzBdID0gbWFpbkxheWVyO1xuICAgICAgICAgICAgemxldmVsTGlzdC5wdXNoKDApO1xuXG4gICAgICAgICAgICB0aGlzLl9kb21Sb290ID0gcm9vdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExheWVycyBmb3IgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nXG4gICAgICAgIHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9MYXllcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hvdmVybGF5ZXI7XG5cbiAgICAgICAgdGhpcy5faG92ZXJFbGVtZW50cyA9IFtdO1xuICAgIH07XG5cbiAgICBQYWludGVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogUGFpbnRlcixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgcGFpbnRlciB1c2UgYSBzaW5nbGUgY2FudmFzXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc1NpbmdsZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbmdsZUNhbnZhcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0hUTUxEaXZFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9tUm9vdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yi35pawXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhaW50QWxsPWZhbHNlXSDlvLrliLbnu5jliLbmiYDmnIlkaXNwbGF5YWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24gKHBhaW50QWxsKSB7XG5cbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG5cbiAgICAgICAgICAgIHRoaXMuX3BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICAgICAgICAgIC8vIFBhaW50IGN1c3R1bSBsYXllcnNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllci5fX2J1aWx0aW5fXyAmJiBsYXllci5yZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFByb2dlc3NpdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkSG92ZXI6IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSkge1xuICAgICAgICAgICAgaWYgKGVsLl9faG92ZXJNaXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZWxNaXJyb3IgPSBuZXcgZWwuY29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgICAgIHN0eWxlOiBlbC5zdHlsZSxcbiAgICAgICAgICAgICAgICBzaGFwZTogZWwuc2hhcGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWxNaXJyb3IuX19mcm9tID0gZWw7XG4gICAgICAgICAgICBlbC5fX2hvdmVyTWlyID0gZWxNaXJyb3I7XG4gICAgICAgICAgICBlbE1pcnJvci5zZXRTdHlsZShob3ZlclN0eWxlKTtcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyRWxlbWVudHMucHVzaChlbE1pcnJvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGVsTWlycm9yID0gZWwuX19ob3Zlck1pcjtcbiAgICAgICAgICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YoaG92ZXJFbGVtZW50cywgZWxNaXJyb3IpO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFySG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3ZlckVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSBob3ZlckVsZW1lbnRzW2ldLl9fZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvdmVyRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgfSxcblxuICAgICAgICByZWZyZXNoSG92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICAgICAgICAgIHZhciBsZW4gPSBob3ZlckVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllcjtcbiAgICAgICAgICAgIGhvdmVyTGF5ZXIgJiYgaG92ZXJMYXllci5jbGVhcigpO1xuXG4gICAgICAgICAgICBpZiAoIWxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbXNvcnQoaG92ZXJFbGVtZW50cywgdGhpcy5zdG9yYWdlLmRpc3BsYXlhYmxlU29ydEZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBVc2UgYSBleHRyZWFtIGxhcmdlIHpsZXZlbFxuICAgICAgICAgICAgLy8gRklYTUU/XG4gICAgICAgICAgICBpZiAoIWhvdmVyTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllciA9IHRoaXMuZ2V0TGF5ZXIoMWU1KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNjb3BlID0ge307XG4gICAgICAgICAgICBob3ZlckxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBob3ZlckVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEVsID0gZWwuX19mcm9tO1xuICAgICAgICAgICAgICAgIC8vIE9yaWdpbmFsIGVsIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAgICAgaWYgKCEob3JpZ2luYWxFbCAmJiBvcmlnaW5hbEVsLl9fenIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvdmVyRWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVsLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcblxuICAgICAgICAgICAgICAgIC8vIFVzZSB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBzdHlsZSBhbmQgc2hhcGUgP1xuICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxFbC5pbnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwudHJhbnNmb3JtID0gb3JpZ2luYWxFbC50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICAgIGVsLmludlRyYW5zZm9ybSA9IG9yaWdpbmFsRWwuaW52VHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICBlbC5fX2NsaXBQYXRocyA9IG9yaWdpbmFsRWwuX19jbGlwUGF0aHM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGhvdmVyTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob3ZlckxheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3N0YXJ0UHJvZ2Vzc2l2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIGEgdG9rZW4gdG8gc3RvcCBwcm9ncmVzcyBzdGVwcyB0cmlnZ2VyZWQgYnlcbiAgICAgICAgICAgIC8vIHByZXZpb3VzIHpyLnJlZnJlc2ggY2FsbGluZy5cbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSArbmV3IERhdGUoKTtcblxuICAgICAgICAgICAgc2VsZi5fcHJvZ3Jlc3MrKztcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHJlZnJlc2hlZCBvciBkaXNwb3NlZFxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gc2VsZi5fcHJvZ3Jlc3NpdmVUb2tlbiAmJiBzZWxmLnN0b3JhZ2UpIHtcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kb1BhaW50TGlzdChzZWxmLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcHJvZ3Jlc3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfY2xlYXJQcm9ncmVzc2l2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NpdmVUb2tlbiA9IC0xO1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBsYXllci5fX2RpcnR5ICYmIGxheWVyLmNsZWFyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCwgcGFpbnRBbGwpIHtcblxuICAgICAgICAgICAgaWYgKHBhaW50QWxsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYWludEFsbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMYXllclN0YXR1cyhsaXN0KTtcblxuICAgICAgICAgICAgdGhpcy5fY2xlYXJQcm9ncmVzc2l2ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIocHJlUHJvY2Vzc0xheWVyKTtcblxuICAgICAgICAgICAgdGhpcy5fZG9QYWludExpc3QobGlzdCwgcGFpbnRBbGwpO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIocG9zdFByb2Nlc3NMYXllcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvUGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCwgcGFpbnRBbGwpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TGF5ZXI7XG4gICAgICAgICAgICB2YXIgY3VycmVudFpMZXZlbDtcbiAgICAgICAgICAgIHZhciBjdHg7XG5cbiAgICAgICAgICAgIC8vIHZhciBpbnZUcmFuc2Zvcm0gPSBbXTtcbiAgICAgICAgICAgIHZhciBzY29wZTtcblxuICAgICAgICAgICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJJZHggPSAwO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyO1xuXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbGF5ZXJQcm9ncmVzcztcbiAgICAgICAgICAgIHZhciBmcmFtZSA9IHRoaXMuX3Byb2dyZXNzO1xuICAgICAgICAgICAgZnVuY3Rpb24gZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIGxheWVyIGRvbid0IGNsZWFyIGluIG5leHQgcHJvZ3Jlc3NpdmUgZnJhbWVcbiAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGxheWVyLmRvbSwgMCwgMCwgd2lkdGggKiBkcHIsIGhlaWdodCAqIGRwcik7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgdmFyIGVsWkxldmVsID0gdGhpcy5fc2luZ2xlQ2FudmFzID8gMCA6IGVsLnpsZXZlbDtcblxuICAgICAgICAgICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZTtcblxuICAgICAgICAgICAgICAgIC8vIEZsdXNoIGF0IGN1cnJlbnQgY29udGV4dFxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgICAgICBpZiAoZWxGcmFtZSA8IDAgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSBkcmF3IGxheWVyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRaTGV2ZWwgIT09IGVsWkxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBzY29wZVxuICAgICAgICAgICAgICAgICAgICBzY29wZSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgMCB6bGV2ZWwgaWYgb25seSBoYXMgb25lIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50WkxldmVsID0gZWxaTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllciA9IHRoaXMuZ2V0TGF5ZXIoY3VycmVudFpMZXZlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50TGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWkxldmVsICcgKyBjdXJyZW50WkxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnIGhhcyBiZWVuIHVzZWQgYnkgdW5rb3duIGxheWVyICcgKyBjdXJyZW50TGF5ZXIuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdHggPSBjdXJyZW50TGF5ZXIuY3R4O1xuICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjb3VudFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIuX191bnVzZWRDb3VudCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxGcmFtZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb2dyZXNzaXZlIGxheWVyIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSB0aGlzLl9wcm9ncmVzc2l2ZUxheWVyc1tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVySWR4KyssIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgLSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLnJlbmRlclNjb3BlID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzID4gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUXVpY2sganVtcCBhbGwgcHJvZ3Jlc3NpdmUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgcHJvZ3Jlc3NpdmUgZWxlbWVudCBhcmUgbm90IGRpcnR5LCBqdW1wIG92ZXIgYW5kIGZsdXNoIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJQcm9ncmVzcyA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3M7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBsYXllclByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzID0gZnJhbWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsRnJhbWUgPT09IGZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLCB0cnVlLCBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5yZW5kZXJTY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgY3VycmVudExheWVyLCBwYWludEFsbCwgc2NvcGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgbGFzdExheWVyIGN0eFxuICAgICAgICAgICAgY3R4ICYmIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAvLyBJZiBzdGlsbCBoYXMgY2xpcHBpbmcgc3RhdGVcbiAgICAgICAgICAgIC8vIGlmIChzY29wZS5wcmV2RWxDbGlwUGF0aHMpIHtcbiAgICAgICAgICAgIC8vICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICB0aGlzLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLl9fbWF4UHJvZ3Jlc3MgPj0gbGF5ZXIuX19wcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb1BhaW50RWw6IGZ1bmN0aW9uIChlbCwgY3VycmVudExheWVyLCBmb3JjZVBhaW50LCBzY29wZSkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IGN1cnJlbnRMYXllci5jdHg7XG4gICAgICAgICAgICB2YXIgbSA9IGVsLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoY3VycmVudExheWVyLl9fZGlydHkgfHwgZm9yY2VQYWludClcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgaW52aXNpYmxlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJiAhZWwuaW52aXNpYmxlXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHRyYW5zcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJiBlbC5zdHlsZS5vcGFjaXR5ICE9PSAwXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHNjYWxlIDAgZWxlbWVudCwgaW4gc29tZSBlbnZpcm9ubWVudCBsaWtlIG5vZGUtY2FudmFzXG4gICAgICAgICAgICAgICAgLy8gRHJhdyBhIHNjYWxlIDAgZWxlbWVudCBjYW4gY2F1c2UgYWxsIGZvbGxvd2luZyBkcmF3IHdyb25nXG4gICAgICAgICAgICAgICAgLy8gQW5kIHNldFRyYW5zZm9ybSB3aXRoIHNjYWxlIDAgd2lsbCBjYXVzZSBzZXQgYmFjayB0cmFuc2Zvcm0gZmFpbGVkLlxuICAgICAgICAgICAgICAgICYmICEobSAmJiAhbVswXSAmJiAhbVszXSlcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgY3VsbGVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJiAhKGVsLmN1bGxpbmcgJiYgaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCkpXG4gICAgICAgICAgICApIHtcblxuICAgICAgICAgICAgICAgIHZhciBjbGlwUGF0aHMgPSBlbC5fX2NsaXBQYXRocztcblxuICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIHdoZW4gY2xpcHBpbmcgb24gZ3JvdXAgd2l0aCBzZXZlcmFsIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlLnByZXZDbGlwTGF5ZXIgIT09IGN1cnJlbnRMYXllclxuICAgICAgICAgICAgICAgICAgICB8fCBpc0NsaXBQYXRoQ2hhbmdlZChjbGlwUGF0aHMsIHNjb3BlLnByZXZFbENsaXBQYXRocylcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaGFzIHByZXZpb3VzIGNsaXBwaW5nIHN0YXRlLCByZXN0b3JlIGZyb20gaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IHNjb3BlLnByZXZFbENsaXBQYXRocyA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHByZXZFbCBzaW5jZSBjb250ZXh0IGhhcyBiZWVuIHJlc3RvcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2RWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyBjbGlwcGluZyBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9DbGlwKGNsaXBQYXRocywgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZDbGlwTGF5ZXIgPSBjdXJyZW50TGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2RWxDbGlwUGF0aHMgPSBjbGlwUGF0aHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWwuYmVmb3JlQnJ1c2ggJiYgZWwuYmVmb3JlQnJ1c2goY3R4KTtcblxuICAgICAgICAgICAgICAgIGVsLmJydXNoKGN0eCwgc2NvcGUucHJldkVsIHx8IG51bGwpO1xuICAgICAgICAgICAgICAgIHNjb3BlLnByZXZFbCA9IGVsO1xuXG4gICAgICAgICAgICAgICAgZWwuYWZ0ZXJCcnVzaCAmJiBlbC5hZnRlckJydXNoKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPliB6bGV2ZWwg5omA5Zyo5bGC77yM5aaC5p6c5LiN5a2Y5Zyo5YiZ5Lya5Yib5bu65LiA5Liq5paw55qE5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBsYXllclxuICAgICAgICAgICAgICAgIGxheWVyID0gbmV3IExheWVyKCd6cl8nICsgemxldmVsLCB0aGlzLCB0aGlzLmRwcik7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19idWlsdGluX18gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllciwgdGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRMYXllcih6bGV2ZWwsIGxheWVyKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnRleHQgaXMgY3JlYXRlZCBhZnRlciBkb20gaW5zZXJ0ZWQgdG8gZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyBPciBleGNhbnZhcyB3aWxsIGdldCAwcHggY2xpZW50V2lkdGggYW5kIGNsaWVudEhlaWdodFxuICAgICAgICAgICAgICAgIGxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnNlcnRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgbGF5ZXIpIHtcblxuICAgICAgICAgICAgdmFyIGxheWVyc01hcCA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsZW4gPSB6bGV2ZWxMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBwcmV2TGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdDtcblxuICAgICAgICAgICAgaWYgKGxheWVyc01hcFt6bGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdaTGV2ZWwgJyArIHpsZXZlbCArICcgaGFzIGJlZW4gdXNlZCBhbHJlYWR5Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXMgYSB2YWxpZCBsYXllclxuICAgICAgICAgICAgaWYgKCFpc0xheWVyVmFsaWQobGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdMYXllciBvZiB6bGV2ZWwgJyArIHpsZXZlbCArICcgaXMgbm90IHZhbGlkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuID4gMCAmJiB6bGV2ZWwgPiB6bGV2ZWxMaXN0WzBdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB6bGV2ZWxMaXN0W2ldIDwgemxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB6bGV2ZWxMaXN0W2kgKyAxXSA+IHpsZXZlbFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZMYXllciA9IGxheWVyc01hcFt6bGV2ZWxMaXN0W2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKGkgKyAxLCAwLCB6bGV2ZWwpO1xuXG4gICAgICAgICAgICBsYXllcnNNYXBbemxldmVsXSA9IGxheWVyO1xuXG4gICAgICAgICAgICAvLyBWaXR1YWwgbGF5ZXIgd2lsbCBub3QgZGlyZWN0bHkgc2hvdyBvbiB0aGUgc2NyZWVuLlxuICAgICAgICAgICAgLy8gKEl0IGNhbiBiZSBhIFdlYkdMIGxheWVyIGFuZCBhc3NpZ25lZCB0byBhIFpJbWFnZSBlbGVtZW50KVxuICAgICAgICAgICAgLy8gQnV0IGl0IHN0aWxsIHVuZGVyIG1hbmFnZW1lbnQgb2YgenJlbmRlci5cbiAgICAgICAgICAgIGlmICghbGF5ZXIudmlydHVhbCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZEb20gPSBwcmV2TGF5ZXIuZG9tO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldkRvbS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEb20ubmV4dFNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21Sb290LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKGxheWVyLmRvbSwgZG9tUm9vdC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdGVyYXRlIGVhY2ggbGF5ZXJcbiAgICAgICAgZWFjaExheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW3pdLCB6KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdGVyYXRlIGVhY2ggYnVpbGRpbiBsYXllclxuICAgICAgICBlYWNoQnVpbHRpbkxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllcjtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGxheWVyLCB6KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSXRlcmF0ZSBlYWNoIG90aGVyIGxheWVyIGV4Y2VwdCBidWlsZGluIGxheWVyXG4gICAgICAgIGVhY2hPdGhlckxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllcjtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmiYDmnInlt7LliJvlu7rnmoTlsYJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvTGF5ZXI+fSBbcHJldkxheWVyXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVMYXllclN0YXR1czogZnVuY3Rpb24gKGxpc3QpIHtcblxuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUxheWVycyA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzO1xuXG4gICAgICAgICAgICB2YXIgZWxDb3VudHNMYXN0RnJhbWUgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lID0ge307XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcihmdW5jdGlvbiAobGF5ZXIsIHopIHtcbiAgICAgICAgICAgICAgICBlbENvdW50c0xhc3RGcmFtZVt6XSA9IGxheWVyLmVsQ291bnQ7XG4gICAgICAgICAgICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHV0aWwuZWFjaChwcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gPSBsYXllci5lbENvdW50O1xuICAgICAgICAgICAgICAgIGxheWVyLmVsQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NpdmVMYXllckNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcbiAgICAgICAgICAgIHZhciBsYXN0UHJvZ3Jlc3NpdmVLZXk7XG4gICAgICAgICAgICB2YXIgZnJhbWVDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgemxldmVsID0gdGhpcy5fc2luZ2xlQ2FudmFzID8gMCA6IGVsLnpsZXZlbDtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbemxldmVsXTtcbiAgICAgICAgICAgICAgICB2YXIgZWxQcm9ncmVzcyA9IGVsLnByb2dyZXNzaXZlO1xuICAgICAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5lbENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBsYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8vLy8vLyBVcGRhdGUgcHJvZ3Jlc3NpdmVcbiAgICAgICAgICAgICAgICBpZiAoZWxQcm9ncmVzcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCB3cm9uZyBwcm9ncmVzc2l2ZSBzZXF1ZW5jZSBwcm9ibGVtLlxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFByb2dyZXNzaXZlS2V5ICE9PSBlbFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvZ3Jlc3NpdmVLZXkgPSBlbFByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZSA9IGZyYW1lQ291bnQgLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHByb2dyZXNzaXZlTGF5ZXJzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdID0gbmV3IExheWVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJvZ3Jlc3NpdmUnLCB0aGlzLCB0aGlzLmRwclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuaW5pdENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fZGlydHkgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmVsQ291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzLCBlbEZyYW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPj0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGtlZXAgcmVuZGVyaW5nIHRoaXMgIGxheWVyIGJlY2F1c2UgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGlzIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbC5fX2ZyYW1lID0gLTE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVyQ291bnQrKztcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g5bGC5Lit55qE5YWD57Sg5pWw6YeP5pyJ5Y+R55Sf5Y+Y5YyWXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsQ291bnRzTGFzdEZyYW1lW3pdICE9PSBsYXllci5lbENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVycy5sZW5ndGggPSBNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVyQ291bnQsIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIpO1xuICAgICAgICAgICAgdXRpbC5lYWNoKHByb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fcHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaRob3ZlcuWxguWkluaJgOacieWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcih0aGlzLl9jbGVhckxheWVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jbGVhckxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS/ruaUueaMh+WumnpsZXZlbOeahOe7mOWItuWPguaVsFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gemxldmVsXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcg6YWN572u5a+56LGhXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0g5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIOaYr+WQpuW8gOWQr+WKqOaAgeaooeezilxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddXG4gICAgICAgICAqICAgICAgICAgICAgICAgICDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAgICAgKi9cbiAgICAgICAgY29uZmlnTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwsIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllckNvbmZpZyA9IHRoaXMuX2xheWVyQ29uZmlnO1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllckNvbmZpZ1t6bGV2ZWxdID0gY29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllckNvbmZpZ1t6bGV2ZWxdLCBjb25maWcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIGxheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5oyH5a6a5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWwg5bGC5omA5Zyo55qEemxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBkZWxMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxheWVyLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICBkZWxldGUgbGF5ZXJzW3psZXZlbF07XG5cbiAgICAgICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yy65Z+f5aSn5bCP5Y+Y5YyW5ZCO6YeN57uYXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG4gICAgICAgICAgICAvLyBGSVhNRSBXaHkgP1xuICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgICAgICAvLyBTYXZlIGlucHV0IHcvaFxuICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgICAgICAgICAgd2lkdGggIT0gbnVsbCAmJiAob3B0cy53aWR0aCA9IHdpZHRoKTtcbiAgICAgICAgICAgIGhlaWdodCAhPSBudWxsICYmIChvcHRzLmhlaWdodCA9IGhlaWdodCk7XG5cbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5fZ2V0U2l6ZSgwKTtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2dldFNpemUoMSk7XG5cbiAgICAgICAgICAgIGRvbVJvb3Quc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICAgICAgICAvLyDkvJjljJbmsqHmnInlrp7pmYXmlLnlj5jnmoRyZXNpemVcbiAgICAgICAgICAgIGlmICh0aGlzLl93aWR0aCAhPSB3aWR0aCB8fCBoZWlnaHQgIT0gdGhpcy5faGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICBkb21Sb290LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyc1tpZF0ucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4hemZpOWNleeLrOeahOS4gOS4quWxglxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhckxheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcbiAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmHiuaUvlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5yb290LmlubmVySFRNTCA9ICcnO1xuXG4gICAgICAgICAgICB0aGlzLnJvb3QgPVxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID1cblxuICAgICAgICAgICAgdGhpcy5fZG9tUm9vdCA9XG4gICAgICAgICAgICB0aGlzLl9sYXllcnMgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY2FudmFzIHdoaWNoIGhhcyBhbGwgdGhpbmcgcmVuZGVyZWRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cbiAgICAgICAgICovXG4gICAgICAgIGdldFJlbmRlcmVkQ2FudmFzOiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgICAgICBpZiAodGhpcy5fc2luZ2xlQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXS5kb207XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbWFnZUxheWVyID0gbmV3IExheWVyKCdpbWFnZScsIHRoaXMsIG9wdHMucGl4ZWxSYXRpbyB8fCB0aGlzLmRwcik7XG4gICAgICAgICAgICBpbWFnZUxheWVyLmluaXRDb250ZXh0KCk7XG5cbiAgICAgICAgICAgIGltYWdlTGF5ZXIuY2xlYXJDb2xvciA9IG9wdHMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgaW1hZ2VMYXllci5jbGVhcigpO1xuXG4gICAgICAgICAgICB2YXIgZGlzcGxheUxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBzY29wZSA9IHt9O1xuICAgICAgICAgICAgdmFyIHpsZXZlbDtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgZnVuY3Rpb24gZmluZEFuZERyYXdPdGhlckxheWVyKHNtYWxsZXIsIGxhcmdlcikge1xuICAgICAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gc2VsZi5femxldmVsTGlzdDtcbiAgICAgICAgICAgICAgICBpZiAoc21hbGxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXIgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbnRlcm1lZGlhdGVMYXllcjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBzZWxmLl9sYXllcnNbel07XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18gJiYgeiA+IHNtYWxsZXIgJiYgeiA8IGxhcmdlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlTGF5ZXIgPSBsYXllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm1lZGlhdGVMYXllciAmJiBpbnRlcm1lZGlhdGVMYXllci5yZW5kZXJUb0NhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZUxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZUxheWVyLnJlbmRlclRvQ2FudmFzKGltYWdlTGF5ZXIuY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBkaXNwbGF5TGlzdFtpXTtcblxuICAgICAgICAgICAgICAgIGlmIChlbC56bGV2ZWwgIT09IHpsZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBmaW5kQW5kRHJhd090aGVyTGF5ZXIoemxldmVsLCBlbC56bGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICB6bGV2ZWwgPSBlbC56bGV2ZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgaW1hZ2VMYXllciwgdHJ1ZSwgc2NvcGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaW5kQW5kRHJhd090aGVyTGF5ZXIoemxldmVsLCBJbmZpbml0eSk7XG5cbiAgICAgICAgICAgIHJldHVybiBpbWFnZUxheWVyLmRvbTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPlue7mOWbvuWMuuWfn+WuveW6plxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W57uY5Zu+5Yy65Z+f6auY5bqmXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFNpemU6IGZ1bmN0aW9uICh3aElkeCkge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgICAgICAgICAgdmFyIHdoID0gWyd3aWR0aCcsICdoZWlnaHQnXVt3aElkeF07XG4gICAgICAgICAgICB2YXIgY3doID0gWydjbGllbnRXaWR0aCcsICdjbGllbnRIZWlnaHQnXVt3aElkeF07XG4gICAgICAgICAgICB2YXIgcGx0ID0gWydwYWRkaW5nTGVmdCcsICdwYWRkaW5nVG9wJ11bd2hJZHhdO1xuICAgICAgICAgICAgdmFyIHByYiA9IFsncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdCb3R0b20nXVt3aElkeF07XG5cbiAgICAgICAgICAgIGlmIChvcHRzW3doXSAhPSBudWxsICYmIG9wdHNbd2hdICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChvcHRzW3doXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgICAgICAgICAgdmFyIHN0bCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUocm9vdCk7XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKHJvb3RbY3doXSB8fCBwYXJzZUludDEwKHN0bFt3aF0pIHx8IHBhcnNlSW50MTAocm9vdC5zdHlsZVt3aF0pKVxuICAgICAgICAgICAgICAgIC0gKHBhcnNlSW50MTAoc3RsW3BsdF0pIHx8IDApXG4gICAgICAgICAgICAgICAgLSAocGFyc2VJbnQxMChzdGxbcHJiXSkgfHwgMClcbiAgICAgICAgICAgICkgfCAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhdGhUb0ltYWdlOiBmdW5jdGlvbiAocGF0aCwgZHByKSB7XG4gICAgICAgICAgICBkcHIgPSBkcHIgfHwgdGhpcy5kcHI7XG5cbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHBhdGguc3R5bGU7XG4gICAgICAgICAgICB2YXIgc2hhZG93Qmx1clNpemUgPSBzdHlsZS5zaGFkb3dCbHVyO1xuICAgICAgICAgICAgdmFyIHNoYWRvd09mZnNldFggPSBzdHlsZS5zaGFkb3dPZmZzZXRYO1xuICAgICAgICAgICAgdmFyIHNoYWRvd09mZnNldFkgPSBzdHlsZS5zaGFkb3dPZmZzZXRZO1xuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmhhc1N0cm9rZSgpID8gc3R5bGUubGluZVdpZHRoIDogMDtcblxuICAgICAgICAgICAgdmFyIGxlZnRNYXJnaW4gPSBNYXRoLm1heChsaW5lV2lkdGggLyAyLCAtc2hhZG93T2Zmc2V0WCArIHNoYWRvd0JsdXJTaXplKTtcbiAgICAgICAgICAgIHZhciByaWdodE1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIHNoYWRvd09mZnNldFggKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgICAgICAgICB2YXIgdG9wTWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgICAgICAgICB2YXIgYm90dG9tTWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgc2hhZG93T2Zmc2V0WSArIHNoYWRvd0JsdXJTaXplKTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGggKyBsZWZ0TWFyZ2luICsgcmlnaHRNYXJnaW47XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKyB0b3BNYXJnaW4gKyBib3R0b21NYXJnaW47XG5cbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAgICAgY3R4LnNjYWxlKGRwciwgZHByKTtcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBjdHguZHByID0gZHByO1xuXG4gICAgICAgICAgICB2YXIgcGF0aFRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcGF0aC5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogcGF0aC5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICBzY2FsZTogcGF0aC5zY2FsZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhdGgucG9zaXRpb24gPSBbbGVmdE1hcmdpbiAtIHJlY3QueCwgdG9wTWFyZ2luIC0gcmVjdC55XTtcbiAgICAgICAgICAgIHBhdGgucm90YXRpb24gPSAwO1xuICAgICAgICAgICAgcGF0aC5zY2FsZSA9IFsxLCAxXTtcbiAgICAgICAgICAgIHBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHBhdGguYnJ1c2goY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIEltYWdlU2hhcGUgPSByZXF1aXJlKCcuL2dyYXBoaWMvSW1hZ2UnKTtcbiAgICAgICAgICAgIHZhciBpbWdTaGFwZSA9IG5ldyBJbWFnZVNoYXBlKHtcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogY2FudmFzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChwYXRoVHJhbnNmb3JtLnBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbWdTaGFwZS5wb3NpdGlvbiA9IHBhdGgucG9zaXRpb24gPSBwYXRoVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGF0aFRyYW5zZm9ybS5yb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW1nU2hhcGUucm90YXRpb24gPSBwYXRoLnJvdGF0aW9uID0gcGF0aFRyYW5zZm9ybS5yb3RhdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhdGhUcmFuc2Zvcm0uc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGltZ1NoYXBlLnNjYWxlID0gcGF0aC5zY2FsZSA9IHBhdGhUcmFuc2Zvcm0uc2NhbGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbWdTaGFwZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhaW50ZXI7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9QYWludGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = __webpack_require__(20);\n    var config = __webpack_require__(50);\n    var Style = __webpack_require__(38);\n    var Pattern = __webpack_require__(62);\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * 创建dom\n     *\n     * @inner\n     * @param {string} id dom id 待用\n     * @param {string} type dom type，such as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // 没append呢，请原谅我这样写，清晰~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id不作为索引用，避免可能造成的重名，定义为私有属性\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * 每次清空画布的颜色\n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * 是否开启动态模糊\n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * 清空该层画布\n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL0xheWVyLmpzP2Y1ODYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2Qiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxMDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9MYXllclxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG4gICAgdmFyIFN0eWxlID0gcmVxdWlyZSgnLi9ncmFwaGljL1N0eWxlJyk7XG4gICAgdmFyIFBhdHRlcm4gPSByZXF1aXJlKCcuL2dyYXBoaWMvUGF0dGVybicpO1xuXG4gICAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDliJvlu7pkb21cbiAgICAgKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBkb20gaWQg5b6F55SoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgZG9tIHR5cGXvvIxzdWNoIGFzIGNhbnZhcywgZGl2IGV0Yy5cbiAgICAgKiBAcGFyYW0ge1BhaW50ZXJ9IHBhaW50ZXIgcGFpbnRlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVEb20oaWQsIHR5cGUsIHBhaW50ZXIsIGRwcikge1xuICAgICAgICB2YXIgbmV3RG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICAgICAgdmFyIHdpZHRoID0gcGFpbnRlci5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcGFpbnRlci5nZXRIZWlnaHQoKTtcblxuICAgICAgICB2YXIgbmV3RG9tU3R5bGUgPSBuZXdEb20uc3R5bGU7XG4gICAgICAgIC8vIOayoWFwcGVuZOWRou+8jOivt+WOn+iwheaIkei/meagt+WGme+8jOa4heaZsH5cbiAgICAgICAgbmV3RG9tU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBuZXdEb21TdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgbmV3RG9tU3R5bGUudG9wID0gMDtcbiAgICAgICAgbmV3RG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIG5ld0RvbVN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgIG5ld0RvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICBuZXdEb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgIC8vIGlk5LiN5L2c5Li657Si5byV55So77yM6YG/5YWN5Y+v6IO96YCg5oiQ55qE6YeN5ZCN77yM5a6a5LmJ5Li656eB5pyJ5bGe5oCnXG4gICAgICAgIG5ld0RvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtenItZG9tLWlkJywgaWQpO1xuICAgICAgICByZXR1cm4gbmV3RG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9MYXllclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Rwcl1cbiAgICAgKi9cbiAgICB2YXIgTGF5ZXIgPSBmdW5jdGlvbihpZCwgcGFpbnRlciwgZHByKSB7XG4gICAgICAgIHZhciBkb207XG4gICAgICAgIGRwciA9IGRwciB8fCBjb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRvbSA9IGNyZWF0ZURvbShpZCwgJ2NhbnZhcycsIHBhaW50ZXIsIGRwcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IHVzaW5nIGlzRG9tIGJlY2F1c2UgaW4gbm9kZSBpdCB3aWxsIHJldHVybiBmYWxzZVxuICAgICAgICBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGlkKSkge1xuICAgICAgICAgICAgZG9tID0gaWQ7XG4gICAgICAgICAgICBpZCA9IGRvbS5pZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuXG4gICAgICAgIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgICAgICAgaWYgKGRvbVN0eWxlKSB7IC8vIE5vdCBpbiBub2RlXG4gICAgICAgICAgICBkb20ub25zZWxlY3RzdGFydCA9IHJldHVybkZhbHNlOyAvLyDpgb/lhY3pobXpnaLpgInkuK3nmoTlsLTlsKxcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXVzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgICAgICAgICBkb21TdHlsZVsndXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgICAgIGRvbVN0eWxlWydwYWRkaW5nJ10gPSAwO1xuICAgICAgICAgICAgZG9tU3R5bGVbJ21hcmdpbiddID0gMDtcbiAgICAgICAgICAgIGRvbVN0eWxlWydib3JkZXItd2lkdGgnXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRvbUJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmN0eEJhY2sgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG5cbiAgICAgICAgdGhpcy5jb25maWcgPSBudWxsO1xuXG4gICAgICAgIC8vIENvbmZpZ3NcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOavj+asoea4heepuueUu+W4g+eahOminOiJslxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwLjdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdEZyYW1lQWxwaGEgPSAwLjc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExheWVyIGRwclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcHIgPSBkcHI7XG4gICAgfTtcblxuICAgIExheWVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogTGF5ZXIsXG5cbiAgICAgICAgZWxDb3VudDogMCxcblxuICAgICAgICBfX2RpcnR5OiB0cnVlLFxuXG4gICAgICAgIGluaXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuZG9tLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIHRoaXMuY3R4LmRwciA9IHRoaXMuZHByO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUJhY2tCdWZmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdGhpcy5kb21CYWNrID0gY3JlYXRlRG9tKCdiYWNrLScgKyB0aGlzLmlkLCAnY2FudmFzJywgdGhpcy5wYWludGVyLCBkcHIpO1xuICAgICAgICAgICAgdGhpcy5jdHhCYWNrID0gdGhpcy5kb21CYWNrLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5zY2FsZShkcHIsIGRwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgICAgICAgICAgdmFyIGRvbVN0eWxlID0gZG9tLnN0eWxlO1xuICAgICAgICAgICAgdmFyIGRvbUJhY2sgPSB0aGlzLmRvbUJhY2s7XG5cbiAgICAgICAgICAgIGRvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgZG9tU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAgICAgZG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgICAgICBkb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgICAgICBpZiAoZG9tQmFjaykge1xuICAgICAgICAgICAgICAgIGRvbUJhY2sud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgICAgICAgICBkb21CYWNrLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAgICAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF56m66K+l5bGC55S75biDXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJBbGwgQ2xlYXIgYWxsIHdpdGggb3V0IG1vdGlvbiBibHVyXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKGNsZWFyQWxsKSB7XG4gICAgICAgICAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBkb20ud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZG9tLmhlaWdodDtcblxuICAgICAgICAgICAgdmFyIGNsZWFyQ29sb3IgPSB0aGlzLmNsZWFyQ29sb3I7XG4gICAgICAgICAgICB2YXIgaGF2ZU1vdGlvbkJMdXIgPSB0aGlzLm1vdGlvbkJsdXIgJiYgIWNsZWFyQWxsO1xuICAgICAgICAgICAgdmFyIGxhc3RGcmFtZUFscGhhID0gdGhpcy5sYXN0RnJhbWVBbHBoYTtcblxuICAgICAgICAgICAgdmFyIGRwciA9IHRoaXMuZHByO1xuXG4gICAgICAgICAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZG9tQmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUJhY2tCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgIGRvbSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggLyBkcHIsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAvIGRwclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBpZiAoY2xlYXJDb2xvcikge1xuICAgICAgICAgICAgICAgIHZhciBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47XG4gICAgICAgICAgICAgICAgLy8gR3JhZGllbnRcbiAgICAgICAgICAgICAgICBpZiAoY2xlYXJDb2xvci5jb2xvclN0b3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIGNhbnZhcyBncmFkaWVudFxuICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBjbGVhckNvbG9yLl9fY2FudmFzR3JhZGllbnQgfHwgU3R5bGUuZ2V0R3JhZGllbnQoY3R4LCBjbGVhckNvbG9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGF0dGVyblxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsZWFyQ29sb3IuaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuID0gUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybi5jYWxsKGNsZWFyQ29sb3IsIGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiB8fCBjbGVhckNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGxhc3RGcmFtZUFscGhhO1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoZG9tQmFjaywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExheWVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL0xheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\n    var Gradient = __webpack_require__(82);\n    module.exports = function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(\n                            idx, 'color', color(seriesModel.getDataParams(idx))\n                        );\n                    });\n                }\n\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3Zpc3VhbC9zZXJpZXNDb2xvci5qcz80YjZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7O0FBRTVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgdmFyIEdyYWRpZW50ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudCcpO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICAgICAgZnVuY3Rpb24gZW5jb2RlQ29sb3Ioc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBjb2xvckFjY2Vzc1BhdGggPSAoc2VyaWVzTW9kZWwudmlzdWFsQ29sb3JBY2Nlc3NQYXRoIHx8ICdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJykuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gc2VyaWVzTW9kZWwuZ2V0KGNvbG9yQWNjZXNzUGF0aCkgLy8gU2V0IGluIGl0ZW1TdHlsZVxuICAgICAgICAgICAgICAgIHx8IHNlcmllc01vZGVsLmdldENvbG9yRnJvbVBhbGV0dGUoc2VyaWVzTW9kZWwuZ2V0KCduYW1lJykpOyAgLy8gRGVmYXVsdCBjb2xvclxuXG4gICAgICAgICAgICAvLyBGSVhNRSBTZXQgY29sb3IgZnVuY3Rpb24gb3IgdXNlIHRoZSBwbGF0dGUgY29sb3JcbiAgICAgICAgICAgIGRhdGEuc2V0VmlzdWFsKCdjb2xvcicsIGNvbG9yKTtcblxuICAgICAgICAgICAgLy8gT25seSB2aXNpYmxlIHNlcmllcyBoYXMgZWFjaCBkYXRhIGJlIHZpc3VhbCBlbmNvZGVkXG4gICAgICAgICAgICBpZiAoIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnZnVuY3Rpb24nICYmICEoY29sb3IgaW5zdGFuY2VvZiBHcmFkaWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHgsICdjb2xvcicsIGNvbG9yKHNlcmllc01vZGVsLmdldERhdGFQYXJhbXMoaWR4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGl0ZW1TdHlsZSBpbiBlYWNoIGRhdGEgaXRlbVxuICAgICAgICAgICAgICAgIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBpdGVtTW9kZWwuZ2V0KGNvbG9yQWNjZXNzUGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InLCBjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlY01vZGVsLmVhY2hSYXdTZXJpZXMoZW5jb2RlQ29sb3IpO1xuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvdmlzdWFsL3Nlcmllc0NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("// Compatitable with 2.0\n\n\n    var zrUtil = __webpack_require__(20);\n    var compatStyle = __webpack_require__(112);\n\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n\n    var LAYOUT_PROPERTIES = [\n        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n    ];\n\n    var COMPATITABLE_COMPONENTS = [\n        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n    ];\n\n    var COMPATITABLE_SERIES = [\n        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n    ];\n\n    var each = zrUtil.each;\n\n    module.exports = function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n\n            var seriesType = seriesOpt.type;\n\n            compatStyle(seriesOpt);\n\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null\n                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3ByZXByb2Nlc3Nvci9iYWNrd2FyZENvbXBhdC5qcz9mMTcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUIiwiZmlsZSI6IjExMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvbXBhdGl0YWJsZSB3aXRoIDIuMFxuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGNvbXBhdFN0eWxlID0gcmVxdWlyZSgnLi9oZWxwZXIvY29tcGF0U3R5bGUnKTtcblxuICAgIGZ1bmN0aW9uIGdldChvcHQsIHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJywnKTtcbiAgICAgICAgdmFyIG9iaiA9IG9wdDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvYmogPSBvYmogJiYgb2JqW3BhdGhbaV1dO1xuICAgICAgICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQob3B0LCBwYXRoLCB2YWwsIG92ZXJ3cml0ZSkge1xuICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLCcpO1xuICAgICAgICB2YXIgb2JqID0gb3B0O1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBrZXkgPSBwYXRoW2ldO1xuICAgICAgICAgICAgaWYgKG9ialtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG92ZXJ3cml0ZSB8fCBvYmpbcGF0aFtpXV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqW3BhdGhbaV1dID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGF0TGF5b3V0UHJvcGVydGllcyhvcHRpb24pIHtcbiAgICAgICAgZWFjaChMQVlPVVRfUFJPUEVSVElFUywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmIChwcm9wWzBdIGluIG9wdGlvbiAmJiAhKHByb3BbMV0gaW4gb3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbltwcm9wWzFdXSA9IG9wdGlvbltwcm9wWzBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIExBWU9VVF9QUk9QRVJUSUVTID0gW1xuICAgICAgICBbJ3gnLCAnbGVmdCddLCBbJ3knLCAndG9wJ10sIFsneDInLCAncmlnaHQnXSwgWyd5MicsICdib3R0b20nXVxuICAgIF07XG5cbiAgICB2YXIgQ09NUEFUSVRBQkxFX0NPTVBPTkVOVFMgPSBbXG4gICAgICAgICdncmlkJywgJ2dlbycsICdwYXJhbGxlbCcsICdsZWdlbmQnLCAndG9vbGJveCcsICd0aXRsZScsICd2aXN1YWxNYXAnLCAnZGF0YVpvb20nLCAndGltZWxpbmUnXG4gICAgXTtcblxuICAgIHZhciBDT01QQVRJVEFCTEVfU0VSSUVTID0gW1xuICAgICAgICAnYmFyJywgJ2JveHBsb3QnLCAnY2FuZGxlc3RpY2snLCAnY2hvcmQnLCAnZWZmZWN0U2NhdHRlcicsXG4gICAgICAgICdmdW5uZWwnLCAnZ2F1Z2UnLCAnbGluZXMnLCAnZ3JhcGgnLCAnaGVhdG1hcCcsICdsaW5lJywgJ21hcCcsICdwYXJhbGxlbCcsXG4gICAgICAgICdwaWUnLCAncmFkYXInLCAnc2Fua2V5JywgJ3NjYXR0ZXInLCAndHJlZW1hcCdcbiAgICBdO1xuXG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICBlYWNoKG9wdGlvbi5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXNPcHQpIHtcbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzT2JqZWN0KHNlcmllc09wdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZXJpZXNUeXBlID0gc2VyaWVzT3B0LnR5cGU7XG5cbiAgICAgICAgICAgIGNvbXBhdFN0eWxlKHNlcmllc09wdCk7XG5cbiAgICAgICAgICAgIGlmIChzZXJpZXNUeXBlID09PSAncGllJyB8fCBzZXJpZXNUeXBlID09PSAnZ2F1Z2UnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcmllc09wdC5jbG9ja1dpc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNPcHQuY2xvY2t3aXNlID0gc2VyaWVzT3B0LmNsb2NrV2lzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ2dhdWdlJykge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludGVyQ29sb3IgPSBnZXQoc2VyaWVzT3B0LCAncG9pbnRlci5jb2xvcicpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJDb2xvciAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICYmIHNldChzZXJpZXNPcHQsICdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJywgcG9pbnRlckNvbG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDT01QQVRJVEFCTEVfU0VSSUVTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKENPTVBBVElUQUJMRV9TRVJJRVNbaV0gPT09IHNlcmllc09wdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhdExheW91dFByb3BlcnRpZXMoc2VyaWVzT3B0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBkYXRhUmFuZ2UgaGFzIGNoYW5nZWQgdG8gdmlzdWFsTWFwXG4gICAgICAgIGlmIChvcHRpb24uZGF0YVJhbmdlKSB7XG4gICAgICAgICAgICBvcHRpb24udmlzdWFsTWFwID0gb3B0aW9uLmRhdGFSYW5nZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhY2goQ09NUEFUSVRBQkxFX0NPTVBPTkVOVFMsIGZ1bmN0aW9uIChjb21wb25lbnROYW1lKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbltjb21wb25lbnROYW1lXTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gW29wdGlvbnNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlYWNoKG9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGF0TGF5b3V0UHJvcGVydGllcyhvcHRpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3ByZXByb2Nlc3Nvci9iYWNrd2FyZENvbXBhdC5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n\n    var POSSIBLE_STYLES = [\n        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n        'chordStyle', 'label', 'labelLine'\n    ];\n\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n\n    module.exports = function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    }\n                    else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3ByZXByb2Nlc3Nvci9oZWxwZXIvY29tcGF0U3R5bGUuanM/YWZmNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgUE9TU0lCTEVfU1RZTEVTID0gW1xuICAgICAgICAnYXJlYVN0eWxlJywgJ2xpbmVTdHlsZScsICdub2RlU3R5bGUnLCAnbGlua1N0eWxlJyxcbiAgICAgICAgJ2Nob3JkU3R5bGUnLCAnbGFiZWwnLCAnbGFiZWxMaW5lJ1xuICAgIF07XG5cbiAgICBmdW5jdGlvbiBjb21wYXRJdGVtU3R5bGUob3B0KSB7XG4gICAgICAgIHZhciBpdGVtU3R5bGVPcHQgPSBvcHQgJiYgb3B0Lml0ZW1TdHlsZTtcbiAgICAgICAgaWYgKGl0ZW1TdHlsZU9wdCkge1xuICAgICAgICAgICAgenJVdGlsLmVhY2goUE9TU0lCTEVfU1RZTEVTLCBmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbEl0ZW1TdHlsZU9wdCA9IGl0ZW1TdHlsZU9wdC5ub3JtYWw7XG4gICAgICAgICAgICAgICAgdmFyIGVtcGhhc2lzSXRlbVN0eWxlT3B0ID0gaXRlbVN0eWxlT3B0LmVtcGhhc2lzO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxJdGVtU3R5bGVPcHQgJiYgbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0W3N0eWxlTmFtZV0gPSBvcHRbc3R5bGVOYW1lXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRbc3R5bGVOYW1lXS5ub3JtYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdFtzdHlsZU5hbWVdLm5vcm1hbCA9IG5vcm1hbEl0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgenJVdGlsLm1lcmdlKG9wdFtzdHlsZU5hbWVdLm5vcm1hbCwgbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbEl0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVtcGhhc2lzSXRlbVN0eWxlT3B0ICYmIGVtcGhhc2lzSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0W3N0eWxlTmFtZV0gPSBvcHRbc3R5bGVOYW1lXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRbc3R5bGVOYW1lXS5lbXBoYXNpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0W3N0eWxlTmFtZV0uZW1waGFzaXMgPSBlbXBoYXNpc0l0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgenJVdGlsLm1lcmdlKG9wdFtzdHlsZU5hbWVdLmVtcGhhc2lzLCBlbXBoYXNpc0l0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbXBoYXNpc0l0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlcmllc09wdCkge1xuICAgICAgICBpZiAoIXNlcmllc09wdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBhdEl0ZW1TdHlsZShzZXJpZXNPcHQpO1xuICAgICAgICBjb21wYXRJdGVtU3R5bGUoc2VyaWVzT3B0Lm1hcmtQb2ludCk7XG4gICAgICAgIGNvbXBhdEl0ZW1TdHlsZShzZXJpZXNPcHQubWFya0xpbmUpO1xuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc09wdC5kYXRhO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29tcGF0SXRlbVN0eWxlKGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFyayBwb2ludCBkYXRhXG4gICAgICAgICAgICB2YXIgbWFya1BvaW50ID0gc2VyaWVzT3B0Lm1hcmtQb2ludDtcbiAgICAgICAgICAgIGlmIChtYXJrUG9pbnQgJiYgbWFya1BvaW50LmRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXBEYXRhID0gbWFya1BvaW50LmRhdGE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtcERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGF0SXRlbVN0eWxlKG1wRGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFyayBsaW5lIGRhdGFcbiAgICAgICAgICAgIHZhciBtYXJrTGluZSA9IHNlcmllc09wdC5tYXJrTGluZTtcbiAgICAgICAgICAgIGlmIChtYXJrTGluZSAmJiBtYXJrTGluZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1sRGF0YSA9IG1hcmtMaW5lLmRhdGE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHpyVXRpbC5pc0FycmF5KG1sRGF0YVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhdEl0ZW1TdHlsZShtbERhdGFbaV1bMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGF0SXRlbVN0eWxlKG1sRGF0YVtpXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wYXRJdGVtU3R5bGUobWxEYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvcHJlcHJvY2Vzc29yL2hlbHBlci9jb21wYXRTdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("\n\n    var graphic = __webpack_require__(34);\n    var zrUtil = __webpack_require__(20);\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    module.exports = function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n            style: {\n                fill: opts.maskColor\n            },\n            zlevel: opts.zlevel,\n            z: 10000\n        });\n        var arc = new graphic.Arc({\n            shape: {\n                startAngle: -PI / 2,\n                endAngle: -PI / 2 + 0.1,\n                r: 10\n            },\n            style: {\n                stroke: opts.color,\n                lineCap: 'round',\n                lineWidth: 5\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n        var labelRect = new graphic.Rect({\n            style: {\n                fill: 'none',\n                text: opts.text,\n                textPosition: 'right',\n                textDistance: 10,\n                textFill: opts.textColor\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n\n        arc.animateShape(true)\n            .when(1000, {\n                endAngle: PI * 3 / 2\n            })\n            .start('circularInOut');\n        arc.animateShape(true)\n            .when(1000, {\n                startAngle: PI * 3 / 2\n            })\n            .delay(300)\n            .start('circularInOut');\n\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2xvYWRpbmcvZGVmYXVsdC5qcz84YTVmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgUEkgPSBNYXRoLlBJO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnRleHRdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbG9yXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50ZXh0Q29sb3JdXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcGksIG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIHpyVXRpbC5kZWZhdWx0cyhvcHRzLCB7XG4gICAgICAgICAgICB0ZXh0OiAnbG9hZGluZycsXG4gICAgICAgICAgICBjb2xvcjogJyNjMjM1MzEnLFxuICAgICAgICAgICAgdGV4dENvbG9yOiAnIzAwMCcsXG4gICAgICAgICAgICBtYXNrQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCknLFxuICAgICAgICAgICAgemxldmVsOiAwXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWFzayA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmaWxsOiBvcHRzLm1hc2tDb2xvclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHpsZXZlbDogb3B0cy56bGV2ZWwsXG4gICAgICAgICAgICB6OiAxMDAwMFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGFyYyA9IG5ldyBncmFwaGljLkFyYyh7XG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IC1QSSAvIDIsXG4gICAgICAgICAgICAgICAgZW5kQW5nbGU6IC1QSSAvIDIgKyAwLjEsXG4gICAgICAgICAgICAgICAgcjogMTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHN0cm9rZTogb3B0cy5jb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lQ2FwOiAncm91bmQnLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogNVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHpsZXZlbDogb3B0cy56bGV2ZWwsXG4gICAgICAgICAgICB6OiAxMDAwMVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxhYmVsUmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgdGV4dDogb3B0cy50ZXh0LFxuICAgICAgICAgICAgICAgIHRleHRQb3NpdGlvbjogJ3JpZ2h0JyxcbiAgICAgICAgICAgICAgICB0ZXh0RGlzdGFuY2U6IDEwLFxuICAgICAgICAgICAgICAgIHRleHRGaWxsOiBvcHRzLnRleHRDb2xvclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHpsZXZlbDogb3B0cy56bGV2ZWwsXG4gICAgICAgICAgICB6OiAxMDAwMVxuICAgICAgICB9KTtcblxuICAgICAgICBhcmMuYW5pbWF0ZVNoYXBlKHRydWUpXG4gICAgICAgICAgICAud2hlbigxMDAwLCB7XG4gICAgICAgICAgICAgICAgZW5kQW5nbGU6IFBJICogMyAvIDJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3RhcnQoJ2NpcmN1bGFySW5PdXQnKTtcbiAgICAgICAgYXJjLmFuaW1hdGVTaGFwZSh0cnVlKVxuICAgICAgICAgICAgLndoZW4oMTAwMCwge1xuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IFBJICogMyAvIDJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVsYXkoMzAwKVxuICAgICAgICAgICAgLnN0YXJ0KCdjaXJjdWxhckluT3V0Jyk7XG5cbiAgICAgICAgdmFyIGdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICAgICAgZ3JvdXAuYWRkKGFyYyk7XG4gICAgICAgIGdyb3VwLmFkZChsYWJlbFJlY3QpO1xuICAgICAgICBncm91cC5hZGQobWFzayk7XG4gICAgICAgIC8vIEluamVjdCByZXNpemVcbiAgICAgICAgZ3JvdXAucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN4ID0gYXBpLmdldFdpZHRoKCkgLyAyO1xuICAgICAgICAgICAgdmFyIGN5ID0gYXBpLmdldEhlaWdodCgpIC8gMjtcbiAgICAgICAgICAgIGFyYy5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgY3g6IGN4LFxuICAgICAgICAgICAgICAgIGN5OiBjeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgciA9IGFyYy5zaGFwZS5yO1xuICAgICAgICAgICAgbGFiZWxSZWN0LnNldFNoYXBlKHtcbiAgICAgICAgICAgICAgICB4OiBjeCAtIHIsXG4gICAgICAgICAgICAgICAgeTogY3kgLSByLFxuICAgICAgICAgICAgICAgIHdpZHRoOiByICogMixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHIgKiAyXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWFzay5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGdyb3VwLnJlc2l6ZSgpO1xuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9sb2FkaW5nL2RlZmF1bHQuanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array;\n\n    var dataCtors = {\n        'float': Float64Array,\n        'int': Int32Array,\n        // Ordinal data type can be string or int\n        'ordinal': Array,\n        'number': Array,\n        'time': Array\n    };\n\n    var Model = __webpack_require__(28);\n    var DataDiffer = __webpack_require__(115);\n\n    var zrUtil = __webpack_require__(20);\n    var modelUtil = __webpack_require__(21);\n    var isObject = zrUtil.isObject;\n\n    var TRANSFERABLE_PROPERTIES = [\n        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n    ];\n\n    function transferProperties(a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n\n        a.__wrappedMethods = b.__wrappedMethods;\n    }\n\n    function DefaultDataProvider(dataArray) {\n        this._array = dataArray || [];\n    }\n\n    DefaultDataProvider.prototype.pure = false;\n\n    DefaultDataProvider.prototype.count = function () {\n        return this._array.length;\n    };\n    DefaultDataProvider.prototype.getItem = function (idx) {\n        return this._array[idx];\n    };\n\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string|Object>} dimensions\n     *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n     *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n\n        dimensions = dimensions || ['x', 'y'];\n\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    coordDim: dimensionName,\n                    coordDimIndex: 0,\n                    stackable: false,\n                    // Type can be 'float', 'int', 'number'\n                    // Default is number, Precision of float may not enough\n                    type: 'number'\n                };\n            }\n            else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n                if (!dimensionInfo.coordDim) {\n                    dimensionInfo.coordDim = dimensionName;\n                    dimensionInfo.coordDimIndex = 0;\n                }\n            }\n            dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n\n    var listProto = List.prototype;\n\n    listProto.type = 'list';\n\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n\n        var isDataArray = zrUtil.isArray(data);\n        if (isDataArray) {\n            data = new DefaultDataProvider(data);\n        }\n        if (__DEV__) {\n            if (!isDataArray && (typeof data.getItem != 'function' || typeof data.count != 'function')) {\n                throw new Error('Inavlid data provider.');\n            }\n        }\n\n        this._rawData = data;\n\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n\n        var dimensions = this.dimensions;\n        var dimensionInfoMap = this._dimensionInfos;\n\n        var size = data.count();\n\n        var idList = [];\n        var nameRepeatCount = {};\n        var nameDimIdx;\n\n        nameList = nameList || [];\n\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(\n                (value instanceof Array)\n                    ? value[dimIndex]\n                    // If value is a single number or something else not array.\n                    : value,\n                dimensionInfoMap[dimName]\n            );\n        };\n\n        for (var i = 0; i < size; i++) {\n            // NOTICE: Try not to write things into dataItem\n            var dataItem = data.getItem(i);\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[i] = dimValueGetter(dataItem, dim, i, k);\n            }\n\n            indices.push(i);\n        }\n\n        // Use the name in option and create id\n        for (var i = 0; i < size; i++) {\n            var dataItem = data.getItem(i);\n            if (!nameList[i] && dataItem) {\n                if (dataItem.name != null) {\n                    nameList[i] = dataItem.name;\n                }\n                else if (nameDimIdx != null) {\n                    nameList[i] = storage[dimensions[nameDimIdx]][i];\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = dataItem && dataItem.id;\n\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n\n        // If value not exists\n        if (dataIndex == null || !storage[dim]) {\n            return NaN;\n        }\n\n        var value = storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n                        || (value <= 0 && stackedValue < 0) // Negative stack\n                    ) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n\n        return values;\n    };\n\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (\n                // Ordinal type can be string or number\n                dimensionInfos[dimensions[i]].type !== 'ordinal'\n                && isNaN(this.get(dimensions[i], idx))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     * @param {Function} filter\n     */\n    listProto.getDataExtent = function (dim, stack, filter) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = (dimInfo && dimInfo.stackable) && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                if (!filter || filter(value, dim, i)) {\n                    value < min && (min = value);\n                    value > max && (max = value);\n                }\n            }\n            return (this._extent[dim + !!stack] = [min, max]);\n        }\n        else {\n            return [Infinity, -Infinity];\n        }\n    };\n\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n\n        // If rawIndex === dataIndex\n        var rawDataIndex = indices[rawIndex];\n        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n            return rawIndex;\n        }\n\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            }\n            else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {Array.<number>} Considere multiple points has the same value.\n     */\n    listProto.indicesOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var nearestIndices = [];\n\n        if (!dimData) {\n            return nearestIndices;\n        }\n\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n\n        var minDist = Number.MAX_VALUE;\n        var minDiff = -1;\n        for (var i = 0, len = this.count(); i < len; i++) {\n            var diff = value - this.get(dim, i, stack);\n            var dist = Math.abs(diff);\n            if (diff <= maxDistance && dist <= minDist) {\n                // For the case of two data are same on xAxis, which has sequence data.\n                // Show the nearest index\n                // https://github.com/ecomfe/echarts/issues/2869\n                if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                    minDist = dist;\n                    minDiff = diff;\n                    nearestIndices.length = 0;\n                }\n                nearestIndices.push(i);\n            }\n        }\n        return nearestIndices;\n    };\n\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData.getItem(this.getRawIndex(idx));\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n    };\n\n\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n                case 0:\n                    cb.call(context, i);\n                    break;\n                case 1:\n                    cb.call(context, this.get(dims[0], i, stack), i);\n                    break;\n                case 2:\n                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                    break;\n                default:\n                    for (var k = 0; k < dimSize; k++) {\n                        value[k] = this.get(dims[k], i, stack);\n                    }\n                    // Index\n                    value[k] = i;\n                    cb.apply(context, value);\n            }\n        }\n    };\n\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (!dimSize) {\n                keep = cb.call(context, i);\n            }\n            else if (dimSize === 1) {\n                keep = cb.call(\n                    context, this.get(dimensions[0], i, stack), i\n                );\n            }\n            else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n\n        this.indices = newIndices;\n\n        // Reset data extent\n        this._extent = {};\n\n        return this;\n    };\n\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(\n            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n            original.hostModel\n        );\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(\n                    originalStorage[dim].length\n                );\n            }\n            else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n\n        var storage = list._storage;\n\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n\n        return list;\n    };\n\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n\n        return list;\n    };\n\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);\n    };\n\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        var val;\n        // Use prefix to avoid index to be the same as otherIdList[idx],\n        // which will cause weird udpate animation.\n        var prefix = 'e\\0\\0';\n\n        return new DataDiffer(\n            otherList ? otherList.indices : [],\n            this.indices,\n            function (idx) {\n                return (val = otherIdList[idx]) != null ? val : prefix + idx;\n            },\n            function (idx) {\n                return (val = idList[idx]) != null ? val : prefix + idx;\n            }\n        );\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge\n            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n            : layout;\n    };\n\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} [ignoreParent=false]\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n\n        this._graphicEls[idx] = el;\n    };\n\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n\n        // FIXME\n        list._storage = this._storage;\n\n        transferProperties(list, this);\n\n\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n\n        return list;\n    };\n\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\n    module.exports = List;\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2RhdGEvTGlzdC5qcz9iMDk2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsMENBQTBDLHlDQUF5QztBQUNuRjtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLGVBQWU7QUFDOUIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MscURBQXFEO0FBQ3JELG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjExNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGlzdCBmb3IgZGF0YSBzdG9yYWdlXG4gKiBAbW9kdWxlIGVjaGFydHMvZGF0YS9MaXN0XG4gKi9cblxuXG4gICAgdmFyIFVOREVGSU5FRCA9ICd1bmRlZmluZWQnO1xuICAgIHZhciBnbG9iYWxPYmogPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdztcbiAgICB2YXIgRmxvYXQ2NEFycmF5ID0gdHlwZW9mIGdsb2JhbE9iai5GbG9hdDY0QXJyYXkgPT09IFVOREVGSU5FRFxuICAgICAgICA/IEFycmF5IDogZ2xvYmFsT2JqLkZsb2F0NjRBcnJheTtcbiAgICB2YXIgSW50MzJBcnJheSA9IHR5cGVvZiBnbG9iYWxPYmouSW50MzJBcnJheSA9PT0gVU5ERUZJTkVEXG4gICAgICAgID8gQXJyYXkgOiBnbG9iYWxPYmouSW50MzJBcnJheTtcblxuICAgIHZhciBkYXRhQ3RvcnMgPSB7XG4gICAgICAgICdmbG9hdCc6IEZsb2F0NjRBcnJheSxcbiAgICAgICAgJ2ludCc6IEludDMyQXJyYXksXG4gICAgICAgIC8vIE9yZGluYWwgZGF0YSB0eXBlIGNhbiBiZSBzdHJpbmcgb3IgaW50XG4gICAgICAgICdvcmRpbmFsJzogQXJyYXksXG4gICAgICAgICdudW1iZXInOiBBcnJheSxcbiAgICAgICAgJ3RpbWUnOiBBcnJheVxuICAgIH07XG5cbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbC9Nb2RlbCcpO1xuICAgIHZhciBEYXRhRGlmZmVyID0gcmVxdWlyZSgnLi9EYXRhRGlmZmVyJyk7XG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgaXNPYmplY3QgPSB6clV0aWwuaXNPYmplY3Q7XG5cbiAgICB2YXIgVFJBTlNGRVJBQkxFX1BST1BFUlRJRVMgPSBbXG4gICAgICAgICdzdGFja2VkT24nLCAnaGFzSXRlbU9wdGlvbicsICdfbmFtZUxpc3QnLCAnX2lkTGlzdCcsICdfcmF3RGF0YSdcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gdHJhbnNmZXJQcm9wZXJ0aWVzKGEsIGIpIHtcbiAgICAgICAgenJVdGlsLmVhY2goVFJBTlNGRVJBQkxFX1BST1BFUlRJRVMuY29uY2F0KGIuX193cmFwcGVkTWV0aG9kcyB8fCBbXSksIGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgYVtwcm9wTmFtZV0gPSBiW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYS5fX3dyYXBwZWRNZXRob2RzID0gYi5fX3dyYXBwZWRNZXRob2RzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIERlZmF1bHREYXRhUHJvdmlkZXIoZGF0YUFycmF5KSB7XG4gICAgICAgIHRoaXMuX2FycmF5ID0gZGF0YUFycmF5IHx8IFtdO1xuICAgIH1cblxuICAgIERlZmF1bHREYXRhUHJvdmlkZXIucHJvdG90eXBlLnB1cmUgPSBmYWxzZTtcblxuICAgIERlZmF1bHREYXRhUHJvdmlkZXIucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICAgIH07XG4gICAgRGVmYXVsdERhdGFQcm92aWRlci5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FycmF5W2lkeF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZ3xPYmplY3Q+fSBkaW1lbnNpb25zXG4gICAgICogICAgICBGb3IgZXhhbXBsZSwgWydzb21lRGltTmFtZScsIHtuYW1lOiAnc29tZURpbU5hbWUnLCB0eXBlOiAnc29tZURpbVR5cGUnfSwgLi4uXS5cbiAgICAgKiAgICAgIERpbWVuc2lvbnMgc2hvdWxkIGJlIGNvbmNyZXRlIG5hbWVzIGxpa2UgeCwgeSwgeiwgbG5nLCBsYXQsIGFuZ2xlLCByYWRpdXNcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBob3N0TW9kZWxcbiAgICAgKi9cbiAgICB2YXIgTGlzdCA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBob3N0TW9kZWwpIHtcblxuICAgICAgICBkaW1lbnNpb25zID0gZGltZW5zaW9ucyB8fCBbJ3gnLCAneSddO1xuXG4gICAgICAgIHZhciBkaW1lbnNpb25JbmZvcyA9IHt9O1xuICAgICAgICB2YXIgZGltZW5zaW9uTmFtZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGltZW5zaW9uTmFtZTtcbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25JbmZvID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRpbWVuc2lvbnNbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uTmFtZSA9IGRpbWVuc2lvbnNbaV07XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZGltZW5zaW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29vcmREaW06IGRpbWVuc2lvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkRGltSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIC8vIFR5cGUgY2FuIGJlICdmbG9hdCcsICdpbnQnLCAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGlzIG51bWJlciwgUHJlY2lzaW9uIG9mIGZsb2F0IG1heSBub3QgZW5vdWdoXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdudW1iZXInXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbkluZm8gPSBkaW1lbnNpb25zW2ldO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbk5hbWUgPSBkaW1lbnNpb25JbmZvLm5hbWU7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uSW5mby50eXBlID0gZGltZW5zaW9uSW5mby50eXBlIHx8ICdudW1iZXInO1xuICAgICAgICAgICAgICAgIGlmICghZGltZW5zaW9uSW5mby5jb29yZERpbSkge1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25JbmZvLmNvb3JkRGltID0gZGltZW5zaW9uTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uSW5mby5jb29yZERpbUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaW1lbnNpb25JbmZvLm90aGVyRGltcyA9IGRpbWVuc2lvbkluZm8ub3RoZXJEaW1zIHx8IHt9O1xuICAgICAgICAgICAgZGltZW5zaW9uTmFtZXMucHVzaChkaW1lbnNpb25OYW1lKTtcbiAgICAgICAgICAgIGRpbWVuc2lvbkluZm9zW2RpbWVuc2lvbk5hbWVdID0gZGltZW5zaW9uSW5mbztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaW1lbnNpb25zID0gZGltZW5zaW9uTmFtZXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZm9tYXRpb24gb2YgZWFjaCBkYXRhIGRpbWVuc2lvbiwgbGlrZSBkYXRhIHR5cGUuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kaW1lbnNpb25JbmZvcyA9IGRpbWVuc2lvbkluZm9zO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhvc3RNb2RlbCA9IGhvc3RNb2RlbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhVHlwZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNlcyBzdG9yZXMgdGhlIGluZGljZXMgb2YgZGF0YSBzdWJzZXQgYWZ0ZXIgZmlsdGVyZWQuXG4gICAgICAgICAqIFRoaXMgZGF0YSBzdWJzZXQgd2lsbCBiZSB1c2VkIGluIGNoYXJ0LlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRpY2VzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGEgc3RvcmFnZVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxrZXksIFR5cGVkQXJyYXl8QXJyYXk+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3RvcmFnZSA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9uYW1lTGlzdCA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faWRMaXN0ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGVscyBvZiBkYXRhIG9wdGlvbiBpcyBzdG9yZWQgc3BhcnNlIGZvciBvcHRpbWl6aW5nIG1lbW9yeSBjb3N0XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWw+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb3B0aW9uTW9kZWxzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFja2VkT24gPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHbG9iYWwgdmlzdWFsIHByb3BlcnRpZXMgYWZ0ZXIgdmlzdWFsIGNvZGluZ1xuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdmlzdWFsID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdsb2JlbCBsYXlvdXQgcHJvcGVydGllcy5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xheW91dCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVtIHZpc3VhbCBwcm9wZXJ0aWVzIGFmdGVyIHZpc3VhbCBjb2RpbmdcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXRlbVZpc3VhbHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXRlbSBsYXlvdXQgcHJvcGVydGllcyBhZnRlciBsYXlvdXRcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXRlbUxheW91dHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGhpYyBlbGVtbmVudHNcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6enJlbmRlci9FbGVtZW50Pn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2dyYXBoaWNFbHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxBcnJheXxPYmplY3Q+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmF3RGF0YTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2V4dGVudDtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RQcm90byA9IExpc3QucHJvdG90eXBlO1xuXG4gICAgbGlzdFByb3RvLnR5cGUgPSAnbGlzdCc7XG5cbiAgICAvKipcbiAgICAgKiBJZiBlYWNoIGRhdGEgaXRlbSBoYXMgaXQncyBvd24gb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgbGlzdFByb3RvLmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogR2V0IGRpbWVuc2lvbiBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkaW1cbiAgICAgKiAgICAgICAgRGltZW5zaW9uIGNhbiBiZSBjb25jcmV0ZSBuYW1lcyBsaWtlIHgsIHksIHosIGxuZywgbGF0LCBhbmdsZSwgcmFkaXVzXG4gICAgICogICAgICAgIE9yIGEgb3JkaW5hbCBudW1iZXIuIEZvciBleGFtcGxlIGdldERpbWVuc2lvbkluZm8oMCkgd2lsbCByZXR1cm4gJ3gnIG9yICdsbmcnIG9yICdyYWRpdXMnXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb25jcmV0ZSBkaW0gbmFtZS5cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICBpZiAoIWlzTmFOKGRpbSkpIHtcbiAgICAgICAgICAgIGRpbSA9IHRoaXMuZGltZW5zaW9uc1tkaW1dIHx8IGRpbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGltO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdHlwZSBhbmQgc3RhY2thYmxlIGluZm8gb2YgcGFydGljdWxhciBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRpbVxuICAgICAqICAgICAgICBEaW1lbnNpb24gY2FuIGJlIGNvbmNyZXRlIG5hbWVzIGxpa2UgeCwgeSwgeiwgbG5nLCBsYXQsIGFuZ2xlLCByYWRpdXNcbiAgICAgKiAgICAgICAgT3IgYSBvcmRpbmFsIG51bWJlci4gRm9yIGV4YW1wbGUgZ2V0RGltZW5zaW9uSW5mbygwKSB3aWxsIHJldHVybiAneCcgb3IgJ2xuZycgb3IgJ3JhZGl1cydcbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0RGltZW5zaW9uSW5mbyA9IGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgcmV0dXJuIHpyVXRpbC5jbG9uZSh0aGlzLl9kaW1lbnNpb25JbmZvc1t0aGlzLmdldERpbWVuc2lvbihkaW0pXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZnJvbSBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0fG51bWJlcnxBcnJheT59IGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbbmFtZUxpc3RdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2RpbVZhbHVlR2V0dGVyXSAoZGF0YUl0ZW0sIGRpbU5hbWUsIGRhdGFJbmRleCwgZGltSW5kZXgpID0+IG51bWJlclxuICAgICAqL1xuICAgIGxpc3RQcm90by5pbml0RGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBuYW1lTGlzdCwgZGltVmFsdWVHZXR0ZXIpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgW107XG5cbiAgICAgICAgdmFyIGlzRGF0YUFycmF5ID0genJVdGlsLmlzQXJyYXkoZGF0YSk7XG4gICAgICAgIGlmIChpc0RhdGFBcnJheSkge1xuICAgICAgICAgICAgZGF0YSA9IG5ldyBEZWZhdWx0RGF0YVByb3ZpZGVyKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoIWlzRGF0YUFycmF5ICYmICh0eXBlb2YgZGF0YS5nZXRJdGVtICE9ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRhdGEuY291bnQgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luYXZsaWQgZGF0YSBwcm92aWRlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Jhd0RhdGEgPSBkYXRhO1xuXG4gICAgICAgIC8vIENsZWFyXG4gICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZSA9IHt9O1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlcyA9IFtdO1xuXG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zO1xuICAgICAgICB2YXIgZGltZW5zaW9uSW5mb01hcCA9IHRoaXMuX2RpbWVuc2lvbkluZm9zO1xuXG4gICAgICAgIHZhciBzaXplID0gZGF0YS5jb3VudCgpO1xuXG4gICAgICAgIHZhciBpZExpc3QgPSBbXTtcbiAgICAgICAgdmFyIG5hbWVSZXBlYXRDb3VudCA9IHt9O1xuICAgICAgICB2YXIgbmFtZURpbUlkeDtcblxuICAgICAgICBuYW1lTGlzdCA9IG5hbWVMaXN0IHx8IFtdO1xuXG4gICAgICAgIC8vIEluaXQgc3RvcmFnZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaW1JbmZvID0gZGltZW5zaW9uSW5mb01hcFtkaW1lbnNpb25zW2ldXTtcbiAgICAgICAgICAgIGRpbUluZm8ub3RoZXJEaW1zLml0ZW1OYW1lID09PSAwICYmIChuYW1lRGltSWR4ID0gaSk7XG4gICAgICAgICAgICB2YXIgRGF0YUN0b3IgPSBkYXRhQ3RvcnNbZGltSW5mby50eXBlXTtcbiAgICAgICAgICAgIHN0b3JhZ2VbZGltZW5zaW9uc1tpXV0gPSBuZXcgRGF0YUN0b3Ioc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghZGltVmFsdWVHZXR0ZXIpIHtcbiAgICAgICAgICAgIHNlbGYuaGFzSXRlbU9wdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZmF1bHQgZGltIHZhbHVlIGdldHRlclxuICAgICAgICBkaW1WYWx1ZUdldHRlciA9IGRpbVZhbHVlR2V0dGVyIHx8IGZ1bmN0aW9uIChkYXRhSXRlbSwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbW9kZWxVdGlsLmdldERhdGFJdGVtVmFsdWUoZGF0YUl0ZW0pO1xuICAgICAgICAgICAgLy8gSWYgYW55IGRhdGFJdGVtIGlzIGxpa2UgeyB2YWx1ZTogMTAgfVxuICAgICAgICAgICAgaWYgKG1vZGVsVXRpbC5pc0RhdGFJdGVtT3B0aW9uKGRhdGFJdGVtKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuaGFzSXRlbU9wdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9kZWxVdGlsLmNvbnZlckRhdGFWYWx1ZShcbiAgICAgICAgICAgICAgICAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVtkaW1JbmRleF1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdmFsdWUgaXMgYSBzaW5nbGUgbnVtYmVyIG9yIHNvbWV0aGluZyBlbHNlIG5vdCBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25JbmZvTWFwW2RpbU5hbWVdXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAvLyBOT1RJQ0U6IFRyeSBub3QgdG8gd3JpdGUgdGhpbmdzIGludG8gZGF0YUl0ZW1cbiAgICAgICAgICAgIHZhciBkYXRhSXRlbSA9IGRhdGEuZ2V0SXRlbShpKTtcbiAgICAgICAgICAgIC8vIEVhY2ggZGF0YSBpdGVtIGlzIHZhbHVlXG4gICAgICAgICAgICAvLyBbMSwgMl1cbiAgICAgICAgICAgIC8vIDJcbiAgICAgICAgICAgIC8vIEJhciBjaGFydCwgbGluZSBjaGFydCB3aGljaCB1c2VzIGNhdGVnb3J5IGF4aXNcbiAgICAgICAgICAgIC8vIG9ubHkgZ2l2ZXMgdGhlICd5JyB2YWx1ZS4gJ3gnIHZhbHVlIGlzIHRoZSBpbmRpY2VzIG9mIGNhdGVvZ3J5XG4gICAgICAgICAgICAvLyBVc2UgYSB0ZW1wVmFsdWUgdG8gbm9ybWFsaXplIHRoZSB2YWx1ZSB0byBiZSBhICh4LCB5KSB2YWx1ZVxuXG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgZGF0YSBieSBkaW1lbnNpb25zXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGRpbWVuc2lvbnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGltID0gZGltZW5zaW9uc1trXTtcbiAgICAgICAgICAgICAgICB2YXIgZGltU3RvcmFnZSA9IHN0b3JhZ2VbZGltXTtcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HIE5VTEwgaXMgZW1wdHkgb3IgemVyb1xuICAgICAgICAgICAgICAgIGRpbVN0b3JhZ2VbaV0gPSBkaW1WYWx1ZUdldHRlcihkYXRhSXRlbSwgZGltLCBpLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIHRoZSBuYW1lIGluIG9wdGlvbiBhbmQgY3JlYXRlIGlkXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGF0YUl0ZW0gPSBkYXRhLmdldEl0ZW0oaSk7XG4gICAgICAgICAgICBpZiAoIW5hbWVMaXN0W2ldICYmIGRhdGFJdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFJdGVtLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lTGlzdFtpXSA9IGRhdGFJdGVtLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWVEaW1JZHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lTGlzdFtpXSA9IHN0b3JhZ2VbZGltZW5zaW9uc1tuYW1lRGltSWR4XV1baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5hbWUgPSBuYW1lTGlzdFtpXSB8fCAnJztcbiAgICAgICAgICAgIC8vIFRyeSB1c2luZyB0aGUgaWQgaW4gb3B0aW9uXG4gICAgICAgICAgICB2YXIgaWQgPSBkYXRhSXRlbSAmJiBkYXRhSXRlbS5pZDtcblxuICAgICAgICAgICAgaWYgKCFpZCAmJiBuYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIG5hbWUgYXMgaWQgYW5kIGFkZCBjb3VudGVyIHRvIGF2b2lkIHNhbWUgbmFtZVxuICAgICAgICAgICAgICAgIG5hbWVSZXBlYXRDb3VudFtuYW1lXSA9IG5hbWVSZXBlYXRDb3VudFtuYW1lXSB8fCAwO1xuICAgICAgICAgICAgICAgIGlkID0gbmFtZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZVJlcGVhdENvdW50W25hbWVdID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZCArPSAnX19lY19fJyArIG5hbWVSZXBlYXRDb3VudFtuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmFtZVJlcGVhdENvdW50W25hbWVdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZCAmJiAoaWRMaXN0W2ldID0gaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbmFtZUxpc3QgPSBuYW1lTGlzdDtcbiAgICAgICAgdGhpcy5faWRMaXN0ID0gaWRMaXN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRpY2VzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlLiBSZXR1cm4gTmFOIGlmIGlkeCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpbSBEaW0gbXVzdCBiZSBjb25jcmV0ZSBuYW1lLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXQgPSBmdW5jdGlvbiAoZGltLCBpZHgsIHN0YWNrKSB7XG4gICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgICAgICAgdmFyIGRhdGFJbmRleCA9IHRoaXMuaW5kaWNlc1tpZHhdO1xuXG4gICAgICAgIC8vIElmIHZhbHVlIG5vdCBleGlzdHNcbiAgICAgICAgaWYgKGRhdGFJbmRleCA9PSBudWxsIHx8ICFzdG9yYWdlW2RpbV0pIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSBzdG9yYWdlW2RpbV1bZGF0YUluZGV4XTtcbiAgICAgICAgLy8gRklYTUUgb3JkaW5hbCBkYXRhIHR5cGUgaXMgbm90IHN0YWNrYWJsZVxuICAgICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25JbmZvID0gdGhpcy5fZGltZW5zaW9uSW5mb3NbZGltXTtcbiAgICAgICAgICAgIGlmIChkaW1lbnNpb25JbmZvICYmIGRpbWVuc2lvbkluZm8uc3RhY2thYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrZWRPbiA9IHRoaXMuc3RhY2tlZE9uO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFja2VkT24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IG5vIHN0YWNrZWQgZGF0YSBvZiBzdGFja2VkIG9uXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFja2VkVmFsdWUgPSBzdGFja2VkT24uZ2V0KGRpbSwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXJpbmcgcG9zaXRpdmUgc3RhY2ssIG5lZ2F0aXZlIHN0YWNrIGFuZCBlbXB0eSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgPj0gMCAmJiBzdGFja2VkVmFsdWUgPiAwKSAgLy8gUG9zaXRpdmUgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICh2YWx1ZSA8PSAwICYmIHN0YWNrZWRWYWx1ZSA8IDApIC8vIE5lZ2F0aXZlIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc3RhY2tlZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrZWRPbiA9IHN0YWNrZWRPbi5zdGFja2VkT247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlIGZvciBtdWx0aSBkaW1lbnNpb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IFtkaW1lbnNpb25zXSBJZiBpZ25vcmVkLCB1c2luZyBhbGwgZGltZW5zaW9ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGFja1xuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0VmFsdWVzID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMsIGlkeCwgc3RhY2spIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkoZGltZW5zaW9ucykpIHtcbiAgICAgICAgICAgIHN0YWNrID0gaWR4O1xuICAgICAgICAgICAgaWR4ID0gZGltZW5zaW9ucztcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSB0aGlzLmRpbWVuc2lvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGltZW5zaW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5nZXQoZGltZW5zaW9uc1tpXSwgaWR4LCBzdGFjaykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSWYgdmFsdWUgaXMgTmFOLiBJbmxjdWRpbmcgJy0nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmhhc1ZhbHVlID0gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICAgICAgdmFyIGRpbWVuc2lvbkluZm9zID0gdGhpcy5fZGltZW5zaW9uSW5mb3M7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkaW1lbnNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gT3JkaW5hbCB0eXBlIGNhbiBiZSBzdHJpbmcgb3IgbnVtYmVyXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uSW5mb3NbZGltZW5zaW9uc1tpXV0udHlwZSAhPT0gJ29yZGluYWwnXG4gICAgICAgICAgICAgICAgJiYgaXNOYU4odGhpcy5nZXQoZGltZW5zaW9uc1tpXSwgaWR4KSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGV4dGVudCBvZiBkYXRhIGluIG9uZSBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGltXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbHRlclxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXREYXRhRXh0ZW50ID0gZnVuY3Rpb24gKGRpbSwgc3RhY2ssIGZpbHRlcikge1xuICAgICAgICBkaW0gPSB0aGlzLmdldERpbWVuc2lvbihkaW0pO1xuICAgICAgICB2YXIgZGltRGF0YSA9IHRoaXMuX3N0b3JhZ2VbZGltXTtcbiAgICAgICAgdmFyIGRpbUluZm8gPSB0aGlzLmdldERpbWVuc2lvbkluZm8oZGltKTtcbiAgICAgICAgc3RhY2sgPSAoZGltSW5mbyAmJiBkaW1JbmZvLnN0YWNrYWJsZSkgJiYgc3RhY2s7XG4gICAgICAgIHZhciBkaW1FeHRlbnQgPSAodGhpcy5fZXh0ZW50IHx8ICh0aGlzLl9leHRlbnQgPSB7fSkpW2RpbSArICghIXN0YWNrKV07XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKGRpbUV4dGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpbUV4dGVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyB2YXIgZGltSW5mbyA9IHRoaXMuX2RpbWVuc2lvbkluZm9zW2RpbV07XG4gICAgICAgIGlmIChkaW1EYXRhKSB7XG4gICAgICAgICAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgICAgICAgICAgLy8gdmFyIGlzT3JkaW5hbCA9IGRpbUluZm8udHlwZSA9PT0gJ29yZGluYWwnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldChkaW0sIGksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgIC8vIGlmIChpc09yZGluYWwgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vICAgICB2YWx1ZSA9IHpyVXRpbC5pbmRleE9mKGRpbURhdGEsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKHZhbHVlLCBkaW0sIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlIDwgbWluICYmIChtaW4gPSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID4gbWF4ICYmIChtYXggPSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9leHRlbnRbZGltICsgISFzdGFja10gPSBbbWluLCBtYXhdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHN1bSBvZiBkYXRhIGluIG9uZSBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGltXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGFja1xuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRTdW0gPSBmdW5jdGlvbiAoZGltLCBzdGFjaykge1xuICAgICAgICB2YXIgZGltRGF0YSA9IHRoaXMuX3N0b3JhZ2VbZGltXTtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGlmIChkaW1EYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChkaW0sIGksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJlaXZlIHRoZSBpbmRleCB3aXRoIGdpdmVuIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICAvLyBGSVhNRSBQcmVjaXNpb24gb2YgZmxvYXQgdmFsdWVcbiAgICBsaXN0UHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIChkaW0sIHZhbHVlKSB7XG4gICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgICAgICAgdmFyIGRpbURhdGEgPSBzdG9yYWdlW2RpbV07XG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuXG4gICAgICAgIGlmIChkaW1EYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByYXdJbmRleCA9IGluZGljZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGRpbURhdGFbcmF3SW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyZWl2ZSB0aGUgaW5kZXggd2l0aCBnaXZlbiBuYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYW1lXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5pbmRleE9mTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuICAgICAgICB2YXIgbmFtZUxpc3QgPSB0aGlzLl9uYW1lTGlzdDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHJhd0luZGV4ID0gaW5kaWNlc1tpXTtcbiAgICAgICAgICAgIGlmIChuYW1lTGlzdFtyYXdJbmRleF0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmVpdmUgdGhlIGluZGV4IHdpdGggZ2l2ZW4gcmF3IGRhdGEgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmluZGV4T2ZSYXdJbmRleCA9IGZ1bmN0aW9uIChyYXdJbmRleCkge1xuICAgICAgICAvLyBJbmRpY2VzIGFyZSBhc2NlbmRpbmdcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG5cbiAgICAgICAgLy8gSWYgcmF3SW5kZXggPT09IGRhdGFJbmRleFxuICAgICAgICB2YXIgcmF3RGF0YUluZGV4ID0gaW5kaWNlc1tyYXdJbmRleF07XG4gICAgICAgIGlmIChyYXdEYXRhSW5kZXggIT0gbnVsbCAmJiByYXdEYXRhSW5kZXggPT09IHJhd0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3SW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVmdCA9IDA7XG4gICAgICAgIHZhciByaWdodCA9IGluZGljZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICAgICAgICAgIHZhciBtaWQgPSAobGVmdCArIHJpZ2h0KSAvIDIgfCAwO1xuICAgICAgICAgICAgaWYgKGluZGljZXNbbWlkXSA8IHJhd0luZGV4KSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmRpY2VzW21pZF0gPiByYXdJbmRleCkge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gbWlkIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyZWl2ZSB0aGUgaW5kZXggb2YgbmVhcmVzdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrIElmIGdpdmVuIHZhbHVlIGlzIGFmdGVyIHN0YWNrZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heERpc3RhbmNlPUluZmluaXR5XVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBDb25zaWRlcmUgbXVsdGlwbGUgcG9pbnRzIGhhcyB0aGUgc2FtZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uaW5kaWNlc09mTmVhcmVzdCA9IGZ1bmN0aW9uIChkaW0sIHZhbHVlLCBzdGFjaywgbWF4RGlzdGFuY2UpIHtcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlO1xuICAgICAgICB2YXIgZGltRGF0YSA9IHN0b3JhZ2VbZGltXTtcbiAgICAgICAgdmFyIG5lYXJlc3RJbmRpY2VzID0gW107XG5cbiAgICAgICAgaWYgKCFkaW1EYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmVhcmVzdEluZGljZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4RGlzdGFuY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5EaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIG1pbkRpZmYgPSAtMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IHZhbHVlIC0gdGhpcy5nZXQoZGltLCBpLCBzdGFjayk7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IE1hdGguYWJzKGRpZmYpO1xuICAgICAgICAgICAgaWYgKGRpZmYgPD0gbWF4RGlzdGFuY2UgJiYgZGlzdCA8PSBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIHRoZSBjYXNlIG9mIHR3byBkYXRhIGFyZSBzYW1lIG9uIHhBeGlzLCB3aGljaCBoYXMgc2VxdWVuY2UgZGF0YS5cbiAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSBuZWFyZXN0IGluZGV4XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS9lY2hhcnRzL2lzc3Vlcy8yODY5XG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0IHx8IChkaWZmID49IDAgJiYgbWluRGlmZiA8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICBtaW5EaWZmID0gZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgbmVhcmVzdEluZGljZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmVhcmVzdEluZGljZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVhcmVzdEluZGljZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCByYXcgZGF0YSBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldFJhd0luZGV4ID0gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICB2YXIgcmF3SWR4ID0gdGhpcy5pbmRpY2VzW2lkeF07XG4gICAgICAgIHJldHVybiByYXdJZHggPT0gbnVsbCA/IC0xIDogcmF3SWR4O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmF3IGRhdGEgaXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldFJhd0RhdGFJdGVtID0gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmF3RGF0YS5nZXRJdGVtKHRoaXMuZ2V0UmF3SW5kZXgoaWR4KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtub3REZWZhdWx0SWR4PWZhbHNlXVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0TmFtZSA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWVMaXN0W3RoaXMuaW5kaWNlc1tpZHhdXSB8fCAnJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vdERlZmF1bHRJZHg9ZmFsc2VdXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRJZCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkTGlzdFt0aGlzLmluZGljZXNbaWR4XV0gfHwgKHRoaXMuZ2V0UmF3SW5kZXgoaWR4KSArICcnKTtcbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVEaW1lbnNpb25zKGRpbWVuc2lvbnMpIHtcbiAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShkaW1lbnNpb25zKSkge1xuICAgICAgICAgICAgZGltZW5zaW9ucyA9IFtkaW1lbnNpb25zXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIGl0ZXJhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3RhY2s9ZmFsc2VdXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgbGlzdC5lYWNoKCd4JywgZnVuY3Rpb24gKHgsIGlkeCkge30pO1xuICAgICAqICBsaXN0LmVhY2goWyd4JywgJ3knXSwgZnVuY3Rpb24gKHgsIHksIGlkeCkge30pO1xuICAgICAqICBsaXN0LmVhY2goZnVuY3Rpb24gKGlkeCkge30pXG4gICAgICovXG4gICAgbGlzdFByb3RvLmVhY2ggPSBmdW5jdGlvbiAoZGltcywgY2IsIHN0YWNrLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGltcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29udGV4dCA9IHN0YWNrO1xuICAgICAgICAgICAgc3RhY2sgPSBjYjtcbiAgICAgICAgICAgIGNiID0gZGltcztcbiAgICAgICAgICAgIGRpbXMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpbXMgPSB6clV0aWwubWFwKG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltcyksIHRoaXMuZ2V0RGltZW5zaW9uLCB0aGlzKTtcblxuICAgICAgICB2YXIgdmFsdWUgPSBbXTtcbiAgICAgICAgdmFyIGRpbVNpemUgPSBkaW1zLmxlbmd0aDtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG5cbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIHN3aXRjaCAoZGltU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMuZ2V0KGRpbXNbMF0sIGksIHN0YWNrKSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLmdldChkaW1zWzBdLCBpLCBzdGFjayksIHRoaXMuZ2V0KGRpbXNbMV0sIGksIHN0YWNrKSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGltU2l6ZTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHRoaXMuZ2V0KGRpbXNba10sIGksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJbmRleFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGNiLmFwcGx5KGNvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIGZpbHRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3RhY2s9ZmFsc2VdXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICAgICAqL1xuICAgIGxpc3RQcm90by5maWx0ZXJTZWxmID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMsIGNiLCBzdGFjaywgY29udGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIGRpbWVuc2lvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBzdGFjaztcbiAgICAgICAgICAgIHN0YWNrID0gY2I7XG4gICAgICAgICAgICBjYiA9IGRpbWVuc2lvbnM7XG4gICAgICAgICAgICBkaW1lbnNpb25zID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBkaW1lbnNpb25zID0genJVdGlsLm1hcChcbiAgICAgICAgICAgIG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltZW5zaW9ucyksIHRoaXMuZ2V0RGltZW5zaW9uLCB0aGlzXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIG5ld0luZGljZXMgPSBbXTtcbiAgICAgICAgdmFyIHZhbHVlID0gW107XG4gICAgICAgIHZhciBkaW1TaXplID0gZGltZW5zaW9ucy5sZW5ndGg7XG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2VlcDtcbiAgICAgICAgICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIGlmICghZGltU2l6ZSkge1xuICAgICAgICAgICAgICAgIGtlZXAgPSBjYi5jYWxsKGNvbnRleHQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGltU2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGtlZXAgPSBjYi5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LCB0aGlzLmdldChkaW1lbnNpb25zWzBdLCBpLCBzdGFjayksIGlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBkaW1TaXplOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVba10gPSB0aGlzLmdldChkaW1lbnNpb25zW2tdLCBpLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gaTtcbiAgICAgICAgICAgICAgICBrZWVwID0gY2IuYXBwbHkoY29udGV4dCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtlZXApIHtcbiAgICAgICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kaWNlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluZGljZXMgPSBuZXdJbmRpY2VzO1xuXG4gICAgICAgIC8vIFJlc2V0IGRhdGEgZXh0ZW50XG4gICAgICAgIHRoaXMuX2V4dGVudCA9IHt9O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIG1hcHBpbmcgdG8gYSBwbGFpbiBhcnJheVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbZGltZW5zaW9uc11cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0YWNrPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc11cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8ubWFwQXJyYXkgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgY2IsIHN0YWNrLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGltZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29udGV4dCA9IHN0YWNrO1xuICAgICAgICAgICAgc3RhY2sgPSBjYjtcbiAgICAgICAgICAgIGNiID0gZGltZW5zaW9ucztcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5lYWNoKGRpbWVuc2lvbnMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNiICYmIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICB9LCBzdGFjaywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNsb25lTGlzdEZvck1hcEFuZFNhbXBsZShvcmlnaW5hbCwgZXhjbHVkZURpbWVuc2lvbnMpIHtcbiAgICAgICAgdmFyIGFsbERpbWVuc2lvbnMgPSBvcmlnaW5hbC5kaW1lbnNpb25zO1xuICAgICAgICB2YXIgbGlzdCA9IG5ldyBMaXN0KFxuICAgICAgICAgICAgenJVdGlsLm1hcChhbGxEaW1lbnNpb25zLCBvcmlnaW5hbC5nZXREaW1lbnNpb25JbmZvLCBvcmlnaW5hbCksXG4gICAgICAgICAgICBvcmlnaW5hbC5ob3N0TW9kZWxcbiAgICAgICAgKTtcbiAgICAgICAgLy8gRklYTUUgSWYgbmVlZHMgc3RhY2tlZE9uLCB2YWx1ZSBtYXkgYWxyZWFkeSBiZWVuIHN0YWNrZWRcbiAgICAgICAgdHJhbnNmZXJQcm9wZXJ0aWVzKGxpc3QsIG9yaWdpbmFsKTtcblxuICAgICAgICB2YXIgc3RvcmFnZSA9IGxpc3QuX3N0b3JhZ2UgPSB7fTtcbiAgICAgICAgdmFyIG9yaWdpbmFsU3RvcmFnZSA9IG9yaWdpbmFsLl9zdG9yYWdlO1xuICAgICAgICAvLyBJbml0IHN0b3JhZ2VcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxEaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGltID0gYWxsRGltZW5zaW9uc1tpXTtcbiAgICAgICAgICAgIHZhciBkaW1TdG9yZSA9IG9yaWdpbmFsU3RvcmFnZVtkaW1dO1xuICAgICAgICAgICAgaWYgKHpyVXRpbC5pbmRleE9mKGV4Y2x1ZGVEaW1lbnNpb25zLCBkaW0pID49IDApIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlW2RpbV0gPSBuZXcgZGltU3RvcmUuY29uc3RydWN0b3IoXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RvcmFnZVtkaW1dLmxlbmd0aFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEaXJlY3QgcmVmZXJlbmNlIGZvciBvdGhlciBkaW1lbnNpb25zXG4gICAgICAgICAgICAgICAgc3RvcmFnZVtkaW1dID0gb3JpZ2luYWxTdG9yYWdlW2RpbV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGF0YSBtYXBwaW5nIHRvIGEgbmV3IExpc3Qgd2l0aCBnaXZlbiBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0YWNrPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc11cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8ubWFwID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMsIGNiLCBzdGFjaywgY29udGV4dCkge1xuICAgICAgICBkaW1lbnNpb25zID0genJVdGlsLm1hcChcbiAgICAgICAgICAgIG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltZW5zaW9ucyksIHRoaXMuZ2V0RGltZW5zaW9uLCB0aGlzXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIGxpc3QgPSBjbG9uZUxpc3RGb3JNYXBBbmRTYW1wbGUodGhpcywgZGltZW5zaW9ucyk7XG4gICAgICAgIC8vIEZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBhbGwgaW1tdXRhYmxlLlxuICAgICAgICAvLyBTbyB3ZSBjYW4gcmVmZXJlbmNlIHRvIHRoZSBzYW1lIHZhbHVlXG4gICAgICAgIHZhciBpbmRpY2VzID0gbGlzdC5pbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuXG4gICAgICAgIHZhciBzdG9yYWdlID0gbGlzdC5fc3RvcmFnZTtcblxuICAgICAgICB2YXIgdG1wUmV0VmFsdWUgPSBbXTtcbiAgICAgICAgdGhpcy5lYWNoKGRpbWVuc2lvbnMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIHJldFZhbHVlID0gY2IgJiYgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmIChyZXRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gYSBudW1iZXJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJldFZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB0bXBSZXRWYWx1ZVswXSA9IHJldFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXRWYWx1ZSA9IHRtcFJldFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaW0gPSBkaW1lbnNpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGltU3RvcmUgPSBzdG9yYWdlW2RpbV07XG4gICAgICAgICAgICAgICAgICAgIHZhciByYXdJZHggPSBpbmRpY2VzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaW1TdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGltU3RvcmVbcmF3SWR4XSA9IHJldFZhbHVlW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzdGFjaywgY29udGV4dCk7XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExhcmdlIGRhdGEgZG93biBzYW1wbGluZyBvbiBnaXZlbiBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzYW1wbGVWYWx1ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNhbXBsZUluZGV4IFNhbXBsZSBpbmRleCBmb3IgbmFtZSBhbmQgaWRcbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZG93blNhbXBsZSA9IGZ1bmN0aW9uIChkaW1lbnNpb24sIHJhdGUsIHNhbXBsZVZhbHVlLCBzYW1wbGVJbmRleCkge1xuICAgICAgICB2YXIgbGlzdCA9IGNsb25lTGlzdEZvck1hcEFuZFNhbXBsZSh0aGlzLCBbZGltZW5zaW9uXSk7XG4gICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgICAgICAgdmFyIHRhcmdldFN0b3JhZ2UgPSBsaXN0Ll9zdG9yYWdlO1xuXG4gICAgICAgIHZhciBvcmlnaW5hbEluZGljZXMgPSB0aGlzLmluZGljZXM7XG4gICAgICAgIHZhciBpbmRpY2VzID0gbGlzdC5pbmRpY2VzID0gW107XG5cbiAgICAgICAgdmFyIGZyYW1lVmFsdWVzID0gW107XG4gICAgICAgIHZhciBmcmFtZUluZGljZXMgPSBbXTtcbiAgICAgICAgdmFyIGZyYW1lU2l6ZSA9IE1hdGguZmxvb3IoMSAvIHJhdGUpO1xuXG4gICAgICAgIHZhciBkaW1TdG9yZSA9IHRhcmdldFN0b3JhZ2VbZGltZW5zaW9uXTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuY291bnQoKTtcbiAgICAgICAgLy8gQ29weSBkYXRhIGZyb20gb3JpZ2luYWwgZGF0YVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3JhZ2VbZGltZW5zaW9uXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGFyZ2V0U3RvcmFnZVtkaW1lbnNpb25dW2ldID0gc3RvcmFnZVtkaW1lbnNpb25dW2ldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IGZyYW1lU2l6ZSkge1xuICAgICAgICAgICAgLy8gTGFzdCBmcmFtZVxuICAgICAgICAgICAgaWYgKGZyYW1lU2l6ZSA+IGxlbiAtIGkpIHtcbiAgICAgICAgICAgICAgICBmcmFtZVNpemUgPSBsZW4gLSBpO1xuICAgICAgICAgICAgICAgIGZyYW1lVmFsdWVzLmxlbmd0aCA9IGZyYW1lU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZnJhbWVTaXplOyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gb3JpZ2luYWxJbmRpY2VzW2kgKyBrXTtcbiAgICAgICAgICAgICAgICBmcmFtZVZhbHVlc1trXSA9IGRpbVN0b3JlW2lkeF07XG4gICAgICAgICAgICAgICAgZnJhbWVJbmRpY2VzW2tdID0gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2FtcGxlVmFsdWUoZnJhbWVWYWx1ZXMpO1xuICAgICAgICAgICAgdmFyIGlkeCA9IGZyYW1lSW5kaWNlc1tzYW1wbGVJbmRleChmcmFtZVZhbHVlcywgdmFsdWUpIHx8IDBdO1xuICAgICAgICAgICAgLy8gT25seSB3cml0ZSB2YWx1ZSBvbiB0aGUgZmlsdGVyZWQgZGF0YVxuICAgICAgICAgICAgZGltU3RvcmVbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGlkeCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IG1vZGVsIG9mIG9uZSBkYXRhIGl0ZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICovXG4gICAgLy8gRklYTUUgTW9kZWwgcHJveHkgP1xuICAgIGxpc3RQcm90by5nZXRJdGVtTW9kZWwgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHZhciBob3N0TW9kZWwgPSB0aGlzLmhvc3RNb2RlbDtcbiAgICAgICAgaWR4ID0gdGhpcy5pbmRpY2VzW2lkeF07XG4gICAgICAgIHJldHVybiBuZXcgTW9kZWwodGhpcy5fcmF3RGF0YS5nZXRJdGVtKGlkeCksIGhvc3RNb2RlbCwgaG9zdE1vZGVsICYmIGhvc3RNb2RlbC5lY01vZGVsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZGF0YSBkaWZmZXJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gb3RoZXJMaXN0XG4gICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvZGF0YS9EYXRhRGlmZmVyfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5kaWZmID0gZnVuY3Rpb24gKG90aGVyTGlzdCkge1xuICAgICAgICB2YXIgaWRMaXN0ID0gdGhpcy5faWRMaXN0O1xuICAgICAgICB2YXIgb3RoZXJJZExpc3QgPSBvdGhlckxpc3QgJiYgb3RoZXJMaXN0Ll9pZExpc3Q7XG4gICAgICAgIHZhciB2YWw7XG4gICAgICAgIC8vIFVzZSBwcmVmaXggdG8gYXZvaWQgaW5kZXggdG8gYmUgdGhlIHNhbWUgYXMgb3RoZXJJZExpc3RbaWR4XSxcbiAgICAgICAgLy8gd2hpY2ggd2lsbCBjYXVzZSB3ZWlyZCB1ZHBhdGUgYW5pbWF0aW9uLlxuICAgICAgICB2YXIgcHJlZml4ID0gJ2VcXDBcXDAnO1xuXG4gICAgICAgIHJldHVybiBuZXcgRGF0YURpZmZlcihcbiAgICAgICAgICAgIG90aGVyTGlzdCA/IG90aGVyTGlzdC5pbmRpY2VzIDogW10sXG4gICAgICAgICAgICB0aGlzLmluZGljZXMsXG4gICAgICAgICAgICBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWwgPSBvdGhlcklkTGlzdFtpZHhdKSAhPSBudWxsID8gdmFsIDogcHJlZml4ICsgaWR4O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbCA9IGlkTGlzdFtpZHhdKSAhPSBudWxsID8gdmFsIDogcHJlZml4ICsgaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHZpc3VhbCBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldFZpc3VhbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZpc3VhbCA9IHRoaXMuX3Zpc3VhbDtcbiAgICAgICAgcmV0dXJuIHZpc3VhbCAmJiB2aXN1YWxba2V5XTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHZpc3VhbCBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5XG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBzZXRWaXN1YWwoJ2NvbG9yJywgY29sb3IpO1xuICAgICAqICBzZXRWaXN1YWwoe1xuICAgICAqICAgICAgJ2NvbG9yJzogY29sb3JcbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgbGlzdFByb3RvLnNldFZpc3VhbCA9IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmlzdWFsKG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc3VhbCA9IHRoaXMuX3Zpc3VhbCB8fCB7fTtcbiAgICAgICAgdGhpcy5fdmlzdWFsW2tleV0gPSB2YWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBsYXlvdXQgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbF1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uc2V0TGF5b3V0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRMYXlvdXQobmFtZSwga2V5W25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGF5b3V0W2tleV0gPSB2YWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBsYXlvdXQgcHJvcGVydHkuXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkuXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0TGF5b3V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0W2tleV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBsYXlvdXQgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0SXRlbUxheW91dCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1MYXlvdXRzW2lkeF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBsYXlvdXQgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGF5b3V0XG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gW21lcmdlPWZhbHNlXVxuICAgICAqL1xuICAgIGxpc3RQcm90by5zZXRJdGVtTGF5b3V0ID0gZnVuY3Rpb24gKGlkeCwgbGF5b3V0LCBtZXJnZSkge1xuICAgICAgICB0aGlzLl9pdGVtTGF5b3V0c1tpZHhdID0gbWVyZ2VcbiAgICAgICAgICAgID8genJVdGlsLmV4dGVuZCh0aGlzLl9pdGVtTGF5b3V0c1tpZHhdIHx8IHt9LCBsYXlvdXQpXG4gICAgICAgICAgICA6IGxheW91dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGxheW91dCBvZiBzaW5nbGUgZGF0YSBpdGVtXG4gICAgICovXG4gICAgbGlzdFByb3RvLmNsZWFySXRlbUxheW91dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1MYXlvdXRzLmxlbmd0aCA9IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB2aXN1YWwgcHJvcGVydHkgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlUGFyZW50PWZhbHNlXVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRJdGVtVmlzdWFsID0gZnVuY3Rpb24gKGlkeCwga2V5LCBpZ25vcmVQYXJlbnQpIHtcbiAgICAgICAgdmFyIGl0ZW1WaXN1YWwgPSB0aGlzLl9pdGVtVmlzdWFsc1tpZHhdO1xuICAgICAgICB2YXIgdmFsID0gaXRlbVZpc3VhbCAmJiBpdGVtVmlzdWFsW2tleV07XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCAmJiAhaWdub3JlUGFyZW50KSB7XG4gICAgICAgICAgICAvLyBVc2UgZ2xvYmFsIHZpc3VhbCBwcm9wZXJ0eVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmlzdWFsKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHZpc3VhbCBwcm9wZXJ0eSBvZiBzaW5nbGUgZGF0YSBpdGVtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZV1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHNldEl0ZW1WaXN1YWwoMCwgJ2NvbG9yJywgY29sb3IpO1xuICAgICAqICBzZXRJdGVtVmlzdWFsKDAsIHtcbiAgICAgKiAgICAgICdjb2xvcic6IGNvbG9yXG4gICAgICogIH0pO1xuICAgICAqL1xuICAgIGxpc3RQcm90by5zZXRJdGVtVmlzdWFsID0gZnVuY3Rpb24gKGlkeCwga2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgaXRlbVZpc3VhbCA9IHRoaXMuX2l0ZW1WaXN1YWxzW2lkeF0gfHwge307XG4gICAgICAgIHRoaXMuX2l0ZW1WaXN1YWxzW2lkeF0gPSBpdGVtVmlzdWFsO1xuXG4gICAgICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVZpc3VhbFtuYW1lXSA9IGtleVtuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaXRlbVZpc3VhbFtrZXldID0gdmFsdWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIGl0ZW1WaXN1YWxzIGFuZCBsaXN0IHZpc3VhbC5cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uY2xlYXJBbGxWaXN1YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Zpc3VhbCA9IHt9O1xuICAgICAgICB0aGlzLl9pdGVtVmlzdWFscyA9IFtdO1xuICAgIH07XG5cbiAgICB2YXIgc2V0SXRlbURhdGFBbmRTZXJpZXNJbmRleCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBjaGlsZC5zZXJpZXNJbmRleCA9IHRoaXMuc2VyaWVzSW5kZXg7XG4gICAgICAgIGNoaWxkLmRhdGFJbmRleCA9IHRoaXMuZGF0YUluZGV4O1xuICAgICAgICBjaGlsZC5kYXRhVHlwZSA9IHRoaXMuZGF0YVR5cGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgZ3JhcGhpYyBlbGVtZW50IHJlbGF0aXZlIHRvIGRhdGEuIEl0IGNhbiBiZSBzZXQgYXMgbnVsbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IFtlbF1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uc2V0SXRlbUdyYXBoaWNFbCA9IGZ1bmN0aW9uIChpZHgsIGVsKSB7XG4gICAgICAgIHZhciBob3N0TW9kZWwgPSB0aGlzLmhvc3RNb2RlbDtcblxuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIC8vIEFkZCBkYXRhIGluZGV4IGFuZCBzZXJpZXMgaW5kZXggZm9yIGluZGV4aW5nIHRoZSBkYXRhIGJ5IGVsZW1lbnRcbiAgICAgICAgICAgIC8vIFVzZWZ1bCBpbiB0b29sdGlwXG4gICAgICAgICAgICBlbC5kYXRhSW5kZXggPSBpZHg7XG4gICAgICAgICAgICBlbC5kYXRhVHlwZSA9IHRoaXMuZGF0YVR5cGU7XG4gICAgICAgICAgICBlbC5zZXJpZXNJbmRleCA9IGhvc3RNb2RlbCAmJiBob3N0TW9kZWwuc2VyaWVzSW5kZXg7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgICAgIGVsLnRyYXZlcnNlKHNldEl0ZW1EYXRhQW5kU2VyaWVzSW5kZXgsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2dyYXBoaWNFbHNbaWR4XSA9IGVsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0SXRlbUdyYXBoaWNFbCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyYXBoaWNFbHNbaWR4XTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZWFjaEl0ZW1HcmFwaGljRWwgPSBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgenJVdGlsLmVhY2godGhpcy5fZ3JhcGhpY0VscywgZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIGNiICYmIGNiLmNhbGwoY29udGV4dCwgZWwsIGlkeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaGFsbG93IGNsb25lIGEgbmV3IGxpc3QgZXhjZXB0IHZpc3VhbCBhbmQgbGF5b3V0IHByb3BlcnRpZXMsIGFuZCBncmFwaCBlbGVtZW50cy5cbiAgICAgKiBOZXcgbGlzdCBvbmx5IGNoYW5nZSB0aGUgaW5kaWNlcy5cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uY2xvbmVTaGFsbG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGltZW5zaW9uSW5mb0xpc3QgPSB6clV0aWwubWFwKHRoaXMuZGltZW5zaW9ucywgdGhpcy5nZXREaW1lbnNpb25JbmZvLCB0aGlzKTtcbiAgICAgICAgdmFyIGxpc3QgPSBuZXcgTGlzdChkaW1lbnNpb25JbmZvTGlzdCwgdGhpcy5ob3N0TW9kZWwpO1xuXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIGxpc3QuX3N0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlO1xuXG4gICAgICAgIHRyYW5zZmVyUHJvcGVydGllcyhsaXN0LCB0aGlzKTtcblxuXG4gICAgICAgIC8vIENsb25lIHdpbGwgbm90IGNoYW5nZSB0aGUgZGF0YSBleHRlbnQgYW5kIGluZGljZXNcbiAgICAgICAgbGlzdC5pbmRpY2VzID0gdGhpcy5pbmRpY2VzLnNsaWNlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2V4dGVudCkge1xuICAgICAgICAgICAgbGlzdC5fZXh0ZW50ID0genJVdGlsLmV4dGVuZCh7fSwgdGhpcy5fZXh0ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXcmFwIHNvbWUgbWV0aG9kIHRvIGFkZCBtb3JlIGZlYXR1cmVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGluamVjdEZ1bmN0aW9uXG4gICAgICovXG4gICAgbGlzdFByb3RvLndyYXBNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5qZWN0RnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsTWV0aG9kID0gdGhpc1ttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbE1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX193cmFwcGVkTWV0aG9kcyA9IHRoaXMuX193cmFwcGVkTWV0aG9kcyB8fCBbXTtcbiAgICAgICAgdGhpcy5fX3dyYXBwZWRNZXRob2RzLnB1c2gobWV0aG9kTmFtZSk7XG4gICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBpbmplY3RGdW5jdGlvbi5hcHBseSh0aGlzLCBbcmVzXS5jb25jYXQoenJVdGlsLnNsaWNlKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gTWV0aG9kcyB0aGF0IGNyZWF0ZSBhIG5ldyBsaXN0IGJhc2VkIG9uIHRoaXMgbGlzdCBzaG91bGQgYmUgbGlzdGVkIGhlcmUuXG4gICAgLy8gTm90aWNlIHRoYXQgdGhvc2UgbWV0aG9kIHNob3VsZCBgUkVUVVJOYCB0aGUgbmV3IGxpc3QuXG4gICAgbGlzdFByb3RvLlRSQU5TRkVSQUJMRV9NRVRIT0RTID0gWydjbG9uZVNoYWxsb3cnLCAnZG93blNhbXBsZScsICdtYXAnXTtcbiAgICAvLyBNZXRob2RzIHRoYXQgY2hhbmdlIGluZGljZXMgb2YgdGhpcyBsaXN0IHNob3VsZCBiZSBsaXN0ZWQgaGVyZS5cbiAgICBsaXN0UHJvdG8uQ0hBTkdBQkxFX01FVEhPRFMgPSBbJ2ZpbHRlclNlbGYnXTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gTGlzdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9kYXRhL0xpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports){eval("'use strict';\n\n\n    function defaultKeyGetter(item) {\n        return item;\n    }\n\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n\n    DataDiffer.prototype = {\n\n        constructor: DataDiffer,\n\n        /**\n         * Callback function when add a data\n         */\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n\n        /**\n         * Callback function when update a data\n         */\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n\n        /**\n         * Callback function when remove a data\n         */\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    }\n                    else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                }\n                else {\n                    this._remove && this._remove(i);\n                }\n            }\n\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    }\n                    else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            // Add prefix to avoid conflict with Object.prototype.\n            var key = '_ec_' + keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            }\n            else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n\n    module.exports = DataDiffer;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2RhdGEvRGF0YURpZmZlci5qcz9mMzMwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0S2V5R2V0dGVyKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRGF0YURpZmZlcihvbGRBcnIsIG5ld0Fyciwgb2xkS2V5R2V0dGVyLCBuZXdLZXlHZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5fb2xkID0gb2xkQXJyO1xuICAgICAgICB0aGlzLl9uZXcgPSBuZXdBcnI7XG5cbiAgICAgICAgdGhpcy5fb2xkS2V5R2V0dGVyID0gb2xkS2V5R2V0dGVyIHx8IGRlZmF1bHRLZXlHZXR0ZXI7XG4gICAgICAgIHRoaXMuX25ld0tleUdldHRlciA9IG5ld0tleUdldHRlciB8fCBkZWZhdWx0S2V5R2V0dGVyO1xuICAgIH1cblxuICAgIERhdGFEaWZmZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBEYXRhRGlmZmVyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayBmdW5jdGlvbiB3aGVuIGFkZCBhIGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZCA9IGZ1bmM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB1cGRhdGUgYSBkYXRhXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUgPSBmdW5jO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gcmVtb3ZlIGEgZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlID0gZnVuYztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvbGRBcnIgPSB0aGlzLl9vbGQ7XG4gICAgICAgICAgICB2YXIgbmV3QXJyID0gdGhpcy5fbmV3O1xuICAgICAgICAgICAgdmFyIG9sZEtleUdldHRlciA9IHRoaXMuX29sZEtleUdldHRlcjtcbiAgICAgICAgICAgIHZhciBuZXdLZXlHZXR0ZXIgPSB0aGlzLl9uZXdLZXlHZXR0ZXI7XG5cbiAgICAgICAgICAgIHZhciBvbGREYXRhSW5kZXhNYXAgPSB7fTtcbiAgICAgICAgICAgIHZhciBuZXdEYXRhSW5kZXhNYXAgPSB7fTtcbiAgICAgICAgICAgIHZhciBvbGREYXRhS2V5QXJyID0gW107XG4gICAgICAgICAgICB2YXIgbmV3RGF0YUtleUFyciA9IFtdO1xuICAgICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICAgIGluaXRJbmRleE1hcChvbGRBcnIsIG9sZERhdGFJbmRleE1hcCwgb2xkRGF0YUtleUFyciwgb2xkS2V5R2V0dGVyKTtcbiAgICAgICAgICAgIGluaXRJbmRleE1hcChuZXdBcnIsIG5ld0RhdGFJbmRleE1hcCwgbmV3RGF0YUtleUFyciwgbmV3S2V5R2V0dGVyKTtcblxuICAgICAgICAgICAgLy8gVHJhdmVsIGJ5IGludmVydGVkIG9yZGVyIHRvIG1ha2Ugc3VyZSBvcmRlciBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgLy8gd2hlbiBkdXBsaWNhdGUga2V5cyBleGlzdHMgKGNvbnNpZGVyIG5ld0RhdGFJbmRleC5wb3AoKSBiZWxvdykuXG4gICAgICAgICAgICAvLyBGb3IgcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbiwgdGhlc2UgY29kZSBiZWxvdyBkbyBub3QgbG9vayBuZWF0LlxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9sZEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBvbGREYXRhS2V5QXJyW2ldO1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBuZXdEYXRhSW5kZXhNYXBba2V5XTtcblxuICAgICAgICAgICAgICAgIC8vIGlkeCBjYW4gbmV2ZXIgYmUgZW1wdHkgYXJyYXkgaGVyZS4gc2VlICdzZXQgbnVsbCcgbG9naWMgYmVsb3cuXG4gICAgICAgICAgICAgICAgaWYgKGlkeCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIHRoZXJlIGlzIGR1cGxpY2F0ZSBrZXkgKGZvciBleGFtcGxlLCB1c2UgZGF0YUl0ZW0ubmFtZSBhcyBrZXkpLlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbWFrZSBzdXJlIGV2ZXJ5IGl0ZW0gaW4gbmV3QXJyIGFuZCBvbGRBcnIgY2FuIGJlIHZpc2l0ZWQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBpZHgubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gPT09IDEgJiYgKG5ld0RhdGFJbmRleE1hcFtrZXldID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpZHgudW5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGF0YUluZGV4TWFwW2tleV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSAmJiB0aGlzLl91cGRhdGUoaWR4LCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZSAmJiB0aGlzLl9yZW1vdmUoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGFLZXlBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gbmV3RGF0YUtleUFycltpXTtcbiAgICAgICAgICAgICAgICBpZiAobmV3RGF0YUluZGV4TWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IG5ld0RhdGFJbmRleE1hcFtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlkeCBjYW4gbmV2ZXIgYmUgZW1wdHkgYXJyYXkgaGVyZS4gc2VlICdzZXQgbnVsbCcgbG9naWMgYWJvdmUuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaWR4Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkICYmIHRoaXMuX2FkZChpZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGlkeC5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZCAmJiB0aGlzLl9hZGQoaWR4W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbml0SW5kZXhNYXAoYXJyLCBtYXAsIGtleUFyciwga2V5R2V0dGVyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBBZGQgcHJlZml4IHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZS5cbiAgICAgICAgICAgIHZhciBrZXkgPSAnX2VjXycgKyBrZXlHZXR0ZXIoYXJyW2ldLCBpKTtcbiAgICAgICAgICAgIHZhciBleGlzdGVuY2UgPSBtYXBba2V5XTtcbiAgICAgICAgICAgIGlmIChleGlzdGVuY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGtleUFyci5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgbWFwW2tleV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdGVuY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtrZXldID0gZXhpc3RlbmNlID0gW2V4aXN0ZW5jZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4aXN0ZW5jZS5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEYXRhRGlmZmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2RhdGEvRGF0YURpZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n    var numberUtil = __webpack_require__(23);\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = __webpack_require__(20);\n    var axisHelper = __webpack_require__(117);\n\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n\n    var normalizedExtent = [0, 1];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [0, 0];\n\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._labelInterval;\n    };\n\n    Axis.prototype = {\n\n        constructor: Axis,\n\n        /**\n         * If axis extent contain given coord\n         * @param {number} coord\n         * @return {boolean}\n         */\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n\n        /**\n         * If axis extent contain given data\n         * @param {number} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n\n        /**\n         * Get coord extent.\n         * @return {Array.<number>}\n         */\n        getExtent: function () {\n            return this._extent.slice();\n        },\n\n        /**\n         * Get precision used for formatting\n         * @param {Array.<number>} [dataExtent]\n         * @return {number}\n         */\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(\n                dataExtent || this.scale.getExtent(),\n                this._extent\n            );\n        },\n\n        /**\n         * Set coord extent\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n\n        /**\n         * Convert data to coord. Data is the rank if it has a ordinal scale\n         * @param {number} data\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n\n        /**\n         * Convert coord to data. Data is the rank if it has a ordinal scale\n         * @param {number} coord\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\n            return this.scale.scale(t);\n        },\n\n        /**\n         * Convert pixel point to data in axis\n         * @param {Array.<number>} point\n         * @param  {boolean} clamp\n         * @return {number} data\n         */\n        pointToData: function (point, clamp) {\n            // Should be implemented in derived class if necessary.\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            }\n            else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n\n        /**\n         * Coords of labels are on the ticks or on the middle of bands\n         * @return {Array.<number>}\n         */\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n\n        /**\n         * Get bands.\n         *\n         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n         * |---1---|---2---|---3---|---4---|.\n         *\n         * @return {Array}\n         */\n         // FIXME Situation when labels is on ticks\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n\n        /**\n         * Get width of band\n         * @return {number}\n         */\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n            return Math.abs(size) / len;\n        },\n\n        /**\n         * Get interval of the axis label.\n         * @return {number}\n         */\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                var axisModel = this.model;\n                var labelModel = axisModel.getModel('axisLabel');\n                var interval = labelModel.get('interval');\n                if (!(this.type === 'category' && interval === 'auto')) {\n                    labelInterval = interval === 'auto' ? 0 : interval;\n                }\n                else if (this.isHorizontal){\n                    labelInterval = axisHelper.getAxisLabelInterval(\n                        zrUtil.map(this.scale.getTicks(), this.dataToCoord, this),\n                        axisModel.getFormattedLabels(),\n                        labelModel.getModel('textStyle').getFont(),\n                        this.isHorizontal()\n                    );\n                }\n                this._labelInterval = labelInterval;\n            }\n            return labelInterval;\n        }\n\n    };\n\n    module.exports = Axis;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2Nvb3JkL0F4aXMuanM/NzM2YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiMTE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbnVtYmVyJyk7XG4gICAgdmFyIGxpbmVhck1hcCA9IG51bWJlclV0aWwubGluZWFyTWFwO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoJy4vYXhpc0hlbHBlcicpO1xuXG4gICAgZnVuY3Rpb24gZml4RXh0ZW50V2l0aEJhbmRzKGV4dGVudCwgblRpY2spIHtcbiAgICAgICAgdmFyIHNpemUgPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gICAgICAgIHZhciBsZW4gPSBuVGljaztcbiAgICAgICAgdmFyIG1hcmdpbiA9IHNpemUgLyBsZW4gLyAyO1xuICAgICAgICBleHRlbnRbMF0gKz0gbWFyZ2luO1xuICAgICAgICBleHRlbnRbMV0gLT0gbWFyZ2luO1xuICAgIH1cblxuICAgIHZhciBub3JtYWxpemVkRXh0ZW50ID0gWzAsIDFdO1xuICAgIC8qKlxuICAgICAqIEBuYW1lIG1vZHVsZTplY2hhcnRzL2Nvb3JkL0NhcnRlc2lhbkF4aXNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQXhpcyA9IGZ1bmN0aW9uIChkaW0sIHNjYWxlLCBleHRlbnQpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXhpcyBkaW1lbnNpb24uIFN1Y2ggYXMgJ3gnLCAneScsICd6JywgJ2FuZ2xlJywgJ3JhZGl1cydcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGltID0gZGltO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBeGlzIHNjYWxlXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9zY2FsZS8qfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9leHRlbnQgPSBleHRlbnQgfHwgWzAsIDBdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW52ZXJzZSA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc3VhbGx5IHRydWUgd2hlbiBheGlzIGhhcyBhIG9yZGluYWwgc2NhbGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmFuZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGFiZWxJbnRlcnZhbDtcbiAgICB9O1xuXG4gICAgQXhpcy5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEF4aXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGF4aXMgZXh0ZW50IGNvbnRhaW4gZ2l2ZW4gY29vcmRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvb3JkXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgbWluID0gTWF0aC5taW4oZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICAgICAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICAgICAgICAgIHJldHVybiBjb29yZCA+PSBtaW4gJiYgY29vcmQgPD0gbWF4O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBheGlzIGV4dGVudCBjb250YWluIGdpdmVuIGRhdGFcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5EYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbih0aGlzLmRhdGFUb0Nvb3JkKGRhdGEpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGNvb3JkIGV4dGVudC5cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRFeHRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHRlbnQuc2xpY2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHByZWNpc2lvbiB1c2VkIGZvciBmb3JtYXR0aW5nXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtkYXRhRXh0ZW50XVxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRQaXhlbFByZWNpc2lvbjogZnVuY3Rpb24gKGRhdGFFeHRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJVdGlsLmdldFBpeGVsUHJlY2lzaW9uKFxuICAgICAgICAgICAgICAgIGRhdGFFeHRlbnQgfHwgdGhpcy5zY2FsZS5nZXRFeHRlbnQoKSxcbiAgICAgICAgICAgICAgICB0aGlzLl9leHRlbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBjb29yZCBleHRlbnRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAgICAgICAgICovXG4gICAgICAgIHNldEV4dGVudDogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICBleHRlbnRbMF0gPSBzdGFydDtcbiAgICAgICAgICAgIGV4dGVudFsxXSA9IGVuZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCBkYXRhIHRvIGNvb3JkLiBEYXRhIGlzIHRoZSByYW5rIGlmIGl0IGhhcyBhIG9yZGluYWwgc2NhbGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gY2xhbXBcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YVRvQ29vcmQ6IGZ1bmN0aW9uIChkYXRhLCBjbGFtcCkge1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBkYXRhID0gc2NhbGUubm9ybWFsaXplKGRhdGEpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vbkJhbmQgJiYgc2NhbGUudHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50ID0gZXh0ZW50LnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgZml4RXh0ZW50V2l0aEJhbmRzKGV4dGVudCwgc2NhbGUuY291bnQoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsaW5lYXJNYXAoZGF0YSwgbm9ybWFsaXplZEV4dGVudCwgZXh0ZW50LCBjbGFtcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgY29vcmQgdG8gZGF0YS4gRGF0YSBpcyB0aGUgcmFuayBpZiBpdCBoYXMgYSBvcmRpbmFsIHNjYWxlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb29yZFxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcFxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb29yZFRvRGF0YTogZnVuY3Rpb24gKGNvb3JkLCBjbGFtcCkge1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9uQmFuZCAmJiBzY2FsZS50eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgICAgICBleHRlbnQgPSBleHRlbnQuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBmaXhFeHRlbnRXaXRoQmFuZHMoZXh0ZW50LCBzY2FsZS5jb3VudCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHQgPSBsaW5lYXJNYXAoY29vcmQsIGV4dGVudCwgbm9ybWFsaXplZEV4dGVudCwgY2xhbXApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZS5zY2FsZSh0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCBwaXhlbCBwb2ludCB0byBkYXRhIGluIGF4aXNcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcG9pbnRcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gY2xhbXBcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBkYXRhXG4gICAgICAgICAqL1xuICAgICAgICBwb2ludFRvRGF0YTogZnVuY3Rpb24gKHBvaW50LCBjbGFtcCkge1xuICAgICAgICAgICAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIGRlcml2ZWQgY2xhc3MgaWYgbmVjZXNzYXJ5LlxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRpY2tzQ29vcmRzOiBmdW5jdGlvbiAoYWxpZ25XaXRoTGFiZWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uQmFuZCAmJiAhYWxpZ25XaXRoTGFiZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFuZHMgPSB0aGlzLmdldEJhbmRzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzLnB1c2goYmFuZHNbaV1bMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmFuZHNbaSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKGJhbmRzW2kgLSAxXVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb29yZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4genJVdGlsLm1hcCh0aGlzLnNjYWxlLmdldFRpY2tzKCksIHRoaXMuZGF0YVRvQ29vcmQsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb29yZHMgb2YgbGFiZWxzIGFyZSBvbiB0aGUgdGlja3Mgb3Igb24gdGhlIG1pZGRsZSBvZiBiYW5kc1xuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldExhYmVsc0Nvb3JkczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAodGhpcy5zY2FsZS5nZXRUaWNrcygpLCB0aGlzLmRhdGFUb0Nvb3JkLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGJhbmRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBheGlzIGhhcyBsYWJlbHMgWzEsIDIsIDMsIDRdLiBCYW5kcyBvbiB0aGUgYXhpcyBhcmVcbiAgICAgICAgICogfC0tLTEtLS18LS0tMi0tLXwtLS0zLS0tfC0tLTQtLS18LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgICAvLyBGSVhNRSBTaXR1YXRpb24gd2hlbiBsYWJlbHMgaXMgb24gdGlja3NcbiAgICAgICAgZ2V0QmFuZHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLmdldEV4dGVudCgpO1xuICAgICAgICAgICAgdmFyIGJhbmRzID0gW107XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5zY2FsZS5jb3VudCgpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZXh0ZW50WzBdO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGV4dGVudFsxXTtcbiAgICAgICAgICAgIHZhciBzcGFuID0gZW5kIC0gc3RhcnQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBiYW5kcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgc3BhbiAqIGkgLyBsZW4gKyBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgc3BhbiAqIChpICsgMSkgLyBsZW4gKyBzdGFydFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJhbmRzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgd2lkdGggb2YgYmFuZFxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRCYW5kV2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBheGlzRXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIGRhdGFFeHRlbnQgPSB0aGlzLnNjYWxlLmdldEV4dGVudCgpO1xuXG4gICAgICAgICAgICB2YXIgbGVuID0gZGF0YUV4dGVudFsxXSAtIGRhdGFFeHRlbnRbMF0gKyAodGhpcy5vbkJhbmQgPyAxIDogMCk7XG4gICAgICAgICAgICAvLyBGaXggIzI3MjgsIGF2b2lkIE5hTiB3aGVuIG9ubHkgb25lIGRhdGEuXG4gICAgICAgICAgICBsZW4gPT09IDAgJiYgKGxlbiA9IDEpO1xuXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGguYWJzKGF4aXNFeHRlbnRbMV0gLSBheGlzRXh0ZW50WzBdKTtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHNpemUpIC8gbGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgaW50ZXJ2YWwgb2YgdGhlIGF4aXMgbGFiZWwuXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldExhYmVsSW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbEludGVydmFsID0gdGhpcy5fbGFiZWxJbnRlcnZhbDtcbiAgICAgICAgICAgIGlmICghbGFiZWxJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbE1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwnKTtcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBsYWJlbE1vZGVsLmdldCgnaW50ZXJ2YWwnKTtcbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzLnR5cGUgPT09ICdjYXRlZ29yeScgJiYgaW50ZXJ2YWwgPT09ICdhdXRvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxJbnRlcnZhbCA9IGludGVydmFsID09PSAnYXV0bycgPyAwIDogaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNIb3Jpem9udGFsKXtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxJbnRlcnZhbCA9IGF4aXNIZWxwZXIuZ2V0QXhpc0xhYmVsSW50ZXJ2YWwoXG4gICAgICAgICAgICAgICAgICAgICAgICB6clV0aWwubWFwKHRoaXMuc2NhbGUuZ2V0VGlja3MoKSwgdGhpcy5kYXRhVG9Db29yZCwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWxzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKS5nZXRGb250KCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsSW50ZXJ2YWwgPSBsYWJlbEludGVydmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsSW50ZXJ2YWw7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEF4aXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29vcmQvQXhpcy5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n    var OrdinalScale = __webpack_require__(118);\n    var IntervalScale = __webpack_require__(120);\n    __webpack_require__(122);\n    __webpack_require__(123);\n    var Scale = __webpack_require__(119);\n\n    var numberUtil = __webpack_require__(23);\n    var zrUtil = __webpack_require__(20);\n    var textContain = __webpack_require__(24);\n    var axisHelper = {};\n\n    /**\n     * Get axis scale extent before niced.\n     * Item of returned array can only be number (including Infinity and NaN).\n     */\n    axisHelper.getScaleExtent = function (scale, model) {\n        var scaleType = scale.type;\n\n        var min = model.getMin();\n        var max = model.getMax();\n        var fixMin = min != null;\n        var fixMax = max != null;\n        var originalExtent = scale.getExtent();\n\n        var axisDataLen;\n        var boundaryGap;\n        var span;\n        if (scaleType === 'ordinal') {\n            axisDataLen = (model.get('data') || []).length;\n        }\n        else {\n            boundaryGap = model.get('boundaryGap');\n            if (!zrUtil.isArray(boundaryGap)) {\n                boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n            }\n            if (typeof boundaryGap[0] === 'boolean') {\n                if (__DEV__) {\n                    console.warn('Boolean type for boundaryGap is only '\n                        + 'allowed for ordinal axis. Please use string in '\n                        + 'percentage instead, e.g., \"20%\". Currently, '\n                        + 'boundaryGap is set to be 0.');\n                }\n                boundaryGap = [0, 0];\n            }\n            boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n            span = (originalExtent[1] - originalExtent[0])\n                || Math.abs(originalExtent[0]);\n        }\n\n        // Notice: When min/max is not set (that is, when there are null/undefined,\n        // which is the most common case), these cases should be ensured:\n        // (1) For 'ordinal', show all axis.data.\n        // (2) For others:\n        //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n        //      disabled).\n        //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n        //      be the result that originalExtent enlarged by boundaryGap.\n        // (3) If no data, it should be ensured that `scale.setBlank` is set.\n\n        // FIXME\n        // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n        // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n        // that the results processed by boundaryGap are positive/negative?\n\n        if (min == null) {\n            min = scaleType === 'ordinal'\n                ? (axisDataLen ? 0 : NaN)\n                : originalExtent[0] - boundaryGap[0] * span;\n        }\n        if (max == null) {\n            max = scaleType === 'ordinal'\n                ? (axisDataLen ? axisDataLen - 1 : NaN)\n                : originalExtent[1] + boundaryGap[1] * span;\n        }\n\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n\n        (min == null || !isFinite(min)) && (min = NaN);\n        (max == null || !isFinite(max)) && (max = NaN);\n\n        scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max));\n\n        // Evaluate if axis needs cross zero\n        if (model.getNeedCrossZero()) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n\n        return [min, max];\n    };\n\n    axisHelper.niceScaleExtent = function (scale, model) {\n        var extent = axisHelper.getScaleExtent(scale, model);\n        var fixMin = model.getMin() != null;\n        var fixMax = model.getMax() != null;\n        var splitNumber = model.get('splitNumber');\n\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent({\n            splitNumber: splitNumber,\n            fixMin: fixMin,\n            fixMax: fixMax,\n            minInterval: scale.type === 'interval' ? model.get('minInterval') : null\n        });\n\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function(model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n                // Buildin scale\n                case 'category':\n                    return new OrdinalScale(\n                        model.getCategories(), [Infinity, -Infinity]\n                    );\n                case 'value':\n                    return new IntervalScale();\n                // Extended scale, like time and log\n                default:\n                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n    };\n\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // 不同角的axis和label，不只是horizontal和vertical.\n\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(\n                labels[i], font, 'center', 'top'\n            );\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }\n            // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            }\n            else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = (function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val != null ? val : '');\n                };\n            })(labelFormatter);\n            // Consider empty array\n            return zrUtil.map(labels, labelFormatter);\n        }\n        else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(\n                    axisHelper.getAxisRawValue(axis, tick),\n                    idx\n                );\n            }, this);\n        }\n        else {\n            return labels;\n        }\n    };\n\n    axisHelper.getAxisRawValue = function (axis, value) {\n        // In category axis with data zoom, tick is not the original\n        // index of axis.data. So tick should not be exposed to user\n        // in category axis.\n        return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n    };\n\n    module.exports = axisHelper;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2Nvb3JkL2F4aXNIZWxwZXIuanM/NDczMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUMsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjExNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIE9yZGluYWxTY2FsZSA9IHJlcXVpcmUoJy4uL3NjYWxlL09yZGluYWwnKTtcbiAgICB2YXIgSW50ZXJ2YWxTY2FsZSA9IHJlcXVpcmUoJy4uL3NjYWxlL0ludGVydmFsJyk7XG4gICAgcmVxdWlyZSgnLi4vc2NhbGUvVGltZScpO1xuICAgIHJlcXVpcmUoJy4uL3NjYWxlL0xvZycpO1xuICAgIHZhciBTY2FsZSA9IHJlcXVpcmUoJy4uL3NjYWxlL1NjYWxlJyk7XG5cbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbnVtYmVyJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xuICAgIHZhciBheGlzSGVscGVyID0ge307XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYXhpcyBzY2FsZSBleHRlbnQgYmVmb3JlIG5pY2VkLlxuICAgICAqIEl0ZW0gb2YgcmV0dXJuZWQgYXJyYXkgY2FuIG9ubHkgYmUgbnVtYmVyIChpbmNsdWRpbmcgSW5maW5pdHkgYW5kIE5hTikuXG4gICAgICovXG4gICAgYXhpc0hlbHBlci5nZXRTY2FsZUV4dGVudCA9IGZ1bmN0aW9uIChzY2FsZSwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHNjYWxlVHlwZSA9IHNjYWxlLnR5cGU7XG5cbiAgICAgICAgdmFyIG1pbiA9IG1vZGVsLmdldE1pbigpO1xuICAgICAgICB2YXIgbWF4ID0gbW9kZWwuZ2V0TWF4KCk7XG4gICAgICAgIHZhciBmaXhNaW4gPSBtaW4gIT0gbnVsbDtcbiAgICAgICAgdmFyIGZpeE1heCA9IG1heCAhPSBudWxsO1xuICAgICAgICB2YXIgb3JpZ2luYWxFeHRlbnQgPSBzY2FsZS5nZXRFeHRlbnQoKTtcblxuICAgICAgICB2YXIgYXhpc0RhdGFMZW47XG4gICAgICAgIHZhciBib3VuZGFyeUdhcDtcbiAgICAgICAgdmFyIHNwYW47XG4gICAgICAgIGlmIChzY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgYXhpc0RhdGFMZW4gPSAobW9kZWwuZ2V0KCdkYXRhJykgfHwgW10pLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvdW5kYXJ5R2FwID0gbW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpO1xuICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShib3VuZGFyeUdhcCkpIHtcbiAgICAgICAgICAgICAgICBib3VuZGFyeUdhcCA9IFtib3VuZGFyeUdhcCB8fCAwLCBib3VuZGFyeUdhcCB8fCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYm91bmRhcnlHYXBbMF0gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQm9vbGVhbiB0eXBlIGZvciBib3VuZGFyeUdhcCBpcyBvbmx5ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2FsbG93ZWQgZm9yIG9yZGluYWwgYXhpcy4gUGxlYXNlIHVzZSBzdHJpbmcgaW4gJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAncGVyY2VudGFnZSBpbnN0ZWFkLCBlLmcuLCBcIjIwJVwiLiBDdXJyZW50bHksICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2JvdW5kYXJ5R2FwIGlzIHNldCB0byBiZSAwLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBib3VuZGFyeUdhcCA9IFswLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvdW5kYXJ5R2FwWzBdID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoYm91bmRhcnlHYXBbMF0sIDEpO1xuICAgICAgICAgICAgYm91bmRhcnlHYXBbMV0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFsxXSwgMSk7XG4gICAgICAgICAgICBzcGFuID0gKG9yaWdpbmFsRXh0ZW50WzFdIC0gb3JpZ2luYWxFeHRlbnRbMF0pXG4gICAgICAgICAgICAgICAgfHwgTWF0aC5hYnMob3JpZ2luYWxFeHRlbnRbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90aWNlOiBXaGVuIG1pbi9tYXggaXMgbm90IHNldCAodGhhdCBpcywgd2hlbiB0aGVyZSBhcmUgbnVsbC91bmRlZmluZWQsXG4gICAgICAgIC8vIHdoaWNoIGlzIHRoZSBtb3N0IGNvbW1vbiBjYXNlKSwgdGhlc2UgY2FzZXMgc2hvdWxkIGJlIGVuc3VyZWQ6XG4gICAgICAgIC8vICgxKSBGb3IgJ29yZGluYWwnLCBzaG93IGFsbCBheGlzLmRhdGEuXG4gICAgICAgIC8vICgyKSBGb3Igb3RoZXJzOlxuICAgICAgICAvLyAgICAgICsgYGJvdW5kYXJ5R2FwYCBpcyBhcHBsaWVkIChpZiBtaW4vbWF4IHNldCwgYm91bmRhcnlHYXAgaXNcbiAgICAgICAgLy8gICAgICBkaXNhYmxlZCkuXG4gICAgICAgIC8vICAgICAgKyBJZiBgbmVlZENyb3NzWmVyb2AsIG1pbi9tYXggc2hvdWxkIGJlIHplcm8sIG90aGVyd2lzZSwgbWluL21heCBzaG91bGRcbiAgICAgICAgLy8gICAgICBiZSB0aGUgcmVzdWx0IHRoYXQgb3JpZ2luYWxFeHRlbnQgZW5sYXJnZWQgYnkgYm91bmRhcnlHYXAuXG4gICAgICAgIC8vICgzKSBJZiBubyBkYXRhLCBpdCBzaG91bGQgYmUgZW5zdXJlZCB0aGF0IGBzY2FsZS5zZXRCbGFua2AgaXMgc2V0LlxuXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vICgxKSBXaGVuIG1pbi9tYXggaXMgJ2RhdGFNaW4nIG9yICdkYXRhTWF4Jywgc2hvdWxkIGJvdW5kYXJ5R2FwIGJlIGFibGUgdG8gdXNlZD9cbiAgICAgICAgLy8gKDIpIFdoZW4gYG5lZWRDcm9zc1plcm9gIGFuZCBhbGwgZGF0YSBpcyBwb3NpdGl2ZS9uZWdhdGl2ZSwgc2hvdWxkIGl0IGJlIGVuc3VyZWRcbiAgICAgICAgLy8gdGhhdCB0aGUgcmVzdWx0cyBwcm9jZXNzZWQgYnkgYm91bmRhcnlHYXAgYXJlIHBvc2l0aXZlL25lZ2F0aXZlP1xuXG4gICAgICAgIGlmIChtaW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgbWluID0gc2NhbGVUeXBlID09PSAnb3JkaW5hbCdcbiAgICAgICAgICAgICAgICA/IChheGlzRGF0YUxlbiA/IDAgOiBOYU4pXG4gICAgICAgICAgICAgICAgOiBvcmlnaW5hbEV4dGVudFswXSAtIGJvdW5kYXJ5R2FwWzBdICogc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgICAgICAgIG1heCA9IHNjYWxlVHlwZSA9PT0gJ29yZGluYWwnXG4gICAgICAgICAgICAgICAgPyAoYXhpc0RhdGFMZW4gPyBheGlzRGF0YUxlbiAtIDEgOiBOYU4pXG4gICAgICAgICAgICAgICAgOiBvcmlnaW5hbEV4dGVudFsxXSArIGJvdW5kYXJ5R2FwWzFdICogc3BhbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaW4gPT09ICdkYXRhTWluJykge1xuICAgICAgICAgICAgbWluID0gb3JpZ2luYWxFeHRlbnRbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heCA9PT0gJ2RhdGFNYXgnKSB7XG4gICAgICAgICAgICBtYXggPSBvcmlnaW5hbEV4dGVudFsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIChtaW4gPT0gbnVsbCB8fCAhaXNGaW5pdGUobWluKSkgJiYgKG1pbiA9IE5hTik7XG4gICAgICAgIChtYXggPT0gbnVsbCB8fCAhaXNGaW5pdGUobWF4KSkgJiYgKG1heCA9IE5hTik7XG5cbiAgICAgICAgc2NhbGUuc2V0QmxhbmsoenJVdGlsLmVxTmFOKG1pbikgfHwgenJVdGlsLmVxTmFOKG1heCkpO1xuXG4gICAgICAgIC8vIEV2YWx1YXRlIGlmIGF4aXMgbmVlZHMgY3Jvc3MgemVyb1xuICAgICAgICBpZiAobW9kZWwuZ2V0TmVlZENyb3NzWmVybygpKSB7XG4gICAgICAgICAgICAvLyBBeGlzIGlzIG92ZXIgemVybyBhbmQgbWluIGlzIG5vdCBzZXRcbiAgICAgICAgICAgIGlmIChtaW4gPiAwICYmIG1heCA+IDAgJiYgIWZpeE1pbikge1xuICAgICAgICAgICAgICAgIG1pbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBeGlzIGlzIHVuZGVyIHplcm8gYW5kIG1heCBpcyBub3Qgc2V0XG4gICAgICAgICAgICBpZiAobWluIDwgMCAmJiBtYXggPCAwICYmICFmaXhNYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgfTtcblxuICAgIGF4aXNIZWxwZXIubmljZVNjYWxlRXh0ZW50ID0gZnVuY3Rpb24gKHNjYWxlLCBtb2RlbCkge1xuICAgICAgICB2YXIgZXh0ZW50ID0gYXhpc0hlbHBlci5nZXRTY2FsZUV4dGVudChzY2FsZSwgbW9kZWwpO1xuICAgICAgICB2YXIgZml4TWluID0gbW9kZWwuZ2V0TWluKCkgIT0gbnVsbDtcbiAgICAgICAgdmFyIGZpeE1heCA9IG1vZGVsLmdldE1heCgpICE9IG51bGw7XG4gICAgICAgIHZhciBzcGxpdE51bWJlciA9IG1vZGVsLmdldCgnc3BsaXROdW1iZXInKTtcblxuICAgICAgICBpZiAoc2NhbGUudHlwZSA9PT0gJ2xvZycpIHtcbiAgICAgICAgICAgIHNjYWxlLmJhc2UgPSBtb2RlbC5nZXQoJ2xvZ0Jhc2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjYWxlLnNldEV4dGVudChleHRlbnRbMF0sIGV4dGVudFsxXSk7XG4gICAgICAgIHNjYWxlLm5pY2VFeHRlbnQoe1xuICAgICAgICAgICAgc3BsaXROdW1iZXI6IHNwbGl0TnVtYmVyLFxuICAgICAgICAgICAgZml4TWluOiBmaXhNaW4sXG4gICAgICAgICAgICBmaXhNYXg6IGZpeE1heCxcbiAgICAgICAgICAgIG1pbkludGVydmFsOiBzY2FsZS50eXBlID09PSAnaW50ZXJ2YWwnID8gbW9kZWwuZ2V0KCdtaW5JbnRlcnZhbCcpIDogbnVsbFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJZiBzb21lIG9uZSBzcGVjaWZpZWQgdGhlIG1pbiwgbWF4LiBBbmQgdGhlIGRlZmF1bHQgY2FsY3VsYXRlZCBpbnRlcnZhbFxuICAgICAgICAvLyBpcyBub3QgZ29vZCBlbm91Z2guIEhlIGNhbiBzcGVjaWZ5IHRoZSBpbnRlcnZhbC4gSXQgaXMgb2Z0ZW4gYXBwZWFyZWRcbiAgICAgICAgLy8gaW4gYW5nbGUgYXhpcyB3aXRoIGFuZ2xlIDAgLSAzNjAuIEludGVydmFsIGNhbGN1bGF0ZWQgaW4gaW50ZXJ2YWwgc2NhbGUgaXMgaGFyZFxuICAgICAgICAvLyB0byBiZSA2MC5cbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgdmFyIGludGVydmFsID0gbW9kZWwuZ2V0KCdpbnRlcnZhbCcpO1xuICAgICAgICBpZiAoaW50ZXJ2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2NhbGUuc2V0SW50ZXJ2YWwgJiYgc2NhbGUuc2V0SW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IG1vZGVsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtheGlzVHlwZV0gRGVmYXVsdCByZXRyaWV2ZSBmcm9tIG1vZGVsLnR5cGVcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9zY2FsZS8qfVxuICAgICAqL1xuICAgIGF4aXNIZWxwZXIuY3JlYXRlU2NhbGVCeU1vZGVsID0gZnVuY3Rpb24obW9kZWwsIGF4aXNUeXBlKSB7XG4gICAgICAgIGF4aXNUeXBlID0gYXhpc1R5cGUgfHwgbW9kZWwuZ2V0KCd0eXBlJyk7XG4gICAgICAgIGlmIChheGlzVHlwZSkge1xuICAgICAgICAgICAgc3dpdGNoIChheGlzVHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIEJ1aWxkaW4gc2NhbGVcbiAgICAgICAgICAgICAgICBjYXNlICdjYXRlZ29yeSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT3JkaW5hbFNjYWxlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuZ2V0Q2F0ZWdvcmllcygpLCBbSW5maW5pdHksIC1JbmZpbml0eV1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWxTY2FsZSgpO1xuICAgICAgICAgICAgICAgIC8vIEV4dGVuZGVkIHNjYWxlLCBsaWtlIHRpbWUgYW5kIGxvZ1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoU2NhbGUuZ2V0Q2xhc3MoYXhpc1R5cGUpIHx8IEludGVydmFsU2NhbGUpLmNyZWF0ZShtb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGF4aXMgY29yc3MgMFxuICAgICAqL1xuICAgIGF4aXNIZWxwZXIuaWZBeGlzQ3Jvc3NaZXJvID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgdmFyIGRhdGFFeHRlbnQgPSBheGlzLnNjYWxlLmdldEV4dGVudCgpO1xuICAgICAgICB2YXIgbWluID0gZGF0YUV4dGVudFswXTtcbiAgICAgICAgdmFyIG1heCA9IGRhdGFFeHRlbnRbMV07XG4gICAgICAgIHJldHVybiAhKChtaW4gPiAwICYmIG1heCA+IDApIHx8IChtaW4gPCAwICYmIG1heCA8IDApKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdGlja0Nvb3JkcyBJbiBheGlzIHNlbGYgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNBeGlzSG9yaXpvbnRhbFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBheGlzSGVscGVyLmdldEF4aXNMYWJlbEludGVydmFsID0gZnVuY3Rpb24gKHRpY2tDb29yZHMsIGxhYmVscywgZm9udCwgaXNBeGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyDkuI3lkIzop5LnmoRheGlz5ZKMbGFiZWzvvIzkuI3lj6rmmK9ob3Jpem9udGFs5ZKMdmVydGljYWwuXG5cbiAgICAgICAgdmFyIHRleHRTcGFjZVRha2VuUmVjdDtcbiAgICAgICAgdmFyIGF1dG9MYWJlbEludGVydmFsID0gMDtcbiAgICAgICAgdmFyIGFjY3VtdWxhdGVkTGFiZWxJbnRlcnZhbCA9IDA7XG5cbiAgICAgICAgdmFyIHN0ZXAgPSAxO1xuICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA+IDQwKSB7XG4gICAgICAgICAgICAvLyBTaW1wbGUgb3B0aW1pemF0aW9uIGZvciBsYXJnZSBhbW91bnQgb2YgbGFiZWxzXG4gICAgICAgICAgICBzdGVwID0gTWF0aC5mbG9vcihsYWJlbHMubGVuZ3RoIC8gNDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrQ29vcmRzLmxlbmd0aDsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICB2YXIgdGlja0Nvb3JkID0gdGlja0Nvb3Jkc1tpXTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KFxuICAgICAgICAgICAgICAgIGxhYmVsc1tpXSwgZm9udCwgJ2NlbnRlcicsICd0b3AnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVjdFtpc0F4aXNIb3Jpem9udGFsID8gJ3gnIDogJ3knXSArPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAvLyBGSVhNRSBNYWdpYyBudW1iZXIgMS41XG4gICAgICAgICAgICByZWN0W2lzQXhpc0hvcml6b250YWwgPyAnd2lkdGgnIDogJ2hlaWdodCddICo9IDEuMztcbiAgICAgICAgICAgIGlmICghdGV4dFNwYWNlVGFrZW5SZWN0KSB7XG4gICAgICAgICAgICAgICAgdGV4dFNwYWNlVGFrZW5SZWN0ID0gcmVjdC5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gc3BhY2UgZm9yIGN1cnJlbnQgbGFiZWw7XG4gICAgICAgICAgICBlbHNlIGlmICh0ZXh0U3BhY2VUYWtlblJlY3QuaW50ZXJzZWN0KHJlY3QpKSB7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRMYWJlbEludGVydmFsKys7XG4gICAgICAgICAgICAgICAgYXV0b0xhYmVsSW50ZXJ2YWwgPSBNYXRoLm1heChhdXRvTGFiZWxJbnRlcnZhbCwgYWNjdW11bGF0ZWRMYWJlbEludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHRTcGFjZVRha2VuUmVjdC51bmlvbihyZWN0KTtcbiAgICAgICAgICAgICAgICAvLyBSZXNldFxuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkTGFiZWxJbnRlcnZhbCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1dG9MYWJlbEludGVydmFsID09PSAwICYmIHN0ZXAgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGF1dG9MYWJlbEludGVydmFsICsgMSkgKiBzdGVwIC0gMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF4aXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsYWJlbEZvcm1hdHRlclxuICAgICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICAgICAqL1xuICAgIGF4aXNIZWxwZXIuZ2V0Rm9ybWF0dGVkTGFiZWxzID0gZnVuY3Rpb24gKGF4aXMsIGxhYmVsRm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IGF4aXMuc2NhbGU7XG4gICAgICAgIHZhciBsYWJlbHMgPSBzY2FsZS5nZXRUaWNrc0xhYmVscygpO1xuICAgICAgICB2YXIgdGlja3MgPSBzY2FsZS5nZXRUaWNrcygpO1xuICAgICAgICBpZiAodHlwZW9mIGxhYmVsRm9ybWF0dGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbGFiZWxGb3JtYXR0ZXIgPSAoZnVuY3Rpb24gKHRwbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cGwucmVwbGFjZSgne3ZhbHVlfScsIHZhbCAhPSBudWxsID8gdmFsIDogJycpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShsYWJlbEZvcm1hdHRlcik7XG4gICAgICAgICAgICAvLyBDb25zaWRlciBlbXB0eSBhcnJheVxuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAobGFiZWxzLCBsYWJlbEZvcm1hdHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxhYmVsRm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4genJVdGlsLm1hcCh0aWNrcywgZnVuY3Rpb24gKHRpY2ssIGlkeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbEZvcm1hdHRlcihcbiAgICAgICAgICAgICAgICAgICAgYXhpc0hlbHBlci5nZXRBeGlzUmF3VmFsdWUoYXhpcywgdGljayksXG4gICAgICAgICAgICAgICAgICAgIGlkeFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXhpc0hlbHBlci5nZXRBeGlzUmF3VmFsdWUgPSBmdW5jdGlvbiAoYXhpcywgdmFsdWUpIHtcbiAgICAgICAgLy8gSW4gY2F0ZWdvcnkgYXhpcyB3aXRoIGRhdGEgem9vbSwgdGljayBpcyBub3QgdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIGluZGV4IG9mIGF4aXMuZGF0YS4gU28gdGljayBzaG91bGQgbm90IGJlIGV4cG9zZWQgdG8gdXNlclxuICAgICAgICAvLyBpbiBjYXRlZ29yeSBheGlzLlxuICAgICAgICByZXR1cm4gYXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gYXhpcy5zY2FsZS5nZXRMYWJlbCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBheGlzSGVscGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2Nvb3JkL2F4aXNIZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\n\n    var zrUtil = __webpack_require__(20);\n    var Scale = __webpack_require__(119);\n\n    var scaleProto = Scale.prototype;\n\n    var OrdinalScale = Scale.extend({\n\n        type: 'ordinal',\n\n        init: function (data, extent) {\n            this._data = data;\n            this._extent = extent || [0, data.length - 1];\n        },\n\n        parse: function (val) {\n            return typeof val === 'string'\n                ? zrUtil.indexOf(this._data, val)\n                // val might be float.\n                : Math.round(val);\n        },\n\n        contain: function (rank) {\n            rank = this.parse(rank);\n            return scaleProto.contain.call(this, rank)\n                && this._data[rank] != null;\n        },\n\n        /**\n         * Normalize given rank or name to linear [0, 1]\n         * @param {number|string} [val]\n         * @return {number}\n         */\n        normalize: function (val) {\n            return scaleProto.normalize.call(this, this.parse(val));\n        },\n\n        scale: function (val) {\n            return Math.round(scaleProto.scale.call(this, val));\n        },\n\n        /**\n         * @return {Array}\n         */\n        getTicks: function () {\n            var ticks = [];\n            var extent = this._extent;\n            var rank = extent[0];\n\n            while (rank <= extent[1]) {\n                ticks.push(rank);\n                rank++;\n            }\n\n            return ticks;\n        },\n\n        /**\n         * Get item on rank n\n         * @param {number} n\n         * @return {string}\n         */\n        getLabel: function (n) {\n            return this._data[n];\n        },\n\n        /**\n         * @return {number}\n         */\n        count: function () {\n            return this._extent[1] - this._extent[0] + 1;\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, false));\n        },\n\n        niceTicks: zrUtil.noop,\n        niceExtent: zrUtil.noop\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n\n    module.exports = OrdinalScale;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3NjYWxlL09yZGluYWwuanM/M2E2YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjExOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGluZWFyIGNvbnRpbnVvdXMgc2NhbGVcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jb29yZC9zY2FsZS9PcmRpbmFsXG4gKlxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXZlbF9vZl9tZWFzdXJlbWVudFxuICovXG5cbi8vIEZJWE1FIG9ubHkgb25lIGRhdGFcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBTY2FsZSA9IHJlcXVpcmUoJy4vU2NhbGUnKTtcblxuICAgIHZhciBzY2FsZVByb3RvID0gU2NhbGUucHJvdG90eXBlO1xuXG4gICAgdmFyIE9yZGluYWxTY2FsZSA9IFNjYWxlLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ29yZGluYWwnLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChkYXRhLCBleHRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5fZXh0ZW50ID0gZXh0ZW50IHx8IFswLCBkYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IHpyVXRpbC5pbmRleE9mKHRoaXMuX2RhdGEsIHZhbClcbiAgICAgICAgICAgICAgICAvLyB2YWwgbWlnaHQgYmUgZmxvYXQuXG4gICAgICAgICAgICAgICAgOiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKHJhbmspIHtcbiAgICAgICAgICAgIHJhbmsgPSB0aGlzLnBhcnNlKHJhbmspO1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxlUHJvdG8uY29udGFpbi5jYWxsKHRoaXMsIHJhbmspXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5fZGF0YVtyYW5rXSAhPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3JtYWxpemUgZ2l2ZW4gcmFuayBvciBuYW1lIHRvIGxpbmVhciBbMCwgMV1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbdmFsXVxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBub3JtYWxpemU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FsZVByb3RvLm5vcm1hbGl6ZS5jYWxsKHRoaXMsIHRoaXMucGFyc2UodmFsKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHNjYWxlUHJvdG8uc2NhbGUuY2FsbCh0aGlzLCB2YWwpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUaWNrczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRpY2tzID0gW107XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIHJhbmsgPSBleHRlbnRbMF07XG5cbiAgICAgICAgICAgIHdoaWxlIChyYW5rIDw9IGV4dGVudFsxXSkge1xuICAgICAgICAgICAgICAgIHRpY2tzLnB1c2gocmFuayk7XG4gICAgICAgICAgICAgICAgcmFuaysrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBpdGVtIG9uIHJhbmsgblxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gblxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYWJlbDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhW25dO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4dGVudFsxXSAtIHRoaXMuX2V4dGVudFswXSArIDE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgdW5pb25FeHRlbnRGcm9tRGF0YTogZnVuY3Rpb24gKGRhdGEsIGRpbSkge1xuICAgICAgICAgICAgdGhpcy51bmlvbkV4dGVudChkYXRhLmdldERhdGFFeHRlbnQoZGltLCBmYWxzZSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5pY2VUaWNrczogenJVdGlsLm5vb3AsXG4gICAgICAgIG5pY2VFeHRlbnQ6IHpyVXRpbC5ub29wXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9zY2FsZS9UaW1lfVxuICAgICAqL1xuICAgIE9yZGluYWxTY2FsZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT3JkaW5hbFNjYWxlKCk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gT3JkaW5hbFNjYWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3NjYWxlL09yZGluYWwuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n\n    var clazzUtil = __webpack_require__(29);\n\n    /**\n     * @param {Object} [setting]\n     */\n    function Scale(setting) {\n        this._setting = setting || {};\n\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [Infinity, -Infinity];\n\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n\n        this.init && this.init.apply(this, arguments);\n    }\n\n    var scaleProto = Scale.prototype;\n\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n\n    scaleProto.getSetting = function (name) {\n        return this._setting[name];\n    };\n\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        // not setExtent because in log axis it may transformed to power\n        // this.setExtent(extent[0], extent[1]);\n    };\n\n    /**\n     * Set extent from data\n     * @param {module:echarts/data/List} data\n     * @param {string} dim\n     */\n    scaleProto.unionExtentFromData = function (data, dim) {\n        this.unionExtent(data.getDataExtent(dim, true));\n    };\n\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.isBlank = function () {\n        return this._isBlank;\n    },\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.setBlank = function (isBlank) {\n        this._isBlank = isBlank;\n    };\n\n\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, {\n        registerWhenExtend: true\n    });\n\n    module.exports = Scale;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3NjYWxlL1NjYWxlLmpzP2M5MjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMIiwiZmlsZSI6IjExOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogLy8gU2NhbGUgY2xhc3MgbWFuYWdlbWVudFxuICogQG1vZHVsZSBlY2hhcnRzL3NjYWxlL1NjYWxlXG4gKi9cblxuXG4gICAgdmFyIGNsYXp6VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhenonKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc2V0dGluZ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTY2FsZShzZXR0aW5nKSB7XG4gICAgICAgIHRoaXMuX3NldHRpbmcgPSBzZXR0aW5nIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRlbnRcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9leHRlbnQgPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0ZXAgaXMgY2FsY3VsYXRlZCBpbiBhZGp1c3RFeHRlbnRcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IDA7XG5cbiAgICAgICAgdGhpcy5pbml0ICYmIHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHZhciBzY2FsZVByb3RvID0gU2NhbGUucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogUGFyc2UgaW5wdXQgdmFsIHRvIHZhbGlkIGlubmVyIG51bWJlci5cbiAgICAgKiBAcGFyYW0geyp9IHZhbFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBzY2FsZVByb3RvLnBhcnNlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAvLyBOb3RpY2U6IFRoaXMgd291bGQgYmUgYSB0cmFwIGhlcmUsIElmIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAvLyBvZiB0aGlzIG1ldGhvZCBkZXBlbmRzIG9uIGV4dGVudCwgYW5kIHRoaXMgbWV0aG9kIGlzIHVzZWRcbiAgICAgICAgLy8gYmVmb3JlIGV4dGVudCBzZXQgKGxpa2UgaW4gZGF0YVpvb20pLCBpdCB3b3VsZCBiZSB3cm9uZy5cbiAgICAgICAgLy8gTmV2ZXJ0aGVsZXNzLCBwYXJzZSBkb2VzIG5vdCBkZXBlbmQgb24gZXh0ZW50IGdlbmVyYWxseS5cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgc2NhbGVQcm90by5nZXRTZXR0aW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdbbmFtZV07XG4gICAgfTtcblxuICAgIHNjYWxlUHJvdG8uY29udGFpbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgcmV0dXJuIHZhbCA+PSBleHRlbnRbMF0gJiYgdmFsIDw9IGV4dGVudFsxXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIHZhbHVlIHRvIGxpbmVhciBbMCwgMV0sIHJldHVybiAwLjUgaWYgZXh0ZW50IHNwYW4gaXMgMFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2NhbGVQcm90by5ub3JtYWxpemUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgIGlmIChleHRlbnRbMV0gPT09IGV4dGVudFswXSkge1xuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHZhbCAtIGV4dGVudFswXSkgLyAoZXh0ZW50WzFdIC0gZXh0ZW50WzBdKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NhbGUgbm9ybWFsaXplZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2NhbGVQcm90by5zY2FsZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgcmV0dXJuIHZhbCAqIChleHRlbnRbMV0gLSBleHRlbnRbMF0pICsgZXh0ZW50WzBdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgZXh0ZW50IGZyb20gZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG90aGVyXG4gICAgICovXG4gICAgc2NhbGVQcm90by51bmlvbkV4dGVudCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICBvdGhlclswXSA8IGV4dGVudFswXSAmJiAoZXh0ZW50WzBdID0gb3RoZXJbMF0pO1xuICAgICAgICBvdGhlclsxXSA+IGV4dGVudFsxXSAmJiAoZXh0ZW50WzFdID0gb3RoZXJbMV0pO1xuICAgICAgICAvLyBub3Qgc2V0RXh0ZW50IGJlY2F1c2UgaW4gbG9nIGF4aXMgaXQgbWF5IHRyYW5zZm9ybWVkIHRvIHBvd2VyXG4gICAgICAgIC8vIHRoaXMuc2V0RXh0ZW50KGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGV4dGVudCBmcm9tIGRhdGFcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAgICAgKi9cbiAgICBzY2FsZVByb3RvLnVuaW9uRXh0ZW50RnJvbURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgZGltKSB7XG4gICAgICAgIHRoaXMudW5pb25FeHRlbnQoZGF0YS5nZXREYXRhRXh0ZW50KGRpbSwgdHJ1ZSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZXh0ZW50XG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgc2NhbGVQcm90by5nZXRFeHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRlbnQuc2xpY2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGV4dGVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAgICAgKi9cbiAgICBzY2FsZVByb3RvLnNldEV4dGVudCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciB0aGlzRXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICBpZiAoIWlzTmFOKHN0YXJ0KSkge1xuICAgICAgICAgICAgdGhpc0V4dGVudFswXSA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOYU4oZW5kKSkge1xuICAgICAgICAgICAgdGhpc0V4dGVudFsxXSA9IGVuZDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBzY2FsZVByb3RvLmdldFRpY2tzTGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFiZWxzID0gW107XG4gICAgICAgIHZhciB0aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGFiZWxzLnB1c2godGhpcy5nZXRMYWJlbCh0aWNrc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYXhpcyBleHRlbnQgZGVwZW5kcyBvbiBkYXRhIGFuZCBubyBkYXRhIGV4aXN0cyxcbiAgICAgKiBheGlzIHRpY2tzIHNob3VsZCBub3QgYmUgZHJhd24sIHdoaWNoIGlzIG5hbWVkICdibGFuaycuXG4gICAgICovXG4gICAgc2NhbGVQcm90by5pc0JsYW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNCbGFuaztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBheGlzIGV4dGVudCBkZXBlbmRzIG9uIGRhdGEgYW5kIG5vIGRhdGEgZXhpc3RzLFxuICAgICAqIGF4aXMgdGlja3Mgc2hvdWxkIG5vdCBiZSBkcmF3biwgd2hpY2ggaXMgbmFtZWQgJ2JsYW5rJy5cbiAgICAgKi9cbiAgICBzY2FsZVByb3RvLnNldEJsYW5rID0gZnVuY3Rpb24gKGlzQmxhbmspIHtcbiAgICAgICAgdGhpcy5faXNCbGFuayA9IGlzQmxhbms7XG4gICAgfTtcblxuXG4gICAgY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKFNjYWxlKTtcbiAgICBjbGF6elV0aWwuZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KFNjYWxlLCB7XG4gICAgICAgIHJlZ2lzdGVyV2hlbkV4dGVuZDogdHJ1ZVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTY2FsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9zY2FsZS9TY2FsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\n\n    var numberUtil = __webpack_require__(23);\n    var formatUtil = __webpack_require__(22);\n    var Scale = __webpack_require__(119);\n    var helper = __webpack_require__(121);\n\n    var roundNumber = numberUtil.round;\n\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n\n        type: 'interval',\n\n        _interval: 0,\n\n        _intervalPrecision: 2,\n\n        setExtent: function (start, end) {\n            var thisExtent = this._extent;\n            //start,end may be a Number like '25',so...\n            if (!isNaN(start)) {\n                thisExtent[0] = parseFloat(start);\n            }\n            if (!isNaN(end)) {\n                thisExtent[1] = parseFloat(end);\n            }\n        },\n\n        unionExtent: function (other) {\n            var extent = this._extent;\n            other[0] < extent[0] && (extent[0] = other[0]);\n            other[1] > extent[1] && (extent[1] = other[1]);\n\n            // unionExtent may called by it's sub classes\n            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n        },\n        /**\n         * Get interval\n         */\n        getInterval: function () {\n            return this._interval;\n        },\n\n        /**\n         * Set interval\n         */\n        setInterval: function (interval) {\n            this._interval = interval;\n            // Dropped auto calculated niceExtent and use user setted extent\n            // We assume user wan't to set both interval, min, max to get a better result\n            this._niceExtent = this._extent.slice();\n\n            this._intervalPrecision = helper.getIntervalPrecision(interval);\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            return helper.intervalScaleGetTicks(\n                this._interval, this._extent, this._niceExtent, this._intervalPrecision\n            );\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getTicksLabels: function () {\n            var labels = [];\n            var ticks = this.getTicks();\n            for (var i = 0; i < ticks.length; i++) {\n                labels.push(this.getLabel(ticks[i]));\n            }\n            return labels;\n        },\n\n        /**\n         * @param {number} data\n         * @param {Object} [opt]\n         * @param {number|string} [opt.precision] If 'auto', use nice presision.\n         * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n         * @return {string}\n         */\n        getLabel: function (data, opt) {\n            if (data == null) {\n                return '';\n            }\n\n            var precision = opt && opt.precision;\n\n            if (precision == null) {\n                precision = numberUtil.getPrecisionSafe(data) || 0;\n            }\n            else if (precision === 'auto') {\n                // Should be more precise then tick.\n                precision = this._intervalPrecision;\n            }\n\n            // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n            // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n            data = roundNumber(data, precision, true);\n\n            return formatUtil.addCommas(data);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         *\n         * @param {number} [splitNumber = 5] Desired number of ticks\n         * @param {number} [minInterval]\n         */\n        niceTicks: function (splitNumber, minInterval) {\n            splitNumber = splitNumber || 5;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (!isFinite(span)) {\n                return;\n            }\n            // User may set axis min 0 and data are all negative\n            // FIXME If it needs to reverse ?\n            if (span < 0) {\n                span = -span;\n                extent.reverse();\n            }\n\n            var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval);\n\n            this._intervalPrecision = result.intervalPrecision;\n            this._interval = result.interval;\n            this._niceExtent = result.niceTickExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {Object} opt\n         * @param {number} [opt.splitNumber = 5] Given approx tick number\n         * @param {boolean} [opt.fixMin=false]\n         * @param {boolean} [opt.fixMax=false]\n         * @param {boolean} [opt.minInterval=false]\n         */\n        niceExtent: function (opt) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                if (extent[0] !== 0) {\n                    // Expand extent\n                    var expandSize = extent[0];\n                    // In the fowllowing case\n                    //      Axis has been fixed max 100\n                    //      Plus data are all 100 and axis extent are [100, 100].\n                    // Extend to the both side will cause expanded max is larger than fixed max.\n                    // So only expand to the smaller side.\n                    if (!opt.fixMax) {\n                        extent[1] += expandSize / 2;\n                        extent[0] -= expandSize / 2;\n                    }\n                    else {\n                        extent[0] -= expandSize / 2;\n                    }\n                }\n                else {\n                    extent[1] = 1;\n                }\n            }\n            var span = extent[1] - extent[0];\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (!isFinite(span)) {\n                extent[0] = 0;\n                extent[1] = 1;\n            }\n\n            this.niceTicks(opt.splitNumber, opt.minInterval);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!opt.fixMin) {\n                extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n            }\n            if (!opt.fixMax) {\n                extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n            }\n        }\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n\n    module.exports = IntervalScale;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3NjYWxlL0ludGVydmFsLmpzPzA4ZTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixjQUFjO0FBQ2pDLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEludGVydmFsIHNjYWxlXG4gKiBAbW9kdWxlIGVjaGFydHMvc2NhbGUvSW50ZXJ2YWxcbiAqL1xuXG5cblxuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvZm9ybWF0Jyk7XG4gICAgdmFyIFNjYWxlID0gcmVxdWlyZSgnLi9TY2FsZScpO1xuICAgIHZhciBoZWxwZXIgPSByZXF1aXJlKCcuL2hlbHBlcicpO1xuXG4gICAgdmFyIHJvdW5kTnVtYmVyID0gbnVtYmVyVXRpbC5yb3VuZDtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9zY2FsZS9JbnRlcnZhbFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBJbnRlcnZhbFNjYWxlID0gU2NhbGUuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnaW50ZXJ2YWwnLFxuXG4gICAgICAgIF9pbnRlcnZhbDogMCxcblxuICAgICAgICBfaW50ZXJ2YWxQcmVjaXNpb246IDIsXG5cbiAgICAgICAgc2V0RXh0ZW50OiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgdmFyIHRoaXNFeHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICAvL3N0YXJ0LGVuZCBtYXkgYmUgYSBOdW1iZXIgbGlrZSAnMjUnLHNvLi4uXG4gICAgICAgICAgICBpZiAoIWlzTmFOKHN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHRoaXNFeHRlbnRbMF0gPSBwYXJzZUZsb2F0KHN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNOYU4oZW5kKSkge1xuICAgICAgICAgICAgICAgIHRoaXNFeHRlbnRbMV0gPSBwYXJzZUZsb2F0KGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5pb25FeHRlbnQ6IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIG90aGVyWzBdIDwgZXh0ZW50WzBdICYmIChleHRlbnRbMF0gPSBvdGhlclswXSk7XG4gICAgICAgICAgICBvdGhlclsxXSA+IGV4dGVudFsxXSAmJiAoZXh0ZW50WzFdID0gb3RoZXJbMV0pO1xuXG4gICAgICAgICAgICAvLyB1bmlvbkV4dGVudCBtYXkgY2FsbGVkIGJ5IGl0J3Mgc3ViIGNsYXNzZXNcbiAgICAgICAgICAgIEludGVydmFsU2NhbGUucHJvdG90eXBlLnNldEV4dGVudC5jYWxsKHRoaXMsIGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBpbnRlcnZhbFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcnZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGludGVydmFsXG4gICAgICAgICAqL1xuICAgICAgICBzZXRJbnRlcnZhbDogZnVuY3Rpb24gKGludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgICAgICAgLy8gRHJvcHBlZCBhdXRvIGNhbGN1bGF0ZWQgbmljZUV4dGVudCBhbmQgdXNlIHVzZXIgc2V0dGVkIGV4dGVudFxuICAgICAgICAgICAgLy8gV2UgYXNzdW1lIHVzZXIgd2FuJ3QgdG8gc2V0IGJvdGggaW50ZXJ2YWwsIG1pbiwgbWF4IHRvIGdldCBhIGJldHRlciByZXN1bHRcbiAgICAgICAgICAgIHRoaXMuX25pY2VFeHRlbnQgPSB0aGlzLl9leHRlbnQuc2xpY2UoKTtcblxuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxQcmVjaXNpb24gPSBoZWxwZXIuZ2V0SW50ZXJ2YWxQcmVjaXNpb24oaW50ZXJ2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRpY2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaGVscGVyLmludGVydmFsU2NhbGVHZXRUaWNrcyhcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcnZhbCwgdGhpcy5fZXh0ZW50LCB0aGlzLl9uaWNlRXh0ZW50LCB0aGlzLl9pbnRlcnZhbFByZWNpc2lvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUaWNrc0xhYmVsczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxhYmVscyA9IFtdO1xuICAgICAgICAgICAgdmFyIHRpY2tzID0gdGhpcy5nZXRUaWNrcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKHRoaXMuZ2V0TGFiZWwodGlja3NbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHQucHJlY2lzaW9uXSBJZiAnYXV0bycsIHVzZSBuaWNlIHByZXNpc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0LnBhZF0gcmV0dXJucyAxLjUwIGJ1dCBub3QgMS41IGlmIHByZWNpc2lvbiBpcyAyLlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYWJlbDogZnVuY3Rpb24gKGRhdGEsIG9wdCkge1xuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByZWNpc2lvbiA9IG9wdCAmJiBvcHQucHJlY2lzaW9uO1xuXG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBudW1iZXJVdGlsLmdldFByZWNpc2lvblNhZmUoZGF0YSkgfHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWNpc2lvbiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIGJlIG1vcmUgcHJlY2lzZSB0aGVuIHRpY2suXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gdGhpcy5faW50ZXJ2YWxQcmVjaXNpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vICgxKSBJZiBgcHJlY2lzaW9uYCBpcyBzZXQsIDEyLjAwNSBzaG91bGQgYmUgZGlzcGxheSBhcyAnMTIuMDA1MDAnLlxuICAgICAgICAgICAgLy8gKDIpIFVzZSByb3VuZE51bWJlciAodG9GaXhlZCkgdG8gYXZvaWQgc2NpZW50aWZpYyBub3RhdGlvbiBsaWtlICczLjVlLTcnLlxuICAgICAgICAgICAgZGF0YSA9IHJvdW5kTnVtYmVyKGRhdGEsIHByZWNpc2lvbiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRVdGlsLmFkZENvbW1hcyhkYXRhKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGludGVydmFsIGFuZCBleHRlbnQgb2YgaW50ZXJ2YWxzIGZvciBuaWNlIHRpY2tzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3BsaXROdW1iZXIgPSA1XSBEZXNpcmVkIG51bWJlciBvZiB0aWNrc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pbkludGVydmFsXVxuICAgICAgICAgKi9cbiAgICAgICAgbmljZVRpY2tzOiBmdW5jdGlvbiAoc3BsaXROdW1iZXIsIG1pbkludGVydmFsKSB7XG4gICAgICAgICAgICBzcGxpdE51bWJlciA9IHNwbGl0TnVtYmVyIHx8IDU7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gICAgICAgICAgICBpZiAoIWlzRmluaXRlKHNwYW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXNlciBtYXkgc2V0IGF4aXMgbWluIDAgYW5kIGRhdGEgYXJlIGFsbCBuZWdhdGl2ZVxuICAgICAgICAgICAgLy8gRklYTUUgSWYgaXQgbmVlZHMgdG8gcmV2ZXJzZSA/XG4gICAgICAgICAgICBpZiAoc3BhbiA8IDApIHtcbiAgICAgICAgICAgICAgICBzcGFuID0gLXNwYW47XG4gICAgICAgICAgICAgICAgZXh0ZW50LnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGhlbHBlci5pbnRlcnZhbFNjYWxlTmljZVRpY2tzKGV4dGVudCwgc3BsaXROdW1iZXIsIG1pbkludGVydmFsKTtcblxuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxQcmVjaXNpb24gPSByZXN1bHQuaW50ZXJ2YWxQcmVjaXNpb247XG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IHJlc3VsdC5pbnRlcnZhbDtcbiAgICAgICAgICAgIHRoaXMuX25pY2VFeHRlbnQgPSByZXN1bHQubmljZVRpY2tFeHRlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5pY2UgZXh0ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LnNwbGl0TnVtYmVyID0gNV0gR2l2ZW4gYXBwcm94IHRpY2sgbnVtYmVyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5maXhNaW49ZmFsc2VdXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5maXhNYXg9ZmFsc2VdXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5taW5JbnRlcnZhbD1mYWxzZV1cbiAgICAgICAgICovXG4gICAgICAgIG5pY2VFeHRlbnQ6IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICAvLyBJZiBleHRlbnQgc3RhcnQgYW5kIGVuZCBhcmUgc2FtZSwgZXhwYW5kIHRoZW1cbiAgICAgICAgICAgIGlmIChleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xuICAgICAgICAgICAgICAgIGlmIChleHRlbnRbMF0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwYW5kIGV4dGVudFxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwYW5kU2l6ZSA9IGV4dGVudFswXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIGZvd2xsb3dpbmcgY2FzZVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIEF4aXMgaGFzIGJlZW4gZml4ZWQgbWF4IDEwMFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIFBsdXMgZGF0YSBhcmUgYWxsIDEwMCBhbmQgYXhpcyBleHRlbnQgYXJlIFsxMDAsIDEwMF0uXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dGVuZCB0byB0aGUgYm90aCBzaWRlIHdpbGwgY2F1c2UgZXhwYW5kZWQgbWF4IGlzIGxhcmdlciB0aGFuIGZpeGVkIG1heC5cbiAgICAgICAgICAgICAgICAgICAgLy8gU28gb25seSBleHBhbmQgdG8gdGhlIHNtYWxsZXIgc2lkZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHQuZml4TWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnRbMV0gKz0gZXhwYW5kU2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnRbMF0gLT0gZXhwYW5kU2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnRbMF0gLT0gZXhwYW5kU2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVudFsxXSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZGF0YSBhbmQgZXh0ZW50IGFyZSBbSW5maW5pdHksIC1JbmZpbml0eV1cbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUoc3BhbikpIHtcbiAgICAgICAgICAgICAgICBleHRlbnRbMF0gPSAwO1xuICAgICAgICAgICAgICAgIGV4dGVudFsxXSA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubmljZVRpY2tzKG9wdC5zcGxpdE51bWJlciwgb3B0Lm1pbkludGVydmFsKTtcblxuICAgICAgICAgICAgLy8gdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHRoaXMuX2ludGVydmFsO1xuXG4gICAgICAgICAgICBpZiAoIW9wdC5maXhNaW4pIHtcbiAgICAgICAgICAgICAgICBleHRlbnRbMF0gPSByb3VuZE51bWJlcihNYXRoLmZsb29yKGV4dGVudFswXSAvIGludGVydmFsKSAqIGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0LmZpeE1heCkge1xuICAgICAgICAgICAgICAgIGV4dGVudFsxXSA9IHJvdW5kTnVtYmVyKE1hdGguY2VpbChleHRlbnRbMV0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3NjYWxlL1RpbWV9XG4gICAgICovXG4gICAgSW50ZXJ2YWxTY2FsZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWxTY2FsZSgpO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEludGVydmFsU2NhbGU7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9zY2FsZS9JbnRlcnZhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("/**\n * For testable.\n */\n\n\n    var numberUtil = __webpack_require__(23);\n\n    var roundNumber = numberUtil.round;\n\n    var helper = {};\n\n    /**\n     * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n     *                                Should be extent[0] < extent[1].\n     * @param {number} splitNumber splitNumber should be >= 1.\n     * @param {number} [minInterval]\n     * @return {Object} {interval, intervalPrecision, niceTickExtent}\n     */\n    helper.intervalScaleNiceTicks = function (extent, splitNumber, minInterval) {\n        var result = {};\n        var span = extent[1] - extent[0];\n\n        var interval = result.interval = numberUtil.nice(span / splitNumber, true);\n        if (minInterval != null && interval < minInterval) {\n            interval = result.interval = minInterval;\n        }\n        // Tow more digital for tick.\n        var precision = result.intervalPrecision = helper.getIntervalPrecision(interval);\n        // Niced extent inside original extent\n        var niceTickExtent = result.niceTickExtent = [\n            roundNumber(Math.ceil(extent[0] / interval) * interval, precision),\n            roundNumber(Math.floor(extent[1] / interval) * interval, precision)\n        ];\n\n        helper.fixExtent(niceTickExtent, extent);\n\n        return result;\n    };\n\n    /**\n     * @param {number} interval\n     * @return {number} interval precision\n     */\n    helper.getIntervalPrecision = function (interval) {\n        // Tow more digital for tick.\n        return numberUtil.getPrecisionSafe(interval) + 2;\n    };\n\n    function clamp(niceTickExtent, idx, extent) {\n        niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n    }\n\n    // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\n    helper.fixExtent = function (niceTickExtent, extent) {\n        !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n        !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n        clamp(niceTickExtent, 0, extent);\n        clamp(niceTickExtent, 1, extent);\n        if (niceTickExtent[0] > niceTickExtent[1]) {\n            niceTickExtent[0] = niceTickExtent[1];\n        }\n    };\n\n    helper.intervalScaleGetTicks = function (interval, extent, niceTickExtent, intervalPrecision) {\n        var ticks = [];\n\n        // If interval is 0, return [];\n        if (!interval) {\n            return ticks;\n        }\n\n        // Consider this case: using dataZoom toolbox, zoom and zoom.\n        var safeLimit = 10000;\n\n        if (extent[0] < niceTickExtent[0]) {\n            ticks.push(extent[0]);\n        }\n        var tick = niceTickExtent[0];\n\n        while (tick <= niceTickExtent[1]) {\n            ticks.push(tick);\n            // Avoid rounding error\n            tick = roundNumber(tick + interval, intervalPrecision);\n            if (tick === ticks[ticks.length - 1]) {\n                // Consider out of safe float point, e.g.,\n                // -3711126.9907707 + 2e-10 === -3711126.9907707\n                break;\n            }\n            if (ticks.length > safeLimit) {\n                return [];\n            }\n        }\n        // Consider this case: the last item of ticks is smaller\n        // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n        if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {\n            ticks.push(extent[1]);\n        }\n\n        return ticks;\n    };\n\n    module.exports = helper;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3NjYWxlL2hlbHBlci5qcz8zNzBiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPLEVBQUU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIxMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZvciB0ZXN0YWJsZS5cbiAqL1xuXG5cbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbnVtYmVyJyk7XG5cbiAgICB2YXIgcm91bmROdW1iZXIgPSBudW1iZXJVdGlsLnJvdW5kO1xuXG4gICAgdmFyIGhlbHBlciA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZXh0ZW50IEJvdGggZXh0ZW50WzBdIGFuZCBleHRlbnRbMV0gc2hvdWxkIGJlIHZhbGlkIG51bWJlci5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2hvdWxkIGJlIGV4dGVudFswXSA8IGV4dGVudFsxXS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3BsaXROdW1iZXIgc3BsaXROdW1iZXIgc2hvdWxkIGJlID49IDEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttaW5JbnRlcnZhbF1cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHtpbnRlcnZhbCwgaW50ZXJ2YWxQcmVjaXNpb24sIG5pY2VUaWNrRXh0ZW50fVxuICAgICAqL1xuICAgIGhlbHBlci5pbnRlcnZhbFNjYWxlTmljZVRpY2tzID0gZnVuY3Rpb24gKGV4dGVudCwgc3BsaXROdW1iZXIsIG1pbkludGVydmFsKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG5cbiAgICAgICAgdmFyIGludGVydmFsID0gcmVzdWx0LmludGVydmFsID0gbnVtYmVyVXRpbC5uaWNlKHNwYW4gLyBzcGxpdE51bWJlciwgdHJ1ZSk7XG4gICAgICAgIGlmIChtaW5JbnRlcnZhbCAhPSBudWxsICYmIGludGVydmFsIDwgbWluSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGludGVydmFsID0gcmVzdWx0LmludGVydmFsID0gbWluSW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG93IG1vcmUgZGlnaXRhbCBmb3IgdGljay5cbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IHJlc3VsdC5pbnRlcnZhbFByZWNpc2lvbiA9IGhlbHBlci5nZXRJbnRlcnZhbFByZWNpc2lvbihpbnRlcnZhbCk7XG4gICAgICAgIC8vIE5pY2VkIGV4dGVudCBpbnNpZGUgb3JpZ2luYWwgZXh0ZW50XG4gICAgICAgIHZhciBuaWNlVGlja0V4dGVudCA9IHJlc3VsdC5uaWNlVGlja0V4dGVudCA9IFtcbiAgICAgICAgICAgIHJvdW5kTnVtYmVyKE1hdGguY2VpbChleHRlbnRbMF0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCwgcHJlY2lzaW9uKSxcbiAgICAgICAgICAgIHJvdW5kTnVtYmVyKE1hdGguZmxvb3IoZXh0ZW50WzFdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwsIHByZWNpc2lvbilcbiAgICAgICAgXTtcblxuICAgICAgICBoZWxwZXIuZml4RXh0ZW50KG5pY2VUaWNrRXh0ZW50LCBleHRlbnQpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gaW50ZXJ2YWwgcHJlY2lzaW9uXG4gICAgICovXG4gICAgaGVscGVyLmdldEludGVydmFsUHJlY2lzaW9uID0gZnVuY3Rpb24gKGludGVydmFsKSB7XG4gICAgICAgIC8vIFRvdyBtb3JlIGRpZ2l0YWwgZm9yIHRpY2suXG4gICAgICAgIHJldHVybiBudW1iZXJVdGlsLmdldFByZWNpc2lvblNhZmUoaW50ZXJ2YWwpICsgMjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2xhbXAobmljZVRpY2tFeHRlbnQsIGlkeCwgZXh0ZW50KSB7XG4gICAgICAgIG5pY2VUaWNrRXh0ZW50W2lkeF0gPSBNYXRoLm1heChNYXRoLm1pbihuaWNlVGlja0V4dGVudFtpZHhdLCBleHRlbnRbMV0pLCBleHRlbnRbMF0pO1xuICAgIH1cblxuICAgIC8vIEluIHNvbWUgY2FzZXMgKGUuZy4sIHNwbGl0TnVtYmVyIGlzIDEpLCBuaWNlVGlja0V4dGVudCBtYXkgYmUgb3V0IG9mIGV4dGVudC5cbiAgICBoZWxwZXIuZml4RXh0ZW50ID0gZnVuY3Rpb24gKG5pY2VUaWNrRXh0ZW50LCBleHRlbnQpIHtcbiAgICAgICAgIWlzRmluaXRlKG5pY2VUaWNrRXh0ZW50WzBdKSAmJiAobmljZVRpY2tFeHRlbnRbMF0gPSBleHRlbnRbMF0pO1xuICAgICAgICAhaXNGaW5pdGUobmljZVRpY2tFeHRlbnRbMV0pICYmIChuaWNlVGlja0V4dGVudFsxXSA9IGV4dGVudFsxXSk7XG4gICAgICAgIGNsYW1wKG5pY2VUaWNrRXh0ZW50LCAwLCBleHRlbnQpO1xuICAgICAgICBjbGFtcChuaWNlVGlja0V4dGVudCwgMSwgZXh0ZW50KTtcbiAgICAgICAgaWYgKG5pY2VUaWNrRXh0ZW50WzBdID4gbmljZVRpY2tFeHRlbnRbMV0pIHtcbiAgICAgICAgICAgIG5pY2VUaWNrRXh0ZW50WzBdID0gbmljZVRpY2tFeHRlbnRbMV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaGVscGVyLmludGVydmFsU2NhbGVHZXRUaWNrcyA9IGZ1bmN0aW9uIChpbnRlcnZhbCwgZXh0ZW50LCBuaWNlVGlja0V4dGVudCwgaW50ZXJ2YWxQcmVjaXNpb24pIHtcbiAgICAgICAgdmFyIHRpY2tzID0gW107XG5cbiAgICAgICAgLy8gSWYgaW50ZXJ2YWwgaXMgMCwgcmV0dXJuIFtdO1xuICAgICAgICBpZiAoIWludGVydmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25zaWRlciB0aGlzIGNhc2U6IHVzaW5nIGRhdGFab29tIHRvb2xib3gsIHpvb20gYW5kIHpvb20uXG4gICAgICAgIHZhciBzYWZlTGltaXQgPSAxMDAwMDtcblxuICAgICAgICBpZiAoZXh0ZW50WzBdIDwgbmljZVRpY2tFeHRlbnRbMF0pIHtcbiAgICAgICAgICAgIHRpY2tzLnB1c2goZXh0ZW50WzBdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGljayA9IG5pY2VUaWNrRXh0ZW50WzBdO1xuXG4gICAgICAgIHdoaWxlICh0aWNrIDw9IG5pY2VUaWNrRXh0ZW50WzFdKSB7XG4gICAgICAgICAgICB0aWNrcy5wdXNoKHRpY2spO1xuICAgICAgICAgICAgLy8gQXZvaWQgcm91bmRpbmcgZXJyb3JcbiAgICAgICAgICAgIHRpY2sgPSByb3VuZE51bWJlcih0aWNrICsgaW50ZXJ2YWwsIGludGVydmFsUHJlY2lzaW9uKTtcbiAgICAgICAgICAgIGlmICh0aWNrID09PSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIG91dCBvZiBzYWZlIGZsb2F0IHBvaW50LCBlLmcuLFxuICAgICAgICAgICAgICAgIC8vIC0zNzExMTI2Ljk5MDc3MDcgKyAyZS0xMCA9PT0gLTM3MTExMjYuOTkwNzcwN1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpY2tzLmxlbmd0aCA+IHNhZmVMaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb25zaWRlciB0aGlzIGNhc2U6IHRoZSBsYXN0IGl0ZW0gb2YgdGlja3MgaXMgc21hbGxlclxuICAgICAgICAvLyB0aGFuIG5pY2VUaWNrRXh0ZW50WzFdIGFuZCBuaWNlVGlja0V4dGVudFsxXSA9PT0gZXh0ZW50WzFdLlxuICAgICAgICBpZiAoZXh0ZW50WzFdID4gKHRpY2tzLmxlbmd0aCA/IHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdIDogbmljZVRpY2tFeHRlbnRbMV0pKSB7XG4gICAgICAgICAgICB0aWNrcy5wdXNoKGV4dGVudFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gaGVscGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3NjYWxlL2hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/**\n * Interval scale\n * @module echarts/coord/scale/Time\n */\n\n\n\n    // [About UTC and local time zone]:\n    // In most cases, `number.parseDate` will treat input data string as local time\n    // (except time zone is specified in time string). And `format.formateTime` returns\n    // local time by default. option.useUTC is false by default. This design have\n    // concidered these common case:\n    // (1) Time that is persistent in server is in UTC, but it is needed to be diplayed\n    // in local time by default.\n    // (2) By default, the input data string (e.g., '2011-01-02') should be displayed\n    // as its original time, without any time difference.\n\n    var zrUtil = __webpack_require__(20);\n    var numberUtil = __webpack_require__(23);\n    var formatUtil = __webpack_require__(22);\n    var scaleHelper = __webpack_require__(121);\n\n    var IntervalScale = __webpack_require__(120);\n\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n\n    // FIXME 公用？\n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            }\n            else {\n                hi  = mid;\n            }\n        }\n        return lo;\n    };\n\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n        type: 'time',\n\n        /**\n         * @override\n         */\n        getLabel: function (val) {\n            var stepLvl = this._stepLvl;\n\n            var date = new Date(val);\n\n            return formatUtil.formatTime(stepLvl[0], date, this.getSetting('useUTC'));\n        },\n\n        /**\n         * @override\n         */\n        niceExtent: function (opt) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                // Expand extent\n                extent[0] -= ONE_DAY;\n                extent[1] += ONE_DAY;\n            }\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (extent[1] === -Infinity && extent[0] === Infinity) {\n                var d = new Date();\n                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                extent[0] = extent[1] - ONE_DAY;\n            }\n\n            this.niceTicks(opt.splitNumber);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!opt.fixMin) {\n                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!opt.fixMax) {\n                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n            }\n        },\n\n        /**\n         * @override\n         */\n        niceTicks: function (approxTickNum) {\n            var timezoneOffset = this.getSetting('useUTC')\n                ? 0 : numberUtil.getTimezoneOffset() * 60 * 1000;\n            approxTickNum = approxTickNum || 10;\n\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            var approxInterval = span / approxTickNum;\n            var scaleLevelsLen = scaleLevels.length;\n            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n            var interval = level[2];\n            // Same with interval scale if span is much larger than 1 year\n            if (level[0] === 'year') {\n                var yearSpan = span / interval;\n\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\n                interval *= yearStep;\n            }\n\n            var niceExtent = [\n                Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset),\n                Math.round(mathFloor((extent[1] - timezoneOffset)/ interval) * interval + timezoneOffset)\n            ];\n\n            scaleHelper.fixExtent(niceExtent, extent);\n\n            this._stepLvl = level;\n            // Interval will be used in getTicks\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        parse: function (val) {\n            // val might be float.\n            return +numberUtil.parseDate(val);\n        }\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n\n    // Steps from d3\n    var scaleLevels = [\n        // Format       step    interval\n        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n        ['week',        7,      ONE_DAY * 7],        // 7d\n        ['month',       1,      ONE_DAY * 31],       // 1M\n        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n        ['year',        1,      ONE_DAY * 380]       // 1Y\n    ];\n\n    /**\n     * @param {module:echarts/model/Model}\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function (model) {\n        return new TimeScale({useUTC: model.ecModel.get('useUTC')});\n    };\n\n    module.exports = TimeScale;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3NjYWxlL1RpbWUuanM/NmZkZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSw4QkFBOEIsb0NBQW9DO0FBQ2xFOztBQUVBIiwiZmlsZSI6IjEyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZXJ2YWwgc2NhbGVcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jb29yZC9zY2FsZS9UaW1lXG4gKi9cblxuXG5cbiAgICAvLyBbQWJvdXQgVVRDIGFuZCBsb2NhbCB0aW1lIHpvbmVdOlxuICAgIC8vIEluIG1vc3QgY2FzZXMsIGBudW1iZXIucGFyc2VEYXRlYCB3aWxsIHRyZWF0IGlucHV0IGRhdGEgc3RyaW5nIGFzIGxvY2FsIHRpbWVcbiAgICAvLyAoZXhjZXB0IHRpbWUgem9uZSBpcyBzcGVjaWZpZWQgaW4gdGltZSBzdHJpbmcpLiBBbmQgYGZvcm1hdC5mb3JtYXRlVGltZWAgcmV0dXJuc1xuICAgIC8vIGxvY2FsIHRpbWUgYnkgZGVmYXVsdC4gb3B0aW9uLnVzZVVUQyBpcyBmYWxzZSBieSBkZWZhdWx0LiBUaGlzIGRlc2lnbiBoYXZlXG4gICAgLy8gY29uY2lkZXJlZCB0aGVzZSBjb21tb24gY2FzZTpcbiAgICAvLyAoMSkgVGltZSB0aGF0IGlzIHBlcnNpc3RlbnQgaW4gc2VydmVyIGlzIGluIFVUQywgYnV0IGl0IGlzIG5lZWRlZCB0byBiZSBkaXBsYXllZFxuICAgIC8vIGluIGxvY2FsIHRpbWUgYnkgZGVmYXVsdC5cbiAgICAvLyAoMikgQnkgZGVmYXVsdCwgdGhlIGlucHV0IGRhdGEgc3RyaW5nIChlLmcuLCAnMjAxMS0wMS0wMicpIHNob3VsZCBiZSBkaXNwbGF5ZWRcbiAgICAvLyBhcyBpdHMgb3JpZ2luYWwgdGltZSwgd2l0aG91dCBhbnkgdGltZSBkaWZmZXJlbmNlLlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvZm9ybWF0Jyk7XG4gICAgdmFyIHNjYWxlSGVscGVyID0gcmVxdWlyZSgnLi9oZWxwZXInKTtcblxuICAgIHZhciBJbnRlcnZhbFNjYWxlID0gcmVxdWlyZSgnLi9JbnRlcnZhbCcpO1xuXG4gICAgdmFyIGludGVydmFsU2NhbGVQcm90byA9IEludGVydmFsU2NhbGUucHJvdG90eXBlO1xuXG4gICAgdmFyIG1hdGhDZWlsID0gTWF0aC5jZWlsO1xuICAgIHZhciBtYXRoRmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBPTkVfU0VDT05EID0gMTAwMDtcbiAgICB2YXIgT05FX01JTlVURSA9IE9ORV9TRUNPTkQgKiA2MDtcbiAgICB2YXIgT05FX0hPVVIgPSBPTkVfTUlOVVRFICogNjA7XG4gICAgdmFyIE9ORV9EQVkgPSBPTkVfSE9VUiAqIDI0O1xuXG4gICAgLy8gRklYTUUg5YWs55So77yfXG4gICAgdmFyIGJpc2VjdCA9IGZ1bmN0aW9uIChhLCB4LCBsbywgaGkpIHtcbiAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICAgICAgaWYgKGFbbWlkXVsyXSA8IHgpIHtcbiAgICAgICAgICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaSAgPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29vcmQvc2NhbGUvVGltZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBUaW1lU2NhbGUgPSBJbnRlcnZhbFNjYWxlLmV4dGVuZCh7XG4gICAgICAgIHR5cGU6ICd0aW1lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYWJlbDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdmFyIHN0ZXBMdmwgPSB0aGlzLl9zdGVwTHZsO1xuXG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHZhbCk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRVdGlsLmZvcm1hdFRpbWUoc3RlcEx2bFswXSwgZGF0ZSwgdGhpcy5nZXRTZXR0aW5nKCd1c2VVVEMnKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgbmljZUV4dGVudDogZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIC8vIElmIGV4dGVudCBzdGFydCBhbmQgZW5kIGFyZSBzYW1lLCBleHBhbmQgdGhlbVxuICAgICAgICAgICAgaWYgKGV4dGVudFswXSA9PT0gZXh0ZW50WzFdKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwYW5kIGV4dGVudFxuICAgICAgICAgICAgICAgIGV4dGVudFswXSAtPSBPTkVfREFZO1xuICAgICAgICAgICAgICAgIGV4dGVudFsxXSArPSBPTkVfREFZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGRhdGEgYW5kIGV4dGVudCBhcmUgW0luZmluaXR5LCAtSW5maW5pdHldXG4gICAgICAgICAgICBpZiAoZXh0ZW50WzFdID09PSAtSW5maW5pdHkgJiYgZXh0ZW50WzBdID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICBleHRlbnRbMV0gPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSwgZC5nZXREYXRlKCkpO1xuICAgICAgICAgICAgICAgIGV4dGVudFswXSA9IGV4dGVudFsxXSAtIE9ORV9EQVk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubmljZVRpY2tzKG9wdC5zcGxpdE51bWJlcik7XG5cbiAgICAgICAgICAgIC8vIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSB0aGlzLl9pbnRlcnZhbDtcblxuICAgICAgICAgICAgaWYgKCFvcHQuZml4TWluKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzBdID0gbnVtYmVyVXRpbC5yb3VuZChtYXRoRmxvb3IoZXh0ZW50WzBdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHQuZml4TWF4KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzFdID0gbnVtYmVyVXRpbC5yb3VuZChtYXRoQ2VpbChleHRlbnRbMV0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgbmljZVRpY2tzOiBmdW5jdGlvbiAoYXBwcm94VGlja051bSkge1xuICAgICAgICAgICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gdGhpcy5nZXRTZXR0aW5nKCd1c2VVVEMnKVxuICAgICAgICAgICAgICAgID8gMCA6IG51bWJlclV0aWwuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwICogMTAwMDtcbiAgICAgICAgICAgIGFwcHJveFRpY2tOdW0gPSBhcHByb3hUaWNrTnVtIHx8IDEwO1xuXG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gICAgICAgICAgICB2YXIgYXBwcm94SW50ZXJ2YWwgPSBzcGFuIC8gYXBwcm94VGlja051bTtcbiAgICAgICAgICAgIHZhciBzY2FsZUxldmVsc0xlbiA9IHNjYWxlTGV2ZWxzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpZHggPSBiaXNlY3Qoc2NhbGVMZXZlbHMsIGFwcHJveEludGVydmFsLCAwLCBzY2FsZUxldmVsc0xlbik7XG5cbiAgICAgICAgICAgIHZhciBsZXZlbCA9IHNjYWxlTGV2ZWxzW01hdGgubWluKGlkeCwgc2NhbGVMZXZlbHNMZW4gLSAxKV07XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBsZXZlbFsyXTtcbiAgICAgICAgICAgIC8vIFNhbWUgd2l0aCBpbnRlcnZhbCBzY2FsZSBpZiBzcGFuIGlzIG11Y2ggbGFyZ2VyIHRoYW4gMSB5ZWFyXG4gICAgICAgICAgICBpZiAobGV2ZWxbMF0gPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgICAgIHZhciB5ZWFyU3BhbiA9IHNwYW4gLyBpbnRlcnZhbDtcblxuICAgICAgICAgICAgICAgIC8vIEZyb20gXCJOaWNlIE51bWJlcnMgZm9yIEdyYXBoIExhYmVsc1wiIG9mIEdyYXBoaWMgR2Vtc1xuICAgICAgICAgICAgICAgIC8vIHZhciBuaWNlWWVhclNwYW4gPSBudW1iZXJVdGlsLm5pY2UoeWVhclNwYW4sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB2YXIgeWVhclN0ZXAgPSBudW1iZXJVdGlsLm5pY2UoeWVhclNwYW4gLyBhcHByb3hUaWNrTnVtLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIGludGVydmFsICo9IHllYXJTdGVwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmljZUV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKG1hdGhDZWlsKChleHRlbnRbMF0gLSB0aW1lem9uZU9mZnNldCkgLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCArIHRpbWV6b25lT2Zmc2V0KSxcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKG1hdGhGbG9vcigoZXh0ZW50WzFdIC0gdGltZXpvbmVPZmZzZXQpLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCArIHRpbWV6b25lT2Zmc2V0KVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgc2NhbGVIZWxwZXIuZml4RXh0ZW50KG5pY2VFeHRlbnQsIGV4dGVudCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3N0ZXBMdmwgPSBsZXZlbDtcbiAgICAgICAgICAgIC8vIEludGVydmFsIHdpbGwgYmUgdXNlZCBpbiBnZXRUaWNrc1xuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICAgICAgICAgIHRoaXMuX25pY2VFeHRlbnQgPSBuaWNlRXh0ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAvLyB2YWwgbWlnaHQgYmUgZmxvYXQuXG4gICAgICAgICAgICByZXR1cm4gK251bWJlclV0aWwucGFyc2VEYXRlKHZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHpyVXRpbC5lYWNoKFsnY29udGFpbicsICdub3JtYWxpemUnXSwgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgVGltZVNjYWxlLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnZhbFNjYWxlUHJvdG9bbWV0aG9kTmFtZV0uY2FsbCh0aGlzLCB0aGlzLnBhcnNlKHZhbCkpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gU3RlcHMgZnJvbSBkM1xuICAgIHZhciBzY2FsZUxldmVscyA9IFtcbiAgICAgICAgLy8gRm9ybWF0ICAgICAgIHN0ZXAgICAgaW50ZXJ2YWxcbiAgICAgICAgWydoaDptbTpzcycsICAgIDEsICAgICAgT05FX1NFQ09ORF0sICAgICAgICAgICAvLyAxc1xuICAgICAgICBbJ2hoOm1tOnNzJywgICAgNSwgICAgICBPTkVfU0VDT05EICogNV0sICAgICAgIC8vIDVzXG4gICAgICAgIFsnaGg6bW06c3MnLCAgICAxMCwgICAgIE9ORV9TRUNPTkQgKiAxMF0sICAgICAgLy8gMTBzXG4gICAgICAgIFsnaGg6bW06c3MnLCAgICAxNSwgICAgIE9ORV9TRUNPTkQgKiAxNV0sICAgICAgLy8gMTVzXG4gICAgICAgIFsnaGg6bW06c3MnLCAgICAzMCwgICAgIE9ORV9TRUNPTkQgKiAzMF0sICAgICAgLy8gMzBzXG4gICAgICAgIFsnaGg6bW1cXG5NTS1kZCcsMSwgICAgICBPTkVfTUlOVVRFXSwgICAgICAgICAgLy8gMW1cbiAgICAgICAgWydoaDptbVxcbk1NLWRkJyw1LCAgICAgIE9ORV9NSU5VVEUgKiA1XSwgICAgICAvLyA1bVxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDEwLCAgICAgT05FX01JTlVURSAqIDEwXSwgICAgIC8vIDEwbVxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDE1LCAgICAgT05FX01JTlVURSAqIDE1XSwgICAgIC8vIDE1bVxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDMwLCAgICAgT05FX01JTlVURSAqIDMwXSwgICAgIC8vIDMwbVxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDEsICAgICAgT05FX0hPVVJdLCAgICAgICAgLy8gMWhcbiAgICAgICAgWydoaDptbVxcbk1NLWRkJywyLCAgICAgIE9ORV9IT1VSICogMl0sICAgIC8vIDJoXG4gICAgICAgIFsnaGg6bW1cXG5NTS1kZCcsNiwgICAgICBPTkVfSE9VUiAqIDZdLCAgICAvLyA2aFxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDEyLCAgICAgT05FX0hPVVIgKiAxMl0sICAgLy8gMTJoXG4gICAgICAgIFsnTU0tZGRcXG55eXl5JywgMSwgICAgICBPTkVfREFZXSwgICAvLyAxZFxuICAgICAgICBbJ3dlZWsnLCAgICAgICAgNywgICAgICBPTkVfREFZICogN10sICAgICAgICAvLyA3ZFxuICAgICAgICBbJ21vbnRoJywgICAgICAgMSwgICAgICBPTkVfREFZICogMzFdLCAgICAgICAvLyAxTVxuICAgICAgICBbJ3F1YXJ0ZXInLCAgICAgMywgICAgICBPTkVfREFZICogMzgwIC8gNF0sICAvLyAzTVxuICAgICAgICBbJ2hhbGYteWVhcicsICAgNiwgICAgICBPTkVfREFZICogMzgwIC8gMl0sICAvLyA2TVxuICAgICAgICBbJ3llYXInLCAgICAgICAgMSwgICAgICBPTkVfREFZICogMzgwXSAgICAgICAvLyAxWVxuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3NjYWxlL1RpbWV9XG4gICAgICovXG4gICAgVGltZVNjYWxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVTY2FsZSh7dXNlVVRDOiBtb2RlbC5lY01vZGVsLmdldCgndXNlVVRDJyl9KTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUaW1lU2NhbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvc2NhbGUvVGltZS5qc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n\n    var zrUtil = __webpack_require__(20);\n    var Scale = __webpack_require__(119);\n    var numberUtil = __webpack_require__(23);\n\n    // Use some method of IntervalScale\n    var IntervalScale = __webpack_require__(120);\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n\n    var mathLog = Math.log;\n\n    var LogScale = Scale.extend({\n\n        type: 'log',\n\n        base: 10,\n\n        $constructor: function () {\n            Scale.apply(this, arguments);\n            this._originalScale = new IntervalScale();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            var originalScale = this._originalScale;\n            var extent = this._extent;\n            var originalExtent = originalScale.getExtent();\n\n            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                var powVal = numberUtil.round(mathPow(this.base, val));\n\n                // Fix #4158\n                powVal = (val === extent[0] && originalScale.__fixMin)\n                    ? fixRoundingError(powVal, originalExtent[0])\n                    : powVal;\n                powVal = (val === extent[1] && originalScale.__fixMax)\n                    ? fixRoundingError(powVal, originalExtent[1])\n                    : powVal;\n\n                return powVal;\n            }, this);\n        },\n\n        /**\n         * @param {number} val\n         * @return {string}\n         */\n        getLabel: intervalScaleProto.getLabel,\n\n        /**\n         * @param  {number} val\n         * @return {number}\n         */\n        scale: function (val) {\n            val = scaleProto.scale.call(this, val);\n            return mathPow(this.base, val);\n        },\n\n        /**\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var base = this.base;\n            start = mathLog(start) / mathLog(base);\n            end = mathLog(end) / mathLog(base);\n            intervalScaleProto.setExtent.call(this, start, end);\n        },\n\n        /**\n         * @return {number} end\n         */\n        getExtent: function () {\n            var base = this.base;\n            var extent = scaleProto.getExtent.call(this);\n            extent[0] = mathPow(base, extent[0]);\n            extent[1] = mathPow(base, extent[1]);\n\n            // Fix #4158\n            var originalScale = this._originalScale;\n            var originalExtent = originalScale.getExtent();\n            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n            return extent;\n        },\n\n        /**\n         * @param  {Array.<number>} extent\n         */\n        unionExtent: function (extent) {\n            this._originalScale.unionExtent(extent);\n\n            var base = this.base;\n            extent[0] = mathLog(extent[0]) / mathLog(base);\n            extent[1] = mathLog(extent[1]) / mathLog(base);\n            scaleProto.unionExtent.call(this, extent);\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, true, function (val) {\n                return val > 0;\n            }));\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         * @param  {number} [approxTickNum = 10] Given approx tick number\n         */\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (span === Infinity || span <= 0) {\n                return;\n            }\n\n            var interval = numberUtil.quantity(span);\n            var err = approxTickNum / span * interval;\n\n            // Filter ticks to get closer to the desired count.\n            if (err <= 0.5) {\n                interval *= 10;\n            }\n\n            // Interval should be integer\n            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                interval *= 10;\n            }\n\n            var niceExtent = [\n                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n            ];\n\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @override\n         */\n        niceExtent: function (opt) {\n            intervalScaleProto.niceExtent.call(this, opt);\n\n            var originalScale = this._originalScale;\n            originalScale.__fixMin = opt.fixMin;\n            originalScale.__fixMax = opt.fixMax;\n        }\n\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n\n    LogScale.create = function () {\n        return new LogScale();\n    };\n\n    function fixRoundingError(val, originalVal) {\n        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n    }\n\n    module.exports = LogScale;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3NjYWxlL0xvZy5qcz8wYWQwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2cgc2NhbGVcbiAqIEBtb2R1bGUgZWNoYXJ0cy9zY2FsZS9Mb2dcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIFNjYWxlID0gcmVxdWlyZSgnLi9TY2FsZScpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9udW1iZXInKTtcblxuICAgIC8vIFVzZSBzb21lIG1ldGhvZCBvZiBJbnRlcnZhbFNjYWxlXG4gICAgdmFyIEludGVydmFsU2NhbGUgPSByZXF1aXJlKCcuL0ludGVydmFsJyk7XG5cbiAgICB2YXIgc2NhbGVQcm90byA9IFNjYWxlLnByb3RvdHlwZTtcbiAgICB2YXIgaW50ZXJ2YWxTY2FsZVByb3RvID0gSW50ZXJ2YWxTY2FsZS5wcm90b3R5cGU7XG5cbiAgICB2YXIgZ2V0UHJlY2lzaW9uU2FmZSA9IG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uU2FmZTtcbiAgICB2YXIgcm91bmRpbmdFcnJvckZpeCA9IG51bWJlclV0aWwucm91bmQ7XG5cbiAgICB2YXIgbWF0aEZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgbWF0aENlaWwgPSBNYXRoLmNlaWw7XG4gICAgdmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcblxuICAgIHZhciBtYXRoTG9nID0gTWF0aC5sb2c7XG5cbiAgICB2YXIgTG9nU2NhbGUgPSBTY2FsZS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdsb2cnLFxuXG4gICAgICAgIGJhc2U6IDEwLFxuXG4gICAgICAgICRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgU2NhbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsU2NhbGUgPSBuZXcgSW50ZXJ2YWxTY2FsZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRpY2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxTY2FsZSA9IHRoaXMuX29yaWdpbmFsU2NhbGU7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXh0ZW50ID0gb3JpZ2luYWxTY2FsZS5nZXRFeHRlbnQoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAoaW50ZXJ2YWxTY2FsZVByb3RvLmdldFRpY2tzLmNhbGwodGhpcyksIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG93VmFsID0gbnVtYmVyVXRpbC5yb3VuZChtYXRoUG93KHRoaXMuYmFzZSwgdmFsKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaXggIzQxNThcbiAgICAgICAgICAgICAgICBwb3dWYWwgPSAodmFsID09PSBleHRlbnRbMF0gJiYgb3JpZ2luYWxTY2FsZS5fX2ZpeE1pbilcbiAgICAgICAgICAgICAgICAgICAgPyBmaXhSb3VuZGluZ0Vycm9yKHBvd1ZhbCwgb3JpZ2luYWxFeHRlbnRbMF0pXG4gICAgICAgICAgICAgICAgICAgIDogcG93VmFsO1xuICAgICAgICAgICAgICAgIHBvd1ZhbCA9ICh2YWwgPT09IGV4dGVudFsxXSAmJiBvcmlnaW5hbFNjYWxlLl9fZml4TWF4KVxuICAgICAgICAgICAgICAgICAgICA/IGZpeFJvdW5kaW5nRXJyb3IocG93VmFsLCBvcmlnaW5hbEV4dGVudFsxXSlcbiAgICAgICAgICAgICAgICAgICAgOiBwb3dWYWw7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcG93VmFsO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGFiZWw6IGludGVydmFsU2NhbGVQcm90by5nZXRMYWJlbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHZhbCA9IHNjYWxlUHJvdG8uc2NhbGUuY2FsbCh0aGlzLCB2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGhQb3codGhpcy5iYXNlLCB2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RXh0ZW50OiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgdmFyIGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgICAgICAgICBzdGFydCA9IG1hdGhMb2coc3RhcnQpIC8gbWF0aExvZyhiYXNlKTtcbiAgICAgICAgICAgIGVuZCA9IG1hdGhMb2coZW5kKSAvIG1hdGhMb2coYmFzZSk7XG4gICAgICAgICAgICBpbnRlcnZhbFNjYWxlUHJvdG8uc2V0RXh0ZW50LmNhbGwodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gZW5kXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFeHRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHNjYWxlUHJvdG8uZ2V0RXh0ZW50LmNhbGwodGhpcyk7XG4gICAgICAgICAgICBleHRlbnRbMF0gPSBtYXRoUG93KGJhc2UsIGV4dGVudFswXSk7XG4gICAgICAgICAgICBleHRlbnRbMV0gPSBtYXRoUG93KGJhc2UsIGV4dGVudFsxXSk7XG5cbiAgICAgICAgICAgIC8vIEZpeCAjNDE1OFxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsU2NhbGUgPSB0aGlzLl9vcmlnaW5hbFNjYWxlO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXh0ZW50ID0gb3JpZ2luYWxTY2FsZS5nZXRFeHRlbnQoKTtcbiAgICAgICAgICAgIG9yaWdpbmFsU2NhbGUuX19maXhNaW4gJiYgKGV4dGVudFswXSA9IGZpeFJvdW5kaW5nRXJyb3IoZXh0ZW50WzBdLCBvcmlnaW5hbEV4dGVudFswXSkpO1xuICAgICAgICAgICAgb3JpZ2luYWxTY2FsZS5fX2ZpeE1heCAmJiAoZXh0ZW50WzFdID0gZml4Um91bmRpbmdFcnJvcihleHRlbnRbMV0sIG9yaWdpbmFsRXh0ZW50WzFdKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBleHRlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBleHRlbnRcbiAgICAgICAgICovXG4gICAgICAgIHVuaW9uRXh0ZW50OiBmdW5jdGlvbiAoZXh0ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFNjYWxlLnVuaW9uRXh0ZW50KGV4dGVudCk7XG5cbiAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuICAgICAgICAgICAgZXh0ZW50WzBdID0gbWF0aExvZyhleHRlbnRbMF0pIC8gbWF0aExvZyhiYXNlKTtcbiAgICAgICAgICAgIGV4dGVudFsxXSA9IG1hdGhMb2coZXh0ZW50WzFdKSAvIG1hdGhMb2coYmFzZSk7XG4gICAgICAgICAgICBzY2FsZVByb3RvLnVuaW9uRXh0ZW50LmNhbGwodGhpcywgZXh0ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICB1bmlvbkV4dGVudEZyb21EYXRhOiBmdW5jdGlvbiAoZGF0YSwgZGltKSB7XG4gICAgICAgICAgICB0aGlzLnVuaW9uRXh0ZW50KGRhdGEuZ2V0RGF0YUV4dGVudChkaW0sIHRydWUsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsID4gMDtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGludGVydmFsIGFuZCBleHRlbnQgb2YgaW50ZXJ2YWxzIGZvciBuaWNlIHRpY2tzXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gW2FwcHJveFRpY2tOdW0gPSAxMF0gR2l2ZW4gYXBwcm94IHRpY2sgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBuaWNlVGlja3M6IGZ1bmN0aW9uIChhcHByb3hUaWNrTnVtKSB7XG4gICAgICAgICAgICBhcHByb3hUaWNrTnVtID0gYXBwcm94VGlja051bSB8fCAxMDtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcbiAgICAgICAgICAgIGlmIChzcGFuID09PSBJbmZpbml0eSB8fCBzcGFuIDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IG51bWJlclV0aWwucXVhbnRpdHkoc3Bhbik7XG4gICAgICAgICAgICB2YXIgZXJyID0gYXBwcm94VGlja051bSAvIHNwYW4gKiBpbnRlcnZhbDtcblxuICAgICAgICAgICAgLy8gRmlsdGVyIHRpY2tzIHRvIGdldCBjbG9zZXIgdG8gdGhlIGRlc2lyZWQgY291bnQuXG4gICAgICAgICAgICBpZiAoZXJyIDw9IDAuNSkge1xuICAgICAgICAgICAgICAgIGludGVydmFsICo9IDEwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbnRlcnZhbCBzaG91bGQgYmUgaW50ZWdlclxuICAgICAgICAgICAgd2hpbGUgKCFpc05hTihpbnRlcnZhbCkgJiYgTWF0aC5hYnMoaW50ZXJ2YWwpIDwgMSAmJiBNYXRoLmFicyhpbnRlcnZhbCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgKj0gMTA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuaWNlRXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgIG51bWJlclV0aWwucm91bmQobWF0aENlaWwoZXh0ZW50WzBdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpLFxuICAgICAgICAgICAgICAgIG51bWJlclV0aWwucm91bmQobWF0aEZsb29yKGV4dGVudFsxXSAvIGludGVydmFsKSAqIGludGVydmFsKVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICAgICAgICAgIHRoaXMuX25pY2VFeHRlbnQgPSBuaWNlRXh0ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOaWNlIGV4dGVudC5cbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBuaWNlRXh0ZW50OiBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgICBpbnRlcnZhbFNjYWxlUHJvdG8ubmljZUV4dGVudC5jYWxsKHRoaXMsIG9wdCk7XG5cbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFNjYWxlID0gdGhpcy5fb3JpZ2luYWxTY2FsZTtcbiAgICAgICAgICAgIG9yaWdpbmFsU2NhbGUuX19maXhNaW4gPSBvcHQuZml4TWluO1xuICAgICAgICAgICAgb3JpZ2luYWxTY2FsZS5fX2ZpeE1heCA9IG9wdC5maXhNYXg7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgenJVdGlsLmVhY2goWydjb250YWluJywgJ25vcm1hbGl6ZSddLCBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgICBMb2dTY2FsZS5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YWwgPSBtYXRoTG9nKHZhbCkgLyBtYXRoTG9nKHRoaXMuYmFzZSk7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVQcm90b1ttZXRob2ROYW1lXS5jYWxsKHRoaXMsIHZhbCk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBMb2dTY2FsZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nU2NhbGUoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZml4Um91bmRpbmdFcnJvcih2YWwsIG9yaWdpbmFsVmFsKSB7XG4gICAgICAgIHJldHVybiByb3VuZGluZ0Vycm9yRml4KHZhbCwgZ2V0UHJlY2lzaW9uU2FmZShvcmlnaW5hbFZhbCkpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gTG9nU2NhbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvc2NhbGUvTG9nLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("\n\n    var createListFromArray = __webpack_require__(125);\n    var symbolUtil = __webpack_require__(127);\n    var axisHelper = __webpack_require__(117);\n    var axisModelCommonMixin = __webpack_require__(128);\n    var Model = __webpack_require__(28);\n    var util = __webpack_require__(20);\n\n    module.exports = {\n        /**\n         * Create a muti dimension List structure from seriesModel.\n         * @param  {module:echarts/model/Model} seriesModel\n         * @return {module:echarts/data/List} list\n         */\n        createList: function (seriesModel) {\n            var data = seriesModel.get('data');\n            return createListFromArray(data, seriesModel, seriesModel.ecModel);\n        },\n\n        /**\n         * @see {module:echarts/data/helper/completeDimensions}\n         */\n        completeDimensions: __webpack_require__(126),\n\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @see http://echarts.baidu.com/option.html#series-scatter.symbol\n         * @param {string} symbolDesc\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: symbolUtil.createSymbol,\n\n        /**\n         * Create scale\n         * @param {Array.<number>} dataExtent\n         * @param {Object|module:echarts/Model} option\n         */\n        createScale: function (dataExtent, option) {\n            var axisModel = option;\n            if (!(option instanceof Model)) {\n                axisModel = new Model(option);\n                util.mixin(axisModel, axisModelCommonMixin);\n            }\n\n            var scale = axisHelper.createScaleByModel(axisModel);\n            scale.setExtent(dataExtent[0], dataExtent[1]);\n\n            axisHelper.niceScaleExtent(scale, axisModel);\n            return scale;\n        },\n\n        /**\n         * Mixin common methods to axis model,\n         *\n         * Inlcude methods\n         * `getFormattedLabels() => Array.<string>`\n         * `getCategories() => Array.<string>`\n         * `getMin(origin: boolean) => number`\n         * `getMax(origin: boolean) => number`\n         * `getNeedCrossZero() => boolean`\n         * `setRange(start: number, end: number)`\n         * `resetRange()`\n         */\n        mixinAxisModelCommonMethods: function (Model) {\n            util.mixin(Model, axisModelCommonMixin);\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2hlbHBlci5qcz81Nzk0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0Msb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgY3JlYXRlTGlzdEZyb21BcnJheSA9IHJlcXVpcmUoJy4vY2hhcnQvaGVscGVyL2NyZWF0ZUxpc3RGcm9tQXJyYXknKTtcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9zeW1ib2wnKTtcbiAgICB2YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoJy4vY29vcmQvYXhpc0hlbHBlcicpO1xuICAgIHZhciBheGlzTW9kZWxDb21tb25NaXhpbiA9IHJlcXVpcmUoJy4vY29vcmQvYXhpc01vZGVsQ29tbW9uTWl4aW4nKTtcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuL21vZGVsL01vZGVsJyk7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbXV0aSBkaW1lbnNpb24gTGlzdCBzdHJ1Y3R1cmUgZnJvbSBzZXJpZXNNb2RlbC5cbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IHNlcmllc01vZGVsXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gbGlzdFxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlTGlzdDogZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldCgnZGF0YScpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpc3RGcm9tQXJyYXkoZGF0YSwgc2VyaWVzTW9kZWwsIHNlcmllc01vZGVsLmVjTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc2VlIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnN9XG4gICAgICAgICAqL1xuICAgICAgICBjb21wbGV0ZURpbWVuc2lvbnM6IHJlcXVpcmUoJy4vZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zJyksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHN5bWJvbCBlbGVtZW50IHdpdGggZ2l2ZW4gc3ltYm9sIGNvbmZpZ3VyYXRpb246IHNoYXBlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvclxuICAgICAgICAgKiBAc2VlIGh0dHA6Ly9lY2hhcnRzLmJhaWR1LmNvbS9vcHRpb24uaHRtbCNzZXJpZXMtc2NhdHRlci5zeW1ib2xcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbERlc2NcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTeW1ib2w6IHN5bWJvbFV0aWwuY3JlYXRlU3ltYm9sLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgc2NhbGVcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZGF0YUV4dGVudFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxtb2R1bGU6ZWNoYXJ0cy9Nb2RlbH0gb3B0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTY2FsZTogZnVuY3Rpb24gKGRhdGFFeHRlbnQsIG9wdGlvbikge1xuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IG9wdGlvbjtcbiAgICAgICAgICAgIGlmICghKG9wdGlvbiBpbnN0YW5jZW9mIE1vZGVsKSkge1xuICAgICAgICAgICAgICAgIGF4aXNNb2RlbCA9IG5ldyBNb2RlbChvcHRpb24pO1xuICAgICAgICAgICAgICAgIHV0aWwubWl4aW4oYXhpc01vZGVsLCBheGlzTW9kZWxDb21tb25NaXhpbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzY2FsZSA9IGF4aXNIZWxwZXIuY3JlYXRlU2NhbGVCeU1vZGVsKGF4aXNNb2RlbCk7XG4gICAgICAgICAgICBzY2FsZS5zZXRFeHRlbnQoZGF0YUV4dGVudFswXSwgZGF0YUV4dGVudFsxXSk7XG5cbiAgICAgICAgICAgIGF4aXNIZWxwZXIubmljZVNjYWxlRXh0ZW50KHNjYWxlLCBheGlzTW9kZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNaXhpbiBjb21tb24gbWV0aG9kcyB0byBheGlzIG1vZGVsLFxuICAgICAgICAgKlxuICAgICAgICAgKiBJbmxjdWRlIG1ldGhvZHNcbiAgICAgICAgICogYGdldEZvcm1hdHRlZExhYmVscygpID0+IEFycmF5LjxzdHJpbmc+YFxuICAgICAgICAgKiBgZ2V0Q2F0ZWdvcmllcygpID0+IEFycmF5LjxzdHJpbmc+YFxuICAgICAgICAgKiBgZ2V0TWluKG9yaWdpbjogYm9vbGVhbikgPT4gbnVtYmVyYFxuICAgICAgICAgKiBgZ2V0TWF4KG9yaWdpbjogYm9vbGVhbikgPT4gbnVtYmVyYFxuICAgICAgICAgKiBgZ2V0TmVlZENyb3NzWmVybygpID0+IGJvb2xlYW5gXG4gICAgICAgICAqIGBzZXRSYW5nZShzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcilgXG4gICAgICAgICAqIGByZXNldFJhbmdlKClgXG4gICAgICAgICAqL1xuICAgICAgICBtaXhpbkF4aXNNb2RlbENvbW1vbk1ldGhvZHM6IGZ1bmN0aW9uIChNb2RlbCkge1xuICAgICAgICAgICAgdXRpbC5taXhpbihNb2RlbCwgYXhpc01vZGVsQ29tbW9uTWl4aW4pO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9oZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var List = __webpack_require__(114);\n    var completeDimensions = __webpack_require__(126);\n    var zrUtil = __webpack_require__(20);\n    var modelUtil = __webpack_require__(21);\n    var CoordinateSystem = __webpack_require__(92);\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null\n            && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        var completeDimOpt = {\n            encodeDef: seriesModel.get('encode'),\n            dimsDef: seriesModel.get('dimensions')\n        };\n\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = (registeredCoordSys && (\n                registeredCoordSys.getDimensionsInfo\n                    ? registeredCoordSys.getDimensionsInfo()\n                    : registeredCoordSys.dimensions.slice()\n            )) || ['x', 'y'];\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n        }\n\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n        var list = new List(dimensions, seriesModel);\n\n        var nameList = createNameList(axesInfo, data);\n\n        var categories = {};\n        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex\n                    ? dataIndex\n                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            }\n            : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName]\n                            || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n\n        return list;\n    }\n\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category'\n            ? 'ordinal'\n            : axisType === 'time'\n            ? 'time'\n            : 'float';\n    }\n\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n\n        cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) {\n\n            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n                return ecModel.queryComponents({\n                    mainType: name,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n            });\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (__DEV__) {\n                if (!xAxisModel) {\n                    throw new Error('xAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('xAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n                if (!yAxisModel) {\n                    throw new Error('yAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('yAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n\n            var xAxisType = xAxisModel.get('type');\n            var yAxisType = yAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'x',\n                    type: getDimTypeByAxis(xAxisType),\n                    stackable: isStackable(xAxisType)\n                },\n                {\n                    name: 'y',\n                    // If two category axes\n                    type: getDimTypeByAxis(yAxisType),\n                    stackable: isStackable(yAxisType)\n                }\n            ];\n\n            var isXAxisCateogry = xAxisType === 'category';\n            var isYAxisCategory = yAxisType === 'category';\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isXAxisCateogry) {\n                categoryAxesModels.x = xAxisModel;\n            }\n            if (isYAxisCategory) {\n                categoryAxesModels.y = yAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        singleAxis: function (data, seriesModel, ecModel, completeDimOpt) {\n\n            var singleAxisModel = ecModel.queryComponents({\n                mainType: 'singleAxis',\n                index: seriesModel.get('singleAxisIndex'),\n                id: seriesModel.get('singleAxisId')\n            })[0];\n\n            if (__DEV__) {\n                if (!singleAxisModel) {\n                    throw new Error('singleAxis should be specified.');\n                }\n            }\n\n            var singleAxisType = singleAxisModel.get('type');\n            var isCategory = singleAxisType === 'category';\n\n            var dimensions = [{\n                name: 'single',\n                type: getDimTypeByAxis(singleAxisType),\n                stackable: isStackable(singleAxisType)\n            }];\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isCategory) {\n                categoryAxesModels.single = singleAxisModel;\n            }\n\n            return {\n                dimensions: dimensions,\n                categoryIndex: isCategory ? 0 : -1,\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        polar: function (data, seriesModel, ecModel, completeDimOpt) {\n            var polarModel = ecModel.queryComponents({\n                mainType: 'polar',\n                index: seriesModel.get('polarIndex'),\n                id: seriesModel.get('polarId')\n            })[0];\n\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n            if (__DEV__) {\n                if (!angleAxisModel) {\n                    throw new Error('angleAxis option not found');\n                }\n                if (!radiusAxisModel) {\n                    throw new Error('radiusAxis option not found');\n                }\n            }\n\n            var radiusAxisType = radiusAxisModel.get('type');\n            var angleAxisType = angleAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'radius',\n                    type: getDimTypeByAxis(radiusAxisType),\n                    stackable: isStackable(radiusAxisType)\n                },\n                {\n                    name: 'angle',\n                    type: getDimTypeByAxis(angleAxisType),\n                    stackable: isStackable(angleAxisType)\n                }\n            ];\n            var isAngleAxisCateogry = angleAxisType === 'category';\n            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isRadiusAxisCateogry) {\n                categoryAxesModels.radius = radiusAxisModel;\n            }\n            if (isAngleAxisCateogry) {\n                categoryAxesModels.angle = angleAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        geo: function (data, seriesModel, ecModel, completeDimOpt) {\n            // TODO Region\n            // 多个散点图系列在同一个地区的时候\n            return {\n                dimensions: completeDimensions([\n                    {name: 'lng'},\n                    {name: 'lat'}\n                ], data, completeDimOpt)\n            };\n        }\n    };\n\n    function createNameList(result, data) {\n        var nameList = [];\n\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                }\n                else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n\n        return nameList;\n    }\n\n    module.exports = createListFromArray;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9jcmVhdGVMaXN0RnJvbUFycmF5LmpzP2UzZmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6IjEyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIExpc3QgPSByZXF1aXJlKCcuLi8uLi9kYXRhL0xpc3QnKTtcbiAgICB2YXIgY29tcGxldGVEaW1lbnNpb25zID0gcmVxdWlyZSgnLi4vLi4vZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIENvb3JkaW5hdGVTeXN0ZW0gPSByZXF1aXJlKCcuLi8uLi9Db29yZGluYXRlU3lzdGVtJyk7XG4gICAgdmFyIGdldERhdGFJdGVtVmFsdWUgPSBtb2RlbFV0aWwuZ2V0RGF0YUl0ZW1WYWx1ZTtcbiAgICB2YXIgY29udmVyRGF0YVZhbHVlID0gbW9kZWxVdGlsLmNvbnZlckRhdGFWYWx1ZTtcblxuICAgIGZ1bmN0aW9uIGZpcnN0RGF0YU5vdE51bGwoZGF0YSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgZGF0YS5sZW5ndGggJiYgZGF0YVtpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFbaV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlmTmVlZENvbXBsZXRlT3JkaW5hbERhdGEoZGF0YSkge1xuICAgICAgICB2YXIgc2FtcGxlSXRlbSA9IGZpcnN0RGF0YU5vdE51bGwoZGF0YSk7XG4gICAgICAgIHJldHVybiBzYW1wbGVJdGVtICE9IG51bGxcbiAgICAgICAgICAgICYmICF6clV0aWwuaXNBcnJheShnZXREYXRhSXRlbVZhbHVlKHNhbXBsZUl0ZW0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbGlzdCBmcm9tIG9wdGlvbiBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTGlzdEZyb21BcnJheShkYXRhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAgICAgICAvLyBJZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICBkYXRhID0gZGF0YSB8fCBbXTtcblxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvb3JkU3lzTmFtZSA9IHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpO1xuICAgICAgICB2YXIgY3JlYXRvciA9IGNyZWF0b3JzW2Nvb3JkU3lzTmFtZV07XG4gICAgICAgIHZhciByZWdpc3RlcmVkQ29vcmRTeXMgPSBDb29yZGluYXRlU3lzdGVtLmdldChjb29yZFN5c05hbWUpO1xuICAgICAgICB2YXIgY29tcGxldGVEaW1PcHQgPSB7XG4gICAgICAgICAgICBlbmNvZGVEZWY6IHNlcmllc01vZGVsLmdldCgnZW5jb2RlJyksXG4gICAgICAgICAgICBkaW1zRGVmOiBzZXJpZXNNb2RlbC5nZXQoJ2RpbWVuc2lvbnMnKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIHZhciBheGVzSW5mbyA9IGNyZWF0b3IgJiYgY3JlYXRvcihkYXRhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgY29tcGxldGVEaW1PcHQpO1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGF4ZXNJbmZvICYmIGF4ZXNJbmZvLmRpbWVuc2lvbnM7XG4gICAgICAgIGlmICghZGltZW5zaW9ucykge1xuICAgICAgICAgICAgLy8gR2V0IGRpbWVuc2lvbnMgZnJvbSByZWdpc3RlcmVkIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICAgICAgICBkaW1lbnNpb25zID0gKHJlZ2lzdGVyZWRDb29yZFN5cyAmJiAoXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJlZENvb3JkU3lzLmdldERpbWVuc2lvbnNJbmZvXG4gICAgICAgICAgICAgICAgICAgID8gcmVnaXN0ZXJlZENvb3JkU3lzLmdldERpbWVuc2lvbnNJbmZvKClcbiAgICAgICAgICAgICAgICAgICAgOiByZWdpc3RlcmVkQ29vcmRTeXMuZGltZW5zaW9ucy5zbGljZSgpXG4gICAgICAgICAgICApKSB8fCBbJ3gnLCAneSddO1xuICAgICAgICAgICAgZGltZW5zaW9ucyA9IGNvbXBsZXRlRGltZW5zaW9ucyhkaW1lbnNpb25zLCBkYXRhLCBjb21wbGV0ZURpbU9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2F0ZWdvcnlJbmRleCA9IGF4ZXNJbmZvID8gYXhlc0luZm8uY2F0ZWdvcnlJbmRleCA6IC0xO1xuXG4gICAgICAgIHZhciBsaXN0ID0gbmV3IExpc3QoZGltZW5zaW9ucywgc2VyaWVzTW9kZWwpO1xuXG4gICAgICAgIHZhciBuYW1lTGlzdCA9IGNyZWF0ZU5hbWVMaXN0KGF4ZXNJbmZvLCBkYXRhKTtcblxuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IHt9O1xuICAgICAgICB2YXIgZGltVmFsdWVHZXR0ZXIgPSAoY2F0ZWdvcnlJbmRleCA+PSAwICYmIGlmTmVlZENvbXBsZXRlT3JkaW5hbERhdGEoZGF0YSkpXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChpdGVtT3B0LCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYW55IGRhdGFJdGVtIGlzIGxpa2UgeyB2YWx1ZTogMTAgfVxuICAgICAgICAgICAgICAgIGlmIChtb2RlbFV0aWwuaXNEYXRhSXRlbU9wdGlvbihpdGVtT3B0KSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0Lmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVzZSBkYXRhSW5kZXggYXMgb3JkaW5hbCB2YWx1ZSBpbiBjYXRlZ29yeUF4aXNcbiAgICAgICAgICAgICAgICByZXR1cm4gZGltSW5kZXggPT09IGNhdGVnb3J5SW5kZXhcbiAgICAgICAgICAgICAgICAgICAgPyBkYXRhSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgOiBjb252ZXJEYXRhVmFsdWUoZ2V0RGF0YUl0ZW1WYWx1ZShpdGVtT3B0KSwgZGltZW5zaW9uc1tkaW1JbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoaXRlbU9wdCwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldERhdGFJdGVtVmFsdWUoaXRlbU9wdCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGNvbnZlckRhdGFWYWx1ZSh2YWx1ZSAmJiB2YWx1ZVtkaW1JbmRleF0sIGRpbWVuc2lvbnNbZGltSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbnkgZGF0YUl0ZW0gaXMgbGlrZSB7IHZhbHVlOiAxMCB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsVXRpbC5pc0RhdGFJdGVtT3B0aW9uKGl0ZW1PcHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QuaGFzSXRlbU9wdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNhdGVnb3J5QXhlc01vZGVscyA9IGF4ZXNJbmZvICYmIGF4ZXNJbmZvLmNhdGVnb3J5QXhlc01vZGVscztcbiAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcnlBeGVzTW9kZWxzICYmIGNhdGVnb3J5QXhlc01vZGVsc1tkaW1OYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBnaXZlbiB2YWx1ZSBpcyBhIGNhdGVnb3J5IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExhenkgZ2V0IGNhdGVnb3JpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3JpZXNbZGltTmFtZV0gPSBjYXRlZ29yaWVzW2RpbU5hbWVdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY2F0ZWdvcnlBeGVzTW9kZWxzW2RpbU5hbWVdLmdldENhdGVnb3JpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHpyVXRpbC5pbmRleE9mKGNhdGVnb3JpZXNbZGltTmFtZV0sIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsIDwgMCAmJiAhaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2Ugc29tZSBvbmUgd3JpdGUgJzEnLCAnMicgaXN0ZWFkIG9mIDEsIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSArdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGxpc3QuaGFzSXRlbU9wdGlvbiA9IGZhbHNlO1xuICAgICAgICBsaXN0LmluaXREYXRhKGRhdGEsIG5hbWVMaXN0LCBkaW1WYWx1ZUdldHRlcik7XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTdGFja2FibGUoYXhpc1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIGF4aXNUeXBlICE9PSAnY2F0ZWdvcnknICYmIGF4aXNUeXBlICE9PSAndGltZSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGltVHlwZUJ5QXhpcyhheGlzVHlwZSkge1xuICAgICAgICByZXR1cm4gYXhpc1R5cGUgPT09ICdjYXRlZ29yeSdcbiAgICAgICAgICAgID8gJ29yZGluYWwnXG4gICAgICAgICAgICA6IGF4aXNUeXBlID09PSAndGltZSdcbiAgICAgICAgICAgID8gJ3RpbWUnXG4gICAgICAgICAgICA6ICdmbG9hdCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcnMgZm9yIGVhY2ggY29vcmQgc3lzdGVtLlxuICAgICAqL1xuICAgIHZhciBjcmVhdG9ycyA9IHtcblxuICAgICAgICBjYXJ0ZXNpYW4yZDogZnVuY3Rpb24gKGRhdGEsIHNlcmllc01vZGVsLCBlY01vZGVsLCBjb21wbGV0ZURpbU9wdCkge1xuXG4gICAgICAgICAgICB2YXIgYXhlc01vZGVscyA9IHpyVXRpbC5tYXAoWyd4QXhpcycsICd5QXhpcyddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgICAgICAgICAgIG1haW5UeXBlOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogc2VyaWVzTW9kZWwuZ2V0KG5hbWUgKyAnSW5kZXgnKSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHNlcmllc01vZGVsLmdldChuYW1lICsgJ0lkJylcbiAgICAgICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHhBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzBdO1xuICAgICAgICAgICAgdmFyIHlBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzFdO1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGlmICgheEF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3hBeGlzIFwiJyArIHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgneEF4aXNJbmRleCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCd4QXhpc0lkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICkgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgheUF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3lBeGlzIFwiJyArIHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgneEF4aXNJbmRleCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCd5QXhpc0lkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICkgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgeEF4aXNUeXBlID0geEF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgICAgIHZhciB5QXhpc1R5cGUgPSB5QXhpc01vZGVsLmdldCgndHlwZScpO1xuXG4gICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZ2V0RGltVHlwZUJ5QXhpcyh4QXhpc1R5cGUpLFxuICAgICAgICAgICAgICAgICAgICBzdGFja2FibGU6IGlzU3RhY2thYmxlKHhBeGlzVHlwZSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3knLFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0d28gY2F0ZWdvcnkgYXhlc1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBnZXREaW1UeXBlQnlBeGlzKHlBeGlzVHlwZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUoeUF4aXNUeXBlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHZhciBpc1hBeGlzQ2F0ZW9ncnkgPSB4QXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgICAgICAgICB2YXIgaXNZQXhpc0NhdGVnb3J5ID0geUF4aXNUeXBlID09PSAnY2F0ZWdvcnknO1xuXG4gICAgICAgICAgICBkaW1lbnNpb25zID0gY29tcGxldGVEaW1lbnNpb25zKGRpbWVuc2lvbnMsIGRhdGEsIGNvbXBsZXRlRGltT3B0KTtcblxuICAgICAgICAgICAgdmFyIGNhdGVnb3J5QXhlc01vZGVscyA9IHt9O1xuICAgICAgICAgICAgaWYgKGlzWEF4aXNDYXRlb2dyeSkge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5QXhlc01vZGVscy54ID0geEF4aXNNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1lBeGlzQ2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUF4ZXNNb2RlbHMueSA9IHlBeGlzTW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlJbmRleDogaXNYQXhpc0NhdGVvZ3J5ID8gMCA6IChpc1lBeGlzQ2F0ZWdvcnkgPyAxIDogLTEpLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5QXhlc01vZGVsczogY2F0ZWdvcnlBeGVzTW9kZWxzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNpbmdsZUF4aXM6IGZ1bmN0aW9uIChkYXRhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgY29tcGxldGVEaW1PcHQpIHtcblxuICAgICAgICAgICAgdmFyIHNpbmdsZUF4aXNNb2RlbCA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgICAgICAgICBtYWluVHlwZTogJ3NpbmdsZUF4aXMnLFxuICAgICAgICAgICAgICAgIGluZGV4OiBzZXJpZXNNb2RlbC5nZXQoJ3NpbmdsZUF4aXNJbmRleCcpLFxuICAgICAgICAgICAgICAgIGlkOiBzZXJpZXNNb2RlbC5nZXQoJ3NpbmdsZUF4aXNJZCcpXG4gICAgICAgICAgICB9KVswXTtcblxuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNpbmdsZUF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbmdsZUF4aXMgc2hvdWxkIGJlIHNwZWNpZmllZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzaW5nbGVBeGlzVHlwZSA9IHNpbmdsZUF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgICAgIHZhciBpc0NhdGVnb3J5ID0gc2luZ2xlQXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG5cbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25zID0gW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnc2luZ2xlJyxcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXREaW1UeXBlQnlBeGlzKHNpbmdsZUF4aXNUeXBlKSxcbiAgICAgICAgICAgICAgICBzdGFja2FibGU6IGlzU3RhY2thYmxlKHNpbmdsZUF4aXNUeXBlKVxuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSBjb21wbGV0ZURpbWVuc2lvbnMoZGltZW5zaW9ucywgZGF0YSwgY29tcGxldGVEaW1PcHQpO1xuXG4gICAgICAgICAgICB2YXIgY2F0ZWdvcnlBeGVzTW9kZWxzID0ge307XG4gICAgICAgICAgICBpZiAoaXNDYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5QXhlc01vZGVscy5zaW5nbGUgPSBzaW5nbGVBeGlzTW9kZWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUluZGV4OiBpc0NhdGVnb3J5ID8gMCA6IC0xLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5QXhlc01vZGVsczogY2F0ZWdvcnlBeGVzTW9kZWxzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBvbGFyOiBmdW5jdGlvbiAoZGF0YSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGNvbXBsZXRlRGltT3B0KSB7XG4gICAgICAgICAgICB2YXIgcG9sYXJNb2RlbCA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgICAgICAgICBtYWluVHlwZTogJ3BvbGFyJyxcbiAgICAgICAgICAgICAgICBpbmRleDogc2VyaWVzTW9kZWwuZ2V0KCdwb2xhckluZGV4JyksXG4gICAgICAgICAgICAgICAgaWQ6IHNlcmllc01vZGVsLmdldCgncG9sYXJJZCcpXG4gICAgICAgICAgICB9KVswXTtcblxuICAgICAgICAgICAgdmFyIGFuZ2xlQXhpc01vZGVsID0gcG9sYXJNb2RlbC5maW5kQXhpc01vZGVsKCdhbmdsZUF4aXMnKTtcbiAgICAgICAgICAgIHZhciByYWRpdXNBeGlzTW9kZWwgPSBwb2xhck1vZGVsLmZpbmRBeGlzTW9kZWwoJ3JhZGl1c0F4aXMnKTtcblxuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFuZ2xlQXhpc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYW5nbGVBeGlzIG9wdGlvbiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyYWRpdXNBeGlzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpdXNBeGlzIG9wdGlvbiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByYWRpdXNBeGlzVHlwZSA9IHJhZGl1c0F4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgICAgIHZhciBhbmdsZUF4aXNUeXBlID0gYW5nbGVBeGlzTW9kZWwuZ2V0KCd0eXBlJyk7XG5cbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25zID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3JhZGl1cycsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGdldERpbVR5cGVCeUF4aXMocmFkaXVzQXhpc1R5cGUpLFxuICAgICAgICAgICAgICAgICAgICBzdGFja2FibGU6IGlzU3RhY2thYmxlKHJhZGl1c0F4aXNUeXBlKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYW5nbGUnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBnZXREaW1UeXBlQnlBeGlzKGFuZ2xlQXhpc1R5cGUpLFxuICAgICAgICAgICAgICAgICAgICBzdGFja2FibGU6IGlzU3RhY2thYmxlKGFuZ2xlQXhpc1R5cGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciBpc0FuZ2xlQXhpc0NhdGVvZ3J5ID0gYW5nbGVBeGlzVHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgICAgICAgICAgIHZhciBpc1JhZGl1c0F4aXNDYXRlb2dyeSA9IHJhZGl1c0F4aXNUeXBlID09PSAnY2F0ZWdvcnknO1xuXG4gICAgICAgICAgICBkaW1lbnNpb25zID0gY29tcGxldGVEaW1lbnNpb25zKGRpbWVuc2lvbnMsIGRhdGEsIGNvbXBsZXRlRGltT3B0KTtcblxuICAgICAgICAgICAgdmFyIGNhdGVnb3J5QXhlc01vZGVscyA9IHt9O1xuICAgICAgICAgICAgaWYgKGlzUmFkaXVzQXhpc0NhdGVvZ3J5KSB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzLnJhZGl1cyA9IHJhZGl1c0F4aXNNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FuZ2xlQXhpc0NhdGVvZ3J5KSB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzLmFuZ2xlID0gYW5nbGVBeGlzTW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlJbmRleDogaXNBbmdsZUF4aXNDYXRlb2dyeSA/IDEgOiAoaXNSYWRpdXNBeGlzQ2F0ZW9ncnkgPyAwIDogLTEpLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5QXhlc01vZGVsczogY2F0ZWdvcnlBeGVzTW9kZWxzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdlbzogZnVuY3Rpb24gKGRhdGEsIHNlcmllc01vZGVsLCBlY01vZGVsLCBjb21wbGV0ZURpbU9wdCkge1xuICAgICAgICAgICAgLy8gVE9ETyBSZWdpb25cbiAgICAgICAgICAgIC8vIOWkmuS4quaVo+eCueWbvuezu+WIl+WcqOWQjOS4gOS4quWcsOWMuueahOaXtuWAmVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiBjb21wbGV0ZURpbWVuc2lvbnMoW1xuICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2xuZyd9LFxuICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2xhdCd9XG4gICAgICAgICAgICAgICAgXSwgZGF0YSwgY29tcGxldGVEaW1PcHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5hbWVMaXN0KHJlc3VsdCwgZGF0YSkge1xuICAgICAgICB2YXIgbmFtZUxpc3QgPSBbXTtcblxuICAgICAgICB2YXIgY2F0ZWdvcnlEaW0gPSByZXN1bHQgJiYgcmVzdWx0LmRpbWVuc2lvbnNbcmVzdWx0LmNhdGVnb3J5SW5kZXhdO1xuICAgICAgICB2YXIgY2F0ZWdvcnlBeGlzTW9kZWw7XG4gICAgICAgIGlmIChjYXRlZ29yeURpbSkge1xuICAgICAgICAgICAgY2F0ZWdvcnlBeGlzTW9kZWwgPSByZXN1bHQuY2F0ZWdvcnlBeGVzTW9kZWxzW2NhdGVnb3J5RGltLm5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhdGVnb3J5QXhpc01vZGVsKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSBUd28gY2F0ZWdvcnkgYXhpc1xuICAgICAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBjYXRlZ29yeUF4aXNNb2RlbC5nZXRDYXRlZ29yaWVzKCk7XG4gICAgICAgICAgICBpZiAoY2F0ZWdvcmllcykge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhTGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gT3JkZXJlZCBkYXRhIGlzIGdpdmVuIGV4cGxpY2l0bHkgbGlrZVxuICAgICAgICAgICAgICAgIC8vIFtbMywgMC4yXSwgWzEsIDAuM10sIFsyLCAwLjE1XV1cbiAgICAgICAgICAgICAgICAvLyBvciBnaXZlbiBzY2F0dGVyIGRhdGEsXG4gICAgICAgICAgICAgICAgLy8gcGljayB0aGUgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXkoZGF0YVswXSkgJiYgZGF0YVswXS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lTGlzdFtpXSA9IGNhdGVnb3JpZXNbZGF0YVtpXVtyZXN1bHQuY2F0ZWdvcnlJbmRleCB8fCAwXV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVMaXN0ID0gY2F0ZWdvcmllcy5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZUxpc3Q7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVMaXN0RnJvbUFycmF5O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL2NyZWF0ZUxpc3RGcm9tQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = __webpack_require__(20);\n    var modelUtil = __webpack_require__(21);\n    var each = zrUtil.each;\n    var isString = zrUtil.isString;\n    var defaults = zrUtil.defaults;\n    var normalizeToArray = modelUtil.normalizeToArray;\n\n    var OTHER_DIMS = {tooltip: 1, label: 1, itemName: 1};\n\n    /**\n     * Complete the dimensions array, by user defined `dimension` and `encode`,\n     * and guessing from the data structure.\n     * If no 'value' dimension specified, the first no-named dimension will be\n     * named as 'value'.\n     *\n     * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which\n     *      provides not only dim template, but also default order.\n     *      `name` of each item provides default coord name.\n     *      [{dimsDef: []}, ...] can be specified to give names.\n     * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].\n     * @param {Object} [opt]\n     * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions\n     *      For example: ['asdf', {name, type}, ...].\n     * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}\n     * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.\n     * @param {string} [opt.extraFromZero] If specified, extra dim names will be:\n     *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...\n     *                      If not specified, extra dim names will be:\n     *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...\n     * @param {number} [opt.dimCount] If not specified, guess by the first data item.\n     * @return {Array.<Object>} [{\n     *      name: string mandatory,\n     *      coordDim: string mandatory,\n     *      coordDimIndex: number mandatory,\n     *      type: string optional,\n     *      tooltipName: string optional,\n     *      otherDims: {\n     *          tooltip: number optional,\n     *          label: number optional\n     *      },\n     *      isExtraCoord: boolean true or undefined.\n     *      other props ...\n     * }]\n     */\n    function completeDimensions(sysDims, data, opt) {\n        data = data || [];\n        opt = opt || {};\n        sysDims = (sysDims || []).slice();\n        var dimsDef = (opt.dimsDef || []).slice();\n        var encodeDef = zrUtil.createHashMap(opt.encodeDef);\n        var dataDimNameMap = zrUtil.createHashMap();\n        var coordDimNameMap = zrUtil.createHashMap();\n        // var valueCandidate;\n        var result = [];\n\n        var dimCount = opt.dimCount;\n        if (dimCount == null) {\n            var value0 = retrieveValue(data[0]);\n            dimCount = Math.max(\n                zrUtil.isArray(value0) && value0.length || 1,\n                sysDims.length,\n                dimsDef.length\n            );\n            each(sysDims, function (sysDimItem) {\n                var sysDimItemDimsDef = sysDimItem.dimsDef;\n                sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));\n            });\n        }\n\n        // Apply user defined dims (`name` and `type`) and init result.\n        for (var i = 0; i < dimCount; i++) {\n            var dimDefItem = isString(dimsDef[i]) ? {name: dimsDef[i]} : (dimsDef[i] || {});\n            var userDimName = dimDefItem.name;\n            var resultItem = result[i] = {otherDims: {}};\n            // Name will be applied later for avoiding duplication.\n            if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n                // Only if `series.dimensions` is defined in option, tooltipName\n                // will be set, and dimension will be diplayed vertically in\n                // tooltip by default.\n                resultItem.name = resultItem.tooltipName = userDimName;\n                dataDimNameMap.set(userDimName, i);\n            }\n            dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n        }\n\n        // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.\n        encodeDef.each(function (dataDims, coordDim) {\n            dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice());\n            each(dataDims, function (resultDimIdx, coordDimIndex) {\n                // The input resultDimIdx can be dim name or index.\n                isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));\n                if (resultDimIdx != null && resultDimIdx < dimCount) {\n                    dataDims[coordDimIndex] = resultDimIdx;\n                    applyDim(result[resultDimIdx], coordDim, coordDimIndex);\n                }\n            });\n        });\n\n        // Apply templetes and default order from `sysDims`.\n        var availDimIdx = 0;\n        each(sysDims, function (sysDimItem, sysDimIndex) {\n            var coordDim;\n            var sysDimItem;\n            var sysDimItemDimsDef;\n            var sysDimItemOtherDims;\n            if (isString(sysDimItem)) {\n                coordDim = sysDimItem;\n                sysDimItem = {};\n            }\n            else {\n                coordDim = sysDimItem.name;\n                sysDimItem = zrUtil.clone(sysDimItem);\n                // `coordDimIndex` should not be set directly.\n                sysDimItemDimsDef = sysDimItem.dimsDef;\n                sysDimItemOtherDims = sysDimItem.otherDims;\n                sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex\n                    = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n            }\n\n            var dataDims = normalizeToArray(encodeDef.get(coordDim));\n            // dimensions provides default dim sequences.\n            if (!dataDims.length) {\n                for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n                    while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n                        availDimIdx++;\n                    }\n                    availDimIdx < result.length && dataDims.push(availDimIdx++);\n                }\n            }\n            // Apply templates.\n            each(dataDims, function (resultDimIdx, coordDimIndex) {\n                var resultItem = result[resultDimIdx];\n                applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n                if (resultItem.name == null && sysDimItemDimsDef) {\n                    resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];\n                }\n                sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n            });\n        });\n\n        // Make sure the first extra dim is 'value'.\n        var extra = opt.extraPrefix || 'value';\n\n        // Set dim `name` and other `coordDim` and other props.\n        for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n            var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};\n            var coordDim = resultItem.coordDim;\n\n            coordDim == null && (\n                resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero),\n                resultItem.coordDimIndex = 0,\n                resultItem.isExtraCoord = true\n            );\n\n            resultItem.name == null && (resultItem.name = genName(\n                resultItem.coordDim,\n                dataDimNameMap\n            ));\n\n            resultItem.type == null && guessOrdinal(data, resultDimIdx)\n                && (resultItem.type = 'ordinal');\n        }\n\n        return result;\n\n        function applyDim(resultItem, coordDim, coordDimIndex) {\n            if (OTHER_DIMS[coordDim]) {\n                resultItem.otherDims[coordDim] = coordDimIndex;\n            }\n            else {\n                resultItem.coordDim = coordDim;\n                resultItem.coordDimIndex = coordDimIndex;\n                coordDimNameMap.set(coordDim, true);\n            }\n        }\n\n        function genName(name, map, fromZero) {\n            if (fromZero || map.get(name) != null) {\n                var i = 0;\n                while (map.get(name + i) != null) {\n                    i++;\n                }\n                name += i;\n            }\n            map.set(name, true);\n            return name;\n        }\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            // Consider usage convenience, '1', '2' will be treated as \"number\".\n            if (value != null && isFinite(value)) {\n                return false;\n            }\n            else if (isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9ucy5qcz85YzllIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLHNCQUFzQjtBQUNyQyxtQ0FBbUMsV0FBVztBQUM5QyxlQUFlLE9BQU8sdUNBQXVDO0FBQzdELGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSx1QkFBdUIsY0FBYztBQUNyQyxxREFBcUQsaUJBQWlCLG9CQUFvQjtBQUMxRjtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBEQUEwRDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjEyNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29tcGxldGUgZGltZW5zaW9ucyBieSBkYXRhIChndWVzcyBkaW1lbnNpb24pLlxuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG4gICAgdmFyIGlzU3RyaW5nID0genJVdGlsLmlzU3RyaW5nO1xuICAgIHZhciBkZWZhdWx0cyA9IHpyVXRpbC5kZWZhdWx0cztcbiAgICB2YXIgbm9ybWFsaXplVG9BcnJheSA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5O1xuXG4gICAgdmFyIE9USEVSX0RJTVMgPSB7dG9vbHRpcDogMSwgbGFiZWw6IDEsIGl0ZW1OYW1lOiAxfTtcblxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIHRoZSBkaW1lbnNpb25zIGFycmF5LCBieSB1c2VyIGRlZmluZWQgYGRpbWVuc2lvbmAgYW5kIGBlbmNvZGVgLFxuICAgICAqIGFuZCBndWVzc2luZyBmcm9tIHRoZSBkYXRhIHN0cnVjdHVyZS5cbiAgICAgKiBJZiBubyAndmFsdWUnIGRpbWVuc2lvbiBzcGVjaWZpZWQsIHRoZSBmaXJzdCBuby1uYW1lZCBkaW1lbnNpb24gd2lsbCBiZVxuICAgICAqIG5hbWVkIGFzICd2YWx1ZScuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBzeXNEaW1zIE5lY2Vzc2FyeSBkaW1lbnNpb25zLCBsaWtlIFsneCcsICd5J10sIHdoaWNoXG4gICAgICogICAgICBwcm92aWRlcyBub3Qgb25seSBkaW0gdGVtcGxhdGUsIGJ1dCBhbHNvIGRlZmF1bHQgb3JkZXIuXG4gICAgICogICAgICBgbmFtZWAgb2YgZWFjaCBpdGVtIHByb3ZpZGVzIGRlZmF1bHQgY29vcmQgbmFtZS5cbiAgICAgKiAgICAgIFt7ZGltc0RlZjogW119LCAuLi5dIGNhbiBiZSBzcGVjaWZpZWQgdG8gZ2l2ZSBuYW1lcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIERhdGEgbGlzdC4gW1sxLCAyLCAzXSwgWzIsIDMsIDRdXS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3R8c3RyaW5nPn0gW29wdC5kaW1zRGVmXSBvcHRpb24uc2VyaWVzLmRpbWVuc2lvbnMgVXNlciBkZWZpbmVkIGRpbWVuc2lvbnNcbiAgICAgKiAgICAgIEZvciBleGFtcGxlOiBbJ2FzZGYnLCB7bmFtZSwgdHlwZX0sIC4uLl0uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHQuZW5jb2RlRGVmXSBvcHRpb24uc2VyaWVzLmVuY29kZSB7eDogMiwgeTogWzMsIDFdLCB0b29sdGlwOiBbMSwgMl0sIGxhYmVsOiAzfVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LmV4dHJhUHJlZml4XSBQcmVmaXggb2YgbmFtZSB3aGVuIGZpbGxpbmcgdGhlIGxlZnQgZGltZW5zaW9ucy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdC5leHRyYUZyb21aZXJvXSBJZiBzcGVjaWZpZWQsIGV4dHJhIGRpbSBuYW1lcyB3aWxsIGJlOlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGV4dHJhUHJlZml4ICsgMCwgZXh0cmFQcmVmaXggKyBleHRyYUJhc2VJbmRleCArIDEgLi4uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgSWYgbm90IHNwZWNpZmllZCwgZXh0cmEgZGltIG5hbWVzIHdpbGwgYmU6XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgZXh0cmFQcmVmaXgsIGV4dHJhUHJlZml4ICsgMCwgZXh0cmFQcmVmaXggKyAxIC4uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmRpbUNvdW50XSBJZiBub3Qgc3BlY2lmaWVkLCBndWVzcyBieSB0aGUgZmlyc3QgZGF0YSBpdGVtLlxuICAgICAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fSBbe1xuICAgICAqICAgICAgbmFtZTogc3RyaW5nIG1hbmRhdG9yeSxcbiAgICAgKiAgICAgIGNvb3JkRGltOiBzdHJpbmcgbWFuZGF0b3J5LFxuICAgICAqICAgICAgY29vcmREaW1JbmRleDogbnVtYmVyIG1hbmRhdG9yeSxcbiAgICAgKiAgICAgIHR5cGU6IHN0cmluZyBvcHRpb25hbCxcbiAgICAgKiAgICAgIHRvb2x0aXBOYW1lOiBzdHJpbmcgb3B0aW9uYWwsXG4gICAgICogICAgICBvdGhlckRpbXM6IHtcbiAgICAgKiAgICAgICAgICB0b29sdGlwOiBudW1iZXIgb3B0aW9uYWwsXG4gICAgICogICAgICAgICAgbGFiZWw6IG51bWJlciBvcHRpb25hbFxuICAgICAqICAgICAgfSxcbiAgICAgKiAgICAgIGlzRXh0cmFDb29yZDogYm9vbGVhbiB0cnVlIG9yIHVuZGVmaW5lZC5cbiAgICAgKiAgICAgIG90aGVyIHByb3BzIC4uLlxuICAgICAqIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGxldGVEaW1lbnNpb25zKHN5c0RpbXMsIGRhdGEsIG9wdCkge1xuICAgICAgICBkYXRhID0gZGF0YSB8fCBbXTtcbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICBzeXNEaW1zID0gKHN5c0RpbXMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIHZhciBkaW1zRGVmID0gKG9wdC5kaW1zRGVmIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICB2YXIgZW5jb2RlRGVmID0genJVdGlsLmNyZWF0ZUhhc2hNYXAob3B0LmVuY29kZURlZik7XG4gICAgICAgIHZhciBkYXRhRGltTmFtZU1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gICAgICAgIHZhciBjb29yZERpbU5hbWVNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICAgICAgICAvLyB2YXIgdmFsdWVDYW5kaWRhdGU7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICB2YXIgZGltQ291bnQgPSBvcHQuZGltQ291bnQ7XG4gICAgICAgIGlmIChkaW1Db3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUwID0gcmV0cmlldmVWYWx1ZShkYXRhWzBdKTtcbiAgICAgICAgICAgIGRpbUNvdW50ID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgenJVdGlsLmlzQXJyYXkodmFsdWUwKSAmJiB2YWx1ZTAubGVuZ3RoIHx8IDEsXG4gICAgICAgICAgICAgICAgc3lzRGltcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgZGltc0RlZi5sZW5ndGhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlYWNoKHN5c0RpbXMsIGZ1bmN0aW9uIChzeXNEaW1JdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN5c0RpbUl0ZW1EaW1zRGVmID0gc3lzRGltSXRlbS5kaW1zRGVmO1xuICAgICAgICAgICAgICAgIHN5c0RpbUl0ZW1EaW1zRGVmICYmIChkaW1Db3VudCA9IE1hdGgubWF4KGRpbUNvdW50LCBzeXNEaW1JdGVtRGltc0RlZi5sZW5ndGgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgdXNlciBkZWZpbmVkIGRpbXMgKGBuYW1lYCBhbmQgYHR5cGVgKSBhbmQgaW5pdCByZXN1bHQuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpbURlZkl0ZW0gPSBpc1N0cmluZyhkaW1zRGVmW2ldKSA/IHtuYW1lOiBkaW1zRGVmW2ldfSA6IChkaW1zRGVmW2ldIHx8IHt9KTtcbiAgICAgICAgICAgIHZhciB1c2VyRGltTmFtZSA9IGRpbURlZkl0ZW0ubmFtZTtcbiAgICAgICAgICAgIHZhciByZXN1bHRJdGVtID0gcmVzdWx0W2ldID0ge290aGVyRGltczoge319O1xuICAgICAgICAgICAgLy8gTmFtZSB3aWxsIGJlIGFwcGxpZWQgbGF0ZXIgZm9yIGF2b2lkaW5nIGR1cGxpY2F0aW9uLlxuICAgICAgICAgICAgaWYgKHVzZXJEaW1OYW1lICE9IG51bGwgJiYgZGF0YURpbU5hbWVNYXAuZ2V0KHVzZXJEaW1OYW1lKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBpZiBgc2VyaWVzLmRpbWVuc2lvbnNgIGlzIGRlZmluZWQgaW4gb3B0aW9uLCB0b29sdGlwTmFtZVxuICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgc2V0LCBhbmQgZGltZW5zaW9uIHdpbGwgYmUgZGlwbGF5ZWQgdmVydGljYWxseSBpblxuICAgICAgICAgICAgICAgIC8vIHRvb2x0aXAgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICByZXN1bHRJdGVtLm5hbWUgPSByZXN1bHRJdGVtLnRvb2x0aXBOYW1lID0gdXNlckRpbU5hbWU7XG4gICAgICAgICAgICAgICAgZGF0YURpbU5hbWVNYXAuc2V0KHVzZXJEaW1OYW1lLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpbURlZkl0ZW0udHlwZSAhPSBudWxsICYmIChyZXN1bHRJdGVtLnR5cGUgPSBkaW1EZWZJdGVtLnR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IGBjb29yZERpbWAgYW5kIGBjb29yZERpbUluZGV4YCBieSBgZW5jb2RlRGVmYCBhbmQgbm9ybWFsaXplIGBlbmNvZGVEZWZgLlxuICAgICAgICBlbmNvZGVEZWYuZWFjaChmdW5jdGlvbiAoZGF0YURpbXMsIGNvb3JkRGltKSB7XG4gICAgICAgICAgICBkYXRhRGltcyA9IGVuY29kZURlZi5zZXQoY29vcmREaW0sIG5vcm1hbGl6ZVRvQXJyYXkoZGF0YURpbXMpLnNsaWNlKCkpO1xuICAgICAgICAgICAgZWFjaChkYXRhRGltcywgZnVuY3Rpb24gKHJlc3VsdERpbUlkeCwgY29vcmREaW1JbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBpbnB1dCByZXN1bHREaW1JZHggY2FuIGJlIGRpbSBuYW1lIG9yIGluZGV4LlxuICAgICAgICAgICAgICAgIGlzU3RyaW5nKHJlc3VsdERpbUlkeCkgJiYgKHJlc3VsdERpbUlkeCA9IGRhdGFEaW1OYW1lTWFwLmdldChyZXN1bHREaW1JZHgpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0RGltSWR4ICE9IG51bGwgJiYgcmVzdWx0RGltSWR4IDwgZGltQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YURpbXNbY29vcmREaW1JbmRleF0gPSByZXN1bHREaW1JZHg7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5RGltKHJlc3VsdFtyZXN1bHREaW1JZHhdLCBjb29yZERpbSwgY29vcmREaW1JbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFwcGx5IHRlbXBsZXRlcyBhbmQgZGVmYXVsdCBvcmRlciBmcm9tIGBzeXNEaW1zYC5cbiAgICAgICAgdmFyIGF2YWlsRGltSWR4ID0gMDtcbiAgICAgICAgZWFjaChzeXNEaW1zLCBmdW5jdGlvbiAoc3lzRGltSXRlbSwgc3lzRGltSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjb29yZERpbTtcbiAgICAgICAgICAgIHZhciBzeXNEaW1JdGVtO1xuICAgICAgICAgICAgdmFyIHN5c0RpbUl0ZW1EaW1zRGVmO1xuICAgICAgICAgICAgdmFyIHN5c0RpbUl0ZW1PdGhlckRpbXM7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoc3lzRGltSXRlbSkpIHtcbiAgICAgICAgICAgICAgICBjb29yZERpbSA9IHN5c0RpbUl0ZW07XG4gICAgICAgICAgICAgICAgc3lzRGltSXRlbSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29vcmREaW0gPSBzeXNEaW1JdGVtLm5hbWU7XG4gICAgICAgICAgICAgICAgc3lzRGltSXRlbSA9IHpyVXRpbC5jbG9uZShzeXNEaW1JdGVtKTtcbiAgICAgICAgICAgICAgICAvLyBgY29vcmREaW1JbmRleGAgc2hvdWxkIG5vdCBiZSBzZXQgZGlyZWN0bHkuXG4gICAgICAgICAgICAgICAgc3lzRGltSXRlbURpbXNEZWYgPSBzeXNEaW1JdGVtLmRpbXNEZWY7XG4gICAgICAgICAgICAgICAgc3lzRGltSXRlbU90aGVyRGltcyA9IHN5c0RpbUl0ZW0ub3RoZXJEaW1zO1xuICAgICAgICAgICAgICAgIHN5c0RpbUl0ZW0ubmFtZSA9IHN5c0RpbUl0ZW0uY29vcmREaW0gPSBzeXNEaW1JdGVtLmNvb3JkRGltSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgPSBzeXNEaW1JdGVtLmRpbXNEZWYgPSBzeXNEaW1JdGVtLm90aGVyRGltcyA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYXRhRGltcyA9IG5vcm1hbGl6ZVRvQXJyYXkoZW5jb2RlRGVmLmdldChjb29yZERpbSkpO1xuICAgICAgICAgICAgLy8gZGltZW5zaW9ucyBwcm92aWRlcyBkZWZhdWx0IGRpbSBzZXF1ZW5jZXMuXG4gICAgICAgICAgICBpZiAoIWRhdGFEaW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKHN5c0RpbUl0ZW1EaW1zRGVmICYmIHN5c0RpbUl0ZW1EaW1zRGVmLmxlbmd0aCB8fCAxKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChhdmFpbERpbUlkeCA8IHJlc3VsdC5sZW5ndGggJiYgcmVzdWx0W2F2YWlsRGltSWR4XS5jb29yZERpbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdmFpbERpbUlkeCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsRGltSWR4IDwgcmVzdWx0Lmxlbmd0aCAmJiBkYXRhRGltcy5wdXNoKGF2YWlsRGltSWR4KyspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFwcGx5IHRlbXBsYXRlcy5cbiAgICAgICAgICAgIGVhY2goZGF0YURpbXMsIGZ1bmN0aW9uIChyZXN1bHREaW1JZHgsIGNvb3JkRGltSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0SXRlbSA9IHJlc3VsdFtyZXN1bHREaW1JZHhdO1xuICAgICAgICAgICAgICAgIGFwcGx5RGltKGRlZmF1bHRzKHJlc3VsdEl0ZW0sIHN5c0RpbUl0ZW0pLCBjb29yZERpbSwgY29vcmREaW1JbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdEl0ZW0ubmFtZSA9PSBudWxsICYmIHN5c0RpbUl0ZW1EaW1zRGVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEl0ZW0ubmFtZSA9IHJlc3VsdEl0ZW0udG9vbHRpcE5hbWUgPSBzeXNEaW1JdGVtRGltc0RlZltjb29yZERpbUluZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3lzRGltSXRlbU90aGVyRGltcyAmJiBkZWZhdWx0cyhyZXN1bHRJdGVtLm90aGVyRGltcywgc3lzRGltSXRlbU90aGVyRGltcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBmaXJzdCBleHRyYSBkaW0gaXMgJ3ZhbHVlJy5cbiAgICAgICAgdmFyIGV4dHJhID0gb3B0LmV4dHJhUHJlZml4IHx8ICd2YWx1ZSc7XG5cbiAgICAgICAgLy8gU2V0IGRpbSBgbmFtZWAgYW5kIG90aGVyIGBjb29yZERpbWAgYW5kIG90aGVyIHByb3BzLlxuICAgICAgICBmb3IgKHZhciByZXN1bHREaW1JZHggPSAwOyByZXN1bHREaW1JZHggPCBkaW1Db3VudDsgcmVzdWx0RGltSWR4KyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRJdGVtID0gcmVzdWx0W3Jlc3VsdERpbUlkeF0gPSByZXN1bHRbcmVzdWx0RGltSWR4XSB8fCB7fTtcbiAgICAgICAgICAgIHZhciBjb29yZERpbSA9IHJlc3VsdEl0ZW0uY29vcmREaW07XG5cbiAgICAgICAgICAgIGNvb3JkRGltID09IG51bGwgJiYgKFxuICAgICAgICAgICAgICAgIHJlc3VsdEl0ZW0uY29vcmREaW0gPSBnZW5OYW1lKGV4dHJhLCBjb29yZERpbU5hbWVNYXAsIG9wdC5leHRyYUZyb21aZXJvKSxcbiAgICAgICAgICAgICAgICByZXN1bHRJdGVtLmNvb3JkRGltSW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIHJlc3VsdEl0ZW0uaXNFeHRyYUNvb3JkID0gdHJ1ZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmVzdWx0SXRlbS5uYW1lID09IG51bGwgJiYgKHJlc3VsdEl0ZW0ubmFtZSA9IGdlbk5hbWUoXG4gICAgICAgICAgICAgICAgcmVzdWx0SXRlbS5jb29yZERpbSxcbiAgICAgICAgICAgICAgICBkYXRhRGltTmFtZU1hcFxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIHJlc3VsdEl0ZW0udHlwZSA9PSBudWxsICYmIGd1ZXNzT3JkaW5hbChkYXRhLCByZXN1bHREaW1JZHgpXG4gICAgICAgICAgICAgICAgJiYgKHJlc3VsdEl0ZW0udHlwZSA9ICdvcmRpbmFsJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5RGltKHJlc3VsdEl0ZW0sIGNvb3JkRGltLCBjb29yZERpbUluZGV4KSB7XG4gICAgICAgICAgICBpZiAoT1RIRVJfRElNU1tjb29yZERpbV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRJdGVtLm90aGVyRGltc1tjb29yZERpbV0gPSBjb29yZERpbUluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0SXRlbS5jb29yZERpbSA9IGNvb3JkRGltO1xuICAgICAgICAgICAgICAgIHJlc3VsdEl0ZW0uY29vcmREaW1JbmRleCA9IGNvb3JkRGltSW5kZXg7XG4gICAgICAgICAgICAgICAgY29vcmREaW1OYW1lTWFwLnNldChjb29yZERpbSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZW5OYW1lKG5hbWUsIG1hcCwgZnJvbVplcm8pIHtcbiAgICAgICAgICAgIGlmIChmcm9tWmVybyB8fCBtYXAuZ2V0KG5hbWUpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG1hcC5nZXQobmFtZSArIGkpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuYW1lICs9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXAuc2V0KG5hbWUsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgcnVsZSBzaG91bGQgbm90IGJlIGNvbXBsZXgsIG90aGVyd2lzZSB1c2VyIG1pZ2h0IG5vdFxuICAgIC8vIGJlIGFibGUgdG8ga25vd24gd2hlcmUgdGhlIGRhdGEgaXMgd3JvbmcuXG4gICAgdmFyIGd1ZXNzT3JkaW5hbCA9IGNvbXBsZXRlRGltZW5zaW9ucy5ndWVzc09yZGluYWwgPSBmdW5jdGlvbiAoZGF0YSwgZGltSW5kZXgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJldHJpZXZlVmFsdWUoZGF0YVtpXSk7XG5cbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZVtkaW1JbmRleF07XG4gICAgICAgICAgICAvLyBDb25zaWRlciB1c2FnZSBjb252ZW5pZW5jZSwgJzEnLCAnMicgd2lsbCBiZSB0cmVhdGVkIGFzIFwibnVtYmVyXCIuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUgIT09ICctJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmV0cmlldmVWYWx1ZShvKSB7XG4gICAgICAgIHJldHVybiB6clV0aWwuaXNBcnJheShvKSA/IG8gOiB6clV0aWwuaXNPYmplY3QobykgPyBvLnZhbHVlOiBvO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY29tcGxldGVEaW1lbnNpb25zO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n// Symbol factory\n\n\n    var graphic = __webpack_require__(34);\n    var BoundingRect = __webpack_require__(25);\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            // TODO Support image object, DynamicImage.\n\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3V0aWwvc3ltYm9sLmpzP2JlMmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjEyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIFN5bWJvbCBmYWN0b3J5XG5cblxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi9ncmFwaGljJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBUcmlhbmdsZSBzaGFwZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBUcmlhbmdsZSA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xuICAgICAgICB0eXBlOiAndHJpYW5nbGUnLFxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgY3ggPSBzaGFwZS5jeDtcbiAgICAgICAgICAgIHZhciBjeSA9IHNoYXBlLmN5O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodCAvIDI7XG4gICAgICAgICAgICBwYXRoLm1vdmVUbyhjeCwgY3kgLSBoZWlnaHQpO1xuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kgKyBoZWlnaHQpO1xuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggLSB3aWR0aCwgY3kgKyBoZWlnaHQpO1xuICAgICAgICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIERpYW1vbmQgc2hhcGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgRGlhbW9uZCA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xuICAgICAgICB0eXBlOiAnZGlhbW9uZCcsXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBjeDogMCxcbiAgICAgICAgICAgIGN5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBjeCA9IHNoYXBlLmN4O1xuICAgICAgICAgICAgdmFyIGN5ID0gc2hhcGUuY3k7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aCAvIDI7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIHBhdGgubW92ZVRvKGN4LCBjeSAtIGhlaWdodCk7XG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCArIHdpZHRoLCBjeSk7XG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCwgY3kgKyBoZWlnaHQpO1xuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggLSB3aWR0aCwgY3kpO1xuICAgICAgICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUGluIHNoYXBlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIFBpbiA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xuICAgICAgICB0eXBlOiAncGluJyxcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIC8vIHgsIHkgb24gdGhlIGN1c3BcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55O1xuICAgICAgICAgICAgdmFyIHcgPSBzaGFwZS53aWR0aCAvIDUgKiAzO1xuICAgICAgICAgICAgLy8gSGVpZ2h0IG11c3QgYmUgbGFyZ2VyIHRoYW4gd2lkdGhcbiAgICAgICAgICAgIHZhciBoID0gTWF0aC5tYXgodywgc2hhcGUuaGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciByID0gdyAvIDI7XG5cbiAgICAgICAgICAgIC8vIERpc3Qgb24geSB3aXRoIHRhbmdlbnQgcG9pbnQgYW5kIGNpcmNsZSBjZW50ZXJcbiAgICAgICAgICAgIHZhciBkeSA9IHIgKiByIC8gKGggLSByKTtcbiAgICAgICAgICAgIHZhciBjeSA9IHkgLSBoICsgciArIGR5O1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hc2luKGR5IC8gcik7XG4gICAgICAgICAgICAvLyBEaXN0IG9uIHggd2l0aCB0YW5nZW50IHBvaW50IGFuZCBjaXJjbGUgY2VudGVyXG4gICAgICAgICAgICB2YXIgZHggPSBNYXRoLmNvcyhhbmdsZSkgKiByO1xuXG4gICAgICAgICAgICB2YXIgdGFuWCA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgICAgIHZhciB0YW5ZID0gTWF0aC5jb3MoYW5nbGUpO1xuXG4gICAgICAgICAgICBwYXRoLmFyYyhcbiAgICAgICAgICAgICAgICB4LCBjeSwgcixcbiAgICAgICAgICAgICAgICBNYXRoLlBJIC0gYW5nbGUsXG4gICAgICAgICAgICAgICAgTWF0aC5QSSAqIDIgKyBhbmdsZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdmFyIGNwTGVuID0gciAqIDAuNjtcbiAgICAgICAgICAgIHZhciBjcExlbjIgPSByICogMC43O1xuICAgICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHggKyBkeCAtIHRhblggKiBjcExlbiwgY3kgKyBkeSArIHRhblkgKiBjcExlbixcbiAgICAgICAgICAgICAgICB4LCB5IC0gY3BMZW4yLFxuICAgICAgICAgICAgICAgIHgsIHlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgICAgeCwgeSAtIGNwTGVuMixcbiAgICAgICAgICAgICAgICB4IC0gZHggKyB0YW5YICogY3BMZW4sIGN5ICsgZHkgKyB0YW5ZICogY3BMZW4sXG4gICAgICAgICAgICAgICAgeCAtIGR4LCBjeSArIGR5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQXJyb3cgc2hhcGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgQXJyb3cgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcblxuICAgICAgICB0eXBlOiAnYXJyb3cnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55O1xuICAgICAgICAgICAgdmFyIGR4ID0gd2lkdGggLyAzICogMjtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBkeCwgeSArIGhlaWdodCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkgKyBoZWlnaHQgLyA0ICogMyk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggLSBkeCwgeSArIGhlaWdodCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBNYXAgb2YgcGF0aCBjb250cnVjdG9yc1xuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoPn1cbiAgICAgKi9cbiAgICB2YXIgc3ltYm9sQ3RvcnMgPSB7XG4gICAgICAgIGxpbmU6IGdyYXBoaWMuTGluZSxcblxuICAgICAgICByZWN0OiBncmFwaGljLlJlY3QsXG5cbiAgICAgICAgcm91bmRSZWN0OiBncmFwaGljLlJlY3QsXG5cbiAgICAgICAgc3F1YXJlOiBncmFwaGljLlJlY3QsXG5cbiAgICAgICAgY2lyY2xlOiBncmFwaGljLkNpcmNsZSxcblxuICAgICAgICBkaWFtb25kOiBEaWFtb25kLFxuXG4gICAgICAgIHBpbjogUGluLFxuXG4gICAgICAgIGFycm93OiBBcnJvdyxcblxuICAgICAgICB0cmlhbmdsZTogVHJpYW5nbGVcbiAgICB9O1xuXG4gICAgdmFyIHN5bWJvbFNoYXBlTWFrZXJzID0ge1xuXG4gICAgICAgIGxpbmU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIHNoYXBlLngxID0geDtcbiAgICAgICAgICAgIHNoYXBlLnkxID0geSArIGggLyAyO1xuICAgICAgICAgICAgc2hhcGUueDIgPSB4ICsgdztcbiAgICAgICAgICAgIHNoYXBlLnkyID0geSArIGggLyAyO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgICAgICAgICAgc2hhcGUueCA9IHg7XG4gICAgICAgICAgICBzaGFwZS55ID0geTtcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcm91bmRSZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xuICAgICAgICAgICAgc2hhcGUueSA9IHk7XG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xuICAgICAgICAgICAgc2hhcGUuciA9IE1hdGgubWluKHcsIGgpIC8gNDtcbiAgICAgICAgfSxcblxuICAgICAgICBzcXVhcmU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbih3LCBoKTtcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xuICAgICAgICAgICAgc2hhcGUueSA9IHk7XG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHNpemU7XG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBzaXplO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNpcmNsZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgICAgICAgICAvLyBQdXQgY2lyY2xlIGluIHRoZSBjZW50ZXIgb2Ygc3F1YXJlXG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgc2hhcGUuciA9IE1hdGgubWluKHcsIGgpIC8gMjtcbiAgICAgICAgfSxcblxuICAgICAgICBkaWFtb25kOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHNoYXBlLmN4ID0geCArIHcgLyAyO1xuICAgICAgICAgICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBpbjogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgICAgICAgICBzaGFwZS54ID0geCArIHcgLyAyO1xuICAgICAgICAgICAgc2hhcGUueSA9IHkgKyBoIC8gMjtcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXJyb3c6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgICAgICAgICAgc2hhcGUueCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5ICsgaCAvIDI7XG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyaWFuZ2xlOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHNoYXBlLmN4ID0geCArIHcgLyAyO1xuICAgICAgICAgICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzeW1ib2xCdWlsZFByb3hpZXMgPSB7fTtcbiAgICBmb3IgKHZhciBuYW1lIGluIHN5bWJvbEN0b3JzKSB7XG4gICAgICAgIGlmIChzeW1ib2xDdG9ycy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgc3ltYm9sQnVpbGRQcm94aWVzW25hbWVdID0gbmV3IHN5bWJvbEN0b3JzW25hbWVdKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgU3ltYm9sID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XG5cbiAgICAgICAgdHlwZTogJ3N5bWJvbCcsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHN5bWJvbFR5cGU6ICcnLFxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LFxuXG4gICAgICAgIGJlZm9yZUJydXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBpZiAoc2hhcGUuc3ltYm9sVHlwZSA9PT0gJ3BpbicgJiYgc3R5bGUudGV4dFBvc2l0aW9uID09PSAnaW5zaWRlJykge1xuICAgICAgICAgICAgICAgIHN0eWxlLnRleHRQb3NpdGlvbiA9IFsnNTAlJywgJzQwJSddO1xuICAgICAgICAgICAgICAgIHN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSwgaW5CdW5kbGUpIHtcbiAgICAgICAgICAgIHZhciBzeW1ib2xUeXBlID0gc2hhcGUuc3ltYm9sVHlwZTtcbiAgICAgICAgICAgIHZhciBwcm94eVN5bWJvbCA9IHN5bWJvbEJ1aWxkUHJveGllc1tzeW1ib2xUeXBlXTtcbiAgICAgICAgICAgIGlmIChzaGFwZS5zeW1ib2xUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3h5U3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgcmVjdFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2xUeXBlID0gJ3JlY3QnO1xuICAgICAgICAgICAgICAgICAgICBwcm94eVN5bWJvbCA9IHN5bWJvbEJ1aWxkUHJveGllc1tzeW1ib2xUeXBlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ltYm9sU2hhcGVNYWtlcnNbc3ltYm9sVHlwZV0oXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlLngsIHNoYXBlLnksIHNoYXBlLndpZHRoLCBzaGFwZS5oZWlnaHQsIHByb3h5U3ltYm9sLnNoYXBlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwcm94eVN5bWJvbC5idWlsZFBhdGgoY3R4LCBwcm94eVN5bWJvbC5zaGFwZSwgaW5CdW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBQcm92aWRlIHNldENvbG9yIGhlbHBlciBtZXRob2QgdG8gYXZvaWQgZGV0ZXJtaW5lIGlmIHNldCB0aGUgZmlsbCBvciBzdHJva2Ugb3V0c2lkZVxuICAgIHZhciBzeW1ib2xQYXRoU2V0Q29sb3IgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ2ltYWdlJykge1xuICAgICAgICAgICAgdmFyIHN5bWJvbFN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBzeW1ib2xTaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgICAgICBpZiAoc3ltYm9sU2hhcGUgJiYgc3ltYm9sU2hhcGUuc3ltYm9sVHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9faXNFbXB0eUJydXNoKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuZmlsbCA9ICcjZmZmJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIOWIpOaWreWbvuW9oum7mOiupOaYr+Whq+WFhei/mOaYr+aPj+i+ue+8jOS9v+eUqCBvbmx5U3Ryb2tlID9cbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5maWxsICYmIChzeW1ib2xTdHlsZS5maWxsID0gY29sb3IpO1xuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSAmJiAoc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN5bWJvbFV0aWwgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBzeW1ib2wgZWxlbWVudCB3aXRoIGdpdmVuIHN5bWJvbCBjb25maWd1cmF0aW9uOiBzaGFwZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbFR5cGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTeW1ib2w6IGZ1bmN0aW9uIChzeW1ib2xUeXBlLCB4LCB5LCB3LCBoLCBjb2xvcikge1xuICAgICAgICAgICAgLy8gVE9ETyBTdXBwb3J0IGltYWdlIG9iamVjdCwgRHluYW1pY0ltYWdlLlxuXG4gICAgICAgICAgICB2YXIgaXNFbXB0eSA9IHN5bWJvbFR5cGUuaW5kZXhPZignZW1wdHknKSA9PT0gMDtcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sVHlwZSA9IHN5bWJvbFR5cGUuc3Vic3RyKDUsIDEpLnRvTG93ZXJDYXNlKCkgKyBzeW1ib2xUeXBlLnN1YnN0cig2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzeW1ib2xQYXRoO1xuXG4gICAgICAgICAgICBpZiAoc3ltYm9sVHlwZS5pbmRleE9mKCdpbWFnZTovLycpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sUGF0aCA9IG5ldyBncmFwaGljLkltYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBzeW1ib2xUeXBlLnNsaWNlKDgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzeW1ib2xUeXBlLmluZGV4T2YoJ3BhdGg6Ly8nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN5bWJvbFBhdGggPSBncmFwaGljLm1ha2VQYXRoKHN5bWJvbFR5cGUuc2xpY2UoNyksIHt9LCBuZXcgQm91bmRpbmdSZWN0KHgsIHksIHcsIGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bWJvbFBhdGggPSBuZXcgU3ltYm9sKHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbFR5cGU6IHN5bWJvbFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3ltYm9sUGF0aC5fX2lzRW1wdHlCcnVzaCA9IGlzRW1wdHk7XG5cbiAgICAgICAgICAgIHN5bWJvbFBhdGguc2V0Q29sb3IgPSBzeW1ib2xQYXRoU2V0Q29sb3I7XG5cbiAgICAgICAgICAgIHN5bWJvbFBhdGguc2V0Q29sb3IoY29sb3IpO1xuXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sUGF0aDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHN5bWJvbFV0aWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvdXRpbC9zeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n    var axisHelper = __webpack_require__(117);\n\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        }\n        else {\n            return obj + '';\n        }\n    }\n\n    module.exports = {\n\n        /**\n         * Format labels\n         * @return {Array.<string>}\n         */\n        getFormattedLabels: function () {\n            return axisHelper.getFormattedLabels(\n                this.axis,\n                this.get('axisLabel.formatter')\n            );\n        },\n\n        /**\n         * Get categories\n         */\n        getCategories: function () {\n            return this.get('type') === 'category'\n                && zrUtil.map(this.get('data'), getName);\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n         */\n        getMin: function (origin) {\n            var option = this.option;\n            var min = (!origin && option.rangeStart != null)\n                ? option.rangeStart : option.min;\n\n            if (this.axis && min != null && min !== 'dataMin' && !zrUtil.eqNaN(min)) {\n                min = this.axis.scale.parse(min);\n            }\n            return min;\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n         */\n        getMax: function (origin) {\n            var option = this.option;\n            var max = (!origin && option.rangeEnd != null)\n                ? option.rangeEnd : option.max;\n\n            if (this.axis && max != null && max !== 'dataMax' && !zrUtil.eqNaN(max)) {\n                max = this.axis.scale.parse(max);\n            }\n            return max;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        getNeedCrossZero: function () {\n            var option = this.option;\n            return (option.rangeStart != null || option.rangeEnd != null)\n                ? false : !option.scale;\n        },\n\n        /**\n         * Should be implemented by each axis model if necessary.\n         * @return {module:echarts/model/Component} coordinate system model\n         */\n        getCoordSysModel: zrUtil.noop,\n\n        /**\n         * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n         * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n         */\n        setRange: function (rangeStart, rangeEnd) {\n            this.option.rangeStart = rangeStart;\n            this.option.rangeEnd = rangeEnd;\n        },\n\n        /**\n         * Reset range\n         */\n        resetRange: function () {\n            // rangeStart and rangeEnd is readonly.\n            this.option.rangeStart = this.option.rangeEnd = null;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2Nvb3JkL2F4aXNNb2RlbENvbW1vbk1peGluLmpzP2E4ZDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoJy4vYXhpc0hlbHBlcicpO1xuXG4gICAgZnVuY3Rpb24gZ2V0TmFtZShvYmopIHtcbiAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChvYmopICYmIG9iai52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiArICcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvcm1hdCBsYWJlbHNcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGb3JtYXR0ZWRMYWJlbHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBheGlzSGVscGVyLmdldEZvcm1hdHRlZExhYmVscyhcbiAgICAgICAgICAgICAgICB0aGlzLmF4aXMsXG4gICAgICAgICAgICAgICAgdGhpcy5nZXQoJ2F4aXNMYWJlbC5mb3JtYXR0ZXInKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGNhdGVnb3JpZXNcbiAgICAgICAgICovXG4gICAgICAgIGdldENhdGVnb3JpZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCgndHlwZScpID09PSAnY2F0ZWdvcnknXG4gICAgICAgICAgICAgICAgJiYgenJVdGlsLm1hcCh0aGlzLmdldCgnZGF0YScpLCBnZXROYW1lKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBvcmlnaW5cbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfHN0cmluZ30gbWluIHZhbHVlIG9yICdkYXRhTWluJyBvciBudWxsL3VuZGVmaW5lZCAobWVhbnMgYXV0bykgb3IgTmFOXG4gICAgICAgICAqL1xuICAgICAgICBnZXRNaW46IGZ1bmN0aW9uIChvcmlnaW4pIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgICAgIHZhciBtaW4gPSAoIW9yaWdpbiAmJiBvcHRpb24ucmFuZ2VTdGFydCAhPSBudWxsKVxuICAgICAgICAgICAgICAgID8gb3B0aW9uLnJhbmdlU3RhcnQgOiBvcHRpb24ubWluO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5heGlzICYmIG1pbiAhPSBudWxsICYmIG1pbiAhPT0gJ2RhdGFNaW4nICYmICF6clV0aWwuZXFOYU4obWluKSkge1xuICAgICAgICAgICAgICAgIG1pbiA9IHRoaXMuYXhpcy5zY2FsZS5wYXJzZShtaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBvcmlnaW5cbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfHN0cmluZ30gbWF4IHZhbHVlIG9yICdkYXRhTWF4JyBvciBudWxsL3VuZGVmaW5lZCAobWVhbnMgYXV0bykgb3IgTmFOXG4gICAgICAgICAqL1xuICAgICAgICBnZXRNYXg6IGZ1bmN0aW9uIChvcmlnaW4pIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgICAgIHZhciBtYXggPSAoIW9yaWdpbiAmJiBvcHRpb24ucmFuZ2VFbmQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICA/IG9wdGlvbi5yYW5nZUVuZCA6IG9wdGlvbi5tYXg7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmF4aXMgJiYgbWF4ICE9IG51bGwgJiYgbWF4ICE9PSAnZGF0YU1heCcgJiYgIXpyVXRpbC5lcU5hTihtYXgpKSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gdGhpcy5heGlzLnNjYWxlLnBhcnNlKG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TmVlZENyb3NzWmVybzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIChvcHRpb24ucmFuZ2VTdGFydCAhPSBudWxsIHx8IG9wdGlvbi5yYW5nZUVuZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgID8gZmFsc2UgOiAhb3B0aW9uLnNjYWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgZWFjaCBheGlzIG1vZGVsIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBjb29yZGluYXRlIHN5c3RlbSBtb2RlbFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29vcmRTeXNNb2RlbDogenJVdGlsLm5vb3AsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYW5nZVN0YXJ0IENhbiBvbmx5IGJlIGZpbml0ZSBudW1iZXIgb3IgbnVsbC91bmRlZmluZWQgb3IgTmFOLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFuZ2VFbmQgQ2FuIG9ubHkgYmUgZmluaXRlIG51bWJlciBvciBudWxsL3VuZGVmaW5lZCBvciBOYU4uXG4gICAgICAgICAqL1xuICAgICAgICBzZXRSYW5nZTogZnVuY3Rpb24gKHJhbmdlU3RhcnQsIHJhbmdlRW5kKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbi5yYW5nZVN0YXJ0ID0gcmFuZ2VTdGFydDtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uLnJhbmdlRW5kID0gcmFuZ2VFbmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0IHJhbmdlXG4gICAgICAgICAqL1xuICAgICAgICByZXNldFJhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyByYW5nZVN0YXJ0IGFuZCByYW5nZUVuZCBpcyByZWFkb25seS5cbiAgICAgICAgICAgIHRoaXMub3B0aW9uLnJhbmdlU3RhcnQgPSB0aGlzLm9wdGlvbi5yYW5nZUVuZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2Nvb3JkL2F4aXNNb2RlbENvbW1vbk1peGluLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("// FIXME Better way to pack data in graphic element\n\n\n    __webpack_require__(130);\n\n    __webpack_require__(143);\n\n    __webpack_require__(144);\n\n\n    // Show tip action\n    /**\n     * @action\n     * @property {string} type\n     * @property {number} seriesIndex\n     * @property {number} dataIndex\n     * @property {number} [x]\n     * @property {number} [y]\n     */\n    __webpack_require__(17).registerAction(\n        {\n            type: 'showTip',\n            event: 'showTip',\n            update: 'tooltip:manuallyShowTip'\n        },\n        // noop\n        function () {}\n    );\n    // Hide tip action\n    __webpack_require__(17).registerAction(\n        {\n            type: 'hideTip',\n            event: 'hideTip',\n            update: 'tooltip:manuallyHideTip'\n        },\n        // noop\n        function () {}\n    );\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwLmpzP2I0OTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsImZpbGUiOiIxMjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGSVhNRSBCZXR0ZXIgd2F5IHRvIHBhY2sgZGF0YSBpbiBncmFwaGljIGVsZW1lbnRcblxuXG4gICAgcmVxdWlyZSgnLi9heGlzUG9pbnRlcicpO1xuXG4gICAgcmVxdWlyZSgnLi90b29sdGlwL1Rvb2x0aXBNb2RlbCcpO1xuXG4gICAgcmVxdWlyZSgnLi90b29sdGlwL1Rvb2x0aXBWaWV3Jyk7XG5cblxuICAgIC8vIFNob3cgdGlwIGFjdGlvblxuICAgIC8qKlxuICAgICAqIEBhY3Rpb25cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZXJpZXNJbmRleFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3hdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt5XVxuICAgICAqL1xuICAgIHJlcXVpcmUoJy4uL2VjaGFydHMnKS5yZWdpc3RlckFjdGlvbihcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgICAgICAgICAgZXZlbnQ6ICdzaG93VGlwJyxcbiAgICAgICAgICAgIHVwZGF0ZTogJ3Rvb2x0aXA6bWFudWFsbHlTaG93VGlwJ1xuICAgICAgICB9LFxuICAgICAgICAvLyBub29wXG4gICAgICAgIGZ1bmN0aW9uICgpIHt9XG4gICAgKTtcbiAgICAvLyBIaWRlIHRpcCBhY3Rpb25cbiAgICByZXF1aXJlKCcuLi9lY2hhcnRzJykucmVnaXN0ZXJBY3Rpb24oXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdoaWRlVGlwJyxcbiAgICAgICAgICAgIGV2ZW50OiAnaGlkZVRpcCcsXG4gICAgICAgICAgICB1cGRhdGU6ICd0b29sdGlwOm1hbnVhbGx5SGlkZVRpcCdcbiAgICAgICAgfSxcbiAgICAgICAgLy8gbm9vcFxuICAgICAgICBmdW5jdGlvbiAoKSB7fVxuICAgICk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n\n    var echarts = __webpack_require__(17);\n    var axisPointerModelHelper = __webpack_require__(131);\n    var axisTrigger = __webpack_require__(132);\n    var zrUtil = __webpack_require__(20);\n\n    __webpack_require__(134);\n    __webpack_require__(135);\n\n    // CartesianAxisPointer is not supposed to be required here. But consider\n    // echarts.simple.js and online build tooltip, which only require gridSimple,\n    // CartesianAxisPointer should be able to required somewhere.\n    __webpack_require__(137);\n\n    echarts.registerPreprocessor(function (option) {\n        // Always has a global axisPointerModel for default setting.\n        if (option) {\n            (!option.axisPointer || option.axisPointer.length === 0)\n                && (option.axisPointer = {});\n\n            var link = option.axisPointer.link;\n            // Normalize to array to avoid object mergin. But if link\n            // is not set, remain null/undefined, otherwise it will\n            // override existent link setting.\n            if (link && !zrUtil.isArray(link)) {\n                option.axisPointer.link = [link];\n            }\n        }\n    });\n\n    // This process should proformed after coordinate systems created\n    // and series data processed. So put it on statistic processing stage.\n    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n        // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n        // allAxesInfo should be updated when setOption performed.\n        ecModel.getComponent('axisPointer').coordSysAxesInfo\n            = axisPointerModelHelper.collect(ecModel, api);\n    });\n\n    // Broadcast to all views.\n    echarts.registerAction({\n        type: 'updateAxisPointer',\n        event: 'updateAxisPointer',\n        update: ':updateAxisPointer'\n    }, axisTrigger);\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci5qcz8xMTBkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLIiwiZmlsZSI6IjEzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGVjaGFydHMgPSByZXF1aXJlKCcuLi9lY2hhcnRzJyk7XG4gICAgdmFyIGF4aXNQb2ludGVyTW9kZWxIZWxwZXIgPSByZXF1aXJlKCcuL2F4aXNQb2ludGVyL21vZGVsSGVscGVyJyk7XG4gICAgdmFyIGF4aXNUcmlnZ2VyID0gcmVxdWlyZSgnLi9heGlzUG9pbnRlci9heGlzVHJpZ2dlcicpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIHJlcXVpcmUoJy4vYXhpc1BvaW50ZXIvQXhpc1BvaW50ZXJNb2RlbCcpO1xuICAgIHJlcXVpcmUoJy4vYXhpc1BvaW50ZXIvQXhpc1BvaW50ZXJWaWV3Jyk7XG5cbiAgICAvLyBDYXJ0ZXNpYW5BeGlzUG9pbnRlciBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgcmVxdWlyZWQgaGVyZS4gQnV0IGNvbnNpZGVyXG4gICAgLy8gZWNoYXJ0cy5zaW1wbGUuanMgYW5kIG9ubGluZSBidWlsZCB0b29sdGlwLCB3aGljaCBvbmx5IHJlcXVpcmUgZ3JpZFNpbXBsZSxcbiAgICAvLyBDYXJ0ZXNpYW5BeGlzUG9pbnRlciBzaG91bGQgYmUgYWJsZSB0byByZXF1aXJlZCBzb21ld2hlcmUuXG4gICAgcmVxdWlyZSgnLi9heGlzUG9pbnRlci9DYXJ0ZXNpYW5BeGlzUG9pbnRlcicpO1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlclByZXByb2Nlc3NvcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIC8vIEFsd2F5cyBoYXMgYSBnbG9iYWwgYXhpc1BvaW50ZXJNb2RlbCBmb3IgZGVmYXVsdCBzZXR0aW5nLlxuICAgICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgICAgICAoIW9wdGlvbi5heGlzUG9pbnRlciB8fCBvcHRpb24uYXhpc1BvaW50ZXIubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICYmIChvcHRpb24uYXhpc1BvaW50ZXIgPSB7fSk7XG5cbiAgICAgICAgICAgIHZhciBsaW5rID0gb3B0aW9uLmF4aXNQb2ludGVyLmxpbms7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gYXJyYXkgdG8gYXZvaWQgb2JqZWN0IG1lcmdpbi4gQnV0IGlmIGxpbmtcbiAgICAgICAgICAgIC8vIGlzIG5vdCBzZXQsIHJlbWFpbiBudWxsL3VuZGVmaW5lZCwgb3RoZXJ3aXNlIGl0IHdpbGxcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlIGV4aXN0ZW50IGxpbmsgc2V0dGluZy5cbiAgICAgICAgICAgIGlmIChsaW5rICYmICF6clV0aWwuaXNBcnJheShsaW5rKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5heGlzUG9pbnRlci5saW5rID0gW2xpbmtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUaGlzIHByb2Nlc3Mgc2hvdWxkIHByb2Zvcm1lZCBhZnRlciBjb29yZGluYXRlIHN5c3RlbXMgY3JlYXRlZFxuICAgIC8vIGFuZCBzZXJpZXMgZGF0YSBwcm9jZXNzZWQuIFNvIHB1dCBpdCBvbiBzdGF0aXN0aWMgcHJvY2Vzc2luZyBzdGFnZS5cbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJvY2Vzc29yKGVjaGFydHMuUFJJT1JJVFkuUFJPQ0VTU09SLlNUQVRJU1RJQywgZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAvLyBCdWlsZCBheGlzUG9pbnRlck1vZGVsLCBtZXJnaW4gdG9vbHRpcC5heGlzUG9pbnRlciBtb2RlbCBmb3IgZWFjaCBheGlzLlxuICAgICAgICAvLyBhbGxBeGVzSW5mbyBzaG91bGQgYmUgdXBkYXRlZCB3aGVuIHNldE9wdGlvbiBwZXJmb3JtZWQuXG4gICAgICAgIGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdheGlzUG9pbnRlcicpLmNvb3JkU3lzQXhlc0luZm9cbiAgICAgICAgICAgID0gYXhpc1BvaW50ZXJNb2RlbEhlbHBlci5jb2xsZWN0KGVjTW9kZWwsIGFwaSk7XG4gICAgfSk7XG5cbiAgICAvLyBCcm9hZGNhc3QgdG8gYWxsIHZpZXdzLlxuICAgIGVjaGFydHMucmVnaXN0ZXJBY3Rpb24oe1xuICAgICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgICBldmVudDogJ3VwZGF0ZUF4aXNQb2ludGVyJyxcbiAgICAgICAgdXBkYXRlOiAnOnVwZGF0ZUF4aXNQb2ludGVyJ1xuICAgIH0sIGF4aXNUcmlnZ2VyKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n    var Model = __webpack_require__(28);\n    var each = zrUtil.each;\n    var curry = zrUtil.curry;\n\n    var helper = {};\n\n    // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n    // allAxesInfo should be updated when setOption performed.\n    helper.collect = function (ecModel, api) {\n        var result = {\n            /**\n             * key: makeKey(axis.model)\n             * value: {\n             *      axis,\n             *      coordSys,\n             *      axisPointerModel,\n             *      triggerTooltip,\n             *      involveSeries,\n             *      snap,\n             *      seriesModels,\n             *      seriesDataCount\n             * }\n             */\n            axesInfo: {},\n            seriesInvolved: false,\n            /**\n             * key: makeKey(coordSys.model)\n             * value: Object: key makeKey(axis.model), value: axisInfo\n             */\n            coordSysAxesInfo: {},\n            coordSysMap: {}\n        };\n\n        collectAxesInfo(result, ecModel, api);\n\n        // Check seriesInvolved for performance, in case too many series in some chart.\n        result.seriesInvolved && collectSeriesInfo(result, ecModel);\n\n        return result;\n    };\n\n    function collectAxesInfo(result, ecModel, api) {\n        var globalTooltipModel = ecModel.getComponent('tooltip');\n        var globalAxisPointerModel = ecModel.getComponent('axisPointer');\n        // links can only be set on global.\n        var linksOption = globalAxisPointerModel.get('link', true) || [];\n        var linkGroups = [];\n\n        // Collect axes info.\n        each(api.getCoordinateSystems(), function (coordSys) {\n            // Some coordinate system do not support axes, like geo.\n            if (!coordSys.axisPointerEnabled) {\n                return;\n            }\n\n            var coordSysKey = makeKey(coordSys.model);\n            var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n            result.coordSysMap[coordSysKey] = coordSys;\n\n            // Set tooltip (like 'cross') is a convienent way to show axisPointer\n            // for user. So we enable seting tooltip on coordSys model.\n            var coordSysModel = coordSys.model;\n            var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n\n            each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null));\n\n            // If axis tooltip used, choose tooltip axis for each coordSys.\n            // Notice this case: coordSys is `grid` but not `cartesian2D` here.\n            if (coordSys.getTooltipAxes\n                && globalTooltipModel\n                // If tooltip.showContent is set as false, tooltip will not\n                // show but axisPointer will show as normal.\n                && baseTooltipModel.get('show')\n            ) {\n                // Compatible with previous logic. But series.tooltip.trigger: 'axis'\n                // or series.data[n].tooltip.trigger: 'axis' are not support any more.\n                var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n                var cross = baseTooltipModel.get('axisPointer.type') === 'cross';\n                var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));\n                if (triggerAxis || cross) {\n                    each(tooltipAxes.baseAxes, curry(\n                        saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis\n                    ));\n                }\n                if (cross) {\n                    each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));\n                }\n            }\n\n            // fromTooltip: true | false | 'cross'\n            // triggerTooltip: true | false | null\n            function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n                var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n\n                var axisPointerShow = axisPointerModel.get('show');\n                if (!axisPointerShow || (\n                    axisPointerShow === 'auto'\n                    && !fromTooltip\n                    && !isHandleTrigger(axisPointerModel)\n                )) {\n                    return;\n                }\n\n                if (triggerTooltip == null) {\n                    triggerTooltip = axisPointerModel.get('triggerTooltip');\n                }\n\n                axisPointerModel = fromTooltip\n                    ? makeAxisPointerModel(\n                        axis, baseTooltipModel, globalAxisPointerModel, ecModel,\n                        fromTooltip, triggerTooltip\n                    )\n                    : axisPointerModel;\n\n                var snap = axisPointerModel.get('snap');\n                var key = makeKey(axis.model);\n                var involveSeries = triggerTooltip || snap || axis.type === 'category';\n\n                // If result.axesInfo[key] exist, override it (tooltip has higher priority).\n                var axisInfo = result.axesInfo[key] = {\n                    key: key,\n                    axis: axis,\n                    coordSys: coordSys,\n                    axisPointerModel: axisPointerModel,\n                    triggerTooltip: triggerTooltip,\n                    involveSeries: involveSeries,\n                    snap: snap,\n                    useHandle: isHandleTrigger(axisPointerModel),\n                    seriesModels: []\n                };\n                axesInfoInCoordSys[key] = axisInfo;\n                result.seriesInvolved |= involveSeries;\n\n                var groupIndex = getLinkGroupIndex(linksOption, axis);\n                if (groupIndex != null) {\n                    var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {axesInfo: {}});\n                    linkGroup.axesInfo[key] = axisInfo;\n                    linkGroup.mapper = linksOption[groupIndex].mapper;\n                    axisInfo.linkGroup = linkGroup;\n                }\n            }\n        });\n    }\n\n    function makeAxisPointerModel(\n        axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip\n    ) {\n        var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n        var volatileOption = {};\n\n        each(\n            [\n                'type', 'snap', 'lineStyle', 'shadowStyle', 'label',\n                'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'\n            ],\n            function (field) {\n                volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));\n            }\n        );\n\n        // category axis do not auto snap, otherwise some tick that do not\n        // has value can not be hovered. value/time/log axis default snap if\n        // triggered from tooltip and trigger tooltip.\n        volatileOption.snap = axis.type !== 'category' && !!triggerTooltip;\n\n        // Compatibel with previous behavior, tooltip axis do not show label by default.\n        // Only these properties can be overrided from tooltip to axisPointer.\n        if (tooltipAxisPointerModel.get('type') === 'cross') {\n            volatileOption.type = 'line';\n        }\n        var labelOption = volatileOption.label || (volatileOption.label = {});\n        // Follow the convention, do not show label when triggered by tooltip by default.\n        labelOption.show == null && (labelOption.show = false);\n\n        if (fromTooltip === 'cross') {\n            // When 'cross', both axes show labels.\n            labelOption.show = true;\n            // If triggerTooltip, this is a base axis, which should better not use cross style\n            // (cross style is dashed by default)\n            if (!triggerTooltip) {\n                var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n                crossStyle && zrUtil.defaults(\n                    labelOption.textStyle || (labelOption.textStyle = {}),\n                    crossStyle.textStyle\n                );\n            }\n        }\n\n        return axis.model.getModel(\n            'axisPointer',\n            new Model(volatileOption, globalAxisPointerModel, ecModel)\n        );\n    }\n\n    function collectSeriesInfo(result, ecModel) {\n        // Prepare data for axis trigger\n        ecModel.eachSeries(function (seriesModel) {\n\n            // Notice this case: this coordSys is `cartesian2D` but not `grid`.\n            var coordSys = seriesModel.coordinateSystem;\n            var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);\n            var seriesTooltipShow = seriesModel.get('tooltip.show', true);\n            if (!coordSys\n                || seriesTooltipTrigger === 'none'\n                || seriesTooltipTrigger === false\n                || seriesTooltipTrigger === 'item'\n                || seriesTooltipShow === false\n                || seriesModel.get('axisPointer.show', true) === false\n            ) {\n                return;\n            }\n\n            each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n                var axis = axisInfo.axis;\n                if (coordSys.getAxis(axis.dim) === axis) {\n                    axisInfo.seriesModels.push(seriesModel);\n                    axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n                    axisInfo.seriesDataCount += seriesModel.getData().count();\n                }\n            });\n\n        }, this);\n    }\n\n    /**\n     * For example:\n     * {\n     *     axisPointer: {\n     *         links: [{\n     *             xAxisIndex: [2, 4],\n     *             yAxisIndex: 'all'\n     *         }, {\n     *             xAxisId: ['a5', 'a7'],\n     *             xAxisName: 'xxx'\n     *         }]\n     *     }\n     * }\n     */\n    function getLinkGroupIndex(linksOption, axis) {\n        var axisModel = axis.model;\n        var dim = axis.dim;\n        for (var i = 0; i < linksOption.length; i++) {\n            var linkOption = linksOption[i] || {};\n            if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id)\n                || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex)\n                || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)\n            ) {\n                return i;\n            }\n        }\n    }\n\n    function checkPropInLink(linkPropValue, axisPropValue) {\n        return linkPropValue === 'all'\n            || (zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0)\n            || linkPropValue === axisPropValue;\n    }\n\n    helper.fixValue = function (axisModel) {\n        var axisInfo = helper.getAxisInfo(axisModel);\n        if (!axisInfo) {\n            return;\n        }\n\n        var axisPointerModel = axisInfo.axisPointerModel;\n        var scale = axisInfo.axis.scale;\n        var option = axisPointerModel.option;\n        var status = axisPointerModel.get('status');\n        var value = axisPointerModel.get('value');\n\n        // Parse init value for category and time axis.\n        if (value != null) {\n            value = scale.parse(value);\n        }\n\n        var useHandle = isHandleTrigger(axisPointerModel);\n        // If `handle` used, `axisPointer` will always be displayed, so value\n        // and status should be initialized.\n        if (status == null) {\n            option.status = useHandle ? 'show' : 'hide';\n        }\n\n        var extent = scale.getExtent().slice();\n        extent[0] > extent[1] && extent.reverse();\n\n        if (// Pick a value on axis when initializing.\n            value == null\n            // If both `handle` and `dataZoom` are used, value may be out of axis extent,\n            // where we should re-pick a value to keep `handle` displaying normally.\n            || value > extent[1]\n        ) {\n            // Make handle displayed on the end of the axis when init, which looks better.\n            value = extent[1];\n        }\n        if (value < extent[0]) {\n            value = extent[0];\n        }\n\n        option.value = value;\n\n        if (useHandle) {\n            option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n        }\n    };\n\n    helper.getAxisInfo = function (axisModel) {\n        var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n        return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n    };\n\n    helper.getAxisPointerModel = function (axisModel) {\n        var axisInfo = helper.getAxisInfo(axisModel);\n        return axisInfo && axisInfo.axisPointerModel;\n    };\n\n    function isHandleTrigger(axisPointerModel) {\n        return !!axisPointerModel.get('handle.show');\n    }\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @return {string} unique key\n     */\n    var makeKey = helper.makeKey = function (model) {\n        return model.type + '||' + model.id;\n    };\n\n    module.exports = helper;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9tb2RlbEhlbHBlci5qcz9iYTAxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUZBQXlGLGFBQWE7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWIsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvTW9kZWwnKTtcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTtcblxuICAgIHZhciBoZWxwZXIgPSB7fTtcblxuICAgIC8vIEJ1aWxkIGF4aXNQb2ludGVyTW9kZWwsIG1lcmdpbiB0b29sdGlwLmF4aXNQb2ludGVyIG1vZGVsIGZvciBlYWNoIGF4aXMuXG4gICAgLy8gYWxsQXhlc0luZm8gc2hvdWxkIGJlIHVwZGF0ZWQgd2hlbiBzZXRPcHRpb24gcGVyZm9ybWVkLlxuICAgIGhlbHBlci5jb2xsZWN0ID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBrZXk6IG1ha2VLZXkoYXhpcy5tb2RlbClcbiAgICAgICAgICAgICAqIHZhbHVlOiB7XG4gICAgICAgICAgICAgKiAgICAgIGF4aXMsXG4gICAgICAgICAgICAgKiAgICAgIGNvb3JkU3lzLFxuICAgICAgICAgICAgICogICAgICBheGlzUG9pbnRlck1vZGVsLFxuICAgICAgICAgICAgICogICAgICB0cmlnZ2VyVG9vbHRpcCxcbiAgICAgICAgICAgICAqICAgICAgaW52b2x2ZVNlcmllcyxcbiAgICAgICAgICAgICAqICAgICAgc25hcCxcbiAgICAgICAgICAgICAqICAgICAgc2VyaWVzTW9kZWxzLFxuICAgICAgICAgICAgICogICAgICBzZXJpZXNEYXRhQ291bnRcbiAgICAgICAgICAgICAqIH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYXhlc0luZm86IHt9LFxuICAgICAgICAgICAgc2VyaWVzSW52b2x2ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBrZXk6IG1ha2VLZXkoY29vcmRTeXMubW9kZWwpXG4gICAgICAgICAgICAgKiB2YWx1ZTogT2JqZWN0OiBrZXkgbWFrZUtleShheGlzLm1vZGVsKSwgdmFsdWU6IGF4aXNJbmZvXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvb3JkU3lzQXhlc0luZm86IHt9LFxuICAgICAgICAgICAgY29vcmRTeXNNYXA6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29sbGVjdEF4ZXNJbmZvKHJlc3VsdCwgZWNNb2RlbCwgYXBpKTtcblxuICAgICAgICAvLyBDaGVjayBzZXJpZXNJbnZvbHZlZCBmb3IgcGVyZm9ybWFuY2UsIGluIGNhc2UgdG9vIG1hbnkgc2VyaWVzIGluIHNvbWUgY2hhcnQuXG4gICAgICAgIHJlc3VsdC5zZXJpZXNJbnZvbHZlZCAmJiBjb2xsZWN0U2VyaWVzSW5mbyhyZXN1bHQsIGVjTW9kZWwpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNvbGxlY3RBeGVzSW5mbyhyZXN1bHQsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICB2YXIgZ2xvYmFsVG9vbHRpcE1vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ3Rvb2x0aXAnKTtcbiAgICAgICAgdmFyIGdsb2JhbEF4aXNQb2ludGVyTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudCgnYXhpc1BvaW50ZXInKTtcbiAgICAgICAgLy8gbGlua3MgY2FuIG9ubHkgYmUgc2V0IG9uIGdsb2JhbC5cbiAgICAgICAgdmFyIGxpbmtzT3B0aW9uID0gZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2xpbmsnLCB0cnVlKSB8fCBbXTtcbiAgICAgICAgdmFyIGxpbmtHcm91cHMgPSBbXTtcblxuICAgICAgICAvLyBDb2xsZWN0IGF4ZXMgaW5mby5cbiAgICAgICAgZWFjaChhcGkuZ2V0Q29vcmRpbmF0ZVN5c3RlbXMoKSwgZnVuY3Rpb24gKGNvb3JkU3lzKSB7XG4gICAgICAgICAgICAvLyBTb21lIGNvb3JkaW5hdGUgc3lzdGVtIGRvIG5vdCBzdXBwb3J0IGF4ZXMsIGxpa2UgZ2VvLlxuICAgICAgICAgICAgaWYgKCFjb29yZFN5cy5heGlzUG9pbnRlckVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb29yZFN5c0tleSA9IG1ha2VLZXkoY29vcmRTeXMubW9kZWwpO1xuICAgICAgICAgICAgdmFyIGF4ZXNJbmZvSW5Db29yZFN5cyA9IHJlc3VsdC5jb29yZFN5c0F4ZXNJbmZvW2Nvb3JkU3lzS2V5XSA9IHt9O1xuICAgICAgICAgICAgcmVzdWx0LmNvb3JkU3lzTWFwW2Nvb3JkU3lzS2V5XSA9IGNvb3JkU3lzO1xuXG4gICAgICAgICAgICAvLyBTZXQgdG9vbHRpcCAobGlrZSAnY3Jvc3MnKSBpcyBhIGNvbnZpZW5lbnQgd2F5IHRvIHNob3cgYXhpc1BvaW50ZXJcbiAgICAgICAgICAgIC8vIGZvciB1c2VyLiBTbyB3ZSBlbmFibGUgc2V0aW5nIHRvb2x0aXAgb24gY29vcmRTeXMgbW9kZWwuXG4gICAgICAgICAgICB2YXIgY29vcmRTeXNNb2RlbCA9IGNvb3JkU3lzLm1vZGVsO1xuICAgICAgICAgICAgdmFyIGJhc2VUb29sdGlwTW9kZWwgPSBjb29yZFN5c01vZGVsLmdldE1vZGVsKCd0b29sdGlwJywgZ2xvYmFsVG9vbHRpcE1vZGVsKTtcblxuICAgICAgICAgICAgZWFjaChjb29yZFN5cy5nZXRBeGVzKCksIGN1cnJ5KHNhdmVUb29sdGlwQXhpc0luZm8sIGZhbHNlLCBudWxsKSk7XG5cbiAgICAgICAgICAgIC8vIElmIGF4aXMgdG9vbHRpcCB1c2VkLCBjaG9vc2UgdG9vbHRpcCBheGlzIGZvciBlYWNoIGNvb3JkU3lzLlxuICAgICAgICAgICAgLy8gTm90aWNlIHRoaXMgY2FzZTogY29vcmRTeXMgaXMgYGdyaWRgIGJ1dCBub3QgYGNhcnRlc2lhbjJEYCBoZXJlLlxuICAgICAgICAgICAgaWYgKGNvb3JkU3lzLmdldFRvb2x0aXBBeGVzXG4gICAgICAgICAgICAgICAgJiYgZ2xvYmFsVG9vbHRpcE1vZGVsXG4gICAgICAgICAgICAgICAgLy8gSWYgdG9vbHRpcC5zaG93Q29udGVudCBpcyBzZXQgYXMgZmFsc2UsIHRvb2x0aXAgd2lsbCBub3RcbiAgICAgICAgICAgICAgICAvLyBzaG93IGJ1dCBheGlzUG9pbnRlciB3aWxsIHNob3cgYXMgbm9ybWFsLlxuICAgICAgICAgICAgICAgICYmIGJhc2VUb29sdGlwTW9kZWwuZ2V0KCdzaG93JylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIENvbXBhdGlibGUgd2l0aCBwcmV2aW91cyBsb2dpYy4gQnV0IHNlcmllcy50b29sdGlwLnRyaWdnZXI6ICdheGlzJ1xuICAgICAgICAgICAgICAgIC8vIG9yIHNlcmllcy5kYXRhW25dLnRvb2x0aXAudHJpZ2dlcjogJ2F4aXMnIGFyZSBub3Qgc3VwcG9ydCBhbnkgbW9yZS5cbiAgICAgICAgICAgICAgICB2YXIgdHJpZ2dlckF4aXMgPSBiYXNlVG9vbHRpcE1vZGVsLmdldCgndHJpZ2dlcicpID09PSAnYXhpcyc7XG4gICAgICAgICAgICAgICAgdmFyIGNyb3NzID0gYmFzZVRvb2x0aXBNb2RlbC5nZXQoJ2F4aXNQb2ludGVyLnR5cGUnKSA9PT0gJ2Nyb3NzJztcbiAgICAgICAgICAgICAgICB2YXIgdG9vbHRpcEF4ZXMgPSBjb29yZFN5cy5nZXRUb29sdGlwQXhlcyhiYXNlVG9vbHRpcE1vZGVsLmdldCgnYXhpc1BvaW50ZXIuYXhpcycpKTtcbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlckF4aXMgfHwgY3Jvc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZWFjaCh0b29sdGlwQXhlcy5iYXNlQXhlcywgY3VycnkoXG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlVG9vbHRpcEF4aXNJbmZvLCBjcm9zcyA/ICdjcm9zcycgOiB0cnVlLCB0cmlnZ2VyQXhpc1xuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNyb3NzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVhY2godG9vbHRpcEF4ZXMub3RoZXJBeGVzLCBjdXJyeShzYXZlVG9vbHRpcEF4aXNJbmZvLCAnY3Jvc3MnLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZnJvbVRvb2x0aXA6IHRydWUgfCBmYWxzZSB8ICdjcm9zcydcbiAgICAgICAgICAgIC8vIHRyaWdnZXJUb29sdGlwOiB0cnVlIHwgZmFsc2UgfCBudWxsXG4gICAgICAgICAgICBmdW5jdGlvbiBzYXZlVG9vbHRpcEF4aXNJbmZvKGZyb21Ub29sdGlwLCB0cmlnZ2VyVG9vbHRpcCwgYXhpcykge1xuICAgICAgICAgICAgICAgIHZhciBheGlzUG9pbnRlck1vZGVsID0gYXhpcy5tb2RlbC5nZXRNb2RlbCgnYXhpc1BvaW50ZXInLCBnbG9iYWxBeGlzUG9pbnRlck1vZGVsKTtcblxuICAgICAgICAgICAgICAgIHZhciBheGlzUG9pbnRlclNob3cgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnc2hvdycpO1xuICAgICAgICAgICAgICAgIGlmICghYXhpc1BvaW50ZXJTaG93IHx8IChcbiAgICAgICAgICAgICAgICAgICAgYXhpc1BvaW50ZXJTaG93ID09PSAnYXV0bydcbiAgICAgICAgICAgICAgICAgICAgJiYgIWZyb21Ub29sdGlwXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0hhbmRsZVRyaWdnZXIoYXhpc1BvaW50ZXJNb2RlbClcbiAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlclRvb2x0aXAgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyVG9vbHRpcCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0cmlnZ2VyVG9vbHRpcCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGF4aXNQb2ludGVyTW9kZWwgPSBmcm9tVG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICA/IG1ha2VBeGlzUG9pbnRlck1vZGVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXhpcywgYmFzZVRvb2x0aXBNb2RlbCwgZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbCwgZWNNb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21Ub29sdGlwLCB0cmlnZ2VyVG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogYXhpc1BvaW50ZXJNb2RlbDtcblxuICAgICAgICAgICAgICAgIHZhciBzbmFwID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3NuYXAnKTtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gbWFrZUtleShheGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB2YXIgaW52b2x2ZVNlcmllcyA9IHRyaWdnZXJUb29sdGlwIHx8IHNuYXAgfHwgYXhpcy50eXBlID09PSAnY2F0ZWdvcnknO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgcmVzdWx0LmF4ZXNJbmZvW2tleV0gZXhpc3QsIG92ZXJyaWRlIGl0ICh0b29sdGlwIGhhcyBoaWdoZXIgcHJpb3JpdHkpLlxuICAgICAgICAgICAgICAgIHZhciBheGlzSW5mbyA9IHJlc3VsdC5heGVzSW5mb1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgYXhpczogYXhpcyxcbiAgICAgICAgICAgICAgICAgICAgY29vcmRTeXM6IGNvb3JkU3lzLFxuICAgICAgICAgICAgICAgICAgICBheGlzUG9pbnRlck1vZGVsOiBheGlzUG9pbnRlck1vZGVsLFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyVG9vbHRpcDogdHJpZ2dlclRvb2x0aXAsXG4gICAgICAgICAgICAgICAgICAgIGludm9sdmVTZXJpZXM6IGludm9sdmVTZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgIHNuYXA6IHNuYXAsXG4gICAgICAgICAgICAgICAgICAgIHVzZUhhbmRsZTogaXNIYW5kbGVUcmlnZ2VyKGF4aXNQb2ludGVyTW9kZWwpLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbHM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBheGVzSW5mb0luQ29vcmRTeXNba2V5XSA9IGF4aXNJbmZvO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXJpZXNJbnZvbHZlZCB8PSBpbnZvbHZlU2VyaWVzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwSW5kZXggPSBnZXRMaW5rR3JvdXBJbmRleChsaW5rc09wdGlvbiwgYXhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlua0dyb3VwID0gbGlua0dyb3Vwc1tncm91cEluZGV4XSB8fCAobGlua0dyb3Vwc1tncm91cEluZGV4XSA9IHtheGVzSW5mbzoge319KTtcbiAgICAgICAgICAgICAgICAgICAgbGlua0dyb3VwLmF4ZXNJbmZvW2tleV0gPSBheGlzSW5mbztcbiAgICAgICAgICAgICAgICAgICAgbGlua0dyb3VwLm1hcHBlciA9IGxpbmtzT3B0aW9uW2dyb3VwSW5kZXhdLm1hcHBlcjtcbiAgICAgICAgICAgICAgICAgICAgYXhpc0luZm8ubGlua0dyb3VwID0gbGlua0dyb3VwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUF4aXNQb2ludGVyTW9kZWwoXG4gICAgICAgIGF4aXMsIGJhc2VUb29sdGlwTW9kZWwsIGdsb2JhbEF4aXNQb2ludGVyTW9kZWwsIGVjTW9kZWwsIGZyb21Ub29sdGlwLCB0cmlnZ2VyVG9vbHRpcFxuICAgICkge1xuICAgICAgICB2YXIgdG9vbHRpcEF4aXNQb2ludGVyTW9kZWwgPSBiYXNlVG9vbHRpcE1vZGVsLmdldE1vZGVsKCdheGlzUG9pbnRlcicpO1xuICAgICAgICB2YXIgdm9sYXRpbGVPcHRpb24gPSB7fTtcblxuICAgICAgICBlYWNoKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICd0eXBlJywgJ3NuYXAnLCAnbGluZVN0eWxlJywgJ3NoYWRvd1N0eWxlJywgJ2xhYmVsJyxcbiAgICAgICAgICAgICAgICAnYW5pbWF0aW9uJywgJ2FuaW1hdGlvbkR1cmF0aW9uVXBkYXRlJywgJ2FuaW1hdGlvbkVhc2luZ1VwZGF0ZScsICd6J1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIHZvbGF0aWxlT3B0aW9uW2ZpZWxkXSA9IHpyVXRpbC5jbG9uZSh0b29sdGlwQXhpc1BvaW50ZXJNb2RlbC5nZXQoZmllbGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBjYXRlZ29yeSBheGlzIGRvIG5vdCBhdXRvIHNuYXAsIG90aGVyd2lzZSBzb21lIHRpY2sgdGhhdCBkbyBub3RcbiAgICAgICAgLy8gaGFzIHZhbHVlIGNhbiBub3QgYmUgaG92ZXJlZC4gdmFsdWUvdGltZS9sb2cgYXhpcyBkZWZhdWx0IHNuYXAgaWZcbiAgICAgICAgLy8gdHJpZ2dlcmVkIGZyb20gdG9vbHRpcCBhbmQgdHJpZ2dlciB0b29sdGlwLlxuICAgICAgICB2b2xhdGlsZU9wdGlvbi5zbmFwID0gYXhpcy50eXBlICE9PSAnY2F0ZWdvcnknICYmICEhdHJpZ2dlclRvb2x0aXA7XG5cbiAgICAgICAgLy8gQ29tcGF0aWJlbCB3aXRoIHByZXZpb3VzIGJlaGF2aW9yLCB0b29sdGlwIGF4aXMgZG8gbm90IHNob3cgbGFiZWwgYnkgZGVmYXVsdC5cbiAgICAgICAgLy8gT25seSB0aGVzZSBwcm9wZXJ0aWVzIGNhbiBiZSBvdmVycmlkZWQgZnJvbSB0b29sdGlwIHRvIGF4aXNQb2ludGVyLlxuICAgICAgICBpZiAodG9vbHRpcEF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJykgPT09ICdjcm9zcycpIHtcbiAgICAgICAgICAgIHZvbGF0aWxlT3B0aW9uLnR5cGUgPSAnbGluZSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhYmVsT3B0aW9uID0gdm9sYXRpbGVPcHRpb24ubGFiZWwgfHwgKHZvbGF0aWxlT3B0aW9uLmxhYmVsID0ge30pO1xuICAgICAgICAvLyBGb2xsb3cgdGhlIGNvbnZlbnRpb24sIGRvIG5vdCBzaG93IGxhYmVsIHdoZW4gdHJpZ2dlcmVkIGJ5IHRvb2x0aXAgYnkgZGVmYXVsdC5cbiAgICAgICAgbGFiZWxPcHRpb24uc2hvdyA9PSBudWxsICYmIChsYWJlbE9wdGlvbi5zaG93ID0gZmFsc2UpO1xuXG4gICAgICAgIGlmIChmcm9tVG9vbHRpcCA9PT0gJ2Nyb3NzJykge1xuICAgICAgICAgICAgLy8gV2hlbiAnY3Jvc3MnLCBib3RoIGF4ZXMgc2hvdyBsYWJlbHMuXG4gICAgICAgICAgICBsYWJlbE9wdGlvbi5zaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIElmIHRyaWdnZXJUb29sdGlwLCB0aGlzIGlzIGEgYmFzZSBheGlzLCB3aGljaCBzaG91bGQgYmV0dGVyIG5vdCB1c2UgY3Jvc3Mgc3R5bGVcbiAgICAgICAgICAgIC8vIChjcm9zcyBzdHlsZSBpcyBkYXNoZWQgYnkgZGVmYXVsdClcbiAgICAgICAgICAgIGlmICghdHJpZ2dlclRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICB2YXIgY3Jvc3NTdHlsZSA9IHZvbGF0aWxlT3B0aW9uLmxpbmVTdHlsZSA9IHRvb2x0aXBBeGlzUG9pbnRlck1vZGVsLmdldCgnY3Jvc3NTdHlsZScpO1xuICAgICAgICAgICAgICAgIGNyb3NzU3R5bGUgJiYgenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAgICAgICAgICBsYWJlbE9wdGlvbi50ZXh0U3R5bGUgfHwgKGxhYmVsT3B0aW9uLnRleHRTdHlsZSA9IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgY3Jvc3NTdHlsZS50ZXh0U3R5bGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF4aXMubW9kZWwuZ2V0TW9kZWwoXG4gICAgICAgICAgICAnYXhpc1BvaW50ZXInLFxuICAgICAgICAgICAgbmV3IE1vZGVsKHZvbGF0aWxlT3B0aW9uLCBnbG9iYWxBeGlzUG9pbnRlck1vZGVsLCBlY01vZGVsKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3RTZXJpZXNJbmZvKHJlc3VsdCwgZWNNb2RlbCkge1xuICAgICAgICAvLyBQcmVwYXJlIGRhdGEgZm9yIGF4aXMgdHJpZ2dlclxuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG5cbiAgICAgICAgICAgIC8vIE5vdGljZSB0aGlzIGNhc2U6IHRoaXMgY29vcmRTeXMgaXMgYGNhcnRlc2lhbjJEYCBidXQgbm90IGBncmlkYC5cbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICB2YXIgc2VyaWVzVG9vbHRpcFRyaWdnZXIgPSBzZXJpZXNNb2RlbC5nZXQoJ3Rvb2x0aXAudHJpZ2dlcicsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHNlcmllc1Rvb2x0aXBTaG93ID0gc2VyaWVzTW9kZWwuZ2V0KCd0b29sdGlwLnNob3cnLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghY29vcmRTeXNcbiAgICAgICAgICAgICAgICB8fCBzZXJpZXNUb29sdGlwVHJpZ2dlciA9PT0gJ25vbmUnXG4gICAgICAgICAgICAgICAgfHwgc2VyaWVzVG9vbHRpcFRyaWdnZXIgPT09IGZhbHNlXG4gICAgICAgICAgICAgICAgfHwgc2VyaWVzVG9vbHRpcFRyaWdnZXIgPT09ICdpdGVtJ1xuICAgICAgICAgICAgICAgIHx8IHNlcmllc1Rvb2x0aXBTaG93ID09PSBmYWxzZVxuICAgICAgICAgICAgICAgIHx8IHNlcmllc01vZGVsLmdldCgnYXhpc1BvaW50ZXIuc2hvdycsIHRydWUpID09PSBmYWxzZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlYWNoKHJlc3VsdC5jb29yZFN5c0F4ZXNJbmZvW21ha2VLZXkoY29vcmRTeXMubW9kZWwpXSwgZnVuY3Rpb24gKGF4aXNJbmZvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuICAgICAgICAgICAgICAgIGlmIChjb29yZFN5cy5nZXRBeGlzKGF4aXMuZGltKSA9PT0gYXhpcykge1xuICAgICAgICAgICAgICAgICAgICBheGlzSW5mby5zZXJpZXNNb2RlbHMucHVzaChzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNJbmZvLnNlcmllc0RhdGFDb3VudCA9PSBudWxsICYmIChheGlzSW5mby5zZXJpZXNEYXRhQ291bnQgPSAwKTtcbiAgICAgICAgICAgICAgICAgICAgYXhpc0luZm8uc2VyaWVzRGF0YUNvdW50ICs9IHNlcmllc01vZGVsLmdldERhdGEoKS5jb3VudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvciBleGFtcGxlOlxuICAgICAqIHtcbiAgICAgKiAgICAgYXhpc1BvaW50ZXI6IHtcbiAgICAgKiAgICAgICAgIGxpbmtzOiBbe1xuICAgICAqICAgICAgICAgICAgIHhBeGlzSW5kZXg6IFsyLCA0XSxcbiAgICAgKiAgICAgICAgICAgICB5QXhpc0luZGV4OiAnYWxsJ1xuICAgICAqICAgICAgICAgfSwge1xuICAgICAqICAgICAgICAgICAgIHhBeGlzSWQ6IFsnYTUnLCAnYTcnXSxcbiAgICAgKiAgICAgICAgICAgICB4QXhpc05hbWU6ICd4eHgnXG4gICAgICogICAgICAgICB9XVxuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldExpbmtHcm91cEluZGV4KGxpbmtzT3B0aW9uLCBheGlzKSB7XG4gICAgICAgIHZhciBheGlzTW9kZWwgPSBheGlzLm1vZGVsO1xuICAgICAgICB2YXIgZGltID0gYXhpcy5kaW07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlua3NPcHRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaW5rT3B0aW9uID0gbGlua3NPcHRpb25baV0gfHwge307XG4gICAgICAgICAgICBpZiAoY2hlY2tQcm9wSW5MaW5rKGxpbmtPcHRpb25bZGltICsgJ0F4aXNJZCddLCBheGlzTW9kZWwuaWQpXG4gICAgICAgICAgICAgICAgfHwgY2hlY2tQcm9wSW5MaW5rKGxpbmtPcHRpb25bZGltICsgJ0F4aXNJbmRleCddLCBheGlzTW9kZWwuY29tcG9uZW50SW5kZXgpXG4gICAgICAgICAgICAgICAgfHwgY2hlY2tQcm9wSW5MaW5rKGxpbmtPcHRpb25bZGltICsgJ0F4aXNOYW1lJ10sIGF4aXNNb2RlbC5uYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1Byb3BJbkxpbmsobGlua1Byb3BWYWx1ZSwgYXhpc1Byb3BWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbGlua1Byb3BWYWx1ZSA9PT0gJ2FsbCdcbiAgICAgICAgICAgIHx8ICh6clV0aWwuaXNBcnJheShsaW5rUHJvcFZhbHVlKSAmJiB6clV0aWwuaW5kZXhPZihsaW5rUHJvcFZhbHVlLCBheGlzUHJvcFZhbHVlKSA+PSAwKVxuICAgICAgICAgICAgfHwgbGlua1Byb3BWYWx1ZSA9PT0gYXhpc1Byb3BWYWx1ZTtcbiAgICB9XG5cbiAgICBoZWxwZXIuZml4VmFsdWUgPSBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgICAgIHZhciBheGlzSW5mbyA9IGhlbHBlci5nZXRBeGlzSW5mbyhheGlzTW9kZWwpO1xuICAgICAgICBpZiAoIWF4aXNJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXhpc1BvaW50ZXJNb2RlbCA9IGF4aXNJbmZvLmF4aXNQb2ludGVyTW9kZWw7XG4gICAgICAgIHZhciBzY2FsZSA9IGF4aXNJbmZvLmF4aXMuc2NhbGU7XG4gICAgICAgIHZhciBvcHRpb24gPSBheGlzUG9pbnRlck1vZGVsLm9wdGlvbjtcbiAgICAgICAgdmFyIHN0YXR1cyA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzdGF0dXMnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3ZhbHVlJyk7XG5cbiAgICAgICAgLy8gUGFyc2UgaW5pdCB2YWx1ZSBmb3IgY2F0ZWdvcnkgYW5kIHRpbWUgYXhpcy5cbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc2NhbGUucGFyc2UodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVzZUhhbmRsZSA9IGlzSGFuZGxlVHJpZ2dlcihheGlzUG9pbnRlck1vZGVsKTtcbiAgICAgICAgLy8gSWYgYGhhbmRsZWAgdXNlZCwgYGF4aXNQb2ludGVyYCB3aWxsIGFsd2F5cyBiZSBkaXNwbGF5ZWQsIHNvIHZhbHVlXG4gICAgICAgIC8vIGFuZCBzdGF0dXMgc2hvdWxkIGJlIGluaXRpYWxpemVkLlxuICAgICAgICBpZiAoc3RhdHVzID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zdGF0dXMgPSB1c2VIYW5kbGUgPyAnc2hvdycgOiAnaGlkZSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXh0ZW50ID0gc2NhbGUuZ2V0RXh0ZW50KCkuc2xpY2UoKTtcbiAgICAgICAgZXh0ZW50WzBdID4gZXh0ZW50WzFdICYmIGV4dGVudC5yZXZlcnNlKCk7XG5cbiAgICAgICAgaWYgKC8vIFBpY2sgYSB2YWx1ZSBvbiBheGlzIHdoZW4gaW5pdGlhbGl6aW5nLlxuICAgICAgICAgICAgdmFsdWUgPT0gbnVsbFxuICAgICAgICAgICAgLy8gSWYgYm90aCBgaGFuZGxlYCBhbmQgYGRhdGFab29tYCBhcmUgdXNlZCwgdmFsdWUgbWF5IGJlIG91dCBvZiBheGlzIGV4dGVudCxcbiAgICAgICAgICAgIC8vIHdoZXJlIHdlIHNob3VsZCByZS1waWNrIGEgdmFsdWUgdG8ga2VlcCBgaGFuZGxlYCBkaXNwbGF5aW5nIG5vcm1hbGx5LlxuICAgICAgICAgICAgfHwgdmFsdWUgPiBleHRlbnRbMV1cbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBNYWtlIGhhbmRsZSBkaXNwbGF5ZWQgb24gdGhlIGVuZCBvZiB0aGUgYXhpcyB3aGVuIGluaXQsIHdoaWNoIGxvb2tzIGJldHRlci5cbiAgICAgICAgICAgIHZhbHVlID0gZXh0ZW50WzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IGV4dGVudFswXSkge1xuICAgICAgICAgICAgdmFsdWUgPSBleHRlbnRbMF07XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb24udmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICBpZiAodXNlSGFuZGxlKSB7XG4gICAgICAgICAgICBvcHRpb24uc3RhdHVzID0gYXhpc0luZm8uYXhpcy5zY2FsZS5pc0JsYW5rKCkgPyAnaGlkZScgOiAnc2hvdyc7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaGVscGVyLmdldEF4aXNJbmZvID0gZnVuY3Rpb24gKGF4aXNNb2RlbCkge1xuICAgICAgICB2YXIgY29vcmRTeXNBeGVzSW5mbyA9IChheGlzTW9kZWwuZWNNb2RlbC5nZXRDb21wb25lbnQoJ2F4aXNQb2ludGVyJykgfHwge30pLmNvb3JkU3lzQXhlc0luZm87XG4gICAgICAgIHJldHVybiBjb29yZFN5c0F4ZXNJbmZvICYmIGNvb3JkU3lzQXhlc0luZm8uYXhlc0luZm9bbWFrZUtleShheGlzTW9kZWwpXTtcbiAgICB9O1xuXG4gICAgaGVscGVyLmdldEF4aXNQb2ludGVyTW9kZWwgPSBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgICAgIHZhciBheGlzSW5mbyA9IGhlbHBlci5nZXRBeGlzSW5mbyhheGlzTW9kZWwpO1xuICAgICAgICByZXR1cm4gYXhpc0luZm8gJiYgYXhpc0luZm8uYXhpc1BvaW50ZXJNb2RlbDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNIYW5kbGVUcmlnZ2VyKGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuICEhYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2hhbmRsZS5zaG93Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbW9kZWxcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHVuaXF1ZSBrZXlcbiAgICAgKi9cbiAgICB2YXIgbWFrZUtleSA9IGhlbHBlci5tYWtlS2V5ID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBtb2RlbC50eXBlICsgJ3x8JyArIG1vZGVsLmlkO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGhlbHBlcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9tb2RlbEhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n    var modelUtil = __webpack_require__(21);\n    var modelHelper = __webpack_require__(131);\n    var findPointFromSeries = __webpack_require__(133);\n\n    var each = zrUtil.each;\n    var curry = zrUtil.curry;\n    var get = modelUtil.makeGetter();\n\n    /**\n     * Basic logic: check all axis, if they do not demand show/highlight,\n     * then hide/downplay them.\n     *\n     * @param {Object} coordSysAxesInfo\n     * @param {Object} payload\n     * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'\n     * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to\n     *              trigger axisPointer and tooltip.\n     * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to\n     *              trigger axisPointer and tooltip.\n     * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.\n     * @param {Object} [payload.dataIndex] finder, restrict target axes.\n     * @param {Object} [payload.axesInfo] finder, restrict target axes.\n     *        [{\n     *          axisDim: 'x'|'y'|'angle'|...,\n     *          axisIndex: ...,\n     *          value: ...\n     *        }, ...]\n     * @param {Function} [payload.dispatchAction]\n     * @param {Object} [payload.tooltipOption]\n     * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,\n     *        which can be specified in dispatchAction\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     * @return {Object} content of event obj for echarts.connect.\n     */\n    function axisTrigger(payload, ecModel, api) {\n        var currTrigger = payload.currTrigger;\n        var point = [payload.x, payload.y];\n        var finder = payload;\n        var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n        var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n        if (illegalPoint(point)) {\n            // Used in the default behavior of `connection`: use the sample seriesIndex\n            // and dataIndex. And also used in the tooltipView trigger.\n            point = findPointFromSeries({\n                seriesIndex: finder.seriesIndex,\n                // Do not use dataIndexInside from other ec instance.\n                // FIXME: auto detect it?\n                dataIndex: finder.dataIndex\n            }, ecModel).point;\n        }\n        var isIllegalPoint = illegalPoint(point);\n\n        // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).\n        // Notice: In this case, it is difficult to get the `point` (which is necessary to show\n        // tooltip, so if point is not given, we just use the point found by sample seriesIndex\n        // and dataIndex.\n        var inputAxesInfo = finder.axesInfo;\n\n        var axesInfo = coordSysAxesInfo.axesInfo;\n        var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n        var outputFinder = {};\n\n        var showValueMap = {};\n        var dataByCoordSys = {list: [], map: {}};\n        var updaters = {\n            showPointer: curry(showPointer, showValueMap),\n            showTooltip: curry(showTooltip, dataByCoordSys)\n        };\n\n        // Process for triggered axes.\n        each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n            // If a point given, it must be contained by the coordinate system.\n            var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);\n\n            each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n                var axis = axisInfo.axis;\n                var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);\n                // If no inputAxesInfo, no axis is restricted.\n                if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {\n                    var val = inputAxisInfo && inputAxisInfo.value;\n                    if (val == null && !isIllegalPoint) {\n                        val = axis.pointToData(point);\n                    }\n                    val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);\n                }\n            });\n        });\n\n        // Process for linked axes.\n        var linkTriggers = {};\n        each(axesInfo, function (tarAxisInfo, tarKey) {\n            var linkGroup = tarAxisInfo.linkGroup;\n\n            // If axis has been triggered in the previous stage, it should not be triggered by link.\n            if (linkGroup && !showValueMap[tarKey]) {\n                each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n                    var srcValItem = showValueMap[srcKey];\n                    // If srcValItem exist, source axis is triggered, so link to target axis.\n                    if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n                        var val = srcValItem.value;\n                        linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(\n                            val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo)\n                        )));\n                        linkTriggers[tarAxisInfo.key] = val;\n                    }\n                });\n            }\n        });\n        each(linkTriggers, function (val, tarKey) {\n            processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);\n        });\n\n        updateModelActually(showValueMap, axesInfo, outputFinder);\n        dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);\n        dispatchHighDownActually(axesInfo, dispatchAction, api);\n\n        return outputFinder;\n    }\n\n    function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {\n        var axis = axisInfo.axis;\n\n        if (axis.scale.isBlank() || !axis.containData(newValue)) {\n            return;\n        }\n\n        if (!axisInfo.involveSeries) {\n            updaters.showPointer(axisInfo, newValue);\n            return;\n        }\n\n        // Heavy calculation. So put it after axis.containData checking.\n        var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n        var payloadBatch = payloadInfo.payloadBatch;\n        var snapToValue = payloadInfo.snapToValue;\n\n        // Fill content of event obj for echarts.connect.\n        // By defualt use the first involved series data as a sample to connect.\n        if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n            zrUtil.extend(outputFinder, payloadBatch[0]);\n        }\n\n        // If no linkSource input, this process is for collecting link\n        // target, where snap should not be accepted.\n        if (!dontSnap && axisInfo.snap) {\n            if (axis.containData(snapToValue) && snapToValue != null) {\n                newValue = snapToValue;\n            }\n        }\n\n        updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder);\n        // Tooltip should always be snapToValue, otherwise there will be\n        // incorrect \"axis value ~ series value\" mapping displayed in tooltip.\n        updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n    }\n\n    function buildPayloadsBySeries(value, axisInfo) {\n        var axis = axisInfo.axis;\n        var dim = axis.dim;\n        var snapToValue = value;\n        var payloadBatch = [];\n        var minDist = Number.MAX_VALUE;\n        var minDiff = -1;\n\n        each(axisInfo.seriesModels, function (series, idx) {\n            var dataDim = series.coordDimToDataDim(dim);\n            var seriesNestestValue;\n            var dataIndices;\n\n            if (series.getAxisTooltipData) {\n                var result = series.getAxisTooltipData(dataDim, value, axis);\n                dataIndices = result.dataIndices;\n                seriesNestestValue = result.nestestValue;\n            }\n            else {\n                dataIndices = series.getData().indicesOfNearest(\n                    dataDim[0],\n                    value,\n                    // Add a threshold to avoid find the wrong dataIndex\n                    // when data length is not same.\n                    false, axis.type === 'category' ? 0.5 : null\n                );\n                if (!dataIndices.length) {\n                    return;\n                }\n                seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n            }\n\n            if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n                return;\n            }\n\n            var diff = value - seriesNestestValue;\n            var dist = Math.abs(diff);\n            // Consider category case\n            if (dist <= minDist) {\n                if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                    minDist = dist;\n                    minDiff = diff;\n                    snapToValue = seriesNestestValue;\n                    payloadBatch.length = 0;\n                }\n                each(dataIndices, function (dataIndex) {\n                    payloadBatch.push({\n                        seriesIndex: series.seriesIndex,\n                        dataIndexInside: dataIndex,\n                        dataIndex: series.getData().getRawIndex(dataIndex)\n                    });\n                });\n            }\n        });\n\n        return {\n            payloadBatch: payloadBatch,\n            snapToValue: snapToValue\n        };\n    }\n\n    function showPointer(showValueMap, axisInfo, value, payloadBatch) {\n        showValueMap[axisInfo.key] = {value: value, payloadBatch: payloadBatch};\n    }\n\n    function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n        var payloadBatch = payloadInfo.payloadBatch;\n        var axis = axisInfo.axis;\n        var axisModel = axis.model;\n        var axisPointerModel = axisInfo.axisPointerModel;\n\n        // If no data, do not create anything in dataByCoordSys,\n        // whose length will be used to judge whether dispatch action.\n        if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n            return;\n        }\n\n        var coordSysModel = axisInfo.coordSys.model;\n        var coordSysKey = modelHelper.makeKey(coordSysModel);\n        var coordSysItem = dataByCoordSys.map[coordSysKey];\n        if (!coordSysItem) {\n            coordSysItem = dataByCoordSys.map[coordSysKey] = {\n                coordSysId: coordSysModel.id,\n                coordSysIndex: coordSysModel.componentIndex,\n                coordSysType: coordSysModel.type,\n                coordSysMainType: coordSysModel.mainType,\n                dataByAxis: []\n            };\n            dataByCoordSys.list.push(coordSysItem);\n        }\n\n        coordSysItem.dataByAxis.push({\n            axisDim: axis.dim,\n            axisIndex: axisModel.componentIndex,\n            axisType: axisModel.type,\n            axisId: axisModel.id,\n            value: value,\n            // Caustion: viewHelper.getValueLabel is actually on \"view stage\", which\n            // depends that all models have been updated. So it should not be performed\n            // here. Considering axisPointerModel used here is volatile, which is hard\n            // to be retrieve in TooltipView, we prepare parameters here.\n            valueLabelOpt: {\n                precision: axisPointerModel.get('label.precision'),\n                formatter: axisPointerModel.get('label.formatter')\n            },\n            seriesDataIndices: payloadBatch.slice()\n        });\n    }\n\n    function updateModelActually(showValueMap, axesInfo, outputFinder) {\n        var outputAxesInfo = outputFinder.axesInfo = [];\n        // Basic logic: If no 'show' required, 'hide' this axisPointer.\n        each(axesInfo, function (axisInfo, key) {\n            var option = axisInfo.axisPointerModel.option;\n            var valItem = showValueMap[key];\n\n            if (valItem) {\n                !axisInfo.useHandle && (option.status = 'show');\n                option.value = valItem.value;\n                // For label formatter param and highlight.\n                option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n            }\n            // When always show (e.g., handle used), remain\n            // original value and status.\n            else {\n                // If hide, value still need to be set, consider\n                // click legend to toggle axis blank.\n                !axisInfo.useHandle && (option.status = 'hide');\n            }\n\n            // If status is 'hide', should be no info in payload.\n            option.status === 'show' && outputAxesInfo.push({\n                axisDim: axisInfo.axis.dim,\n                axisIndex: axisInfo.axis.model.componentIndex,\n                value: option.value\n            });\n        });\n    }\n\n    function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {\n        // Basic logic: If no showTip required, hideTip will be dispatched.\n        if (illegalPoint(point) || !dataByCoordSys.list.length) {\n            dispatchAction({type: 'hideTip'});\n            return;\n        }\n\n        // In most case only one axis (or event one series is used). It is\n        // convinient to fetch payload.seriesIndex and payload.dataIndex\n        // dirtectly. So put the first seriesIndex and dataIndex of the first\n        // axis on the payload.\n        var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n\n        dispatchAction({\n            type: 'showTip',\n            escapeConnect: true,\n            x: point[0],\n            y: point[1],\n            tooltipOption: payload.tooltipOption,\n            position: payload.position,\n            dataIndexInside: sampleItem.dataIndexInside,\n            dataIndex: sampleItem.dataIndex,\n            seriesIndex: sampleItem.seriesIndex,\n            dataByCoordSys: dataByCoordSys.list\n        });\n    }\n\n    function dispatchHighDownActually(axesInfo, dispatchAction, api) {\n        // FIXME\n        // highlight status modification shoule be a stage of main process?\n        // (Consider confilct (e.g., legend and axisPointer) and setOption)\n\n        var zr = api.getZr();\n        var highDownKey = 'axisPointerLastHighlights';\n        var lastHighlights = get(zr)[highDownKey] || {};\n        var newHighlights = get(zr)[highDownKey] = {};\n\n        // Update highlight/downplay status according to axisPointer model.\n        // Build hash map and remove duplicate incidentally.\n        each(axesInfo, function (axisInfo, key) {\n            var option = axisInfo.axisPointerModel.option;\n            option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {\n                var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n                newHighlights[key] = batchItem;\n            });\n        });\n\n        // Diff.\n        var toHighlight = [];\n        var toDownplay = [];\n        zrUtil.each(lastHighlights, function (batchItem, key) {\n            !newHighlights[key] && toDownplay.push(batchItem);\n        });\n        zrUtil.each(newHighlights, function (batchItem, key) {\n            !lastHighlights[key] && toHighlight.push(batchItem);\n        });\n\n        toDownplay.length && api.dispatchAction({\n            type: 'downplay', escapeConnect: true, batch: toDownplay\n        });\n        toHighlight.length && api.dispatchAction({\n            type: 'highlight', escapeConnect: true, batch: toHighlight\n        });\n    }\n\n    function findInputAxisInfo(inputAxesInfo, axisInfo) {\n        for (var i = 0; i < (inputAxesInfo || []).length; i++) {\n            var inputAxisInfo = inputAxesInfo[i];\n            if (axisInfo.axis.dim === inputAxisInfo.axisDim\n                && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex\n            ) {\n                return inputAxisInfo;\n            }\n        }\n    }\n\n    function makeMapperParam(axisInfo) {\n        var axisModel = axisInfo.axis.model;\n        var item = {};\n        var dim = item.axisDim = axisInfo.axis.dim;\n        item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n        item.axisName = item[dim + 'AxisName'] = axisModel.name;\n        item.axisId = item[dim + 'AxisId'] = axisModel.id;\n        return item;\n    }\n\n    function illegalPoint(point) {\n        return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n    }\n\n    module.exports = axisTrigger;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9heGlzVHJpZ2dlci5qcz84NmU4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLCtCQUErQjtBQUM5QztBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsNEJBQTRCO0FBQzNDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSx3RUFBd0UsMEJBQTBCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjEzMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIG1vZGVsSGVscGVyID0gcmVxdWlyZSgnLi9tb2RlbEhlbHBlcicpO1xuICAgIHZhciBmaW5kUG9pbnRGcm9tU2VyaWVzID0gcmVxdWlyZSgnLi9maW5kUG9pbnRGcm9tU2VyaWVzJyk7XG5cbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTtcbiAgICB2YXIgZ2V0ID0gbW9kZWxVdGlsLm1ha2VHZXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEJhc2ljIGxvZ2ljOiBjaGVjayBhbGwgYXhpcywgaWYgdGhleSBkbyBub3QgZGVtYW5kIHNob3cvaGlnaGxpZ2h0LFxuICAgICAqIHRoZW4gaGlkZS9kb3ducGxheSB0aGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvb3JkU3lzQXhlc0luZm9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF5bG9hZC5jdXJyVHJpZ2dlcl0gJ2NsaWNrJyB8ICdtb3VzZW1vdmUnIHwgJ2xlYXZlJ1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtwYXlsb2FkLnhdIHggYW5kIHksIHdoaWNoIGFyZSBtYW5kYXRvcnksIHNwZWNpZnkgYSBwb2ludCB0b1xuICAgICAqICAgICAgICAgICAgICB0cmlnZ2VyIGF4aXNQb2ludGVyIGFuZCB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtwYXlsb2FkLnldIHggYW5kIHksIHdoaWNoIGFyZSBtYW5kYXRvcnksIHNwZWNpZnkgYSBwb2ludCB0b1xuICAgICAqICAgICAgICAgICAgICB0cmlnZ2VyIGF4aXNQb2ludGVyIGFuZCB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGF5bG9hZC5zZXJpZXNJbmRleF0gZmluZGVyLCBvcHRpb25hbCwgcmVzdHJpY3QgdGFyZ2V0IGF4ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXlsb2FkLmRhdGFJbmRleF0gZmluZGVyLCByZXN0cmljdCB0YXJnZXQgYXhlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BheWxvYWQuYXhlc0luZm9dIGZpbmRlciwgcmVzdHJpY3QgdGFyZ2V0IGF4ZXMuXG4gICAgICogICAgICAgIFt7XG4gICAgICogICAgICAgICAgYXhpc0RpbTogJ3gnfCd5J3wnYW5nbGUnfC4uLixcbiAgICAgKiAgICAgICAgICBheGlzSW5kZXg6IC4uLixcbiAgICAgKiAgICAgICAgICB2YWx1ZTogLi4uXG4gICAgICogICAgICAgIH0sIC4uLl1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGF5bG9hZC5kaXNwYXRjaEFjdGlvbl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BheWxvYWQudG9vbHRpcE9wdGlvbl1cbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheS48bnVtYmVyPnxGdW5jdGlvbn0gW3BheWxvYWQucG9zaXRpb25dIFRvb2x0aXAgcG9zaXRpb24sXG4gICAgICogICAgICAgIHdoaWNoIGNhbiBiZSBzcGVjaWZpZWQgaW4gZGlzcGF0Y2hBY3Rpb25cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGNvbnRlbnQgb2YgZXZlbnQgb2JqIGZvciBlY2hhcnRzLmNvbm5lY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXhpc1RyaWdnZXIocGF5bG9hZCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHZhciBjdXJyVHJpZ2dlciA9IHBheWxvYWQuY3VyclRyaWdnZXI7XG4gICAgICAgIHZhciBwb2ludCA9IFtwYXlsb2FkLngsIHBheWxvYWQueV07XG4gICAgICAgIHZhciBmaW5kZXIgPSBwYXlsb2FkO1xuICAgICAgICB2YXIgZGlzcGF0Y2hBY3Rpb24gPSBwYXlsb2FkLmRpc3BhdGNoQWN0aW9uIHx8IHpyVXRpbC5iaW5kKGFwaS5kaXNwYXRjaEFjdGlvbiwgYXBpKTtcbiAgICAgICAgdmFyIGNvb3JkU3lzQXhlc0luZm8gPSBlY01vZGVsLmdldENvbXBvbmVudCgnYXhpc1BvaW50ZXInKS5jb29yZFN5c0F4ZXNJbmZvO1xuXG4gICAgICAgIGlmIChpbGxlZ2FsUG9pbnQocG9pbnQpKSB7XG4gICAgICAgICAgICAvLyBVc2VkIGluIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGBjb25uZWN0aW9uYDogdXNlIHRoZSBzYW1wbGUgc2VyaWVzSW5kZXhcbiAgICAgICAgICAgIC8vIGFuZCBkYXRhSW5kZXguIEFuZCBhbHNvIHVzZWQgaW4gdGhlIHRvb2x0aXBWaWV3IHRyaWdnZXIuXG4gICAgICAgICAgICBwb2ludCA9IGZpbmRQb2ludEZyb21TZXJpZXMoe1xuICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBmaW5kZXIuc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHVzZSBkYXRhSW5kZXhJbnNpZGUgZnJvbSBvdGhlciBlYyBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogYXV0byBkZXRlY3QgaXQ/XG4gICAgICAgICAgICAgICAgZGF0YUluZGV4OiBmaW5kZXIuZGF0YUluZGV4XG4gICAgICAgICAgICB9LCBlY01vZGVsKS5wb2ludDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNJbGxlZ2FsUG9pbnQgPSBpbGxlZ2FsUG9pbnQocG9pbnQpO1xuXG4gICAgICAgIC8vIEF4aXMgYW5kIHZhbHVlIGNhbiBiZSBzcGVjaWZpZWQgd2hlbiBjYWxsaW5nIGRpc3BhdGNoQWN0aW9uKHt0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInfSkuXG4gICAgICAgIC8vIE5vdGljZTogSW4gdGhpcyBjYXNlLCBpdCBpcyBkaWZmaWN1bHQgdG8gZ2V0IHRoZSBgcG9pbnRgICh3aGljaCBpcyBuZWNlc3NhcnkgdG8gc2hvd1xuICAgICAgICAvLyB0b29sdGlwLCBzbyBpZiBwb2ludCBpcyBub3QgZ2l2ZW4sIHdlIGp1c3QgdXNlIHRoZSBwb2ludCBmb3VuZCBieSBzYW1wbGUgc2VyaWVzSW5kZXhcbiAgICAgICAgLy8gYW5kIGRhdGFJbmRleC5cbiAgICAgICAgdmFyIGlucHV0QXhlc0luZm8gPSBmaW5kZXIuYXhlc0luZm87XG5cbiAgICAgICAgdmFyIGF4ZXNJbmZvID0gY29vcmRTeXNBeGVzSW5mby5heGVzSW5mbztcbiAgICAgICAgdmFyIHNob3VsZEhpZGUgPSBjdXJyVHJpZ2dlciA9PT0gJ2xlYXZlJyB8fCBpbGxlZ2FsUG9pbnQocG9pbnQpO1xuICAgICAgICB2YXIgb3V0cHV0RmluZGVyID0ge307XG5cbiAgICAgICAgdmFyIHNob3dWYWx1ZU1hcCA9IHt9O1xuICAgICAgICB2YXIgZGF0YUJ5Q29vcmRTeXMgPSB7bGlzdDogW10sIG1hcDoge319O1xuICAgICAgICB2YXIgdXBkYXRlcnMgPSB7XG4gICAgICAgICAgICBzaG93UG9pbnRlcjogY3Vycnkoc2hvd1BvaW50ZXIsIHNob3dWYWx1ZU1hcCksXG4gICAgICAgICAgICBzaG93VG9vbHRpcDogY3Vycnkoc2hvd1Rvb2x0aXAsIGRhdGFCeUNvb3JkU3lzKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFByb2Nlc3MgZm9yIHRyaWdnZXJlZCBheGVzLlxuICAgICAgICBlYWNoKGNvb3JkU3lzQXhlc0luZm8uY29vcmRTeXNNYXAsIGZ1bmN0aW9uIChjb29yZFN5cywgY29vcmRTeXNLZXkpIHtcbiAgICAgICAgICAgIC8vIElmIGEgcG9pbnQgZ2l2ZW4sIGl0IG11c3QgYmUgY29udGFpbmVkIGJ5IHRoZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgICAgICAgIHZhciBjb29yZFN5c0NvbnRhaW5zUG9pbnQgPSBpc0lsbGVnYWxQb2ludCB8fCBjb29yZFN5cy5jb250YWluUG9pbnQocG9pbnQpO1xuXG4gICAgICAgICAgICBlYWNoKGNvb3JkU3lzQXhlc0luZm8uY29vcmRTeXNBeGVzSW5mb1tjb29yZFN5c0tleV0sIGZ1bmN0aW9uIChheGlzSW5mbywga2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dEF4aXNJbmZvID0gZmluZElucHV0QXhpc0luZm8oaW5wdXRBeGVzSW5mbywgYXhpc0luZm8pO1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIGlucHV0QXhlc0luZm8sIG5vIGF4aXMgaXMgcmVzdHJpY3RlZC5cbiAgICAgICAgICAgICAgICBpZiAoIXNob3VsZEhpZGUgJiYgY29vcmRTeXNDb250YWluc1BvaW50ICYmICghaW5wdXRBeGVzSW5mbyB8fCBpbnB1dEF4aXNJbmZvKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gaW5wdXRBeGlzSW5mbyAmJiBpbnB1dEF4aXNJbmZvLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09IG51bGwgJiYgIWlzSWxsZWdhbFBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBheGlzLnBvaW50VG9EYXRhKHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWwgIT0gbnVsbCAmJiBwcm9jZXNzT25BeGlzKGF4aXNJbmZvLCB2YWwsIHVwZGF0ZXJzLCBmYWxzZSwgb3V0cHV0RmluZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBmb3IgbGlua2VkIGF4ZXMuXG4gICAgICAgIHZhciBsaW5rVHJpZ2dlcnMgPSB7fTtcbiAgICAgICAgZWFjaChheGVzSW5mbywgZnVuY3Rpb24gKHRhckF4aXNJbmZvLCB0YXJLZXkpIHtcbiAgICAgICAgICAgIHZhciBsaW5rR3JvdXAgPSB0YXJBeGlzSW5mby5saW5rR3JvdXA7XG5cbiAgICAgICAgICAgIC8vIElmIGF4aXMgaGFzIGJlZW4gdHJpZ2dlcmVkIGluIHRoZSBwcmV2aW91cyBzdGFnZSwgaXQgc2hvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgYnkgbGluay5cbiAgICAgICAgICAgIGlmIChsaW5rR3JvdXAgJiYgIXNob3dWYWx1ZU1hcFt0YXJLZXldKSB7XG4gICAgICAgICAgICAgICAgZWFjaChsaW5rR3JvdXAuYXhlc0luZm8sIGZ1bmN0aW9uIChzcmNBeGlzSW5mbywgc3JjS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcmNWYWxJdGVtID0gc2hvd1ZhbHVlTWFwW3NyY0tleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHNyY1ZhbEl0ZW0gZXhpc3QsIHNvdXJjZSBheGlzIGlzIHRyaWdnZXJlZCwgc28gbGluayB0byB0YXJnZXQgYXhpcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY0F4aXNJbmZvICE9PSB0YXJBeGlzSW5mbyAmJiBzcmNWYWxJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gc3JjVmFsSXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtHcm91cC5tYXBwZXIgJiYgKHZhbCA9IHRhckF4aXNJbmZvLmF4aXMuc2NhbGUucGFyc2UobGlua0dyb3VwLm1hcHBlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwsIG1ha2VNYXBwZXJQYXJhbShzcmNBeGlzSW5mbyksIG1ha2VNYXBwZXJQYXJhbSh0YXJBeGlzSW5mbylcbiAgICAgICAgICAgICAgICAgICAgICAgICkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtUcmlnZ2Vyc1t0YXJBeGlzSW5mby5rZXldID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoKGxpbmtUcmlnZ2VycywgZnVuY3Rpb24gKHZhbCwgdGFyS2V5KSB7XG4gICAgICAgICAgICBwcm9jZXNzT25BeGlzKGF4ZXNJbmZvW3RhcktleV0sIHZhbCwgdXBkYXRlcnMsIHRydWUsIG91dHB1dEZpbmRlcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHVwZGF0ZU1vZGVsQWN0dWFsbHkoc2hvd1ZhbHVlTWFwLCBheGVzSW5mbywgb3V0cHV0RmluZGVyKTtcbiAgICAgICAgZGlzcGF0Y2hUb29sdGlwQWN0dWFsbHkoZGF0YUJ5Q29vcmRTeXMsIHBvaW50LCBwYXlsb2FkLCBkaXNwYXRjaEFjdGlvbik7XG4gICAgICAgIGRpc3BhdGNoSGlnaERvd25BY3R1YWxseShheGVzSW5mbywgZGlzcGF0Y2hBY3Rpb24sIGFwaSk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dEZpbmRlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzT25BeGlzKGF4aXNJbmZvLCBuZXdWYWx1ZSwgdXBkYXRlcnMsIGRvbnRTbmFwLCBvdXRwdXRGaW5kZXIpIHtcbiAgICAgICAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuXG4gICAgICAgIGlmIChheGlzLnNjYWxlLmlzQmxhbmsoKSB8fCAhYXhpcy5jb250YWluRGF0YShuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYXhpc0luZm8uaW52b2x2ZVNlcmllcykge1xuICAgICAgICAgICAgdXBkYXRlcnMuc2hvd1BvaW50ZXIoYXhpc0luZm8sIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhlYXZ5IGNhbGN1bGF0aW9uLiBTbyBwdXQgaXQgYWZ0ZXIgYXhpcy5jb250YWluRGF0YSBjaGVja2luZy5cbiAgICAgICAgdmFyIHBheWxvYWRJbmZvID0gYnVpbGRQYXlsb2Fkc0J5U2VyaWVzKG5ld1ZhbHVlLCBheGlzSW5mbyk7XG4gICAgICAgIHZhciBwYXlsb2FkQmF0Y2ggPSBwYXlsb2FkSW5mby5wYXlsb2FkQmF0Y2g7XG4gICAgICAgIHZhciBzbmFwVG9WYWx1ZSA9IHBheWxvYWRJbmZvLnNuYXBUb1ZhbHVlO1xuXG4gICAgICAgIC8vIEZpbGwgY29udGVudCBvZiBldmVudCBvYmogZm9yIGVjaGFydHMuY29ubmVjdC5cbiAgICAgICAgLy8gQnkgZGVmdWFsdCB1c2UgdGhlIGZpcnN0IGludm9sdmVkIHNlcmllcyBkYXRhIGFzIGEgc2FtcGxlIHRvIGNvbm5lY3QuXG4gICAgICAgIGlmIChwYXlsb2FkQmF0Y2hbMF0gJiYgb3V0cHV0RmluZGVyLnNlcmllc0luZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHpyVXRpbC5leHRlbmQob3V0cHV0RmluZGVyLCBwYXlsb2FkQmF0Y2hbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gbGlua1NvdXJjZSBpbnB1dCwgdGhpcyBwcm9jZXNzIGlzIGZvciBjb2xsZWN0aW5nIGxpbmtcbiAgICAgICAgLy8gdGFyZ2V0LCB3aGVyZSBzbmFwIHNob3VsZCBub3QgYmUgYWNjZXB0ZWQuXG4gICAgICAgIGlmICghZG9udFNuYXAgJiYgYXhpc0luZm8uc25hcCkge1xuICAgICAgICAgICAgaWYgKGF4aXMuY29udGFpbkRhdGEoc25hcFRvVmFsdWUpICYmIHNuYXBUb1ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHNuYXBUb1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlcnMuc2hvd1BvaW50ZXIoYXhpc0luZm8sIG5ld1ZhbHVlLCBwYXlsb2FkQmF0Y2gsIG91dHB1dEZpbmRlcik7XG4gICAgICAgIC8vIFRvb2x0aXAgc2hvdWxkIGFsd2F5cyBiZSBzbmFwVG9WYWx1ZSwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmVcbiAgICAgICAgLy8gaW5jb3JyZWN0IFwiYXhpcyB2YWx1ZSB+IHNlcmllcyB2YWx1ZVwiIG1hcHBpbmcgZGlzcGxheWVkIGluIHRvb2x0aXAuXG4gICAgICAgIHVwZGF0ZXJzLnNob3dUb29sdGlwKGF4aXNJbmZvLCBwYXlsb2FkSW5mbywgc25hcFRvVmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkUGF5bG9hZHNCeVNlcmllcyh2YWx1ZSwgYXhpc0luZm8pIHtcbiAgICAgICAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuICAgICAgICB2YXIgZGltID0gYXhpcy5kaW07XG4gICAgICAgIHZhciBzbmFwVG9WYWx1ZSA9IHZhbHVlO1xuICAgICAgICB2YXIgcGF5bG9hZEJhdGNoID0gW107XG4gICAgICAgIHZhciBtaW5EaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIG1pbkRpZmYgPSAtMTtcblxuICAgICAgICBlYWNoKGF4aXNJbmZvLnNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllcywgaWR4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YURpbSA9IHNlcmllcy5jb29yZERpbVRvRGF0YURpbShkaW0pO1xuICAgICAgICAgICAgdmFyIHNlcmllc05lc3Rlc3RWYWx1ZTtcbiAgICAgICAgICAgIHZhciBkYXRhSW5kaWNlcztcblxuICAgICAgICAgICAgaWYgKHNlcmllcy5nZXRBeGlzVG9vbHRpcERhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2VyaWVzLmdldEF4aXNUb29sdGlwRGF0YShkYXRhRGltLCB2YWx1ZSwgYXhpcyk7XG4gICAgICAgICAgICAgICAgZGF0YUluZGljZXMgPSByZXN1bHQuZGF0YUluZGljZXM7XG4gICAgICAgICAgICAgICAgc2VyaWVzTmVzdGVzdFZhbHVlID0gcmVzdWx0Lm5lc3Rlc3RWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFJbmRpY2VzID0gc2VyaWVzLmdldERhdGEoKS5pbmRpY2VzT2ZOZWFyZXN0KFxuICAgICAgICAgICAgICAgICAgICBkYXRhRGltWzBdLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGEgdGhyZXNob2xkIHRvIGF2b2lkIGZpbmQgdGhlIHdyb25nIGRhdGFJbmRleFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGRhdGEgbGVuZ3RoIGlzIG5vdCBzYW1lLlxuICAgICAgICAgICAgICAgICAgICBmYWxzZSwgYXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gMC41IDogbnVsbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXJpZXNOZXN0ZXN0VmFsdWUgPSBzZXJpZXMuZ2V0RGF0YSgpLmdldChkYXRhRGltWzBdLCBkYXRhSW5kaWNlc1swXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXJpZXNOZXN0ZXN0VmFsdWUgPT0gbnVsbCB8fCAhaXNGaW5pdGUoc2VyaWVzTmVzdGVzdFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpZmYgPSB2YWx1ZSAtIHNlcmllc05lc3Rlc3RWYWx1ZTtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gTWF0aC5hYnMoZGlmZik7XG4gICAgICAgICAgICAvLyBDb25zaWRlciBjYXRlZ29yeSBjYXNlXG4gICAgICAgICAgICBpZiAoZGlzdCA8PSBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0IHx8IChkaWZmID49IDAgJiYgbWluRGlmZiA8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICBtaW5EaWZmID0gZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgc25hcFRvVmFsdWUgPSBzZXJpZXNOZXN0ZXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWRCYXRjaC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlYWNoKGRhdGFJbmRpY2VzLCBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWRCYXRjaC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzZXJpZXMuc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSW5kZXhJbnNpZGU6IGRhdGFJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJbmRleDogc2VyaWVzLmdldERhdGEoKS5nZXRSYXdJbmRleChkYXRhSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF5bG9hZEJhdGNoOiBwYXlsb2FkQmF0Y2gsXG4gICAgICAgICAgICBzbmFwVG9WYWx1ZTogc25hcFRvVmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG93UG9pbnRlcihzaG93VmFsdWVNYXAsIGF4aXNJbmZvLCB2YWx1ZSwgcGF5bG9hZEJhdGNoKSB7XG4gICAgICAgIHNob3dWYWx1ZU1hcFtheGlzSW5mby5rZXldID0ge3ZhbHVlOiB2YWx1ZSwgcGF5bG9hZEJhdGNoOiBwYXlsb2FkQmF0Y2h9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwKGRhdGFCeUNvb3JkU3lzLCBheGlzSW5mbywgcGF5bG9hZEluZm8sIHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXlsb2FkQmF0Y2ggPSBwYXlsb2FkSW5mby5wYXlsb2FkQmF0Y2g7XG4gICAgICAgIHZhciBheGlzID0gYXhpc0luZm8uYXhpcztcbiAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGF4aXMubW9kZWw7XG4gICAgICAgIHZhciBheGlzUG9pbnRlck1vZGVsID0gYXhpc0luZm8uYXhpc1BvaW50ZXJNb2RlbDtcblxuICAgICAgICAvLyBJZiBubyBkYXRhLCBkbyBub3QgY3JlYXRlIGFueXRoaW5nIGluIGRhdGFCeUNvb3JkU3lzLFxuICAgICAgICAvLyB3aG9zZSBsZW5ndGggd2lsbCBiZSB1c2VkIHRvIGp1ZGdlIHdoZXRoZXIgZGlzcGF0Y2ggYWN0aW9uLlxuICAgICAgICBpZiAoIWF4aXNJbmZvLnRyaWdnZXJUb29sdGlwIHx8ICFwYXlsb2FkQmF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29vcmRTeXNNb2RlbCA9IGF4aXNJbmZvLmNvb3JkU3lzLm1vZGVsO1xuICAgICAgICB2YXIgY29vcmRTeXNLZXkgPSBtb2RlbEhlbHBlci5tYWtlS2V5KGNvb3JkU3lzTW9kZWwpO1xuICAgICAgICB2YXIgY29vcmRTeXNJdGVtID0gZGF0YUJ5Q29vcmRTeXMubWFwW2Nvb3JkU3lzS2V5XTtcbiAgICAgICAgaWYgKCFjb29yZFN5c0l0ZW0pIHtcbiAgICAgICAgICAgIGNvb3JkU3lzSXRlbSA9IGRhdGFCeUNvb3JkU3lzLm1hcFtjb29yZFN5c0tleV0gPSB7XG4gICAgICAgICAgICAgICAgY29vcmRTeXNJZDogY29vcmRTeXNNb2RlbC5pZCxcbiAgICAgICAgICAgICAgICBjb29yZFN5c0luZGV4OiBjb29yZFN5c01vZGVsLmNvbXBvbmVudEluZGV4LFxuICAgICAgICAgICAgICAgIGNvb3JkU3lzVHlwZTogY29vcmRTeXNNb2RlbC50eXBlLFxuICAgICAgICAgICAgICAgIGNvb3JkU3lzTWFpblR5cGU6IGNvb3JkU3lzTW9kZWwubWFpblR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YUJ5QXhpczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkYXRhQnlDb29yZFN5cy5saXN0LnB1c2goY29vcmRTeXNJdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvb3JkU3lzSXRlbS5kYXRhQnlBeGlzLnB1c2goe1xuICAgICAgICAgICAgYXhpc0RpbTogYXhpcy5kaW0sXG4gICAgICAgICAgICBheGlzSW5kZXg6IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgICAgICAgIGF4aXNUeXBlOiBheGlzTW9kZWwudHlwZSxcbiAgICAgICAgICAgIGF4aXNJZDogYXhpc01vZGVsLmlkLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgLy8gQ2F1c3Rpb246IHZpZXdIZWxwZXIuZ2V0VmFsdWVMYWJlbCBpcyBhY3R1YWxseSBvbiBcInZpZXcgc3RhZ2VcIiwgd2hpY2hcbiAgICAgICAgICAgIC8vIGRlcGVuZHMgdGhhdCBhbGwgbW9kZWxzIGhhdmUgYmVlbiB1cGRhdGVkLiBTbyBpdCBzaG91bGQgbm90IGJlIHBlcmZvcm1lZFxuICAgICAgICAgICAgLy8gaGVyZS4gQ29uc2lkZXJpbmcgYXhpc1BvaW50ZXJNb2RlbCB1c2VkIGhlcmUgaXMgdm9sYXRpbGUsIHdoaWNoIGlzIGhhcmRcbiAgICAgICAgICAgIC8vIHRvIGJlIHJldHJpZXZlIGluIFRvb2x0aXBWaWV3LCB3ZSBwcmVwYXJlIHBhcmFtZXRlcnMgaGVyZS5cbiAgICAgICAgICAgIHZhbHVlTGFiZWxPcHQ6IHtcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdsYWJlbC5wcmVjaXNpb24nKSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdsYWJlbC5mb3JtYXR0ZXInKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcmllc0RhdGFJbmRpY2VzOiBwYXlsb2FkQmF0Y2guc2xpY2UoKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVNb2RlbEFjdHVhbGx5KHNob3dWYWx1ZU1hcCwgYXhlc0luZm8sIG91dHB1dEZpbmRlcikge1xuICAgICAgICB2YXIgb3V0cHV0QXhlc0luZm8gPSBvdXRwdXRGaW5kZXIuYXhlc0luZm8gPSBbXTtcbiAgICAgICAgLy8gQmFzaWMgbG9naWM6IElmIG5vICdzaG93JyByZXF1aXJlZCwgJ2hpZGUnIHRoaXMgYXhpc1BvaW50ZXIuXG4gICAgICAgIGVhY2goYXhlc0luZm8sIGZ1bmN0aW9uIChheGlzSW5mbywga2V5KSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gYXhpc0luZm8uYXhpc1BvaW50ZXJNb2RlbC5vcHRpb247XG4gICAgICAgICAgICB2YXIgdmFsSXRlbSA9IHNob3dWYWx1ZU1hcFtrZXldO1xuXG4gICAgICAgICAgICBpZiAodmFsSXRlbSkge1xuICAgICAgICAgICAgICAgICFheGlzSW5mby51c2VIYW5kbGUgJiYgKG9wdGlvbi5zdGF0dXMgPSAnc2hvdycpO1xuICAgICAgICAgICAgICAgIG9wdGlvbi52YWx1ZSA9IHZhbEl0ZW0udmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGxhYmVsIGZvcm1hdHRlciBwYXJhbSBhbmQgaGlnaGxpZ2h0LlxuICAgICAgICAgICAgICAgIG9wdGlvbi5zZXJpZXNEYXRhSW5kaWNlcyA9ICh2YWxJdGVtLnBheWxvYWRCYXRjaCB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdoZW4gYWx3YXlzIHNob3cgKGUuZy4sIGhhbmRsZSB1c2VkKSwgcmVtYWluXG4gICAgICAgICAgICAvLyBvcmlnaW5hbCB2YWx1ZSBhbmQgc3RhdHVzLlxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaGlkZSwgdmFsdWUgc3RpbGwgbmVlZCB0byBiZSBzZXQsIGNvbnNpZGVyXG4gICAgICAgICAgICAgICAgLy8gY2xpY2sgbGVnZW5kIHRvIHRvZ2dsZSBheGlzIGJsYW5rLlxuICAgICAgICAgICAgICAgICFheGlzSW5mby51c2VIYW5kbGUgJiYgKG9wdGlvbi5zdGF0dXMgPSAnaGlkZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBzdGF0dXMgaXMgJ2hpZGUnLCBzaG91bGQgYmUgbm8gaW5mbyBpbiBwYXlsb2FkLlxuICAgICAgICAgICAgb3B0aW9uLnN0YXR1cyA9PT0gJ3Nob3cnICYmIG91dHB1dEF4ZXNJbmZvLnB1c2goe1xuICAgICAgICAgICAgICAgIGF4aXNEaW06IGF4aXNJbmZvLmF4aXMuZGltLFxuICAgICAgICAgICAgICAgIGF4aXNJbmRleDogYXhpc0luZm8uYXhpcy5tb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9uLnZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hUb29sdGlwQWN0dWFsbHkoZGF0YUJ5Q29vcmRTeXMsIHBvaW50LCBwYXlsb2FkLCBkaXNwYXRjaEFjdGlvbikge1xuICAgICAgICAvLyBCYXNpYyBsb2dpYzogSWYgbm8gc2hvd1RpcCByZXF1aXJlZCwgaGlkZVRpcCB3aWxsIGJlIGRpc3BhdGNoZWQuXG4gICAgICAgIGlmIChpbGxlZ2FsUG9pbnQocG9pbnQpIHx8ICFkYXRhQnlDb29yZFN5cy5saXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hBY3Rpb24oe3R5cGU6ICdoaWRlVGlwJ30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW4gbW9zdCBjYXNlIG9ubHkgb25lIGF4aXMgKG9yIGV2ZW50IG9uZSBzZXJpZXMgaXMgdXNlZCkuIEl0IGlzXG4gICAgICAgIC8vIGNvbnZpbmllbnQgdG8gZmV0Y2ggcGF5bG9hZC5zZXJpZXNJbmRleCBhbmQgcGF5bG9hZC5kYXRhSW5kZXhcbiAgICAgICAgLy8gZGlydGVjdGx5LiBTbyBwdXQgdGhlIGZpcnN0IHNlcmllc0luZGV4IGFuZCBkYXRhSW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICAgIC8vIGF4aXMgb24gdGhlIHBheWxvYWQuXG4gICAgICAgIHZhciBzYW1wbGVJdGVtID0gKChkYXRhQnlDb29yZFN5cy5saXN0WzBdLmRhdGFCeUF4aXNbMF0gfHwge30pLnNlcmllc0RhdGFJbmRpY2VzIHx8IFtdKVswXSB8fCB7fTtcblxuICAgICAgICBkaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgICAgICAgICBlc2NhcGVDb25uZWN0OiB0cnVlLFxuICAgICAgICAgICAgeDogcG9pbnRbMF0sXG4gICAgICAgICAgICB5OiBwb2ludFsxXSxcbiAgICAgICAgICAgIHRvb2x0aXBPcHRpb246IHBheWxvYWQudG9vbHRpcE9wdGlvbixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwYXlsb2FkLnBvc2l0aW9uLFxuICAgICAgICAgICAgZGF0YUluZGV4SW5zaWRlOiBzYW1wbGVJdGVtLmRhdGFJbmRleEluc2lkZSxcbiAgICAgICAgICAgIGRhdGFJbmRleDogc2FtcGxlSXRlbS5kYXRhSW5kZXgsXG4gICAgICAgICAgICBzZXJpZXNJbmRleDogc2FtcGxlSXRlbS5zZXJpZXNJbmRleCxcbiAgICAgICAgICAgIGRhdGFCeUNvb3JkU3lzOiBkYXRhQnlDb29yZFN5cy5saXN0XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoSGlnaERvd25BY3R1YWxseShheGVzSW5mbywgZGlzcGF0Y2hBY3Rpb24sIGFwaSkge1xuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBoaWdobGlnaHQgc3RhdHVzIG1vZGlmaWNhdGlvbiBzaG91bGUgYmUgYSBzdGFnZSBvZiBtYWluIHByb2Nlc3M/XG4gICAgICAgIC8vIChDb25zaWRlciBjb25maWxjdCAoZS5nLiwgbGVnZW5kIGFuZCBheGlzUG9pbnRlcikgYW5kIHNldE9wdGlvbilcblxuICAgICAgICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcbiAgICAgICAgdmFyIGhpZ2hEb3duS2V5ID0gJ2F4aXNQb2ludGVyTGFzdEhpZ2hsaWdodHMnO1xuICAgICAgICB2YXIgbGFzdEhpZ2hsaWdodHMgPSBnZXQoenIpW2hpZ2hEb3duS2V5XSB8fCB7fTtcbiAgICAgICAgdmFyIG5ld0hpZ2hsaWdodHMgPSBnZXQoenIpW2hpZ2hEb3duS2V5XSA9IHt9O1xuXG4gICAgICAgIC8vIFVwZGF0ZSBoaWdobGlnaHQvZG93bnBsYXkgc3RhdHVzIGFjY29yZGluZyB0byBheGlzUG9pbnRlciBtb2RlbC5cbiAgICAgICAgLy8gQnVpbGQgaGFzaCBtYXAgYW5kIHJlbW92ZSBkdXBsaWNhdGUgaW5jaWRlbnRhbGx5LlxuICAgICAgICBlYWNoKGF4ZXNJbmZvLCBmdW5jdGlvbiAoYXhpc0luZm8sIGtleSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGF4aXNJbmZvLmF4aXNQb2ludGVyTW9kZWwub3B0aW9uO1xuICAgICAgICAgICAgb3B0aW9uLnN0YXR1cyA9PT0gJ3Nob3cnICYmIGVhY2gob3B0aW9uLnNlcmllc0RhdGFJbmRpY2VzLCBmdW5jdGlvbiAoYmF0Y2hJdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGJhdGNoSXRlbS5zZXJpZXNJbmRleCArICcgfCAnICsgYmF0Y2hJdGVtLmRhdGFJbmRleDtcbiAgICAgICAgICAgICAgICBuZXdIaWdobGlnaHRzW2tleV0gPSBiYXRjaEl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRGlmZi5cbiAgICAgICAgdmFyIHRvSGlnaGxpZ2h0ID0gW107XG4gICAgICAgIHZhciB0b0Rvd25wbGF5ID0gW107XG4gICAgICAgIHpyVXRpbC5lYWNoKGxhc3RIaWdobGlnaHRzLCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBrZXkpIHtcbiAgICAgICAgICAgICFuZXdIaWdobGlnaHRzW2tleV0gJiYgdG9Eb3ducGxheS5wdXNoKGJhdGNoSXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICB6clV0aWwuZWFjaChuZXdIaWdobGlnaHRzLCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBrZXkpIHtcbiAgICAgICAgICAgICFsYXN0SGlnaGxpZ2h0c1trZXldICYmIHRvSGlnaGxpZ2h0LnB1c2goYmF0Y2hJdGVtKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdG9Eb3ducGxheS5sZW5ndGggJiYgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdkb3ducGxheScsIGVzY2FwZUNvbm5lY3Q6IHRydWUsIGJhdGNoOiB0b0Rvd25wbGF5XG4gICAgICAgIH0pO1xuICAgICAgICB0b0hpZ2hsaWdodC5sZW5ndGggJiYgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdoaWdobGlnaHQnLCBlc2NhcGVDb25uZWN0OiB0cnVlLCBiYXRjaDogdG9IaWdobGlnaHRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZElucHV0QXhpc0luZm8oaW5wdXRBeGVzSW5mbywgYXhpc0luZm8pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoaW5wdXRBeGVzSW5mbyB8fCBbXSkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbnB1dEF4aXNJbmZvID0gaW5wdXRBeGVzSW5mb1tpXTtcbiAgICAgICAgICAgIGlmIChheGlzSW5mby5heGlzLmRpbSA9PT0gaW5wdXRBeGlzSW5mby5heGlzRGltXG4gICAgICAgICAgICAgICAgJiYgYXhpc0luZm8uYXhpcy5tb2RlbC5jb21wb25lbnRJbmRleCA9PT0gaW5wdXRBeGlzSW5mby5heGlzSW5kZXhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dEF4aXNJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZU1hcHBlclBhcmFtKGF4aXNJbmZvKSB7XG4gICAgICAgIHZhciBheGlzTW9kZWwgPSBheGlzSW5mby5heGlzLm1vZGVsO1xuICAgICAgICB2YXIgaXRlbSA9IHt9O1xuICAgICAgICB2YXIgZGltID0gaXRlbS5heGlzRGltID0gYXhpc0luZm8uYXhpcy5kaW07XG4gICAgICAgIGl0ZW0uYXhpc0luZGV4ID0gaXRlbVtkaW0gKyAnQXhpc0luZGV4J10gPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG4gICAgICAgIGl0ZW0uYXhpc05hbWUgPSBpdGVtW2RpbSArICdBeGlzTmFtZSddID0gYXhpc01vZGVsLm5hbWU7XG4gICAgICAgIGl0ZW0uYXhpc0lkID0gaXRlbVtkaW0gKyAnQXhpc0lkJ10gPSBheGlzTW9kZWwuaWQ7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlsbGVnYWxQb2ludChwb2ludCkge1xuICAgICAgICByZXR1cm4gIXBvaW50IHx8IHBvaW50WzBdID09IG51bGwgfHwgaXNOYU4ocG9pbnRbMF0pIHx8IHBvaW50WzFdID09IG51bGwgfHwgaXNOYU4ocG9pbnRbMV0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gYXhpc1RyaWdnZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL2F4aXNUcmlnZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n    var modelUtil = __webpack_require__(21);\n\n    /**\n     * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}\n     * @param {module:echarts/model/Global} ecModel\n     * @return {Object} {point: [x, y], el: ...} point Will not be null.\n     */\n    module.exports = function (finder, ecModel) {\n        var point = [];\n        var seriesIndex = finder.seriesIndex;\n        var seriesModel;\n        if (seriesIndex == null || !(\n            seriesModel = ecModel.getSeriesByIndex(seriesIndex)\n        )) {\n            return {point: []};\n        }\n\n        var data = seriesModel.getData();\n        var dataIndex = modelUtil.queryDataIndex(data, finder);\n        if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n            return {point: []};\n        }\n\n        var el = data.getItemGraphicEl(dataIndex);\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (seriesModel.getTooltipPosition) {\n            point = seriesModel.getTooltipPosition(dataIndex) || [];\n        }\n        else if (coordSys && coordSys.dataToPoint) {\n            point = coordSys.dataToPoint(\n                data.getValues(\n                    zrUtil.map(coordSys.dimensions, function (dim) {\n                        return seriesModel.coordDimToDataDim(dim)[0];\n                    }), dataIndex, true\n                )\n            ) || [];\n        }\n        else if (el) {\n            // Use graphic bounding rect\n            var rect = el.getBoundingRect().clone();\n            rect.applyTransform(el.transform);\n            point = [\n                rect.x + rect.width / 2,\n                rect.y + rect.height / 2\n            ];\n        }\n\n        return {point: point, el: el};\n    };\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9maW5kUG9pbnRGcm9tU2VyaWVzLmpzPzIxODkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPLGtCQUFrQjtBQUN4QyxlQUFlLDRCQUE0QjtBQUMzQyxnQkFBZ0IsT0FBTyxFQUFFLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQiIsImZpbGUiOiIxMzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9tb2RlbCcpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbmRlciBjb250YWlucyB7c2VyaWVzSW5kZXgsIGRhdGFJbmRleCwgZGF0YUluZGV4SW5zaWRlfVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB7cG9pbnQ6IFt4LCB5XSwgZWw6IC4uLn0gcG9pbnQgV2lsbCBub3QgYmUgbnVsbC5cbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmaW5kZXIsIGVjTW9kZWwpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gW107XG4gICAgICAgIHZhciBzZXJpZXNJbmRleCA9IGZpbmRlci5zZXJpZXNJbmRleDtcbiAgICAgICAgdmFyIHNlcmllc01vZGVsO1xuICAgICAgICBpZiAoc2VyaWVzSW5kZXggPT0gbnVsbCB8fCAhKFxuICAgICAgICAgICAgc2VyaWVzTW9kZWwgPSBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoc2VyaWVzSW5kZXgpXG4gICAgICAgICkpIHtcbiAgICAgICAgICAgIHJldHVybiB7cG9pbnQ6IFtdfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICB2YXIgZGF0YUluZGV4ID0gbW9kZWxVdGlsLnF1ZXJ5RGF0YUluZGV4KGRhdGEsIGZpbmRlcik7XG4gICAgICAgIGlmIChkYXRhSW5kZXggPT0gbnVsbCB8fCB6clV0aWwuaXNBcnJheShkYXRhSW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4ge3BvaW50OiBbXX07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWwgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4KTtcbiAgICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcblxuICAgICAgICBpZiAoc2VyaWVzTW9kZWwuZ2V0VG9vbHRpcFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBwb2ludCA9IHNlcmllc01vZGVsLmdldFRvb2x0aXBQb3NpdGlvbihkYXRhSW5kZXgpIHx8IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvb3JkU3lzICYmIGNvb3JkU3lzLmRhdGFUb1BvaW50KSB7XG4gICAgICAgICAgICBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KFxuICAgICAgICAgICAgICAgIGRhdGEuZ2V0VmFsdWVzKFxuICAgICAgICAgICAgICAgICAgICB6clV0aWwubWFwKGNvb3JkU3lzLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShkaW0pWzBdO1xuICAgICAgICAgICAgICAgICAgICB9KSwgZGF0YUluZGV4LCB0cnVlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB8fCBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbCkge1xuICAgICAgICAgICAgLy8gVXNlIGdyYXBoaWMgYm91bmRpbmcgcmVjdFxuICAgICAgICAgICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpO1xuICAgICAgICAgICAgcmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgcG9pbnQgPSBbXG4gICAgICAgICAgICAgICAgcmVjdC54ICsgcmVjdC53aWR0aCAvIDIsXG4gICAgICAgICAgICAgICAgcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtwb2ludDogcG9pbnQsIGVsOiBlbH07XG4gICAgfTtcblxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL2ZpbmRQb2ludEZyb21TZXJpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n\n    var echarts = __webpack_require__(17);\n\n    var AxisPointerModel = echarts.extendComponentModel({\n\n        type: 'axisPointer',\n\n        coordSysAxesInfo: null,\n\n        defaultOption: {\n            // 'auto' means that show when triggered by tooltip or handle.\n            show: 'auto',\n            // 'click' | 'mousemove' | 'none'\n            triggerOn: null, // set default in AxisPonterView.js\n\n            zlevel: 0,\n            z: 50,\n\n            type: 'line',\n            // axispointer triggered by tootip determine snap automatically,\n            // see `modelHelper`.\n            snap: false,\n            triggerTooltip: true,\n\n            value: null,\n            status: null, // Init value depends on whether handle is used.\n\n            // [group0, group1, ...]\n            // Each group can be: {\n            //      mapper: function () {},\n            //      singleTooltip: 'multiple',  // 'multiple' or 'single'\n            //      xAxisId: ...,\n            //      yAxisName: ...,\n            //      angleAxisIndex: ...\n            // }\n            // mapper: can be ignored.\n            //      input: {axisInfo, value}\n            //      output: {axisInfo, value}\n            link: [],\n\n            // Do not set 'auto' here, otherwise global animation: false\n            // will not effect at this axispointer.\n            animation: null,\n            animationDurationUpdate: 200,\n\n            lineStyle: {\n                color: '#aaa',\n                width: 1,\n                type: 'solid'\n            },\n\n            shadowStyle: {\n                color: 'rgba(150,150,150,0.3)'\n            },\n\n            label: {\n                show: true,\n                formatter: null, // string | Function\n                precision: 'auto', // Or a number like 0, 1, 2 ...\n                margin: 3,\n                textStyle: {\n                    color: '#fff'\n                },\n                padding: [5, 7, 5, 7],\n                backgroundColor: 'auto', // default: axis line color\n                borderColor: null,\n                borderWidth: 0,\n                shadowBlur: 3,\n                shadowColor: '#aaa'\n                // Considering applicability, common style should\n                // better not have shadowOffset.\n                // shadowOffsetX: 0,\n                // shadowOffsetY: 2\n            },\n\n            handle: {\n                show: false,\n                icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z', // jshint ignore:line\n                size: 45,\n                // handle margin is from symbol center to axis, which is stable when circular move.\n                margin: 50,\n                // color: '#1b8bbd'\n                // color: '#2f4554'\n                color: '#333',\n                shadowBlur: 3,\n                shadowColor: '#aaa',\n                shadowOffsetX: 0,\n                shadowOffsetY: 2,\n\n                // For mobile performance\n                throttle: 40\n            }\n        }\n\n    });\n\n    module.exports = AxisPointerModel;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9BeGlzUG9pbnRlck1vZGVsLmpzP2U5OWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUwiLCJmaWxlIjoiMTM0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKTtcblxuICAgIHZhciBBeGlzUG9pbnRlck1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG5cbiAgICAgICAgdHlwZTogJ2F4aXNQb2ludGVyJyxcblxuICAgICAgICBjb29yZFN5c0F4ZXNJbmZvOiBudWxsLFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIC8vICdhdXRvJyBtZWFucyB0aGF0IHNob3cgd2hlbiB0cmlnZ2VyZWQgYnkgdG9vbHRpcCBvciBoYW5kbGUuXG4gICAgICAgICAgICBzaG93OiAnYXV0bycsXG4gICAgICAgICAgICAvLyAnY2xpY2snIHwgJ21vdXNlbW92ZScgfCAnbm9uZSdcbiAgICAgICAgICAgIHRyaWdnZXJPbjogbnVsbCwgLy8gc2V0IGRlZmF1bHQgaW4gQXhpc1BvbnRlclZpZXcuanNcblxuICAgICAgICAgICAgemxldmVsOiAwLFxuICAgICAgICAgICAgejogNTAsXG5cbiAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgIC8vIGF4aXNwb2ludGVyIHRyaWdnZXJlZCBieSB0b290aXAgZGV0ZXJtaW5lIHNuYXAgYXV0b21hdGljYWxseSxcbiAgICAgICAgICAgIC8vIHNlZSBgbW9kZWxIZWxwZXJgLlxuICAgICAgICAgICAgc25hcDogZmFsc2UsXG4gICAgICAgICAgICB0cmlnZ2VyVG9vbHRpcDogdHJ1ZSxcblxuICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICBzdGF0dXM6IG51bGwsIC8vIEluaXQgdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIGhhbmRsZSBpcyB1c2VkLlxuXG4gICAgICAgICAgICAvLyBbZ3JvdXAwLCBncm91cDEsIC4uLl1cbiAgICAgICAgICAgIC8vIEVhY2ggZ3JvdXAgY2FuIGJlOiB7XG4gICAgICAgICAgICAvLyAgICAgIG1hcHBlcjogZnVuY3Rpb24gKCkge30sXG4gICAgICAgICAgICAvLyAgICAgIHNpbmdsZVRvb2x0aXA6ICdtdWx0aXBsZScsICAvLyAnbXVsdGlwbGUnIG9yICdzaW5nbGUnXG4gICAgICAgICAgICAvLyAgICAgIHhBeGlzSWQ6IC4uLixcbiAgICAgICAgICAgIC8vICAgICAgeUF4aXNOYW1lOiAuLi4sXG4gICAgICAgICAgICAvLyAgICAgIGFuZ2xlQXhpc0luZGV4OiAuLi5cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIG1hcHBlcjogY2FuIGJlIGlnbm9yZWQuXG4gICAgICAgICAgICAvLyAgICAgIGlucHV0OiB7YXhpc0luZm8sIHZhbHVlfVxuICAgICAgICAgICAgLy8gICAgICBvdXRwdXQ6IHtheGlzSW5mbywgdmFsdWV9XG4gICAgICAgICAgICBsaW5rOiBbXSxcblxuICAgICAgICAgICAgLy8gRG8gbm90IHNldCAnYXV0bycgaGVyZSwgb3RoZXJ3aXNlIGdsb2JhbCBhbmltYXRpb246IGZhbHNlXG4gICAgICAgICAgICAvLyB3aWxsIG5vdCBlZmZlY3QgYXQgdGhpcyBheGlzcG9pbnRlci5cbiAgICAgICAgICAgIGFuaW1hdGlvbjogbnVsbCxcbiAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlOiAyMDAsXG5cbiAgICAgICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2FhYScsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2hhZG93U3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMTUwLDE1MCwxNTAsMC4zKSdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IG51bGwsIC8vIHN0cmluZyB8IEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiAnYXV0bycsIC8vIE9yIGEgbnVtYmVyIGxpa2UgMCwgMSwgMiAuLi5cbiAgICAgICAgICAgICAgICBtYXJnaW46IDMsXG4gICAgICAgICAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IFs1LCA3LCA1LCA3XSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdhdXRvJywgLy8gZGVmYXVsdDogYXhpcyBsaW5lIGNvbG9yXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgc2hhZG93Qmx1cjogMyxcbiAgICAgICAgICAgICAgICBzaGFkb3dDb2xvcjogJyNhYWEnXG4gICAgICAgICAgICAgICAgLy8gQ29uc2lkZXJpbmcgYXBwbGljYWJpbGl0eSwgY29tbW9uIHN0eWxlIHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIGJldHRlciBub3QgaGF2ZSBzaGFkb3dPZmZzZXQuXG4gICAgICAgICAgICAgICAgLy8gc2hhZG93T2Zmc2V0WDogMCxcbiAgICAgICAgICAgICAgICAvLyBzaGFkb3dPZmZzZXRZOiAyXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBoYW5kbGU6IHtcbiAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpY29uOiAnTTEwLjcsMTEuOXYtMS4zSDkuM3YxLjNjLTQuOSwwLjMtOC44LDQuNC04LjgsOS40YzAsNSwzLjksOS4xLDguOCw5LjRoMS4zYzQuOS0wLjMsOC44LTQuNCw4LjgtOS40QzE5LjUsMTYuMywxNS42LDEyLjIsMTAuNywxMS45eiBNMTMuMywyNC40SDYuN3YtMS4yaDYuNnogTTEzLjMsMjJINi43di0xLjJoNi42eiBNMTMuMywxOS42SDYuN3YtMS4yaDYuNnonLCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgICAgICBzaXplOiA0NSxcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgbWFyZ2luIGlzIGZyb20gc3ltYm9sIGNlbnRlciB0byBheGlzLCB3aGljaCBpcyBzdGFibGUgd2hlbiBjaXJjdWxhciBtb3ZlLlxuICAgICAgICAgICAgICAgIG1hcmdpbjogNTAsXG4gICAgICAgICAgICAgICAgLy8gY29sb3I6ICcjMWI4YmJkJ1xuICAgICAgICAgICAgICAgIC8vIGNvbG9yOiAnIzJmNDU1NCdcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMzMzMnLFxuICAgICAgICAgICAgICAgIHNoYWRvd0JsdXI6IDMsXG4gICAgICAgICAgICAgICAgc2hhZG93Q29sb3I6ICcjYWFhJyxcbiAgICAgICAgICAgICAgICBzaGFkb3dPZmZzZXRYOiAwLFxuICAgICAgICAgICAgICAgIHNoYWRvd09mZnNldFk6IDIsXG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgbW9iaWxlIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgdGhyb3R0bGU6IDQwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBeGlzUG9pbnRlck1vZGVsO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0F4aXNQb2ludGVyTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n\n    var globalListener = __webpack_require__(136);\n\n    var AxisPonterView = __webpack_require__(17).extendComponentView({\n\n        type: 'axisPointer',\n\n        render: function (globalAxisPointerModel, ecModel, api) {\n            var globalTooltipModel = ecModel.getComponent('tooltip');\n            var triggerOn = globalAxisPointerModel.get('triggerOn')\n                || (globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click');\n\n            // Register global listener in AxisPointerView to enable\n            // AxisPointerView to be independent to Tooltip.\n            globalListener.register(\n                'axisPointer',\n                api,\n                function (currTrigger, e, dispatchAction) {\n                    // If 'none', it is not controlled by mouse totally.\n                    if (triggerOn !== 'none'\n                        && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)\n                    ) {\n                        dispatchAction({\n                            type: 'updateAxisPointer',\n                            currTrigger: currTrigger,\n                            x: e && e.offsetX,\n                            y: e && e.offsetY\n                        });\n                    }\n                }\n            );\n        },\n\n        /**\n         * @override\n         */\n        remove: function (ecModel, api) {\n            globalListener.disopse(api.getZr(), 'axisPointer');\n            AxisPonterView.superApply(this._model, 'remove', arguments);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function (ecModel, api) {\n            globalListener.unregister('axisPointer', api);\n            AxisPonterView.superApply(this._model, 'dispose', arguments);\n        }\n\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9BeGlzUG9pbnRlclZpZXcuanM/NDI5MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSyIsImZpbGUiOiIxMzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBnbG9iYWxMaXN0ZW5lciA9IHJlcXVpcmUoJy4vZ2xvYmFsTGlzdGVuZXInKTtcblxuICAgIHZhciBBeGlzUG9udGVyVmlldyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRDb21wb25lbnRWaWV3KHtcblxuICAgICAgICB0eXBlOiAnYXhpc1BvaW50ZXInLFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKGdsb2JhbEF4aXNQb2ludGVyTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGdsb2JhbFRvb2x0aXBNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCd0b29sdGlwJyk7XG4gICAgICAgICAgICB2YXIgdHJpZ2dlck9uID0gZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3RyaWdnZXJPbicpXG4gICAgICAgICAgICAgICAgfHwgKGdsb2JhbFRvb2x0aXBNb2RlbCAmJiBnbG9iYWxUb29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyT24nKSB8fCAnbW91c2Vtb3ZlfGNsaWNrJyk7XG5cbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIGdsb2JhbCBsaXN0ZW5lciBpbiBBeGlzUG9pbnRlclZpZXcgdG8gZW5hYmxlXG4gICAgICAgICAgICAvLyBBeGlzUG9pbnRlclZpZXcgdG8gYmUgaW5kZXBlbmRlbnQgdG8gVG9vbHRpcC5cbiAgICAgICAgICAgIGdsb2JhbExpc3RlbmVyLnJlZ2lzdGVyKFxuICAgICAgICAgICAgICAgICdheGlzUG9pbnRlcicsXG4gICAgICAgICAgICAgICAgYXBpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjdXJyVHJpZ2dlciwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgJ25vbmUnLCBpdCBpcyBub3QgY29udHJvbGxlZCBieSBtb3VzZSB0b3RhbGx5LlxuICAgICAgICAgICAgICAgICAgICBpZiAodHJpZ2dlck9uICE9PSAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChjdXJyVHJpZ2dlciA9PT0gJ2xlYXZlJyB8fCB0cmlnZ2VyT24uaW5kZXhPZihjdXJyVHJpZ2dlcikgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VwZGF0ZUF4aXNQb2ludGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyVHJpZ2dlcjogY3VyclRyaWdnZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogZSAmJiBlLm9mZnNldFgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogZSAmJiBlLm9mZnNldFlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIGdsb2JhbExpc3RlbmVyLmRpc29wc2UoYXBpLmdldFpyKCksICdheGlzUG9pbnRlcicpO1xuICAgICAgICAgICAgQXhpc1BvbnRlclZpZXcuc3VwZXJBcHBseSh0aGlzLl9tb2RlbCwgJ3JlbW92ZScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgZ2xvYmFsTGlzdGVuZXIudW5yZWdpc3RlcignYXhpc1BvaW50ZXInLCBhcGkpO1xuICAgICAgICAgICAgQXhpc1BvbnRlclZpZXcuc3VwZXJBcHBseSh0aGlzLl9tb2RlbCwgJ2Rpc3Bvc2UnLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9BeGlzUG9pbnRlclZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n\n    var env = __webpack_require__(18);\n    var zrUtil = __webpack_require__(20);\n    var get = __webpack_require__(21).makeGetter();\n\n    var each = zrUtil.each;\n\n    var globalListener = {};\n\n    /**\n     * @param {string} key\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Function} handler\n     *      param: {string} currTrigger\n     *      param: {Array.<number>} point\n     */\n    globalListener.register = function (key, api, handler) {\n        if (env.node) {\n            return;\n        }\n\n        var zr = api.getZr();\n        get(zr).records || (get(zr).records = {});\n\n        initGlobalListeners(zr, api);\n\n        var record = get(zr).records[key] || (get(zr).records[key] = {});\n        record.handler = handler;\n    };\n\n    function initGlobalListeners(zr, api) {\n        if (get(zr).initialized) {\n            return;\n        }\n\n        get(zr).initialized = true;\n\n        useHandler('click', zrUtil.curry(doEnter, 'click'));\n        useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove'));\n        // useHandler('mouseout', onLeave);\n        useHandler('globalout', onLeave);\n\n        function useHandler(eventType, cb) {\n            zr.on(eventType, function (e) {\n                var dis = makeDispatchAction(api);\n\n                each(get(zr).records, function (record) {\n                    record && cb(record, e, dis.dispatchAction);\n                });\n\n                dispatchTooltipFinally(dis.pendings, api);\n            });\n        }\n    }\n\n    function dispatchTooltipFinally(pendings, api) {\n        var showLen = pendings.showTip.length;\n        var hideLen = pendings.hideTip.length;\n\n        var actuallyPayload;\n        if (showLen) {\n            actuallyPayload = pendings.showTip[showLen - 1];\n        }\n        else if (hideLen) {\n            actuallyPayload = pendings.hideTip[hideLen - 1];\n        }\n        if (actuallyPayload) {\n            actuallyPayload.dispatchAction = null;\n            api.dispatchAction(actuallyPayload);\n        }\n    }\n\n    function onLeave(record, e, dispatchAction) {\n        record.handler('leave', null, dispatchAction);\n    }\n\n    function doEnter(currTrigger, record, e, dispatchAction) {\n        record.handler(currTrigger, e, dispatchAction);\n    }\n\n    function makeDispatchAction(api) {\n        var pendings = {\n            showTip: [],\n            hideTip: []\n        };\n        // FIXME\n        // better approach?\n        // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\n        // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\n        // So we have to add \"final stage\" to merge those dispatched actions.\n        var dispatchAction = function (payload) {\n            var pendingList = pendings[payload.type];\n            if (pendingList) {\n                pendingList.push(payload);\n            }\n            else {\n                payload.dispatchAction = dispatchAction;\n                api.dispatchAction(payload);\n            }\n        };\n\n        return {\n            dispatchAction: dispatchAction,\n            pendings: pendings\n        };\n    }\n\n    /**\n     * @param {string} key\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    globalListener.unregister = function (key, api) {\n        if (env.node) {\n            return;\n        }\n        var zr = api.getZr();\n        var record = (get(zr).records || {})[key];\n        if (record) {\n            get(zr).records[key] = null;\n        }\n    };\n\n    module.exports = globalListener;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9nbG9iYWxMaXN0ZW5lci5qcz8wMGNmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsU0FBUztBQUN4QixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEOztBQUVoRDs7QUFFQSx1RUFBdUU7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxMzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2VudicpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZ2V0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9tb2RlbCcpLm1ha2VHZXR0ZXIoKTtcblxuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG5cbiAgICB2YXIgZ2xvYmFsTGlzdGVuZXIgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqICAgICAgcGFyYW06IHtzdHJpbmd9IGN1cnJUcmlnZ2VyXG4gICAgICogICAgICBwYXJhbToge0FycmF5LjxudW1iZXI+fSBwb2ludFxuICAgICAqL1xuICAgIGdsb2JhbExpc3RlbmVyLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGtleSwgYXBpLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChlbnYubm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHpyID0gYXBpLmdldFpyKCk7XG4gICAgICAgIGdldCh6cikucmVjb3JkcyB8fCAoZ2V0KHpyKS5yZWNvcmRzID0ge30pO1xuXG4gICAgICAgIGluaXRHbG9iYWxMaXN0ZW5lcnMoenIsIGFwaSk7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IGdldCh6cikucmVjb3Jkc1trZXldIHx8IChnZXQoenIpLnJlY29yZHNba2V5XSA9IHt9KTtcbiAgICAgICAgcmVjb3JkLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbml0R2xvYmFsTGlzdGVuZXJzKHpyLCBhcGkpIHtcbiAgICAgICAgaWYgKGdldCh6cikuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldCh6cikuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAgIHVzZUhhbmRsZXIoJ2NsaWNrJywgenJVdGlsLmN1cnJ5KGRvRW50ZXIsICdjbGljaycpKTtcbiAgICAgICAgdXNlSGFuZGxlcignbW91c2Vtb3ZlJywgenJVdGlsLmN1cnJ5KGRvRW50ZXIsICdtb3VzZW1vdmUnKSk7XG4gICAgICAgIC8vIHVzZUhhbmRsZXIoJ21vdXNlb3V0Jywgb25MZWF2ZSk7XG4gICAgICAgIHVzZUhhbmRsZXIoJ2dsb2JhbG91dCcsIG9uTGVhdmUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHVzZUhhbmRsZXIoZXZlbnRUeXBlLCBjYikge1xuICAgICAgICAgICAgenIub24oZXZlbnRUeXBlLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBkaXMgPSBtYWtlRGlzcGF0Y2hBY3Rpb24oYXBpKTtcblxuICAgICAgICAgICAgICAgIGVhY2goZ2V0KHpyKS5yZWNvcmRzLCBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCAmJiBjYihyZWNvcmQsIGUsIGRpcy5kaXNwYXRjaEFjdGlvbik7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkaXNwYXRjaFRvb2x0aXBGaW5hbGx5KGRpcy5wZW5kaW5ncywgYXBpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hUb29sdGlwRmluYWxseShwZW5kaW5ncywgYXBpKSB7XG4gICAgICAgIHZhciBzaG93TGVuID0gcGVuZGluZ3Muc2hvd1RpcC5sZW5ndGg7XG4gICAgICAgIHZhciBoaWRlTGVuID0gcGVuZGluZ3MuaGlkZVRpcC5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGFjdHVhbGx5UGF5bG9hZDtcbiAgICAgICAgaWYgKHNob3dMZW4pIHtcbiAgICAgICAgICAgIGFjdHVhbGx5UGF5bG9hZCA9IHBlbmRpbmdzLnNob3dUaXBbc2hvd0xlbiAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhpZGVMZW4pIHtcbiAgICAgICAgICAgIGFjdHVhbGx5UGF5bG9hZCA9IHBlbmRpbmdzLmhpZGVUaXBbaGlkZUxlbiAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3R1YWxseVBheWxvYWQpIHtcbiAgICAgICAgICAgIGFjdHVhbGx5UGF5bG9hZC5kaXNwYXRjaEFjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oYWN0dWFsbHlQYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTGVhdmUocmVjb3JkLCBlLCBkaXNwYXRjaEFjdGlvbikge1xuICAgICAgICByZWNvcmQuaGFuZGxlcignbGVhdmUnLCBudWxsLCBkaXNwYXRjaEFjdGlvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9FbnRlcihjdXJyVHJpZ2dlciwgcmVjb3JkLCBlLCBkaXNwYXRjaEFjdGlvbikge1xuICAgICAgICByZWNvcmQuaGFuZGxlcihjdXJyVHJpZ2dlciwgZSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VEaXNwYXRjaEFjdGlvbihhcGkpIHtcbiAgICAgICAgdmFyIHBlbmRpbmdzID0ge1xuICAgICAgICAgICAgc2hvd1RpcDogW10sXG4gICAgICAgICAgICBoaWRlVGlwOiBbXVxuICAgICAgICB9O1xuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBiZXR0ZXIgYXBwcm9hY2g/XG4gICAgICAgIC8vICdzaG93VGlwJyBhbmQgJ2hpZGVUaXAnIGNhbiBiZSB0cmlnZ2VyZWQgYnkgYXhpc1BvaW50ZXIgYW5kIHRvb2x0aXAsXG4gICAgICAgIC8vIHdoaWNoIG1heSBiZSBjb25mbGljdCwgKGF4aXNQb2ludGVyIGNhbGwgc2hvd1RpcCBidXQgdG9vbHRpcCBjYWxsIGhpZGVUaXApO1xuICAgICAgICAvLyBTbyB3ZSBoYXZlIHRvIGFkZCBcImZpbmFsIHN0YWdlXCIgdG8gbWVyZ2UgdGhvc2UgZGlzcGF0Y2hlZCBhY3Rpb25zLlxuICAgICAgICB2YXIgZGlzcGF0Y2hBY3Rpb24gPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIHBlbmRpbmdMaXN0ID0gcGVuZGluZ3NbcGF5bG9hZC50eXBlXTtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nTGlzdCkge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdMaXN0LnB1c2gocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmRpc3BhdGNoQWN0aW9uID0gZGlzcGF0Y2hBY3Rpb247XG4gICAgICAgICAgICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXNwYXRjaEFjdGlvbjogZGlzcGF0Y2hBY3Rpb24sXG4gICAgICAgICAgICBwZW5kaW5nczogcGVuZGluZ3NcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAqL1xuICAgIGdsb2JhbExpc3RlbmVyLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiAoa2V5LCBhcGkpIHtcbiAgICAgICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHpyID0gYXBpLmdldFpyKCk7XG4gICAgICAgIHZhciByZWNvcmQgPSAoZ2V0KHpyKS5yZWNvcmRzIHx8IHt9KVtrZXldO1xuICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICBnZXQoenIpLnJlY29yZHNba2V5XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWxMaXN0ZW5lcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvZ2xvYmFsTGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var graphic = __webpack_require__(34);\n    var BaseAxisPointer = __webpack_require__(138);\n    var viewHelper = __webpack_require__(139);\n    var cartesianAxisHelper = __webpack_require__(141);\n    var AxisView = __webpack_require__(142);\n\n    var CartesianAxisPointer = BaseAxisPointer.extend({\n\n        /**\n         * @override\n         */\n        makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n            var axis = axisModel.axis;\n            var grid = axis.grid;\n            var axisPointerType = axisPointerModel.get('type');\n            var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n            var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n\n            if (axisPointerType && axisPointerType !== 'none') {\n                var elStyle = viewHelper.buildElStyle(axisPointerModel);\n                var pointerOption = pointerShapeBuilder[axisPointerType](\n                    axis, pixelValue, otherExtent, elStyle\n                );\n                pointerOption.style = elStyle;\n                elOption.graphicKey = pointerOption.type;\n                elOption.pointer = pointerOption;\n            }\n\n            var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);\n            viewHelper.buildCartesianSingleLabelElOption(\n                value, elOption, layoutInfo, axisModel, axisPointerModel, api\n            );\n        },\n\n        /**\n         * @override\n         */\n        getHandleTransform: function (value, axisModel, axisPointerModel) {\n            var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {\n                labelInside: false\n            });\n            layoutInfo.labelMargin = axisPointerModel.get('handle.margin');\n            return {\n                position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n                rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n            };\n        },\n\n        /**\n         * @override\n         */\n        updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {\n            var axis = axisModel.axis;\n            var grid = axis.grid;\n            var axisExtent = axis.getGlobalExtent(true);\n            var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n            var dimIndex = axis.dim === 'x' ? 0 : 1;\n\n            var currPosition = transform.position;\n            currPosition[dimIndex] += delta[dimIndex];\n            currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n            currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n\n            var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n            var cursorPoint = [cursorOtherValue, cursorOtherValue];\n            cursorPoint[dimIndex] = currPosition[dimIndex];\n\n            // Make tooltip do not overlap axisPointer and in the middle of the grid.\n            var tooltipOptions = [{verticalAlign: 'middle'}, {align: 'center'}];\n\n            return {\n                position: currPosition,\n                rotation: transform.rotation,\n                cursorPoint: cursorPoint,\n                tooltipOption: tooltipOptions[dimIndex]\n            };\n        }\n\n    });\n\n    function getCartesian(grid, axis) {\n        var opt = {};\n        opt[axis.dim + 'AxisIndex'] = axis.index;\n        return grid.getCartesian(opt);\n    }\n\n    var pointerShapeBuilder = {\n\n        line: function (axis, pixelValue, otherExtent, elStyle) {\n            var targetShape = viewHelper.makeLineShape(\n                [pixelValue, otherExtent[0]],\n                [pixelValue, otherExtent[1]],\n                getAxisDimIndex(axis)\n            );\n            graphic.subPixelOptimizeLine({\n                shape: targetShape,\n                style: elStyle\n            });\n            return {\n                type: 'Line',\n                shape: targetShape\n            };\n        },\n\n        shadow: function (axis, pixelValue, otherExtent, elStyle) {\n            var bandWidth = axis.getBandWidth();\n            var span = otherExtent[1] - otherExtent[0];\n            return {\n                type: 'Rect',\n                shape: viewHelper.makeRectShape(\n                    [pixelValue - bandWidth / 2, otherExtent[0]],\n                    [bandWidth, span],\n                    getAxisDimIndex(axis)\n                )\n            };\n        }\n    };\n\n    function getAxisDimIndex(axis) {\n        return axis.dim === 'x' ? 0 : 1;\n    }\n\n    AxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);\n\n    module.exports = CartesianAxisPointer;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9DYXJ0ZXNpYW5BeGlzUG9pbnRlci5qcz9hYjFlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLHdCQUF3QixHQUFHLGdCQUFnQjs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjEzNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgQmFzZUF4aXNQb2ludGVyID0gcmVxdWlyZSgnLi9CYXNlQXhpc1BvaW50ZXInKTtcbiAgICB2YXIgdmlld0hlbHBlciA9IHJlcXVpcmUoJy4vdmlld0hlbHBlcicpO1xuICAgIHZhciBjYXJ0ZXNpYW5BeGlzSGVscGVyID0gcmVxdWlyZSgnLi4vYXhpcy9jYXJ0ZXNpYW5BeGlzSGVscGVyJyk7XG4gICAgdmFyIEF4aXNWaWV3ID0gcmVxdWlyZSgnLi4vYXhpcy9BeGlzVmlldycpO1xuXG4gICAgdmFyIENhcnRlc2lhbkF4aXNQb2ludGVyID0gQmFzZUF4aXNQb2ludGVyLmV4dGVuZCh7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgbWFrZUVsT3B0aW9uOiBmdW5jdGlvbiAoZWxPcHRpb24sIHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICAgICAgICAgIHZhciBncmlkID0gYXhpcy5ncmlkO1xuICAgICAgICAgICAgdmFyIGF4aXNQb2ludGVyVHlwZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJyk7XG4gICAgICAgICAgICB2YXIgb3RoZXJFeHRlbnQgPSBnZXRDYXJ0ZXNpYW4oZ3JpZCwgYXhpcykuZ2V0T3RoZXJBeGlzKGF4aXMpLmdldEdsb2JhbEV4dGVudCgpO1xuICAgICAgICAgICAgdmFyIHBpeGVsVmFsdWUgPSBheGlzLnRvR2xvYmFsQ29vcmQoYXhpcy5kYXRhVG9Db29yZCh2YWx1ZSwgdHJ1ZSkpO1xuXG4gICAgICAgICAgICBpZiAoYXhpc1BvaW50ZXJUeXBlICYmIGF4aXNQb2ludGVyVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsU3R5bGUgPSB2aWV3SGVscGVyLmJ1aWxkRWxTdHlsZShheGlzUG9pbnRlck1vZGVsKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRlck9wdGlvbiA9IHBvaW50ZXJTaGFwZUJ1aWxkZXJbYXhpc1BvaW50ZXJUeXBlXShcbiAgICAgICAgICAgICAgICAgICAgYXhpcywgcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnQsIGVsU3R5bGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJPcHRpb24uc3R5bGUgPSBlbFN0eWxlO1xuICAgICAgICAgICAgICAgIGVsT3B0aW9uLmdyYXBoaWNLZXkgPSBwb2ludGVyT3B0aW9uLnR5cGU7XG4gICAgICAgICAgICAgICAgZWxPcHRpb24ucG9pbnRlciA9IHBvaW50ZXJPcHRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsYXlvdXRJbmZvID0gY2FydGVzaWFuQXhpc0hlbHBlci5sYXlvdXQoZ3JpZC5tb2RlbCwgYXhpc01vZGVsKTtcbiAgICAgICAgICAgIHZpZXdIZWxwZXIuYnVpbGRDYXJ0ZXNpYW5TaW5nbGVMYWJlbEVsT3B0aW9uKFxuICAgICAgICAgICAgICAgIHZhbHVlLCBlbE9wdGlvbiwgbGF5b3V0SW5mbywgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGFuZGxlVHJhbnNmb3JtOiBmdW5jdGlvbiAodmFsdWUsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGxheW91dEluZm8gPSBjYXJ0ZXNpYW5BeGlzSGVscGVyLmxheW91dChheGlzTW9kZWwuYXhpcy5ncmlkLm1vZGVsLCBheGlzTW9kZWwsIHtcbiAgICAgICAgICAgICAgICBsYWJlbEluc2lkZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGF5b3V0SW5mby5sYWJlbE1hcmdpbiA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdoYW5kbGUubWFyZ2luJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB2aWV3SGVscGVyLmdldFRyYW5zZm9ybWVkUG9zaXRpb24oYXhpc01vZGVsLmF4aXMsIHZhbHVlLCBsYXlvdXRJbmZvKSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogbGF5b3V0SW5mby5yb3RhdGlvbiArIChsYXlvdXRJbmZvLmxhYmVsRGlyZWN0aW9uIDwgMCA/IE1hdGguUEkgOiAwKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVIYW5kbGVUcmFuc2Zvcm06IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIGRlbHRhLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IGF4aXMuZ3JpZDtcbiAgICAgICAgICAgIHZhciBheGlzRXh0ZW50ID0gYXhpcy5nZXRHbG9iYWxFeHRlbnQodHJ1ZSk7XG4gICAgICAgICAgICB2YXIgb3RoZXJFeHRlbnQgPSBnZXRDYXJ0ZXNpYW4oZ3JpZCwgYXhpcykuZ2V0T3RoZXJBeGlzKGF4aXMpLmdldEdsb2JhbEV4dGVudCgpO1xuICAgICAgICAgICAgdmFyIGRpbUluZGV4ID0gYXhpcy5kaW0gPT09ICd4JyA/IDAgOiAxO1xuXG4gICAgICAgICAgICB2YXIgY3VyclBvc2l0aW9uID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgICAgICAgICAgY3VyclBvc2l0aW9uW2RpbUluZGV4XSArPSBkZWx0YVtkaW1JbmRleF07XG4gICAgICAgICAgICBjdXJyUG9zaXRpb25bZGltSW5kZXhdID0gTWF0aC5taW4oYXhpc0V4dGVudFsxXSwgY3VyclBvc2l0aW9uW2RpbUluZGV4XSk7XG4gICAgICAgICAgICBjdXJyUG9zaXRpb25bZGltSW5kZXhdID0gTWF0aC5tYXgoYXhpc0V4dGVudFswXSwgY3VyclBvc2l0aW9uW2RpbUluZGV4XSk7XG5cbiAgICAgICAgICAgIHZhciBjdXJzb3JPdGhlclZhbHVlID0gKG90aGVyRXh0ZW50WzFdICsgb3RoZXJFeHRlbnRbMF0pIC8gMjtcbiAgICAgICAgICAgIHZhciBjdXJzb3JQb2ludCA9IFtjdXJzb3JPdGhlclZhbHVlLCBjdXJzb3JPdGhlclZhbHVlXTtcbiAgICAgICAgICAgIGN1cnNvclBvaW50W2RpbUluZGV4XSA9IGN1cnJQb3NpdGlvbltkaW1JbmRleF07XG5cbiAgICAgICAgICAgIC8vIE1ha2UgdG9vbHRpcCBkbyBub3Qgb3ZlcmxhcCBheGlzUG9pbnRlciBhbmQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgZ3JpZC5cbiAgICAgICAgICAgIHZhciB0b29sdGlwT3B0aW9ucyA9IFt7dmVydGljYWxBbGlnbjogJ21pZGRsZSd9LCB7YWxpZ246ICdjZW50ZXInfV07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGN1cnJQb3NpdGlvbixcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogdHJhbnNmb3JtLnJvdGF0aW9uLFxuICAgICAgICAgICAgICAgIGN1cnNvclBvaW50OiBjdXJzb3JQb2ludCxcbiAgICAgICAgICAgICAgICB0b29sdGlwT3B0aW9uOiB0b29sdGlwT3B0aW9uc1tkaW1JbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q2FydGVzaWFuKGdyaWQsIGF4aXMpIHtcbiAgICAgICAgdmFyIG9wdCA9IHt9O1xuICAgICAgICBvcHRbYXhpcy5kaW0gKyAnQXhpc0luZGV4J10gPSBheGlzLmluZGV4O1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRDYXJ0ZXNpYW4ob3B0KTtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnRlclNoYXBlQnVpbGRlciA9IHtcblxuICAgICAgICBsaW5lOiBmdW5jdGlvbiAoYXhpcywgcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnQsIGVsU3R5bGUpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRTaGFwZSA9IHZpZXdIZWxwZXIubWFrZUxpbmVTaGFwZShcbiAgICAgICAgICAgICAgICBbcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnRbMF1dLFxuICAgICAgICAgICAgICAgIFtwaXhlbFZhbHVlLCBvdGhlckV4dGVudFsxXV0sXG4gICAgICAgICAgICAgICAgZ2V0QXhpc0RpbUluZGV4KGF4aXMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSh7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHRhcmdldFNoYXBlLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBlbFN0eWxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0xpbmUnLFxuICAgICAgICAgICAgICAgIHNoYXBlOiB0YXJnZXRTaGFwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaGFkb3c6IGZ1bmN0aW9uIChheGlzLCBwaXhlbFZhbHVlLCBvdGhlckV4dGVudCwgZWxTdHlsZSkge1xuICAgICAgICAgICAgdmFyIGJhbmRXaWR0aCA9IGF4aXMuZ2V0QmFuZFdpZHRoKCk7XG4gICAgICAgICAgICB2YXIgc3BhbiA9IG90aGVyRXh0ZW50WzFdIC0gb3RoZXJFeHRlbnRbMF07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdSZWN0JyxcbiAgICAgICAgICAgICAgICBzaGFwZTogdmlld0hlbHBlci5tYWtlUmVjdFNoYXBlKFxuICAgICAgICAgICAgICAgICAgICBbcGl4ZWxWYWx1ZSAtIGJhbmRXaWR0aCAvIDIsIG90aGVyRXh0ZW50WzBdXSxcbiAgICAgICAgICAgICAgICAgICAgW2JhbmRXaWR0aCwgc3Bhbl0sXG4gICAgICAgICAgICAgICAgICAgIGdldEF4aXNEaW1JbmRleChheGlzKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0QXhpc0RpbUluZGV4KGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIGF4aXMuZGltID09PSAneCcgPyAwIDogMTtcbiAgICB9XG5cbiAgICBBeGlzVmlldy5yZWdpc3RlckF4aXNQb2ludGVyQ2xhc3MoJ0NhcnRlc2lhbkF4aXNQb2ludGVyJywgQ2FydGVzaWFuQXhpc1BvaW50ZXIpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDYXJ0ZXNpYW5BeGlzUG9pbnRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvQ2FydGVzaWFuQXhpc1BvaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var zrUtil = __webpack_require__(20);\n    var clazzUtil = __webpack_require__(29);\n    var graphic = __webpack_require__(34);\n    var get = __webpack_require__(21).makeGetter();\n    var axisPointerModelHelper = __webpack_require__(131);\n    var eventTool = __webpack_require__(104);\n    var throttle = __webpack_require__(97);\n\n    var clone = zrUtil.clone;\n    var bind = zrUtil.bind;\n\n    /**\n     * Base axis pointer class in 2D.\n     * Implemenents {module:echarts/component/axis/IAxisPointer}.\n     */\n    function BaseAxisPointer () {\n    }\n\n    BaseAxisPointer.prototype = {\n\n        /**\n         * @private\n         */\n        _group: null,\n\n        /**\n         * @private\n         */\n        _lastGraphicKey: null,\n\n        /**\n         * @private\n         */\n        _handle: null,\n\n        /**\n         * @private\n         */\n        _dragging: false,\n\n        /**\n         * @private\n         */\n        _lastValue: null,\n\n        /**\n         * @private\n         */\n        _lastStatus: null,\n\n        /**\n         * @private\n         */\n        _payloadInfo: null,\n\n        /**\n         * In px, arbitrary value. Do not set too small,\n         * no animation is ok for most cases.\n         * @protected\n         */\n        animationThreshold: 15,\n\n        /**\n         * @implement\n         */\n        render: function (axisModel, axisPointerModel, api, forceRender) {\n            var value = axisPointerModel.get('value');\n            var status = axisPointerModel.get('status');\n\n            // Bind them to `this`, not in closure, otherwise they will not\n            // be replaced when user calling setOption in not merge mode.\n            this._axisModel = axisModel;\n            this._axisPointerModel = axisPointerModel;\n            this._api = api;\n\n            // Optimize: `render` will be called repeatly during mouse move.\n            // So it is power consuming if performing `render` each time,\n            // especially on mobile device.\n            if (!forceRender\n                && this._lastValue === value\n                && this._lastStatus === status\n            ) {\n                return;\n            }\n            this._lastValue = value;\n            this._lastStatus = status;\n\n            var group = this._group;\n            var handle = this._handle;\n\n            if (!status || status === 'hide') {\n                // Do not clear here, for animation better.\n                group && group.hide();\n                handle && handle.hide();\n                return;\n            }\n            group && group.show();\n            handle && handle.show();\n\n            // Otherwise status is 'show'\n            var elOption = {};\n            this.makeElOption(elOption, value, axisModel, axisPointerModel, api);\n\n            // Enable change axis pointer type.\n            var graphicKey = elOption.graphicKey;\n            if (graphicKey !== this._lastGraphicKey) {\n                this.clear(api);\n            }\n            this._lastGraphicKey = graphicKey;\n\n            var moveAnimation = this._moveAnimation =\n                this.determineAnimation(axisModel, axisPointerModel);\n\n            if (!group) {\n                group = this._group = new graphic.Group();\n                this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n                this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n                api.getZr().add(group);\n            }\n            else {\n                var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);\n                this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);\n                this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n            }\n\n            updateMandatoryProps(group, axisPointerModel, true);\n\n            this._renderHandle(value);\n        },\n\n        /**\n         * @implement\n         */\n        remove: function (api) {\n            this.clear(api);\n        },\n\n        /**\n         * @implement\n         */\n        dispose: function (api) {\n            this.clear(api);\n        },\n\n        /**\n         * @protected\n         */\n        determineAnimation: function (axisModel, axisPointerModel) {\n            var animation = axisPointerModel.get('animation');\n            var axis = axisModel.axis;\n            var isCategoryAxis = axis.type === 'category';\n            var useSnap = axisPointerModel.get('snap');\n\n            // Value axis without snap always do not snap.\n            if (!useSnap && !isCategoryAxis) {\n                return false;\n            }\n\n            if (animation === 'auto' || animation == null) {\n                var animationThreshold = this.animationThreshold;\n                if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n                    return true;\n                }\n\n                // It is important to auto animation when snap used. Consider if there is\n                // a dataZoom, animation will be disabled when too many points exist, while\n                // it will be enabled for better visual effect when little points exist.\n                if (useSnap) {\n                    var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;\n                    var axisExtent = axis.getExtent();\n                    // Approximate band width\n                    return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n                }\n\n                return false;\n            }\n\n            return animation === true;\n        },\n\n        /**\n         * add {pointer, label, graphicKey} to elOption\n         * @protected\n         */\n        makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n            // Shoule be implemenented by sub-class.\n        },\n\n        /**\n         * @protected\n         */\n        createPointerEl: function (group, elOption, axisModel, axisPointerModel) {\n            var pointerOption = elOption.pointer;\n            if (pointerOption) {\n                var pointerEl = get(group).pointerEl = new graphic[pointerOption.type](\n                    clone(elOption.pointer)\n                );\n                group.add(pointerEl);\n            }\n        },\n\n        /**\n         * @protected\n         */\n        createLabelEl: function (group, elOption, axisModel, axisPointerModel) {\n            if (elOption.label) {\n                var labelEl = get(group).labelEl = new graphic.Rect(\n                    clone(elOption.label)\n                );\n\n                group.add(labelEl);\n                updateLabelShowHide(labelEl, axisPointerModel);\n            }\n        },\n\n        /**\n         * @protected\n         */\n        updatePointerEl: function (group, elOption, updateProps) {\n            var pointerEl = get(group).pointerEl;\n            if (pointerEl) {\n                pointerEl.setStyle(elOption.pointer.style);\n                updateProps(pointerEl, {shape: elOption.pointer.shape});\n            }\n        },\n\n        /**\n         * @protected\n         */\n        updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {\n            var labelEl = get(group).labelEl;\n            if (labelEl) {\n                labelEl.setStyle(elOption.label.style);\n                updateProps(labelEl, {\n                    // Consider text length change in vertical axis, animation should\n                    // be used on shape, otherwise the effect will be weird.\n                    shape: elOption.label.shape,\n                    position: elOption.label.position\n                });\n\n                updateLabelShowHide(labelEl, axisPointerModel);\n            }\n        },\n\n        /**\n         * @private\n         */\n        _renderHandle: function (value) {\n            if (this._dragging || !this.updateHandleTransform) {\n                return;\n            }\n\n            var axisPointerModel = this._axisPointerModel;\n            var zr = this._api.getZr();\n            var handle = this._handle;\n            var handleModel = axisPointerModel.getModel('handle');\n\n            var status = axisPointerModel.get('status');\n            if (!handleModel.get('show') || !status || status === 'hide') {\n                handle && zr.remove(handle);\n                this._handle = null;\n                return;\n            }\n\n            var isInit;\n            if (!this._handle) {\n                isInit = true;\n                handle = this._handle = createIcon(handleModel, {\n                    onmousemove: function (e) {\n                        // Fot mobile devicem, prevent screen slider on the button.\n                        eventTool.stop(e.event);\n                    },\n                    onmousedown: bind(this._onHandleDragMove, this, 0, 0),\n                    drift: bind(this._onHandleDragMove, this),\n                    ondragend: bind(this._onHandleDragEnd, this)\n                });\n                zr.add(handle);\n            }\n\n            updateMandatoryProps(handle, axisPointerModel, false);\n\n            // update style\n            var includeStyles = [\n                'color', 'borderColor', 'borderWidth', 'opacity',\n                'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'\n            ];\n            handle.setStyle(handleModel.getItemStyle(null, includeStyles));\n\n            // update position\n            var handleSize = handleModel.get('size');\n            if (!zrUtil.isArray(handleSize)) {\n                handleSize = [handleSize, handleSize];\n            }\n            handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);\n\n            throttle.createOrUpdate(\n                this,\n                '_doDispatchAxisPointer',\n                handleModel.get('throttle') || 0,\n                'fixRate'\n            );\n\n            this._moveHandleToValue(value, isInit);\n        },\n\n        /**\n         * @private\n         */\n        _moveHandleToValue: function (value, isInit) {\n            updateProps(\n                this._axisPointerModel,\n                !isInit && this._moveAnimation,\n                this._handle,\n                getHandleTransProps(this.getHandleTransform(\n                    value, this._axisModel, this._axisPointerModel\n                ))\n            );\n        },\n\n        /**\n         * @private\n         */\n        _onHandleDragMove: function (dx, dy) {\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            this._dragging = true;\n\n            // Persistent for throttle.\n            var trans = this.updateHandleTransform(\n                getHandleTransProps(handle),\n                [dx, dy],\n                this._axisModel,\n                this._axisPointerModel\n            );\n            this._payloadInfo = trans;\n\n            handle.stopAnimation();\n            handle.attr(getHandleTransProps(trans));\n            get(handle).lastProp = null;\n\n            this._doDispatchAxisPointer();\n        },\n\n        /**\n         * Throttled method.\n         * @private\n         */\n        _doDispatchAxisPointer: function () {\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            var payloadInfo = this._payloadInfo;\n            var axisModel = this._axisModel;\n            this._api.dispatchAction({\n                type: 'updateAxisPointer',\n                x: payloadInfo.cursorPoint[0],\n                y: payloadInfo.cursorPoint[1],\n                tooltipOption: payloadInfo.tooltipOption,\n                axesInfo: [{\n                    axisDim: axisModel.axis.dim,\n                    axisIndex: axisModel.componentIndex\n                }]\n            });\n        },\n\n        /**\n         * @private\n         */\n        _onHandleDragEnd: function (moveAnimation) {\n            this._dragging = false;\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            var value = this._axisPointerModel.get('value');\n            // Consider snap or categroy axis, handle may be not consistent with\n            // axisPointer. So move handle to align the exact value position when\n            // drag ended.\n            this._moveHandleToValue(value);\n\n            // For the effect: tooltip will be shown when finger holding on handle\n            // button, and will be hidden after finger left handle button.\n            this._api.dispatchAction({\n                type: 'hideTip'\n            });\n        },\n\n        /**\n         * Should be implemenented by sub-class if support `handle`.\n         * @protected\n         * @param {number} value\n         * @param {module:echarts/model/Model} axisModel\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @return {Object} {position: [x, y], rotation: 0}\n         */\n        getHandleTransform: null,\n\n        /**\n         * * Should be implemenented by sub-class if support `handle`.\n         * @protected\n         * @param {Object} transform {position, rotation}\n         * @param {Array.<number>} delta [dx, dy]\n         * @param {module:echarts/model/Model} axisModel\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}\n         */\n        updateHandleTransform: null,\n\n        /**\n         * @private\n         */\n        clear: function (api) {\n            this._lastValue = null;\n            this._lastStatus = null;\n\n            var zr = api.getZr();\n            var group = this._group;\n            var handle = this._handle;\n            if (zr && group) {\n                this._lastGraphicKey = null;\n                group && zr.remove(group);\n                handle && zr.remove(handle);\n                this._group = null;\n                this._handle = null;\n                this._payloadInfo = null;\n            }\n        },\n\n        /**\n         * @protected\n         */\n        doClear: function () {\n            // Implemented by sub-class if necessary.\n        },\n\n        /**\n         * @protected\n         * @param {Array.<number>} xy\n         * @param {Array.<number>} wh\n         * @param {number} [xDimIndex=0] or 1\n         */\n        buildLabel: function (xy, wh, xDimIndex) {\n            xDimIndex = xDimIndex || 0;\n            return {\n                x: xy[xDimIndex],\n                y: xy[1 - xDimIndex],\n                width: wh[xDimIndex],\n                height: wh[1 - xDimIndex]\n            };\n        }\n    };\n\n    BaseAxisPointer.prototype.constructor = BaseAxisPointer;\n\n\n    function updateProps(animationModel, moveAnimation, el, props) {\n        // Animation optimize.\n        if (!propsEqual(get(el).lastProp, props)) {\n            get(el).lastProp = props;\n            moveAnimation\n                ? graphic.updateProps(el, props, animationModel)\n                : (el.stopAnimation(), el.attr(props));\n        }\n    }\n\n    function propsEqual(lastProps, newProps) {\n        if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {\n            var equals = true;\n            zrUtil.each(newProps, function (item, key) {\n                equals &= propsEqual(lastProps[key], item);\n            });\n            return !!equals;\n        }\n        else {\n            return lastProps === newProps;\n        }\n    }\n\n    function updateLabelShowHide(labelEl, axisPointerModel) {\n        labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();\n    }\n\n    function getHandleTransProps(trans) {\n        return {\n            position: trans.position.slice(),\n            rotation: trans.rotation || 0\n        };\n    }\n\n    function createIcon(handleModel, handlers) {\n        var iconStr = handleModel.get('icon');\n        var style = {\n            x: -1, y: -1, width: 2, height: 2\n        };\n        var opt = zrUtil.extend({\n            style: {\n                strokeNoScale: true\n            },\n            rectHover: true,\n            cursor: 'move',\n            draggable: true\n        }, handlers);\n\n        return iconStr.indexOf('image://') === 0\n            ? (\n                style.image = iconStr.slice(8),\n                opt.style = style,\n                new graphic.Image(opt)\n            )\n            : graphic.makePath(\n                iconStr.replace('path://', ''),\n                opt,\n                style,\n                'center'\n            );\n    }\n\n    function updateMandatoryProps(group, axisPointerModel, silent) {\n        var z = axisPointerModel.get('z');\n        var zlevel = axisPointerModel.get('zlevel');\n\n        group && group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n                el.silent = silent;\n            }\n        });\n    }\n\n    clazzUtil.enableClassExtend(BaseAxisPointer);\n\n    module.exports = BaseAxisPointer;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9CYXNlQXhpc1BvaW50ZXIuanM/MDI3YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDJDQUEyQztBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDhCQUE4QjtBQUN0RTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLDJCQUEyQjtBQUM5QyxtQkFBbUIsMkJBQTJCO0FBQzlDLG9CQUFvQixPQUFPLEVBQUU7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTyxZQUFZO0FBQ3RDLG1CQUFtQixlQUFlO0FBQ2xDLG1CQUFtQiwyQkFBMkI7QUFDOUMsbUJBQW1CLDJCQUEyQjtBQUM5QyxvQkFBb0IsT0FBTyxFQUFFO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxtQkFBbUIsZUFBZTtBQUNsQyxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQSIsImZpbGUiOiIxMzguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jbGF6eicpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIGdldCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbW9kZWwnKS5tYWtlR2V0dGVyKCk7XG4gICAgdmFyIGF4aXNQb2ludGVyTW9kZWxIZWxwZXIgPSByZXF1aXJlKCcuL21vZGVsSGVscGVyJyk7XG4gICAgdmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQnKTtcbiAgICB2YXIgdGhyb3R0bGUgPSByZXF1aXJlKCcuLi8uLi91dGlsL3Rocm90dGxlJyk7XG5cbiAgICB2YXIgY2xvbmUgPSB6clV0aWwuY2xvbmU7XG4gICAgdmFyIGJpbmQgPSB6clV0aWwuYmluZDtcblxuICAgIC8qKlxuICAgICAqIEJhc2UgYXhpcyBwb2ludGVyIGNsYXNzIGluIDJELlxuICAgICAqIEltcGxlbWVuZW50cyB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L2F4aXMvSUF4aXNQb2ludGVyfS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCYXNlQXhpc1BvaW50ZXIgKCkge1xuICAgIH1cblxuICAgIEJhc2VBeGlzUG9pbnRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZ3JvdXA6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfbGFzdEdyYXBoaWNLZXk6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfaGFuZGxlOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2RyYWdnaW5nOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9sYXN0VmFsdWU6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfbGFzdFN0YXR1czogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9wYXlsb2FkSW5mbzogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW4gcHgsIGFyYml0cmFyeSB2YWx1ZS4gRG8gbm90IHNldCB0b28gc21hbGwsXG4gICAgICAgICAqIG5vIGFuaW1hdGlvbiBpcyBvayBmb3IgbW9zdCBjYXNlcy5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0aW9uVGhyZXNob2xkOiAxNSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGltcGxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGksIGZvcmNlUmVuZGVyKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTtcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnc3RhdHVzJyk7XG5cbiAgICAgICAgICAgIC8vIEJpbmQgdGhlbSB0byBgdGhpc2AsIG5vdCBpbiBjbG9zdXJlLCBvdGhlcndpc2UgdGhleSB3aWxsIG5vdFxuICAgICAgICAgICAgLy8gYmUgcmVwbGFjZWQgd2hlbiB1c2VyIGNhbGxpbmcgc2V0T3B0aW9uIGluIG5vdCBtZXJnZSBtb2RlLlxuICAgICAgICAgICAgdGhpcy5fYXhpc01vZGVsID0gYXhpc01vZGVsO1xuICAgICAgICAgICAgdGhpcy5fYXhpc1BvaW50ZXJNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWw7XG4gICAgICAgICAgICB0aGlzLl9hcGkgPSBhcGk7XG5cbiAgICAgICAgICAgIC8vIE9wdGltaXplOiBgcmVuZGVyYCB3aWxsIGJlIGNhbGxlZCByZXBlYXRseSBkdXJpbmcgbW91c2UgbW92ZS5cbiAgICAgICAgICAgIC8vIFNvIGl0IGlzIHBvd2VyIGNvbnN1bWluZyBpZiBwZXJmb3JtaW5nIGByZW5kZXJgIGVhY2ggdGltZSxcbiAgICAgICAgICAgIC8vIGVzcGVjaWFsbHkgb24gbW9iaWxlIGRldmljZS5cbiAgICAgICAgICAgIGlmICghZm9yY2VSZW5kZXJcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9sYXN0VmFsdWUgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5fbGFzdFN0YXR1cyA9PT0gc3RhdHVzXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RTdGF0dXMgPSBzdGF0dXM7XG5cbiAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuX2dyb3VwO1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcblxuICAgICAgICAgICAgaWYgKCFzdGF0dXMgfHwgc3RhdHVzID09PSAnaGlkZScpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgY2xlYXIgaGVyZSwgZm9yIGFuaW1hdGlvbiBiZXR0ZXIuXG4gICAgICAgICAgICAgICAgZ3JvdXAgJiYgZ3JvdXAuaGlkZSgpO1xuICAgICAgICAgICAgICAgIGhhbmRsZSAmJiBoYW5kbGUuaGlkZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyb3VwICYmIGdyb3VwLnNob3coKTtcbiAgICAgICAgICAgIGhhbmRsZSAmJiBoYW5kbGUuc2hvdygpO1xuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugc3RhdHVzIGlzICdzaG93J1xuICAgICAgICAgICAgdmFyIGVsT3B0aW9uID0ge307XG4gICAgICAgICAgICB0aGlzLm1ha2VFbE9wdGlvbihlbE9wdGlvbiwgdmFsdWUsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpKTtcblxuICAgICAgICAgICAgLy8gRW5hYmxlIGNoYW5nZSBheGlzIHBvaW50ZXIgdHlwZS5cbiAgICAgICAgICAgIHZhciBncmFwaGljS2V5ID0gZWxPcHRpb24uZ3JhcGhpY0tleTtcbiAgICAgICAgICAgIGlmIChncmFwaGljS2V5ICE9PSB0aGlzLl9sYXN0R3JhcGhpY0tleSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoYXBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xhc3RHcmFwaGljS2V5ID0gZ3JhcGhpY0tleTtcblxuICAgICAgICAgICAgdmFyIG1vdmVBbmltYXRpb24gPSB0aGlzLl9tb3ZlQW5pbWF0aW9uID1cbiAgICAgICAgICAgICAgICB0aGlzLmRldGVybWluZUFuaW1hdGlvbihheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuXG4gICAgICAgICAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAgPSB0aGlzLl9ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVQb2ludGVyRWwoZ3JvdXAsIGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlTGFiZWxFbChncm91cCwgZWxPcHRpb24sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICAgICAgICAgICAgYXBpLmdldFpyKCkuYWRkKGdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkb1VwZGF0ZVByb3BzID0genJVdGlsLmN1cnJ5KHVwZGF0ZVByb3BzLCBheGlzUG9pbnRlck1vZGVsLCBtb3ZlQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBvaW50ZXJFbChncm91cCwgZWxPcHRpb24sIGRvVXBkYXRlUHJvcHMsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGFiZWxFbChncm91cCwgZWxPcHRpb24sIGRvVXBkYXRlUHJvcHMsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVNYW5kYXRvcnlQcm9wcyhncm91cCwgYXhpc1BvaW50ZXJNb2RlbCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckhhbmRsZSh2YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbXBsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGFwaSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhcihhcGkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW1wbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoYXBpKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKGFwaSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRldGVybWluZUFuaW1hdGlvbjogZnVuY3Rpb24gKGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdhbmltYXRpb24nKTtcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgICAgICAgICB2YXIgaXNDYXRlZ29yeUF4aXMgPSBheGlzLnR5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgICAgICAgICB2YXIgdXNlU25hcCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzbmFwJyk7XG5cbiAgICAgICAgICAgIC8vIFZhbHVlIGF4aXMgd2l0aG91dCBzbmFwIGFsd2F5cyBkbyBub3Qgc25hcC5cbiAgICAgICAgICAgIGlmICghdXNlU25hcCAmJiAhaXNDYXRlZ29yeUF4aXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbmltYXRpb24gPT09ICdhdXRvJyB8fCBhbmltYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25UaHJlc2hvbGQgPSB0aGlzLmFuaW1hdGlvblRocmVzaG9sZDtcbiAgICAgICAgICAgICAgICBpZiAoaXNDYXRlZ29yeUF4aXMgJiYgYXhpcy5nZXRCYW5kV2lkdGgoKSA+IGFuaW1hdGlvblRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gYXV0byBhbmltYXRpb24gd2hlbiBzbmFwIHVzZWQuIENvbnNpZGVyIGlmIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgLy8gYSBkYXRhWm9vbSwgYW5pbWF0aW9uIHdpbGwgYmUgZGlzYWJsZWQgd2hlbiB0b28gbWFueSBwb2ludHMgZXhpc3QsIHdoaWxlXG4gICAgICAgICAgICAgICAgLy8gaXQgd2lsbCBiZSBlbmFibGVkIGZvciBiZXR0ZXIgdmlzdWFsIGVmZmVjdCB3aGVuIGxpdHRsZSBwb2ludHMgZXhpc3QuXG4gICAgICAgICAgICAgICAgaWYgKHVzZVNuYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllc0RhdGFDb3VudCA9IGF4aXNQb2ludGVyTW9kZWxIZWxwZXIuZ2V0QXhpc0luZm8oYXhpc01vZGVsKS5zZXJpZXNEYXRhQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzRXh0ZW50ID0gYXhpcy5nZXRFeHRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwcm94aW1hdGUgYmFuZCB3aWR0aFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoYXhpc0V4dGVudFswXSAtIGF4aXNFeHRlbnRbMV0pIC8gc2VyaWVzRGF0YUNvdW50ID4gYW5pbWF0aW9uVGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbiA9PT0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogYWRkIHtwb2ludGVyLCBsYWJlbCwgZ3JhcGhpY0tleX0gdG8gZWxPcHRpb25cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbWFrZUVsT3B0aW9uOiBmdW5jdGlvbiAoZWxPcHRpb24sIHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgLy8gU2hvdWxlIGJlIGltcGxlbWVuZW50ZWQgYnkgc3ViLWNsYXNzLlxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVQb2ludGVyRWw6IGZ1bmN0aW9uIChncm91cCwgZWxPcHRpb24sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgICAgICAgICAgdmFyIHBvaW50ZXJPcHRpb24gPSBlbE9wdGlvbi5wb2ludGVyO1xuICAgICAgICAgICAgaWYgKHBvaW50ZXJPcHRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRlckVsID0gZ2V0KGdyb3VwKS5wb2ludGVyRWwgPSBuZXcgZ3JhcGhpY1twb2ludGVyT3B0aW9uLnR5cGVdKFxuICAgICAgICAgICAgICAgICAgICBjbG9uZShlbE9wdGlvbi5wb2ludGVyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZ3JvdXAuYWRkKHBvaW50ZXJFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUxhYmVsRWw6IGZ1bmN0aW9uIChncm91cCwgZWxPcHRpb24sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgICAgICAgICAgaWYgKGVsT3B0aW9uLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsRWwgPSBnZXQoZ3JvdXApLmxhYmVsRWwgPSBuZXcgZ3JhcGhpYy5SZWN0KFxuICAgICAgICAgICAgICAgICAgICBjbG9uZShlbE9wdGlvbi5sYWJlbClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZ3JvdXAuYWRkKGxhYmVsRWwpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUxhYmVsU2hvd0hpZGUobGFiZWxFbCwgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVBvaW50ZXJFbDogZnVuY3Rpb24gKGdyb3VwLCBlbE9wdGlvbiwgdXBkYXRlUHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBwb2ludGVyRWwgPSBnZXQoZ3JvdXApLnBvaW50ZXJFbDtcbiAgICAgICAgICAgIGlmIChwb2ludGVyRWwpIHtcbiAgICAgICAgICAgICAgICBwb2ludGVyRWwuc2V0U3R5bGUoZWxPcHRpb24ucG9pbnRlci5zdHlsZSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlUHJvcHMocG9pbnRlckVsLCB7c2hhcGU6IGVsT3B0aW9uLnBvaW50ZXIuc2hhcGV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlTGFiZWxFbDogZnVuY3Rpb24gKGdyb3VwLCBlbE9wdGlvbiwgdXBkYXRlUHJvcHMsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbEVsID0gZ2V0KGdyb3VwKS5sYWJlbEVsO1xuICAgICAgICAgICAgaWYgKGxhYmVsRWwpIHtcbiAgICAgICAgICAgICAgICBsYWJlbEVsLnNldFN0eWxlKGVsT3B0aW9uLmxhYmVsLnN0eWxlKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVQcm9wcyhsYWJlbEVsLCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIHRleHQgbGVuZ3RoIGNoYW5nZSBpbiB2ZXJ0aWNhbCBheGlzLCBhbmltYXRpb24gc2hvdWxkXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIHVzZWQgb24gc2hhcGUsIG90aGVyd2lzZSB0aGUgZWZmZWN0IHdpbGwgYmUgd2VpcmQuXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiBlbE9wdGlvbi5sYWJlbC5zaGFwZSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGVsT3B0aW9uLmxhYmVsLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVMYWJlbFNob3dIaWRlKGxhYmVsRWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3JlbmRlckhhbmRsZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhZ2dpbmcgfHwgIXRoaXMudXBkYXRlSGFuZGxlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXhpc1BvaW50ZXJNb2RlbCA9IHRoaXMuX2F4aXNQb2ludGVyTW9kZWw7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9hcGkuZ2V0WnIoKTtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG4gICAgICAgICAgICB2YXIgaGFuZGxlTW9kZWwgPSBheGlzUG9pbnRlck1vZGVsLmdldE1vZGVsKCdoYW5kbGUnKTtcblxuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzdGF0dXMnKTtcbiAgICAgICAgICAgIGlmICghaGFuZGxlTW9kZWwuZ2V0KCdzaG93JykgfHwgIXN0YXR1cyB8fCBzdGF0dXMgPT09ICdoaWRlJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZSAmJiB6ci5yZW1vdmUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlzSW5pdDtcbiAgICAgICAgICAgIGlmICghdGhpcy5faGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgaXNJbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSB0aGlzLl9oYW5kbGUgPSBjcmVhdGVJY29uKGhhbmRsZU1vZGVsLCB7XG4gICAgICAgICAgICAgICAgICAgIG9ubW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm90IG1vYmlsZSBkZXZpY2VtLCBwcmV2ZW50IHNjcmVlbiBzbGlkZXIgb24gdGhlIGJ1dHRvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VG9vbC5zdG9wKGUuZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbm1vdXNlZG93bjogYmluZCh0aGlzLl9vbkhhbmRsZURyYWdNb3ZlLCB0aGlzLCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgZHJpZnQ6IGJpbmQodGhpcy5fb25IYW5kbGVEcmFnTW92ZSwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIG9uZHJhZ2VuZDogYmluZCh0aGlzLl9vbkhhbmRsZURyYWdFbmQsIHRoaXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgenIuYWRkKGhhbmRsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZU1hbmRhdG9yeVByb3BzKGhhbmRsZSwgYXhpc1BvaW50ZXJNb2RlbCwgZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgc3R5bGVcbiAgICAgICAgICAgIHZhciBpbmNsdWRlU3R5bGVzID0gW1xuICAgICAgICAgICAgICAgICdjb2xvcicsICdib3JkZXJDb2xvcicsICdib3JkZXJXaWR0aCcsICdvcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAnc2hhZG93Q29sb3InLCAnc2hhZG93Qmx1cicsICdzaGFkb3dPZmZzZXRYJywgJ3NoYWRvd09mZnNldFknXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaGFuZGxlLnNldFN0eWxlKGhhbmRsZU1vZGVsLmdldEl0ZW1TdHlsZShudWxsLCBpbmNsdWRlU3R5bGVzKSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvblxuICAgICAgICAgICAgdmFyIGhhbmRsZVNpemUgPSBoYW5kbGVNb2RlbC5nZXQoJ3NpemUnKTtcbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkoaGFuZGxlU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVTaXplID0gW2hhbmRsZVNpemUsIGhhbmRsZVNpemVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlLmF0dHIoJ3NjYWxlJywgW2hhbmRsZVNpemVbMF0gLyAyLCBoYW5kbGVTaXplWzFdIC8gMl0pO1xuXG4gICAgICAgICAgICB0aHJvdHRsZS5jcmVhdGVPclVwZGF0ZShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICdfZG9EaXNwYXRjaEF4aXNQb2ludGVyJyxcbiAgICAgICAgICAgICAgICBoYW5kbGVNb2RlbC5nZXQoJ3Rocm90dGxlJykgfHwgMCxcbiAgICAgICAgICAgICAgICAnZml4UmF0ZSdcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuX21vdmVIYW5kbGVUb1ZhbHVlKHZhbHVlLCBpc0luaXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX21vdmVIYW5kbGVUb1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGlzSW5pdCkge1xuICAgICAgICAgICAgdXBkYXRlUHJvcHMoXG4gICAgICAgICAgICAgICAgdGhpcy5fYXhpc1BvaW50ZXJNb2RlbCxcbiAgICAgICAgICAgICAgICAhaXNJbml0ICYmIHRoaXMuX21vdmVBbmltYXRpb24sXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlLFxuICAgICAgICAgICAgICAgIGdldEhhbmRsZVRyYW5zUHJvcHModGhpcy5nZXRIYW5kbGVUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLCB0aGlzLl9heGlzTW9kZWwsIHRoaXMuX2F4aXNQb2ludGVyTW9kZWxcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9vbkhhbmRsZURyYWdNb3ZlOiBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gdGhpcy5faGFuZGxlO1xuICAgICAgICAgICAgaWYgKCFoYW5kbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gUGVyc2lzdGVudCBmb3IgdGhyb3R0bGUuXG4gICAgICAgICAgICB2YXIgdHJhbnMgPSB0aGlzLnVwZGF0ZUhhbmRsZVRyYW5zZm9ybShcbiAgICAgICAgICAgICAgICBnZXRIYW5kbGVUcmFuc1Byb3BzKGhhbmRsZSksXG4gICAgICAgICAgICAgICAgW2R4LCBkeV0sXG4gICAgICAgICAgICAgICAgdGhpcy5fYXhpc01vZGVsLFxuICAgICAgICAgICAgICAgIHRoaXMuX2F4aXNQb2ludGVyTW9kZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9wYXlsb2FkSW5mbyA9IHRyYW5zO1xuXG4gICAgICAgICAgICBoYW5kbGUuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgaGFuZGxlLmF0dHIoZ2V0SGFuZGxlVHJhbnNQcm9wcyh0cmFucykpO1xuICAgICAgICAgICAgZ2V0KGhhbmRsZSkubGFzdFByb3AgPSBudWxsO1xuXG4gICAgICAgICAgICB0aGlzLl9kb0Rpc3BhdGNoQXhpc1BvaW50ZXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhyb3R0bGVkIG1ldGhvZC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9kb0Rpc3BhdGNoQXhpc1BvaW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBheWxvYWRJbmZvID0gdGhpcy5fcGF5bG9hZEluZm87XG4gICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5fYXhpc01vZGVsO1xuICAgICAgICAgICAgdGhpcy5fYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgICAgICAgICAgIHg6IHBheWxvYWRJbmZvLmN1cnNvclBvaW50WzBdLFxuICAgICAgICAgICAgICAgIHk6IHBheWxvYWRJbmZvLmN1cnNvclBvaW50WzFdLFxuICAgICAgICAgICAgICAgIHRvb2x0aXBPcHRpb246IHBheWxvYWRJbmZvLnRvb2x0aXBPcHRpb24sXG4gICAgICAgICAgICAgICAgYXhlc0luZm86IFt7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNEaW06IGF4aXNNb2RlbC5heGlzLmRpbSxcbiAgICAgICAgICAgICAgICAgICAgYXhpc0luZGV4OiBheGlzTW9kZWwuY29tcG9uZW50SW5kZXhcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfb25IYW5kbGVEcmFnRW5kOiBmdW5jdGlvbiAobW92ZUFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3ZhbHVlJyk7XG4gICAgICAgICAgICAvLyBDb25zaWRlciBzbmFwIG9yIGNhdGVncm95IGF4aXMsIGhhbmRsZSBtYXkgYmUgbm90IGNvbnNpc3RlbnQgd2l0aFxuICAgICAgICAgICAgLy8gYXhpc1BvaW50ZXIuIFNvIG1vdmUgaGFuZGxlIHRvIGFsaWduIHRoZSBleGFjdCB2YWx1ZSBwb3NpdGlvbiB3aGVuXG4gICAgICAgICAgICAvLyBkcmFnIGVuZGVkLlxuICAgICAgICAgICAgdGhpcy5fbW92ZUhhbmRsZVRvVmFsdWUodmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBGb3IgdGhlIGVmZmVjdDogdG9vbHRpcCB3aWxsIGJlIHNob3duIHdoZW4gZmluZ2VyIGhvbGRpbmcgb24gaGFuZGxlXG4gICAgICAgICAgICAvLyBidXR0b24sIGFuZCB3aWxsIGJlIGhpZGRlbiBhZnRlciBmaW5nZXIgbGVmdCBoYW5kbGUgYnV0dG9uLlxuICAgICAgICAgICAgdGhpcy5fYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGlkZVRpcCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgYmUgaW1wbGVtZW5lbnRlZCBieSBzdWItY2xhc3MgaWYgc3VwcG9ydCBgaGFuZGxlYC5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gYXhpc01vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGF4aXNQb2ludGVyTW9kZWxcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB7cG9zaXRpb246IFt4LCB5XSwgcm90YXRpb246IDB9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRIYW5kbGVUcmFuc2Zvcm06IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICogU2hvdWxkIGJlIGltcGxlbWVuZW50ZWQgYnkgc3ViLWNsYXNzIGlmIHN1cHBvcnQgYGhhbmRsZWAuXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSB7cG9zaXRpb24sIHJvdGF0aW9ufVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkZWx0YSBbZHgsIGR5XVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBheGlzTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gYXhpc1BvaW50ZXJNb2RlbFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHtwb3NpdGlvbjogW3gsIHldLCByb3RhdGlvbjogMCwgY3Vyc29yUG9pbnQ6IFt4LCB5XX1cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZUhhbmRsZVRyYW5zZm9ybTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoYXBpKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFN0YXR1cyA9IG51bGw7XG5cbiAgICAgICAgICAgIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5fZ3JvdXA7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gdGhpcy5faGFuZGxlO1xuICAgICAgICAgICAgaWYgKHpyICYmIGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdEdyYXBoaWNLZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGdyb3VwICYmIHpyLnJlbW92ZShncm91cCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlICYmIHpyLnJlbW92ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dyb3VwID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BheWxvYWRJbmZvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZG9DbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gSW1wbGVtZW50ZWQgYnkgc3ViLWNsYXNzIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB4eVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB3aFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3hEaW1JbmRleD0wXSBvciAxXG4gICAgICAgICAqL1xuICAgICAgICBidWlsZExhYmVsOiBmdW5jdGlvbiAoeHksIHdoLCB4RGltSW5kZXgpIHtcbiAgICAgICAgICAgIHhEaW1JbmRleCA9IHhEaW1JbmRleCB8fCAwO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4eVt4RGltSW5kZXhdLFxuICAgICAgICAgICAgICAgIHk6IHh5WzEgLSB4RGltSW5kZXhdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aFt4RGltSW5kZXhdLFxuICAgICAgICAgICAgICAgIGhlaWdodDogd2hbMSAtIHhEaW1JbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJhc2VBeGlzUG9pbnRlcjtcblxuXG4gICAgZnVuY3Rpb24gdXBkYXRlUHJvcHMoYW5pbWF0aW9uTW9kZWwsIG1vdmVBbmltYXRpb24sIGVsLCBwcm9wcykge1xuICAgICAgICAvLyBBbmltYXRpb24gb3B0aW1pemUuXG4gICAgICAgIGlmICghcHJvcHNFcXVhbChnZXQoZWwpLmxhc3RQcm9wLCBwcm9wcykpIHtcbiAgICAgICAgICAgIGdldChlbCkubGFzdFByb3AgPSBwcm9wcztcbiAgICAgICAgICAgIG1vdmVBbmltYXRpb25cbiAgICAgICAgICAgICAgICA/IGdyYXBoaWMudXBkYXRlUHJvcHMoZWwsIHByb3BzLCBhbmltYXRpb25Nb2RlbClcbiAgICAgICAgICAgICAgICA6IChlbC5zdG9wQW5pbWF0aW9uKCksIGVsLmF0dHIocHJvcHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb3BzRXF1YWwobGFzdFByb3BzLCBuZXdQcm9wcykge1xuICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KGxhc3RQcm9wcykgJiYgenJVdGlsLmlzT2JqZWN0KG5ld1Byb3BzKSkge1xuICAgICAgICAgICAgdmFyIGVxdWFscyA9IHRydWU7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChuZXdQcm9wcywgZnVuY3Rpb24gKGl0ZW0sIGtleSkge1xuICAgICAgICAgICAgICAgIGVxdWFscyAmPSBwcm9wc0VxdWFsKGxhc3RQcm9wc1trZXldLCBpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICEhZXF1YWxzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RQcm9wcyA9PT0gbmV3UHJvcHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVMYWJlbFNob3dIaWRlKGxhYmVsRWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICAgICAgbGFiZWxFbFtheGlzUG9pbnRlck1vZGVsLmdldCgnbGFiZWwuc2hvdycpID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEhhbmRsZVRyYW5zUHJvcHModHJhbnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0cmFucy5wb3NpdGlvbi5zbGljZSgpLFxuICAgICAgICAgICAgcm90YXRpb246IHRyYW5zLnJvdGF0aW9uIHx8IDBcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJY29uKGhhbmRsZU1vZGVsLCBoYW5kbGVycykge1xuICAgICAgICB2YXIgaWNvblN0ciA9IGhhbmRsZU1vZGVsLmdldCgnaWNvbicpO1xuICAgICAgICB2YXIgc3R5bGUgPSB7XG4gICAgICAgICAgICB4OiAtMSwgeTogLTEsIHdpZHRoOiAyLCBoZWlnaHQ6IDJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9wdCA9IHpyVXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBzdHJva2VOb1NjYWxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjdEhvdmVyOiB0cnVlLFxuICAgICAgICAgICAgY3Vyc29yOiAnbW92ZScsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcbiAgICAgICAgfSwgaGFuZGxlcnMpO1xuXG4gICAgICAgIHJldHVybiBpY29uU3RyLmluZGV4T2YoJ2ltYWdlOi8vJykgPT09IDBcbiAgICAgICAgICAgID8gKFxuICAgICAgICAgICAgICAgIHN0eWxlLmltYWdlID0gaWNvblN0ci5zbGljZSg4KSxcbiAgICAgICAgICAgICAgICBvcHQuc3R5bGUgPSBzdHlsZSxcbiAgICAgICAgICAgICAgICBuZXcgZ3JhcGhpYy5JbWFnZShvcHQpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICA6IGdyYXBoaWMubWFrZVBhdGgoXG4gICAgICAgICAgICAgICAgaWNvblN0ci5yZXBsYWNlKCdwYXRoOi8vJywgJycpLFxuICAgICAgICAgICAgICAgIG9wdCxcbiAgICAgICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgICAgICAnY2VudGVyJ1xuICAgICAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVNYW5kYXRvcnlQcm9wcyhncm91cCwgYXhpc1BvaW50ZXJNb2RlbCwgc2lsZW50KSB7XG4gICAgICAgIHZhciB6ID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3onKTtcbiAgICAgICAgdmFyIHpsZXZlbCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd6bGV2ZWwnKTtcblxuICAgICAgICBncm91cCAmJiBncm91cC50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgeiAhPSBudWxsICYmIChlbC56ID0geik7XG4gICAgICAgICAgICAgICAgemxldmVsICE9IG51bGwgJiYgKGVsLnpsZXZlbCA9IHpsZXZlbCk7XG4gICAgICAgICAgICAgICAgZWwuc2lsZW50ID0gc2lsZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoQmFzZUF4aXNQb2ludGVyKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQmFzZUF4aXNQb2ludGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9CYXNlQXhpc1BvaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var zrUtil = __webpack_require__(20);\n    var graphic = __webpack_require__(34);\n    var textContain = __webpack_require__(24);\n    var formatUtil = __webpack_require__(22);\n    var matrix = __webpack_require__(27);\n    var axisHelper = __webpack_require__(117);\n    var AxisBuilder = __webpack_require__(140);\n\n    var helper = {};\n\n    /**\n     * @param {module:echarts/model/Model} axisPointerModel\n     */\n    helper.buildElStyle = function (axisPointerModel) {\n        var axisPointerType = axisPointerModel.get('type');\n        var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n        var style;\n        if (axisPointerType === 'line') {\n            style = styleModel.getLineStyle();\n            style.fill = null;\n        }\n        else if (axisPointerType === 'shadow') {\n            style = styleModel.getAreaStyle();\n            style.stroke = null;\n        }\n        return style;\n    };\n\n    /**\n     * @param {Function} labelPos {align, verticalAlign, position}\n     */\n    helper.buildLabelElOption = function (\n        elOption, axisModel, axisPointerModel, api, labelPos\n    ) {\n        var value = axisPointerModel.get('value');\n        var text = helper.getValueLabel(\n            value, axisModel.axis, axisModel.ecModel,\n            axisPointerModel.get('seriesDataIndices'),\n            {\n                precision: axisPointerModel.get('label.precision'),\n                formatter: axisPointerModel.get('label.formatter')\n            }\n        );\n        var labelModel = axisPointerModel.getModel('label');\n        var textStyleModel = labelModel.getModel('textStyle');\n        var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n\n        var font = textStyleModel.getFont();\n        var textRect = textContain.getBoundingRect(\n            text, font, labelPos.textAlign, labelPos.textBaseline\n        );\n\n        var position = labelPos.position;\n        var width = textRect.width + paddings[1] + paddings[3];\n        var height = textRect.height + paddings[0] + paddings[2];\n\n        // Adjust by align.\n        var align = labelPos.align;\n        align === 'right' && (position[0] -= width);\n        align === 'center' && (position[0] -= width / 2);\n        var verticalAlign = labelPos.verticalAlign;\n        verticalAlign === 'bottom' && (position[1] -= height);\n        verticalAlign === 'middle' && (position[1] -= height / 2);\n\n        // Not overflow ec container\n        confineInContainer(position, width, height, api);\n\n        var bgColor = labelModel.get('backgroundColor');\n        if (!bgColor || bgColor === 'auto') {\n            bgColor = axisModel.get('axisLine.lineStyle.color');\n        }\n\n        elOption.label = {\n            shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},\n            position: position.slice(),\n            style: {\n                text: text,\n                textFont: font,\n                textFill: textStyleModel.getTextColor(),\n                textPosition: 'inside',\n                fill: bgColor,\n                stroke: labelModel.get('borderColor') || 'transparent',\n                lineWidth: labelModel.get('borderWidth') || 0,\n                shadowBlur: labelModel.get('shadowBlur'),\n                shadowColor: labelModel.get('shadowColor'),\n                shadowOffsetX: labelModel.get('shadowOffsetX'),\n                shadowOffsetY: labelModel.get('shadowOffsetY')\n            },\n            // Lable should be over axisPointer.\n            z2: 10\n        };\n    };\n\n    // Do not overflow ec container\n    function confineInContainer(position, width, height, api) {\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n        position[0] = Math.min(position[0] + width, viewWidth) - width;\n        position[1] = Math.min(position[1] + height, viewHeight) - height;\n        position[0] = Math.max(position[0], 0);\n        position[1] = Math.max(position[1], 0);\n    }\n\n    /**\n     * @param {number} value\n     * @param {module:echarts/coord/Axis} axis\n     * @param {module:echarts/model/Global} ecModel\n     * @param {Object} opt\n     * @param {Array.<Object>} seriesDataIndices\n     * @param {number|string} opt.precision 'auto' or a number\n     * @param {string|Function} opt.formatter label formatter\n     */\n    helper.getValueLabel = function (value, axis, ecModel, seriesDataIndices, opt) {\n        var text = axis.scale.getLabel(\n            // If `precision` is set, width can be fixed (like '12.00500'), which\n            // helps to debounce when when moving label.\n            value, {precision: opt.precision}\n        );\n        var formatter = opt.formatter;\n\n        if (formatter) {\n            var params = {\n                value: axisHelper.getAxisRawValue(axis, value),\n                seriesData: []\n            };\n            zrUtil.each(seriesDataIndices, function (idxItem) {\n                var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n                var dataIndex = idxItem.dataIndexInside;\n                var dataParams = series && series.getDataParams(dataIndex);\n                dataParams && params.seriesData.push(dataParams);\n            });\n\n            if (zrUtil.isString(formatter)) {\n                text = formatter.replace('{value}', text);\n            }\n            else if (zrUtil.isFunction(formatter)) {\n                text = formatter(params);\n            }\n        }\n\n        return text;\n    };\n\n    /**\n     * @param {module:echarts/coord/Axis} axis\n     * @param {number} value\n     * @param {Object} layoutInfo {\n     *  rotation, position, labelOffset, labelDirection, labelMargin\n     * }\n     */\n    helper.getTransformedPosition = function (axis, value, layoutInfo) {\n        var transform = matrix.create();\n        matrix.rotate(transform, transform, layoutInfo.rotation);\n        matrix.translate(transform, transform, layoutInfo.position);\n\n        return graphic.applyTransform([\n            axis.dataToCoord(value),\n            (layoutInfo.labelOffset || 0)\n                + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)\n        ], transform);\n    };\n\n    helper.buildCartesianSingleLabelElOption = function (\n        value, elOption, layoutInfo, axisModel, axisPointerModel, api\n    ) {\n        var textLayout = AxisBuilder.innerTextLayout(\n            layoutInfo.rotation, 0, layoutInfo.labelDirection\n        );\n        layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n        helper.buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n            position: helper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n            align: textLayout.textAlign,\n            verticalAlign: textLayout.textVerticalAlign\n        });\n    };\n\n    /**\n     * @param {Array.<number>} p1\n     * @param {Array.<number>} p2\n     * @param {number} [xDimIndex=0] or 1\n     */\n    helper.makeLineShape = function (p1, p2, xDimIndex) {\n        xDimIndex = xDimIndex || 0;\n        return {\n            x1: p1[xDimIndex],\n            y1: p1[1 - xDimIndex],\n            x2: p2[xDimIndex],\n            y2: p2[1 - xDimIndex]\n        };\n    };\n\n    /**\n     * @param {Array.<number>} xy\n     * @param {Array.<number>} wh\n     * @param {number} [xDimIndex=0] or 1\n     */\n    helper.makeRectShape = function (xy, wh, xDimIndex) {\n        xDimIndex = xDimIndex || 0;\n        return {\n            x: xy[xDimIndex],\n            y: xy[1 - xDimIndex],\n            width: wh[xDimIndex],\n            height: wh[1 - xDimIndex]\n        };\n    };\n\n    helper.makeSectorShape = function (cx, cy, r0, r, startAngle, endAngle) {\n        return {\n            cx: cx,\n            cy: cy,\n            r0: r0,\n            r: r,\n            startAngle: startAngle,\n            endAngle: endAngle,\n            clockwise: true\n        };\n    };\n\n    module.exports = helper;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci92aWV3SGVscGVyLmpzPzM1YzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxTQUFTLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsNEVBQTRFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsY0FBYztBQUM3QixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsMkNBQTJDLE1BQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxMzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9mb3JtYXQnKTtcbiAgICB2YXIgbWF0cml4ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9tYXRyaXgnKTtcbiAgICB2YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoJy4uLy4uL2Nvb3JkL2F4aXNIZWxwZXInKTtcbiAgICB2YXIgQXhpc0J1aWxkZXIgPSByZXF1aXJlKCcuLi9heGlzL0F4aXNCdWlsZGVyJyk7XG5cbiAgICB2YXIgaGVscGVyID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBheGlzUG9pbnRlck1vZGVsXG4gICAgICovXG4gICAgaGVscGVyLmJ1aWxkRWxTdHlsZSA9IGZ1bmN0aW9uIChheGlzUG9pbnRlck1vZGVsKSB7XG4gICAgICAgIHZhciBheGlzUG9pbnRlclR5cGUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndHlwZScpO1xuICAgICAgICB2YXIgc3R5bGVNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0TW9kZWwoYXhpc1BvaW50ZXJUeXBlICsgJ1N0eWxlJyk7XG4gICAgICAgIHZhciBzdHlsZTtcbiAgICAgICAgaWYgKGF4aXNQb2ludGVyVHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICBzdHlsZSA9IHN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCk7XG4gICAgICAgICAgICBzdHlsZS5maWxsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChheGlzUG9pbnRlclR5cGUgPT09ICdzaGFkb3cnKSB7XG4gICAgICAgICAgICBzdHlsZSA9IHN0eWxlTW9kZWwuZ2V0QXJlYVN0eWxlKCk7XG4gICAgICAgICAgICBzdHlsZS5zdHJva2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGFiZWxQb3Mge2FsaWduLCB2ZXJ0aWNhbEFsaWduLCBwb3NpdGlvbn1cbiAgICAgKi9cbiAgICBoZWxwZXIuYnVpbGRMYWJlbEVsT3B0aW9uID0gZnVuY3Rpb24gKFxuICAgICAgICBlbE9wdGlvbiwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGksIGxhYmVsUG9zXG4gICAgKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd2YWx1ZScpO1xuICAgICAgICB2YXIgdGV4dCA9IGhlbHBlci5nZXRWYWx1ZUxhYmVsKFxuICAgICAgICAgICAgdmFsdWUsIGF4aXNNb2RlbC5heGlzLCBheGlzTW9kZWwuZWNNb2RlbCxcbiAgICAgICAgICAgIGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzZXJpZXNEYXRhSW5kaWNlcycpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2xhYmVsLnByZWNpc2lvbicpLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2xhYmVsLmZvcm1hdHRlcicpXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHZhciBsYWJlbE1vZGVsID0gYXhpc1BvaW50ZXJNb2RlbC5nZXRNb2RlbCgnbGFiZWwnKTtcbiAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gbGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgICAgIHZhciBwYWRkaW5ncyA9IGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkobGFiZWxNb2RlbC5nZXQoJ3BhZGRpbmcnKSB8fCAwKTtcblxuICAgICAgICB2YXIgZm9udCA9IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKTtcbiAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KFxuICAgICAgICAgICAgdGV4dCwgZm9udCwgbGFiZWxQb3MudGV4dEFsaWduLCBsYWJlbFBvcy50ZXh0QmFzZWxpbmVcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgcG9zaXRpb24gPSBsYWJlbFBvcy5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHdpZHRoID0gdGV4dFJlY3Qud2lkdGggKyBwYWRkaW5nc1sxXSArIHBhZGRpbmdzWzNdO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGV4dFJlY3QuaGVpZ2h0ICsgcGFkZGluZ3NbMF0gKyBwYWRkaW5nc1syXTtcblxuICAgICAgICAvLyBBZGp1c3QgYnkgYWxpZ24uXG4gICAgICAgIHZhciBhbGlnbiA9IGxhYmVsUG9zLmFsaWduO1xuICAgICAgICBhbGlnbiA9PT0gJ3JpZ2h0JyAmJiAocG9zaXRpb25bMF0gLT0gd2lkdGgpO1xuICAgICAgICBhbGlnbiA9PT0gJ2NlbnRlcicgJiYgKHBvc2l0aW9uWzBdIC09IHdpZHRoIC8gMik7XG4gICAgICAgIHZhciB2ZXJ0aWNhbEFsaWduID0gbGFiZWxQb3MudmVydGljYWxBbGlnbjtcbiAgICAgICAgdmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScgJiYgKHBvc2l0aW9uWzFdIC09IGhlaWdodCk7XG4gICAgICAgIHZlcnRpY2FsQWxpZ24gPT09ICdtaWRkbGUnICYmIChwb3NpdGlvblsxXSAtPSBoZWlnaHQgLyAyKTtcblxuICAgICAgICAvLyBOb3Qgb3ZlcmZsb3cgZWMgY29udGFpbmVyXG4gICAgICAgIGNvbmZpbmVJbkNvbnRhaW5lcihwb3NpdGlvbiwgd2lkdGgsIGhlaWdodCwgYXBpKTtcblxuICAgICAgICB2YXIgYmdDb2xvciA9IGxhYmVsTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgaWYgKCFiZ0NvbG9yIHx8IGJnQ29sb3IgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgYmdDb2xvciA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLmxpbmVTdHlsZS5jb2xvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxPcHRpb24ubGFiZWwgPSB7XG4gICAgICAgICAgICBzaGFwZToge3g6IDAsIHk6IDAsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHI6IGxhYmVsTW9kZWwuZ2V0KCdib3JkZXJSYWRpdXMnKX0sXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24uc2xpY2UoKSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogZm9udCxcbiAgICAgICAgICAgICAgICB0ZXh0RmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCksXG4gICAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uOiAnaW5zaWRlJyxcbiAgICAgICAgICAgICAgICBmaWxsOiBiZ0NvbG9yLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogbGFiZWxNb2RlbC5nZXQoJ2JvcmRlckNvbG9yJykgfHwgJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IGxhYmVsTW9kZWwuZ2V0KCdib3JkZXJXaWR0aCcpIHx8IDAsXG4gICAgICAgICAgICAgICAgc2hhZG93Qmx1cjogbGFiZWxNb2RlbC5nZXQoJ3NoYWRvd0JsdXInKSxcbiAgICAgICAgICAgICAgICBzaGFkb3dDb2xvcjogbGFiZWxNb2RlbC5nZXQoJ3NoYWRvd0NvbG9yJyksXG4gICAgICAgICAgICAgICAgc2hhZG93T2Zmc2V0WDogbGFiZWxNb2RlbC5nZXQoJ3NoYWRvd09mZnNldFgnKSxcbiAgICAgICAgICAgICAgICBzaGFkb3dPZmZzZXRZOiBsYWJlbE1vZGVsLmdldCgnc2hhZG93T2Zmc2V0WScpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gTGFibGUgc2hvdWxkIGJlIG92ZXIgYXhpc1BvaW50ZXIuXG4gICAgICAgICAgICB6MjogMTBcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gRG8gbm90IG92ZXJmbG93IGVjIGNvbnRhaW5lclxuICAgIGZ1bmN0aW9uIGNvbmZpbmVJbkNvbnRhaW5lcihwb3NpdGlvbiwgd2lkdGgsIGhlaWdodCwgYXBpKSB7XG4gICAgICAgIHZhciB2aWV3V2lkdGggPSBhcGkuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIHZpZXdIZWlnaHQgPSBhcGkuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIHBvc2l0aW9uWzBdID0gTWF0aC5taW4ocG9zaXRpb25bMF0gKyB3aWR0aCwgdmlld1dpZHRoKSAtIHdpZHRoO1xuICAgICAgICBwb3NpdGlvblsxXSA9IE1hdGgubWluKHBvc2l0aW9uWzFdICsgaGVpZ2h0LCB2aWV3SGVpZ2h0KSAtIGhlaWdodDtcbiAgICAgICAgcG9zaXRpb25bMF0gPSBNYXRoLm1heChwb3NpdGlvblswXSwgMCk7XG4gICAgICAgIHBvc2l0aW9uWzFdID0gTWF0aC5tYXgocG9zaXRpb25bMV0sIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvQXhpc30gYXhpc1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IHNlcmllc0RhdGFJbmRpY2VzXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBvcHQucHJlY2lzaW9uICdhdXRvJyBvciBhIG51bWJlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSBvcHQuZm9ybWF0dGVyIGxhYmVsIGZvcm1hdHRlclxuICAgICAqL1xuICAgIGhlbHBlci5nZXRWYWx1ZUxhYmVsID0gZnVuY3Rpb24gKHZhbHVlLCBheGlzLCBlY01vZGVsLCBzZXJpZXNEYXRhSW5kaWNlcywgb3B0KSB7XG4gICAgICAgIHZhciB0ZXh0ID0gYXhpcy5zY2FsZS5nZXRMYWJlbChcbiAgICAgICAgICAgIC8vIElmIGBwcmVjaXNpb25gIGlzIHNldCwgd2lkdGggY2FuIGJlIGZpeGVkIChsaWtlICcxMi4wMDUwMCcpLCB3aGljaFxuICAgICAgICAgICAgLy8gaGVscHMgdG8gZGVib3VuY2Ugd2hlbiB3aGVuIG1vdmluZyBsYWJlbC5cbiAgICAgICAgICAgIHZhbHVlLCB7cHJlY2lzaW9uOiBvcHQucHJlY2lzaW9ufVxuICAgICAgICApO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gb3B0LmZvcm1hdHRlcjtcblxuICAgICAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBheGlzSGVscGVyLmdldEF4aXNSYXdWYWx1ZShheGlzLCB2YWx1ZSksXG4gICAgICAgICAgICAgICAgc2VyaWVzRGF0YTogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB6clV0aWwuZWFjaChzZXJpZXNEYXRhSW5kaWNlcywgZnVuY3Rpb24gKGlkeEl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzID0gZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KGlkeEl0ZW0uc2VyaWVzSW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBpZHhJdGVtLmRhdGFJbmRleEluc2lkZTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVBhcmFtcyA9IHNlcmllcyAmJiBzZXJpZXMuZ2V0RGF0YVBhcmFtcyhkYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgIGRhdGFQYXJhbXMgJiYgcGFyYW1zLnNlcmllc0RhdGEucHVzaChkYXRhUGFyYW1zKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoenJVdGlsLmlzU3RyaW5nKGZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZm9ybWF0dGVyLnJlcGxhY2UoJ3t2YWx1ZX0nLCB0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHpyVXRpbC5pc0Z1bmN0aW9uKGZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZm9ybWF0dGVyKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9BeGlzfSBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxheW91dEluZm8ge1xuICAgICAqICByb3RhdGlvbiwgcG9zaXRpb24sIGxhYmVsT2Zmc2V0LCBsYWJlbERpcmVjdGlvbiwgbGFiZWxNYXJnaW5cbiAgICAgKiB9XG4gICAgICovXG4gICAgaGVscGVyLmdldFRyYW5zZm9ybWVkUG9zaXRpb24gPSBmdW5jdGlvbiAoYXhpcywgdmFsdWUsIGxheW91dEluZm8pIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IG1hdHJpeC5jcmVhdGUoKTtcbiAgICAgICAgbWF0cml4LnJvdGF0ZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybSwgbGF5b3V0SW5mby5yb3RhdGlvbik7XG4gICAgICAgIG1hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIGxheW91dEluZm8ucG9zaXRpb24pO1xuXG4gICAgICAgIHJldHVybiBncmFwaGljLmFwcGx5VHJhbnNmb3JtKFtcbiAgICAgICAgICAgIGF4aXMuZGF0YVRvQ29vcmQodmFsdWUpLFxuICAgICAgICAgICAgKGxheW91dEluZm8ubGFiZWxPZmZzZXQgfHwgMClcbiAgICAgICAgICAgICAgICArIChsYXlvdXRJbmZvLmxhYmVsRGlyZWN0aW9uIHx8IDEpICogKGxheW91dEluZm8ubGFiZWxNYXJnaW4gfHwgMClcbiAgICAgICAgXSwgdHJhbnNmb3JtKTtcbiAgICB9O1xuXG4gICAgaGVscGVyLmJ1aWxkQ2FydGVzaWFuU2luZ2xlTGFiZWxFbE9wdGlvbiA9IGZ1bmN0aW9uIChcbiAgICAgICAgdmFsdWUsIGVsT3B0aW9uLCBsYXlvdXRJbmZvLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaVxuICAgICkge1xuICAgICAgICB2YXIgdGV4dExheW91dCA9IEF4aXNCdWlsZGVyLmlubmVyVGV4dExheW91dChcbiAgICAgICAgICAgIGxheW91dEluZm8ucm90YXRpb24sIDAsIGxheW91dEluZm8ubGFiZWxEaXJlY3Rpb25cbiAgICAgICAgKTtcbiAgICAgICAgbGF5b3V0SW5mby5sYWJlbE1hcmdpbiA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdsYWJlbC5tYXJnaW4nKTtcbiAgICAgICAgaGVscGVyLmJ1aWxkTGFiZWxFbE9wdGlvbihlbE9wdGlvbiwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGksIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBoZWxwZXIuZ2V0VHJhbnNmb3JtZWRQb3NpdGlvbihheGlzTW9kZWwuYXhpcywgdmFsdWUsIGxheW91dEluZm8pLFxuICAgICAgICAgICAgYWxpZ246IHRleHRMYXlvdXQudGV4dEFsaWduLFxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogdGV4dExheW91dC50ZXh0VmVydGljYWxBbGlnblxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcDFcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwMlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeERpbUluZGV4PTBdIG9yIDFcbiAgICAgKi9cbiAgICBoZWxwZXIubWFrZUxpbmVTaGFwZSA9IGZ1bmN0aW9uIChwMSwgcDIsIHhEaW1JbmRleCkge1xuICAgICAgICB4RGltSW5kZXggPSB4RGltSW5kZXggfHwgMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgxOiBwMVt4RGltSW5kZXhdLFxuICAgICAgICAgICAgeTE6IHAxWzEgLSB4RGltSW5kZXhdLFxuICAgICAgICAgICAgeDI6IHAyW3hEaW1JbmRleF0sXG4gICAgICAgICAgICB5MjogcDJbMSAtIHhEaW1JbmRleF1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0geHlcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB3aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeERpbUluZGV4PTBdIG9yIDFcbiAgICAgKi9cbiAgICBoZWxwZXIubWFrZVJlY3RTaGFwZSA9IGZ1bmN0aW9uICh4eSwgd2gsIHhEaW1JbmRleCkge1xuICAgICAgICB4RGltSW5kZXggPSB4RGltSW5kZXggfHwgMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHh5W3hEaW1JbmRleF0sXG4gICAgICAgICAgICB5OiB4eVsxIC0geERpbUluZGV4XSxcbiAgICAgICAgICAgIHdpZHRoOiB3aFt4RGltSW5kZXhdLFxuICAgICAgICAgICAgaGVpZ2h0OiB3aFsxIC0geERpbUluZGV4XVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBoZWxwZXIubWFrZVNlY3RvclNoYXBlID0gZnVuY3Rpb24gKGN4LCBjeSwgcjAsIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgICByMDogcjAsXG4gICAgICAgICAgICByOiByLFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcbiAgICAgICAgICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGhlbHBlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvdmlld0hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n    var formatUtil = __webpack_require__(22);\n    var graphic = __webpack_require__(34);\n    var Model = __webpack_require__(28);\n    var numberUtil = __webpack_require__(23);\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = __webpack_require__(26);\n    var matrix = __webpack_require__(27);\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n\n    var PI = Math.PI;\n\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = {\n            componentType: axisModel.mainType\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     * @param {number} [opt.nameTruncateMaxWidth]\n     */\n    var AxisBuilder = function (axisModel, opt) {\n\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n\n        // Default value\n        zrUtil.defaults(\n            opt,\n            {\n                labelOffset: 0,\n                nameDirection: 1,\n                tickDirection: 1,\n                labelDirection: 1,\n                silent: true\n            }\n        );\n\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n            position: opt.position.slice(),\n            rotation: opt.rotation\n        });\n\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n\n        this._dumbGroup = dumbGroup;\n    };\n\n    AxisBuilder.prototype = {\n\n        constructor: AxisBuilder,\n\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n\n        add: function (name) {\n            builders[name].call(this);\n        },\n\n        getGroup: function () {\n            return this.group;\n        }\n\n    };\n\n    var builders = {\n\n        /**\n         * @private\n         */\n        axisLine: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisLine.show')) {\n                return;\n            }\n\n            var extent = this.axisModel.axis.getExtent();\n\n            var matrix = this._transform;\n            var pt1 = [extent[0], 0];\n            var pt2 = [extent[1], 0];\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n\n            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                // Id for animation\n                anid: 'line',\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.extend(\n                    {lineCap: 'round'},\n                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n                ),\n                strokeContainThreshold: opt.strokeContainThreshold || 5,\n                silent: true,\n                z2: 1\n            })));\n        },\n\n        /**\n         * @private\n         */\n        axisTick: function () {\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n\n            if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n                return;\n            }\n\n            var tickModel = axisModel.getModel('axisTick');\n            var opt = this.opt;\n\n            var lineStyleModel = tickModel.getModel('lineStyle');\n            var tickLen = tickModel.get('length');\n\n            var tickInterval = getInterval(tickModel, opt.labelInterval);\n            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n            var ticks = axis.scale.getTicks();\n\n            var pt1 = [];\n            var pt2 = [];\n            var matrix = this._transform;\n\n            for (var i = 0; i < ticksCoords.length; i++) {\n                // Only ordinal scale support tick interval\n                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                     continue;\n                }\n\n                var tickCoord = ticksCoords[i];\n\n                pt1[0] = tickCoord;\n                pt1[1] = 0;\n                pt2[0] = tickCoord;\n                pt2[1] = opt.tickDirection * tickLen;\n\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                // Tick line, Not use group transform to have better line draw\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                    // Id for animation\n                    anid: 'tick_' + ticks[i],\n\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.defaults(\n                        lineStyleModel.getLineStyle(),\n                        {\n                            stroke: axisModel.get('axisLine.lineStyle.color')\n                        }\n                    ),\n                    z2: 2,\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @private\n         */\n        axisLabel: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n            if (!show || axis.scale.isBlank()) {\n                return;\n            }\n\n            var labelModel = axisModel.getModel('axisLabel');\n            var textStyleModel = labelModel.getModel('textStyle');\n            var labelMargin = labelModel.get('margin');\n            var ticks = axis.scale.getTicks();\n            var labels = axisModel.getFormattedLabels();\n\n            // Special label rotate.\n            var labelRotation = (\n                retrieve(opt.labelRotate, labelModel.get('rotate')) || 0\n            ) * PI / 180;\n\n            var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n            var categoryData = axisModel.get('data');\n\n            var textEls = [];\n            var silent = isSilent(axisModel);\n            var triggerEvent = axisModel.get('triggerEvent');\n\n            zrUtil.each(ticks, function (tickVal, index) {\n                if (ifIgnoreOnTick(axis, index, opt.labelInterval)) {\n                     return;\n                }\n\n                var itemTextStyleModel = textStyleModel;\n                if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n                    itemTextStyleModel = new Model(\n                        categoryData[tickVal].textStyle, textStyleModel, axisModel.ecModel\n                    );\n                }\n                var textColor = itemTextStyleModel.getTextColor()\n                    || axisModel.get('axisLine.lineStyle.color');\n\n                var tickCoord = axis.dataToCoord(tickVal);\n                var pos = [\n                    tickCoord,\n                    opt.labelOffset + opt.labelDirection * labelMargin\n                ];\n                var labelStr = axis.scale.getLabel(tickVal);\n\n                var textEl = new graphic.Text({\n\n                    // Id for animation\n                    anid: 'label_' + tickVal,\n\n                    style: {\n                        text: labels[index],\n                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.textVerticalAlign,\n                        textFont: itemTextStyleModel.getFont(),\n                        fill: typeof textColor === 'function'\n                            ? textColor(\n                                // (1) In category axis with data zoom, tick is not the original\n                                // index of axis.data. So tick should not be exposed to user\n                                // in category axis.\n                                // (2) Compatible with previous version, which always returns labelStr.\n                                // But in interval scale labelStr is like '223,445', which maked\n                                // user repalce ','. So we modify it to return original val but remain\n                                // it as 'string' to avoid error in replacing.\n                                axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal,\n                                index\n                            )\n                            : textColor\n                    },\n                    position: pos,\n                    rotation: labelLayout.rotation,\n                    silent: silent,\n                    z2: 10\n                });\n\n                // Pack data for mouse event\n                if (triggerEvent) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisLabel';\n                    textEl.eventData.value = labelStr;\n                }\n\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n\n                textEls.push(textEl);\n                this.group.add(textEl);\n\n                textEl.decomposeTransform();\n\n            }, this);\n\n            fixMinMaxLabelShow(axisModel, textEls);\n        },\n\n        /**\n         * @private\n         */\n        axisName: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var name = retrieve(opt.axisName, axisModel.get('name'));\n\n            if (!name) {\n                return;\n            }\n\n            var nameLocation = axisModel.get('nameLocation');\n            var nameDirection = opt.nameDirection;\n            var textStyleModel = axisModel.getModel('nameTextStyle');\n            var gap = axisModel.get('nameGap') || 0;\n\n            var extent = this.axisModel.axis.getExtent();\n            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n            var pos = [\n                nameLocation === 'start'\n                    ? extent[0] - gapSignal * gap\n                    : nameLocation === 'end'\n                    ? extent[1] + gapSignal * gap\n                    : (extent[0] + extent[1]) / 2, // 'middle'\n                // Reuse labelOffset.\n                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n            ];\n\n            var labelLayout;\n\n            var nameRotation = axisModel.get('nameRotate');\n            if (nameRotation != null) {\n                nameRotation = nameRotation * PI / 180; // To radian.\n            }\n\n            var axisNameAvailableWidth;\n\n            if (nameLocation === 'middle') {\n                labelLayout = innerTextLayout(\n                    opt.rotation,\n                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                    nameDirection\n                );\n            }\n            else {\n                labelLayout = endTextLayout(\n                    opt, nameLocation, nameRotation || 0, extent\n                );\n\n                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                if (axisNameAvailableWidth != null) {\n                    axisNameAvailableWidth = Math.abs(\n                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                    );\n                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                }\n            }\n\n            var textFont = textStyleModel.getFont();\n\n            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n            var ellipsis = truncateOpt.ellipsis;\n            var maxWidth = retrieve(\n                opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth\n            );\n            var truncatedText = (ellipsis != null && maxWidth != null)\n                ? formatUtil.truncateText(\n                    name, maxWidth, textFont, ellipsis,\n                    {minChar: 2, placeholder: truncateOpt.placeholder}\n                )\n                : name;\n\n            var tooltipOpt = axisModel.get('tooltip', true);\n\n            var mainType = axisModel.mainType;\n            var formatterParams = {\n                componentType: mainType,\n                name: name,\n                $vars: ['name']\n            };\n            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n            var textEl = new graphic.Text({\n\n                // Id for animation\n                anid: 'name',\n\n                __fullText: name,\n                __truncatedText: truncatedText,\n\n                style: {\n                    text: truncatedText,\n                    textFont: textFont,\n                    fill: textStyleModel.getTextColor()\n                        || axisModel.get('axisLine.lineStyle.color'),\n                    textAlign: labelLayout.textAlign,\n                    textVerticalAlign: labelLayout.textVerticalAlign\n                },\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: isSilent(axisModel),\n                z2: 1,\n                tooltip: (tooltipOpt && tooltipOpt.show)\n                    ? zrUtil.extend({\n                        content: name,\n                        formatter: function () {\n                            return name;\n                        },\n                        formatterParams: formatterParams\n                    }, tooltipOpt)\n                    : null\n            });\n\n            if (axisModel.get('triggerEvent')) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisName';\n                textEl.eventData.name = name;\n            }\n\n            // FIXME\n            this._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            this.group.add(textEl);\n\n            textEl.decomposeTransform();\n        }\n\n    };\n\n    /**\n     * @public\n     * @static\n     * @param {Object} opt\n     * @param {number} axisRotation in radian\n     * @param {number} textRotation in radian\n     * @param {number} direction\n     * @return {Object} {\n     *  rotation, // according to axis\n     *  textAlign,\n     *  textVerticalAlign\n     * }\n     */\n    var innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - axisRotation);\n        var textAlign;\n        var textVerticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            }\n            else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    };\n\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var textVerticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = (textPosition === 'start' && !inverse)\n            || (textPosition !== 'start' && inverse);\n\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            textVerticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            textVerticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            }\n            else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    }\n\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent')\n            // Consider mouse cursor, add these restrictions.\n            || !(\n                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n            );\n    }\n\n    function fixMinMaxLabelShow(axisModel, textEls) {\n        // If min or max are user set, we need to check\n        // If the tick on min(max) are overlap on their neighbour tick\n        // If they are overlapped, we need to hide the min(max) tick label\n        var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n        var firstLabel = textEls[0];\n        var nextLabel = textEls[1];\n        var lastLabel = textEls[textEls.length - 1];\n        var prevLabel = textEls[textEls.length - 2];\n\n        if (showMinLabel === false) {\n            firstLabel.ignore = true;\n        }\n        else if (axisModel.getMin() != null && isTwoLabelOverlapped(firstLabel, nextLabel)) {\n            showMinLabel ? (nextLabel.ignore = true) : (firstLabel.ignore = true);\n        }\n\n        if (showMaxLabel === false) {\n            lastLabel.ignore = true;\n        }\n        else if (axisModel.getMax() != null && isTwoLabelOverlapped(prevLabel, lastLabel)) {\n            showMaxLabel ? (prevLabel.ignore = true) : (lastLabel.ignore = true);\n        }\n    }\n\n    function isTwoLabelOverlapped(current, next, labelLayout) {\n        // current and next has the same rotation.\n        var firstRect = current && current.getBoundingRect().clone();\n        var nextRect = next && next.getBoundingRect().clone();\n\n        if (!firstRect || !nextRect) {\n            return;\n        }\n\n        // When checking intersect of two rotated labels, we use mRotationBack\n        // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n        var mRotationBack = matrix.identity([]);\n        matrix.rotate(mRotationBack, mRotationBack, -current.rotation);\n\n        firstRect.applyTransform(matrix.mul([], mRotationBack, current.getLocalTransform()));\n        nextRect.applyTransform(matrix.mul([], mRotationBack, next.getLocalTransform()));\n\n        return firstRect.intersect(nextRect);\n    }\n\n\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n        var rawTick;\n        var scale = axis.scale;\n        return scale.type === 'ordinal'\n            && (\n                typeof interval === 'function'\n                    ? (\n                        rawTick = scale.getTicks()[i],\n                        !interval(rawTick, scale.getLabel(rawTick))\n                    )\n                    : i % (interval + 1)\n            );\n    };\n\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n        var interval = model.get('interval');\n        if (interval == null || interval == 'auto') {\n            interval = labelInterval;\n        }\n        return interval;\n    };\n\n    module.exports = AxisBuilder;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL0F4aXNCdWlsZGVyLmpzPzY0MTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLHlDQUF5QztBQUM1RCxtQkFBbUIseUNBQXlDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYTs7QUFFYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE0MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9mb3JtYXQnKTtcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL01vZGVsJyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bWJlcicpO1xuICAgIHZhciByZW1SYWRpYW4gPSBudW1iZXJVdGlsLnJlbVJhZGlhbjtcbiAgICB2YXIgaXNSYWRpYW5Bcm91bmRaZXJvID0gbnVtYmVyVXRpbC5pc1JhZGlhbkFyb3VuZFplcm87XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeCcpO1xuICAgIHZhciB2MkFwcGx5VHJhbnNmb3JtID0gdmVjMi5hcHBseVRyYW5zZm9ybTtcbiAgICB2YXIgcmV0cmlldmUgPSB6clV0aWwucmV0cmlldmU7XG5cbiAgICB2YXIgUEkgPSBNYXRoLlBJO1xuXG4gICAgZnVuY3Rpb24gbWFrZUF4aXNFdmVudERhdGFCYXNlKGF4aXNNb2RlbCkge1xuICAgICAgICB2YXIgZXZlbnREYXRhID0ge1xuICAgICAgICAgICAgY29tcG9uZW50VHlwZTogYXhpc01vZGVsLm1haW5UeXBlXG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50RGF0YVtheGlzTW9kZWwubWFpblR5cGUgKyAnSW5kZXgnXSA9IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleDtcbiAgICAgICAgcmV0dXJuIGV2ZW50RGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGZpbmFsIGF4aXMgaXMgdHJhbnNsYXRlZCBhbmQgcm90YXRlZCBmcm9tIGEgXCJzdGFuZGFyZCBheGlzXCIuXG4gICAgICogU28gb3B0LnBvc2l0aW9uIGFuZCBvcHQucm90YXRpb24gaXMgcmVxdWlyZWQuXG4gICAgICpcbiAgICAgKiBBIHN0YW5kYXJkIGF4aXMgaXMgYW5kIGF4aXMgZnJvbSBbMCwgMF0gdG8gWzAsIGF4aXNFeHRlbnRbMV1dLFxuICAgICAqIGZvciBleGFtcGxlOiAoMCwgMCkgLS0tLS0tLS0tLS0tPiAoMCwgNTApXG4gICAgICpcbiAgICAgKiBuYW1lRGlyZWN0aW9uIG9yIHRpY2tEaXJlY3Rpb24gb3IgbGFiZWxEaXJlY3Rpb24gaXMgMSBtZWFucyB0aWNrXG4gICAgICogb3IgbGFiZWwgaXMgYmVsb3cgdGhlIHN0YW5kYXJkIGF4aXMsIHdoZXJlYXMgaXMgLTEgbWVhbnMgYWJvdmVcbiAgICAgKiB0aGUgc3RhbmRhcmQgYXhpcy4gbGFiZWxPZmZzZXQgbWVhbnMgb2Zmc2V0IGJldHdlZW4gbGFiZWwgYW5kIGF4aXMsXG4gICAgICogd2hpY2ggaXMgdXNlZnVsIHdoZW4gJ29uWmVybycsIHdoZXJlIGF4aXNMYWJlbCBpcyBpbiB0aGUgZ3JpZCBhbmRcbiAgICAgKiBsYWJlbCBpbiBvdXRzaWRlIGdyaWQuXG4gICAgICpcbiAgICAgKiBUaXBzOiBsaWtlIGFsd2F5cyxcbiAgICAgKiBwb3NpdGl2ZSByb3RhdGlvbiByZXByZXNlbnRzIGFudGljbG9ja3dpc2UsIGFuZCBuZWdhdGl2ZSByb3RhdGlvblxuICAgICAqIHJlcHJlc2VudHMgY2xvY2t3aXNlLlxuICAgICAqIFRoZSBkaXJlY3Rpb24gb2YgcG9zaXRpb24gY29vcmRpbmF0ZSBpcyB0aGUgc2FtZSBhcyB0aGUgZGlyZWN0aW9uXG4gICAgICogb2Ygc2NyZWVuIGNvb3JkaW5hdGUuXG4gICAgICpcbiAgICAgKiBEbyBub3QgbmVlZCB0byBjb25zaWRlciBheGlzICdpbnZlcnNlJywgd2hpY2ggaXMgYXV0byBwcm9jZXNzZWQgYnlcbiAgICAgKiBheGlzIGV4dGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfSBncm91cFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBheGlzTW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0IFN0YW5kYXJkIGF4aXMgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvcHQucG9zaXRpb24gW3gsIHldXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdC5yb3RhdGlvbiBieSByYWRpYW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5uYW1lRGlyZWN0aW9uPTFdIDEgb3IgLTEgVXNlZCB3aGVuIG5hbWVMb2NhdGlvbiBpcyAnbWlkZGxlJy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC50aWNrRGlyZWN0aW9uPTFdIDEgb3IgLTFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5sYWJlbERpcmVjdGlvbj0xXSAxIG9yIC0xXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQubGFiZWxPZmZzZXQ9MF0gVXNlZnVsbCB3aGVuIG9uWmVyby5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdC5heGlzTGFiZWxTaG93XSBkZWZhdWx0IGdldCBmcm9tIGF4aXNNb2RlbC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdC5heGlzTmFtZV0gZGVmYXVsdCBnZXQgZnJvbSBheGlzTW9kZWwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuYXhpc05hbWVBdmFpbGFibGVXaWR0aF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5sYWJlbFJvdGF0ZV0gYnkgZGVncmVlLCBkZWZhdWx0IGdldCBmcm9tIGF4aXNNb2RlbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5sYWJlbEludGVydmFsXSBEZWZhdWx0IGxhYmVsIGludGVydmFsIHdoZW4gbGFiZWxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCBmcm9tIG1vZGVsIGlzIG51bGwgb3IgJ2F1dG8nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LnN0cm9rZUNvbnRhaW5UaHJlc2hvbGRdIERlZmF1bHQgbGFiZWwgaW50ZXJ2YWwgd2hlbiBsYWJlbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0Lm5hbWVUcnVuY2F0ZU1heFdpZHRoXVxuICAgICAqL1xuICAgIHZhciBBeGlzQnVpbGRlciA9IGZ1bmN0aW9uIChheGlzTW9kZWwsIG9wdCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0ID0gb3B0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXhpc01vZGVsID0gYXhpc01vZGVsO1xuXG4gICAgICAgIC8vIERlZmF1bHQgdmFsdWVcbiAgICAgICAgenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAgb3B0LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIG5hbWVEaXJlY3Rpb246IDEsXG4gICAgICAgICAgICAgICAgdGlja0RpcmVjdGlvbjogMSxcbiAgICAgICAgICAgICAgICBsYWJlbERpcmVjdGlvbjogMSxcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcblxuICAgICAgICAvLyBGSVhNRSBOb3QgdXNlIGEgc2VwZXJhdGUgdGV4dCBncm91cD9cbiAgICAgICAgdmFyIGR1bWJHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBvcHQucG9zaXRpb24uc2xpY2UoKSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBvcHQucm90YXRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGhpcy5ncm91cC5hZGQoZHVtYkdyb3VwKTtcbiAgICAgICAgLy8gdGhpcy5fZHVtYkdyb3VwID0gZHVtYkdyb3VwO1xuXG4gICAgICAgIGR1bWJHcm91cC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gZHVtYkdyb3VwLnRyYW5zZm9ybTtcblxuICAgICAgICB0aGlzLl9kdW1iR3JvdXAgPSBkdW1iR3JvdXA7XG4gICAgfTtcblxuICAgIEF4aXNCdWlsZGVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQXhpc0J1aWxkZXIsXG5cbiAgICAgICAgaGFzQnVpbGRlcjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWJ1aWxkZXJzW25hbWVdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGJ1aWxkZXJzW25hbWVdLmNhbGwodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0R3JvdXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyb3VwO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdmFyIGJ1aWxkZXJzID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXhpc0xpbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdDtcbiAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmF4aXNNb2RlbDtcblxuICAgICAgICAgICAgaWYgKCFheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5zaG93JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLmF4aXNNb2RlbC5heGlzLmdldEV4dGVudCgpO1xuXG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5fdHJhbnNmb3JtO1xuICAgICAgICAgICAgdmFyIHB0MSA9IFtleHRlbnRbMF0sIDBdO1xuICAgICAgICAgICAgdmFyIHB0MiA9IFtleHRlbnRbMV0sIDBdO1xuICAgICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocHQxLCBwdDEsIG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwdDIsIHB0MiwgbWF0cml4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQobmV3IGdyYXBoaWMuTGluZShncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lKHtcblxuICAgICAgICAgICAgICAgIC8vIElkIGZvciBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBhbmlkOiAnbGluZScsXG5cbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICB4MTogcHQxWzBdLFxuICAgICAgICAgICAgICAgICAgICB5MTogcHQxWzFdLFxuICAgICAgICAgICAgICAgICAgICB4MjogcHQyWzBdLFxuICAgICAgICAgICAgICAgICAgICB5MjogcHQyWzFdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZTogenJVdGlsLmV4dGVuZChcbiAgICAgICAgICAgICAgICAgICAge2xpbmVDYXA6ICdyb3VuZCd9LFxuICAgICAgICAgICAgICAgICAgICBheGlzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNMaW5lLmxpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBzdHJva2VDb250YWluVGhyZXNob2xkOiBvcHQuc3Ryb2tlQ29udGFpblRocmVzaG9sZCB8fCA1LFxuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB6MjogMVxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGF4aXNUaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5heGlzTW9kZWw7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuXG4gICAgICAgICAgICBpZiAoIWF4aXNNb2RlbC5nZXQoJ2F4aXNUaWNrLnNob3cnKSB8fCBheGlzLnNjYWxlLmlzQmxhbmsoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRpY2tNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnYXhpc1RpY2snKTtcbiAgICAgICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdDtcblxuICAgICAgICAgICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gdGlja01vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKTtcbiAgICAgICAgICAgIHZhciB0aWNrTGVuID0gdGlja01vZGVsLmdldCgnbGVuZ3RoJyk7XG5cbiAgICAgICAgICAgIHZhciB0aWNrSW50ZXJ2YWwgPSBnZXRJbnRlcnZhbCh0aWNrTW9kZWwsIG9wdC5sYWJlbEludGVydmFsKTtcbiAgICAgICAgICAgIHZhciB0aWNrc0Nvb3JkcyA9IGF4aXMuZ2V0VGlja3NDb29yZHModGlja01vZGVsLmdldCgnYWxpZ25XaXRoTGFiZWwnKSk7XG4gICAgICAgICAgICB2YXIgdGlja3MgPSBheGlzLnNjYWxlLmdldFRpY2tzKCk7XG5cbiAgICAgICAgICAgIHZhciBwdDEgPSBbXTtcbiAgICAgICAgICAgIHZhciBwdDIgPSBbXTtcbiAgICAgICAgICAgIHZhciBtYXRyaXggPSB0aGlzLl90cmFuc2Zvcm07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3NDb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IG9yZGluYWwgc2NhbGUgc3VwcG9ydCB0aWNrIGludGVydmFsXG4gICAgICAgICAgICAgICAgaWYgKGlmSWdub3JlT25UaWNrKGF4aXMsIGksIHRpY2tJbnRlcnZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0aWNrQ29vcmQgPSB0aWNrc0Nvb3Jkc1tpXTtcblxuICAgICAgICAgICAgICAgIHB0MVswXSA9IHRpY2tDb29yZDtcbiAgICAgICAgICAgICAgICBwdDFbMV0gPSAwO1xuICAgICAgICAgICAgICAgIHB0MlswXSA9IHRpY2tDb29yZDtcbiAgICAgICAgICAgICAgICBwdDJbMV0gPSBvcHQudGlja0RpcmVjdGlvbiAqIHRpY2tMZW47XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocHQxLCBwdDEsIG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocHQyLCBwdDIsIG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRpY2sgbGluZSwgTm90IHVzZSBncm91cCB0cmFuc2Zvcm0gdG8gaGF2ZSBiZXR0ZXIgbGluZSBkcmF3XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQobmV3IGdyYXBoaWMuTGluZShncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lKHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZCBmb3IgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGFuaWQ6ICd0aWNrXycgKyB0aWNrc1tpXSxcblxuICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDE6IHB0MVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxOiBwdDFbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB4MjogcHQyWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTI6IHB0MlsxXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5saW5lU3R5bGUuY29sb3InKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICB6MjogMixcbiAgICAgICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsfSBheGlzTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZE1vZGVsfSBncmlkTW9kZWxcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGF4aXNMYWJlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0O1xuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuYXhpc01vZGVsO1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICAgICAgICAgIHZhciBzaG93ID0gcmV0cmlldmUob3B0LmF4aXNMYWJlbFNob3csIGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93JykpO1xuXG4gICAgICAgICAgICBpZiAoIXNob3cgfHwgYXhpcy5zY2FsZS5pc0JsYW5rKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsYWJlbE1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwnKTtcbiAgICAgICAgICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGxhYmVsTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICAgICAgICAgICAgdmFyIGxhYmVsTWFyZ2luID0gbGFiZWxNb2RlbC5nZXQoJ21hcmdpbicpO1xuICAgICAgICAgICAgdmFyIHRpY2tzID0gYXhpcy5zY2FsZS5nZXRUaWNrcygpO1xuICAgICAgICAgICAgdmFyIGxhYmVscyA9IGF4aXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbHMoKTtcblxuICAgICAgICAgICAgLy8gU3BlY2lhbCBsYWJlbCByb3RhdGUuXG4gICAgICAgICAgICB2YXIgbGFiZWxSb3RhdGlvbiA9IChcbiAgICAgICAgICAgICAgICByZXRyaWV2ZShvcHQubGFiZWxSb3RhdGUsIGxhYmVsTW9kZWwuZ2V0KCdyb3RhdGUnKSkgfHwgMFxuICAgICAgICAgICAgKSAqIFBJIC8gMTgwO1xuXG4gICAgICAgICAgICB2YXIgbGFiZWxMYXlvdXQgPSBpbm5lclRleHRMYXlvdXQob3B0LnJvdGF0aW9uLCBsYWJlbFJvdGF0aW9uLCBvcHQubGFiZWxEaXJlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIGNhdGVnb3J5RGF0YSA9IGF4aXNNb2RlbC5nZXQoJ2RhdGEnKTtcblxuICAgICAgICAgICAgdmFyIHRleHRFbHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBzaWxlbnQgPSBpc1NpbGVudChheGlzTW9kZWwpO1xuICAgICAgICAgICAgdmFyIHRyaWdnZXJFdmVudCA9IGF4aXNNb2RlbC5nZXQoJ3RyaWdnZXJFdmVudCcpO1xuXG4gICAgICAgICAgICB6clV0aWwuZWFjaCh0aWNrcywgZnVuY3Rpb24gKHRpY2tWYWwsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlmSWdub3JlT25UaWNrKGF4aXMsIGluZGV4LCBvcHQubGFiZWxJbnRlcnZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaXRlbVRleHRTdHlsZU1vZGVsID0gdGV4dFN0eWxlTW9kZWw7XG4gICAgICAgICAgICAgICAgaWYgKGNhdGVnb3J5RGF0YSAmJiBjYXRlZ29yeURhdGFbdGlja1ZhbF0gJiYgY2F0ZWdvcnlEYXRhW3RpY2tWYWxdLnRleHRTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtVGV4dFN0eWxlTW9kZWwgPSBuZXcgTW9kZWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeURhdGFbdGlja1ZhbF0udGV4dFN0eWxlLCB0ZXh0U3R5bGVNb2RlbCwgYXhpc01vZGVsLmVjTW9kZWxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRleHRDb2xvciA9IGl0ZW1UZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKVxuICAgICAgICAgICAgICAgICAgICB8fCBheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5saW5lU3R5bGUuY29sb3InKTtcblxuICAgICAgICAgICAgICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLmRhdGFUb0Nvb3JkKHRpY2tWYWwpO1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIHRpY2tDb29yZCxcbiAgICAgICAgICAgICAgICAgICAgb3B0LmxhYmVsT2Zmc2V0ICsgb3B0LmxhYmVsRGlyZWN0aW9uICogbGFiZWxNYXJnaW5cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbFN0ciA9IGF4aXMuc2NhbGUuZ2V0TGFiZWwodGlja1ZhbCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dEVsID0gbmV3IGdyYXBoaWMuVGV4dCh7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWQgZm9yIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICBhbmlkOiAnbGFiZWxfJyArIHRpY2tWYWwsXG5cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IGl0ZW1UZXh0U3R5bGVNb2RlbC5nZXQoJ2FsaWduJywgdHJ1ZSkgfHwgbGFiZWxMYXlvdXQudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IGl0ZW1UZXh0U3R5bGVNb2RlbC5nZXQoJ2Jhc2VsaW5lJywgdHJ1ZSkgfHwgbGFiZWxMYXlvdXQudGV4dFZlcnRpY2FsQWxpZ24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogaXRlbVRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IHR5cGVvZiB0ZXh0Q29sb3IgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRleHRDb2xvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKDEpIEluIGNhdGVnb3J5IGF4aXMgd2l0aCBkYXRhIHpvb20sIHRpY2sgaXMgbm90IHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmRleCBvZiBheGlzLmRhdGEuIFNvIHRpY2sgc2hvdWxkIG5vdCBiZSBleHBvc2VkIHRvIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gY2F0ZWdvcnkgYXhpcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKDIpIENvbXBhdGlibGUgd2l0aCBwcmV2aW91cyB2ZXJzaW9uLCB3aGljaCBhbHdheXMgcmV0dXJucyBsYWJlbFN0ci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGluIGludGVydmFsIHNjYWxlIGxhYmVsU3RyIGlzIGxpa2UgJzIyMyw0NDUnLCB3aGljaCBtYWtlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VyIHJlcGFsY2UgJywnLiBTbyB3ZSBtb2RpZnkgaXQgdG8gcmV0dXJuIG9yaWdpbmFsIHZhbCBidXQgcmVtYWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGFzICdzdHJpbmcnIHRvIGF2b2lkIGVycm9yIGluIHJlcGxhY2luZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gbGFiZWxTdHIgOiBheGlzLnR5cGUgPT09ICd2YWx1ZScgPyB0aWNrVmFsICsgJycgOiB0aWNrVmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRleHRDb2xvclxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogbGFiZWxMYXlvdXQucm90YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHNpbGVudDogc2lsZW50LFxuICAgICAgICAgICAgICAgICAgICB6MjogMTBcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFBhY2sgZGF0YSBmb3IgbW91c2UgZXZlbnRcbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRFbC5ldmVudERhdGEgPSBtYWtlQXhpc0V2ZW50RGF0YUJhc2UoYXhpc01vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVsLmV2ZW50RGF0YS50YXJnZXRUeXBlID0gJ2F4aXNMYWJlbCc7XG4gICAgICAgICAgICAgICAgICAgIHRleHRFbC5ldmVudERhdGEudmFsdWUgPSBsYWJlbFN0cjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgIHRoaXMuX2R1bWJHcm91cC5hZGQodGV4dEVsKTtcbiAgICAgICAgICAgICAgICB0ZXh0RWwudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgICAgICB0ZXh0RWxzLnB1c2godGV4dEVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmFkZCh0ZXh0RWwpO1xuXG4gICAgICAgICAgICAgICAgdGV4dEVsLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgZml4TWluTWF4TGFiZWxTaG93KGF4aXNNb2RlbCwgdGV4dEVscyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBheGlzTmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0O1xuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuYXhpc01vZGVsO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSByZXRyaWV2ZShvcHQuYXhpc05hbWUsIGF4aXNNb2RlbC5nZXQoJ25hbWUnKSk7XG5cbiAgICAgICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5hbWVMb2NhdGlvbiA9IGF4aXNNb2RlbC5nZXQoJ25hbWVMb2NhdGlvbicpO1xuICAgICAgICAgICAgdmFyIG5hbWVEaXJlY3Rpb24gPSBvcHQubmFtZURpcmVjdGlvbjtcbiAgICAgICAgICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnbmFtZVRleHRTdHlsZScpO1xuICAgICAgICAgICAgdmFyIGdhcCA9IGF4aXNNb2RlbC5nZXQoJ25hbWVHYXAnKSB8fCAwO1xuXG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5heGlzTW9kZWwuYXhpcy5nZXRFeHRlbnQoKTtcbiAgICAgICAgICAgIHZhciBnYXBTaWduYWwgPSBleHRlbnRbMF0gPiBleHRlbnRbMV0gPyAtMSA6IDE7XG4gICAgICAgICAgICB2YXIgcG9zID0gW1xuICAgICAgICAgICAgICAgIG5hbWVMb2NhdGlvbiA9PT0gJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICA/IGV4dGVudFswXSAtIGdhcFNpZ25hbCAqIGdhcFxuICAgICAgICAgICAgICAgICAgICA6IG5hbWVMb2NhdGlvbiA9PT0gJ2VuZCdcbiAgICAgICAgICAgICAgICAgICAgPyBleHRlbnRbMV0gKyBnYXBTaWduYWwgKiBnYXBcbiAgICAgICAgICAgICAgICAgICAgOiAoZXh0ZW50WzBdICsgZXh0ZW50WzFdKSAvIDIsIC8vICdtaWRkbGUnXG4gICAgICAgICAgICAgICAgLy8gUmV1c2UgbGFiZWxPZmZzZXQuXG4gICAgICAgICAgICAgICAgbmFtZUxvY2F0aW9uID09PSAnbWlkZGxlJyA/IG9wdC5sYWJlbE9mZnNldCArIG5hbWVEaXJlY3Rpb24gKiBnYXAgOiAwXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICB2YXIgbGFiZWxMYXlvdXQ7XG5cbiAgICAgICAgICAgIHZhciBuYW1lUm90YXRpb24gPSBheGlzTW9kZWwuZ2V0KCduYW1lUm90YXRlJyk7XG4gICAgICAgICAgICBpZiAobmFtZVJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuYW1lUm90YXRpb24gPSBuYW1lUm90YXRpb24gKiBQSSAvIDE4MDsgLy8gVG8gcmFkaWFuLlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXhpc05hbWVBdmFpbGFibGVXaWR0aDtcblxuICAgICAgICAgICAgaWYgKG5hbWVMb2NhdGlvbiA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgICAgICAgICBsYWJlbExheW91dCA9IGlubmVyVGV4dExheW91dChcbiAgICAgICAgICAgICAgICAgICAgb3B0LnJvdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBuYW1lUm90YXRpb24gIT0gbnVsbCA/IG5hbWVSb3RhdGlvbiA6IG9wdC5yb3RhdGlvbiwgLy8gQWRhcHQgdG8gYXhpcy5cbiAgICAgICAgICAgICAgICAgICAgbmFtZURpcmVjdGlvblxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYWJlbExheW91dCA9IGVuZFRleHRMYXlvdXQoXG4gICAgICAgICAgICAgICAgICAgIG9wdCwgbmFtZUxvY2F0aW9uLCBuYW1lUm90YXRpb24gfHwgMCwgZXh0ZW50XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggPSBvcHQuYXhpc05hbWVBdmFpbGFibGVXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoYXhpc05hbWVBdmFpbGFibGVXaWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggPSBNYXRoLmFicyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggLyBNYXRoLnNpbihsYWJlbExheW91dC5yb3RhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgIWlzRmluaXRlKGF4aXNOYW1lQXZhaWxhYmxlV2lkdGgpICYmIChheGlzTmFtZUF2YWlsYWJsZVdpZHRoID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGV4dEZvbnQgPSB0ZXh0U3R5bGVNb2RlbC5nZXRGb250KCk7XG5cbiAgICAgICAgICAgIHZhciB0cnVuY2F0ZU9wdCA9IGF4aXNNb2RlbC5nZXQoJ25hbWVUcnVuY2F0ZScsIHRydWUpIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGVsbGlwc2lzID0gdHJ1bmNhdGVPcHQuZWxsaXBzaXM7XG4gICAgICAgICAgICB2YXIgbWF4V2lkdGggPSByZXRyaWV2ZShcbiAgICAgICAgICAgICAgICBvcHQubmFtZVRydW5jYXRlTWF4V2lkdGgsIHRydW5jYXRlT3B0Lm1heFdpZHRoLCBheGlzTmFtZUF2YWlsYWJsZVdpZHRoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIHRydW5jYXRlZFRleHQgPSAoZWxsaXBzaXMgIT0gbnVsbCAmJiBtYXhXaWR0aCAhPSBudWxsKVxuICAgICAgICAgICAgICAgID8gZm9ybWF0VXRpbC50cnVuY2F0ZVRleHQoXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsIG1heFdpZHRoLCB0ZXh0Rm9udCwgZWxsaXBzaXMsXG4gICAgICAgICAgICAgICAgICAgIHttaW5DaGFyOiAyLCBwbGFjZWhvbGRlcjogdHJ1bmNhdGVPcHQucGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogbmFtZTtcblxuICAgICAgICAgICAgdmFyIHRvb2x0aXBPcHQgPSBheGlzTW9kZWwuZ2V0KCd0b29sdGlwJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBtYWluVHlwZSA9IGF4aXNNb2RlbC5tYWluVHlwZTtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZXJQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50VHlwZTogbWFpblR5cGUsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAkdmFyczogWyduYW1lJ11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3JtYXR0ZXJQYXJhbXNbbWFpblR5cGUgKyAnSW5kZXgnXSA9IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleDtcblxuICAgICAgICAgICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuXG4gICAgICAgICAgICAgICAgLy8gSWQgZm9yIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIGFuaWQ6ICduYW1lJyxcblxuICAgICAgICAgICAgICAgIF9fZnVsbFRleHQ6IG5hbWUsXG4gICAgICAgICAgICAgICAgX190cnVuY2F0ZWRUZXh0OiB0cnVuY2F0ZWRUZXh0LFxuXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdHJ1bmNhdGVkVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZvbnQ6IHRleHRGb250LFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgYXhpc01vZGVsLmdldCgnYXhpc0xpbmUubGluZVN0eWxlLmNvbG9yJyksXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogbGFiZWxMYXlvdXQudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogbGFiZWxMYXlvdXQudGV4dFZlcnRpY2FsQWxpZ25cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICAgICAgICAgICAgcm90YXRpb246IGxhYmVsTGF5b3V0LnJvdGF0aW9uLFxuICAgICAgICAgICAgICAgIHNpbGVudDogaXNTaWxlbnQoYXhpc01vZGVsKSxcbiAgICAgICAgICAgICAgICB6MjogMSxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiAodG9vbHRpcE9wdCAmJiB0b29sdGlwT3B0LnNob3cpXG4gICAgICAgICAgICAgICAgICAgID8genJVdGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyUGFyYW1zOiBmb3JtYXR0ZXJQYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgfSwgdG9vbHRpcE9wdClcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGF4aXNNb2RlbC5nZXQoJ3RyaWdnZXJFdmVudCcpKSB7XG4gICAgICAgICAgICAgICAgdGV4dEVsLmV2ZW50RGF0YSA9IG1ha2VBeGlzRXZlbnREYXRhQmFzZShheGlzTW9kZWwpO1xuICAgICAgICAgICAgICAgIHRleHRFbC5ldmVudERhdGEudGFyZ2V0VHlwZSA9ICdheGlzTmFtZSc7XG4gICAgICAgICAgICAgICAgdGV4dEVsLmV2ZW50RGF0YS5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIHRoaXMuX2R1bWJHcm91cC5hZGQodGV4dEVsKTtcbiAgICAgICAgICAgIHRleHRFbC51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQodGV4dEVsKTtcblxuICAgICAgICAgICAgdGV4dEVsLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF4aXNSb3RhdGlvbiBpbiByYWRpYW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGV4dFJvdGF0aW9uIGluIHJhZGlhblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHtcbiAgICAgKiAgcm90YXRpb24sIC8vIGFjY29yZGluZyB0byBheGlzXG4gICAgICogIHRleHRBbGlnbixcbiAgICAgKiAgdGV4dFZlcnRpY2FsQWxpZ25cbiAgICAgKiB9XG4gICAgICovXG4gICAgdmFyIGlubmVyVGV4dExheW91dCA9IEF4aXNCdWlsZGVyLmlubmVyVGV4dExheW91dCA9IGZ1bmN0aW9uIChheGlzUm90YXRpb24sIHRleHRSb3RhdGlvbiwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciByb3RhdGlvbkRpZmYgPSByZW1SYWRpYW4odGV4dFJvdGF0aW9uIC0gYXhpc1JvdGF0aW9uKTtcbiAgICAgICAgdmFyIHRleHRBbGlnbjtcbiAgICAgICAgdmFyIHRleHRWZXJ0aWNhbEFsaWduO1xuXG4gICAgICAgIGlmIChpc1JhZGlhbkFyb3VuZFplcm8ocm90YXRpb25EaWZmKSkgeyAvLyBMYWJlbCBpcyBwYXJhbGxlbCB3aXRoIGF4aXMgbGluZS5cbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gZGlyZWN0aW9uID4gMCA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JhZGlhbkFyb3VuZFplcm8ocm90YXRpb25EaWZmIC0gUEkpKSB7IC8vIExhYmVsIGlzIGludmVyc2UgcGFyYWxsZWwgd2l0aCBheGlzIGxpbmUuXG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IGRpcmVjdGlvbiA+IDAgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuXG4gICAgICAgICAgICBpZiAocm90YXRpb25EaWZmID4gMCAmJiByb3RhdGlvbkRpZmYgPCBQSSkge1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IGRpcmVjdGlvbiA+IDAgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gZGlyZWN0aW9uID4gMCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm90YXRpb246IHJvdGF0aW9uRGlmZixcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGVuZFRleHRMYXlvdXQob3B0LCB0ZXh0UG9zaXRpb24sIHRleHRSb3RhdGUsIGV4dGVudCkge1xuICAgICAgICB2YXIgcm90YXRpb25EaWZmID0gcmVtUmFkaWFuKHRleHRSb3RhdGUgLSBvcHQucm90YXRpb24pO1xuICAgICAgICB2YXIgdGV4dEFsaWduO1xuICAgICAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ247XG4gICAgICAgIHZhciBpbnZlcnNlID0gZXh0ZW50WzBdID4gZXh0ZW50WzFdO1xuICAgICAgICB2YXIgb25MZWZ0ID0gKHRleHRQb3NpdGlvbiA9PT0gJ3N0YXJ0JyAmJiAhaW52ZXJzZSlcbiAgICAgICAgICAgIHx8ICh0ZXh0UG9zaXRpb24gIT09ICdzdGFydCcgJiYgaW52ZXJzZSk7XG5cbiAgICAgICAgaWYgKGlzUmFkaWFuQXJvdW5kWmVybyhyb3RhdGlvbkRpZmYgLSBQSSAvIDIpKSB7XG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IG9uTGVmdCA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JhZGlhbkFyb3VuZFplcm8ocm90YXRpb25EaWZmIC0gUEkgKiAxLjUpKSB7XG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IG9uTGVmdCA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBpZiAocm90YXRpb25EaWZmIDwgUEkgKiAxLjUgJiYgcm90YXRpb25EaWZmID4gUEkgLyAyKSB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gb25MZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IG9uTGVmdCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm90YXRpb246IHJvdGF0aW9uRGlmZixcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTaWxlbnQoYXhpc01vZGVsKSB7XG4gICAgICAgIHZhciB0b29sdGlwT3B0ID0gYXhpc01vZGVsLmdldCgndG9vbHRpcCcpO1xuICAgICAgICByZXR1cm4gYXhpc01vZGVsLmdldCgnc2lsZW50JylcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIG1vdXNlIGN1cnNvciwgYWRkIHRoZXNlIHJlc3RyaWN0aW9ucy5cbiAgICAgICAgICAgIHx8ICEoXG4gICAgICAgICAgICAgICAgYXhpc01vZGVsLmdldCgndHJpZ2dlckV2ZW50JykgfHwgKHRvb2x0aXBPcHQgJiYgdG9vbHRpcE9wdC5zaG93KVxuICAgICAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXhNaW5NYXhMYWJlbFNob3coYXhpc01vZGVsLCB0ZXh0RWxzKSB7XG4gICAgICAgIC8vIElmIG1pbiBvciBtYXggYXJlIHVzZXIgc2V0LCB3ZSBuZWVkIHRvIGNoZWNrXG4gICAgICAgIC8vIElmIHRoZSB0aWNrIG9uIG1pbihtYXgpIGFyZSBvdmVybGFwIG9uIHRoZWlyIG5laWdoYm91ciB0aWNrXG4gICAgICAgIC8vIElmIHRoZXkgYXJlIG92ZXJsYXBwZWQsIHdlIG5lZWQgdG8gaGlkZSB0aGUgbWluKG1heCkgdGljayBsYWJlbFxuICAgICAgICB2YXIgc2hvd01pbkxhYmVsID0gYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnNob3dNaW5MYWJlbCcpO1xuICAgICAgICB2YXIgc2hvd01heExhYmVsID0gYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnNob3dNYXhMYWJlbCcpO1xuICAgICAgICB2YXIgZmlyc3RMYWJlbCA9IHRleHRFbHNbMF07XG4gICAgICAgIHZhciBuZXh0TGFiZWwgPSB0ZXh0RWxzWzFdO1xuICAgICAgICB2YXIgbGFzdExhYmVsID0gdGV4dEVsc1t0ZXh0RWxzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcHJldkxhYmVsID0gdGV4dEVsc1t0ZXh0RWxzLmxlbmd0aCAtIDJdO1xuXG4gICAgICAgIGlmIChzaG93TWluTGFiZWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmaXJzdExhYmVsLmlnbm9yZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXhpc01vZGVsLmdldE1pbigpICE9IG51bGwgJiYgaXNUd29MYWJlbE92ZXJsYXBwZWQoZmlyc3RMYWJlbCwgbmV4dExhYmVsKSkge1xuICAgICAgICAgICAgc2hvd01pbkxhYmVsID8gKG5leHRMYWJlbC5pZ25vcmUgPSB0cnVlKSA6IChmaXJzdExhYmVsLmlnbm9yZSA9IHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3dNYXhMYWJlbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGxhc3RMYWJlbC5pZ25vcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF4aXNNb2RlbC5nZXRNYXgoKSAhPSBudWxsICYmIGlzVHdvTGFiZWxPdmVybGFwcGVkKHByZXZMYWJlbCwgbGFzdExhYmVsKSkge1xuICAgICAgICAgICAgc2hvd01heExhYmVsID8gKHByZXZMYWJlbC5pZ25vcmUgPSB0cnVlKSA6IChsYXN0TGFiZWwuaWdub3JlID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1R3b0xhYmVsT3ZlcmxhcHBlZChjdXJyZW50LCBuZXh0LCBsYWJlbExheW91dCkge1xuICAgICAgICAvLyBjdXJyZW50IGFuZCBuZXh0IGhhcyB0aGUgc2FtZSByb3RhdGlvbi5cbiAgICAgICAgdmFyIGZpcnN0UmVjdCA9IGN1cnJlbnQgJiYgY3VycmVudC5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpO1xuICAgICAgICB2YXIgbmV4dFJlY3QgPSBuZXh0ICYmIG5leHQuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcblxuICAgICAgICBpZiAoIWZpcnN0UmVjdCB8fCAhbmV4dFJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoZW4gY2hlY2tpbmcgaW50ZXJzZWN0IG9mIHR3byByb3RhdGVkIGxhYmVscywgd2UgdXNlIG1Sb3RhdGlvbkJhY2tcbiAgICAgICAgLy8gdG8gYXZvaWQgdGhhdCBib3VuZGluZ1JlY3QgaXMgZW5sYXJnZSB3aGVuIHVzaW5nIGBib3VuZGluZ1JlY3QuYXBwbHlUcmFuc2Zvcm1gLlxuICAgICAgICB2YXIgbVJvdGF0aW9uQmFjayA9IG1hdHJpeC5pZGVudGl0eShbXSk7XG4gICAgICAgIG1hdHJpeC5yb3RhdGUobVJvdGF0aW9uQmFjaywgbVJvdGF0aW9uQmFjaywgLWN1cnJlbnQucm90YXRpb24pO1xuXG4gICAgICAgIGZpcnN0UmVjdC5hcHBseVRyYW5zZm9ybShtYXRyaXgubXVsKFtdLCBtUm90YXRpb25CYWNrLCBjdXJyZW50LmdldExvY2FsVHJhbnNmb3JtKCkpKTtcbiAgICAgICAgbmV4dFJlY3QuYXBwbHlUcmFuc2Zvcm0obWF0cml4Lm11bChbXSwgbVJvdGF0aW9uQmFjaywgbmV4dC5nZXRMb2NhbFRyYW5zZm9ybSgpKSk7XG5cbiAgICAgICAgcmV0dXJuIGZpcnN0UmVjdC5pbnRlcnNlY3QobmV4dFJlY3QpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhciBpZklnbm9yZU9uVGljayA9IEF4aXNCdWlsZGVyLmlmSWdub3JlT25UaWNrID0gZnVuY3Rpb24gKGF4aXMsIGksIGludGVydmFsKSB7XG4gICAgICAgIHZhciByYXdUaWNrO1xuICAgICAgICB2YXIgc2NhbGUgPSBheGlzLnNjYWxlO1xuICAgICAgICByZXR1cm4gc2NhbGUudHlwZSA9PT0gJ29yZGluYWwnXG4gICAgICAgICAgICAmJiAoXG4gICAgICAgICAgICAgICAgdHlwZW9mIGludGVydmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3VGljayA9IHNjYWxlLmdldFRpY2tzKClbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAhaW50ZXJ2YWwocmF3VGljaywgc2NhbGUuZ2V0TGFiZWwocmF3VGljaykpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgOiBpICUgKGludGVydmFsICsgMSlcbiAgICAgICAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB2YXIgZ2V0SW50ZXJ2YWwgPSBBeGlzQnVpbGRlci5nZXRJbnRlcnZhbCA9IGZ1bmN0aW9uIChtb2RlbCwgbGFiZWxJbnRlcnZhbCkge1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBtb2RlbC5nZXQoJ2ludGVydmFsJyk7XG4gICAgICAgIGlmIChpbnRlcnZhbCA9PSBudWxsIHx8IGludGVydmFsID09ICdhdXRvJykge1xuICAgICAgICAgICAgaW50ZXJ2YWwgPSBsYWJlbEludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRlcnZhbDtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBeGlzQnVpbGRlcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL0F4aXNCdWlsZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n\n    var helper = {};\n\n    /**\n     * @param {Object} opt {labelInside}\n     * @return {Object} {\n     *  position, rotation, labelDirection, labelOffset,\n     *  tickDirection, labelRotate, labelInterval, z2\n     * }\n     */\n    helper.layout = function (gridModel, axisModel, opt) {\n        opt = opt || {};\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n\n        // [left, right, top, bottom]\n        var rect = grid.getRect();\n        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\n        var axisOffset = axisModel.get('offset') || 0;\n\n        var posMap = {\n            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },\n            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }\n        };\n\n        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\n        function getZero(dim, val) {\n            var theAxis = grid.getAxis(dim);\n            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n        }\n\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n        ];\n\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\n        // Tick and label direction, x y is axisDim\n        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        layout.labelOffset = axis.onZero ? posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero : 0;\n\n        if (axisModel.get('axisTick.inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n\n        // Special label rotation\n        var labelRotate = axisModel.get('axisLabel.rotate');\n        layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate;\n\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n\n        return layout;\n    };\n\n    module.exports = helper;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL2NhcnRlc2lhbkF4aXNIZWxwZXIuanM/Y2U4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxPQUFPLE1BQU07QUFDNUIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0Isb0VBQW9FO0FBQ3BGLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE0MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIGhlbHBlciA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdCB7bGFiZWxJbnNpZGV9XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB7XG4gICAgICogIHBvc2l0aW9uLCByb3RhdGlvbiwgbGFiZWxEaXJlY3Rpb24sIGxhYmVsT2Zmc2V0LFxuICAgICAqICB0aWNrRGlyZWN0aW9uLCBsYWJlbFJvdGF0ZSwgbGFiZWxJbnRlcnZhbCwgejJcbiAgICAgKiB9XG4gICAgICovXG4gICAgaGVscGVyLmxheW91dCA9IGZ1bmN0aW9uIChncmlkTW9kZWwsIGF4aXNNb2RlbCwgb3B0KSB7XG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIGdyaWQgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICAgICAgdmFyIGxheW91dCA9IHt9O1xuXG4gICAgICAgIHZhciByYXdBeGlzUG9zaXRpb24gPSBheGlzLnBvc2l0aW9uO1xuICAgICAgICB2YXIgYXhpc1Bvc2l0aW9uID0gYXhpcy5vblplcm8gPyAnb25aZXJvJyA6IHJhd0F4aXNQb3NpdGlvbjtcbiAgICAgICAgdmFyIGF4aXNEaW0gPSBheGlzLmRpbTtcblxuICAgICAgICAvLyBbbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tXVxuICAgICAgICB2YXIgcmVjdCA9IGdyaWQuZ2V0UmVjdCgpO1xuICAgICAgICB2YXIgcmVjdEJvdW5kID0gW3JlY3QueCwgcmVjdC54ICsgcmVjdC53aWR0aCwgcmVjdC55LCByZWN0LnkgKyByZWN0LmhlaWdodF07XG5cbiAgICAgICAgdmFyIGF4aXNPZmZzZXQgPSBheGlzTW9kZWwuZ2V0KCdvZmZzZXQnKSB8fCAwO1xuXG4gICAgICAgIHZhciBwb3NNYXAgPSB7XG4gICAgICAgICAgICB4OiB7IHRvcDogcmVjdEJvdW5kWzJdIC0gYXhpc09mZnNldCwgYm90dG9tOiByZWN0Qm91bmRbM10gKyBheGlzT2Zmc2V0IH0sXG4gICAgICAgICAgICB5OiB7IGxlZnQ6IHJlY3RCb3VuZFswXSAtIGF4aXNPZmZzZXQsIHJpZ2h0OiByZWN0Qm91bmRbMV0gKyBheGlzT2Zmc2V0IH1cbiAgICAgICAgfTtcblxuICAgICAgICBwb3NNYXAueC5vblplcm8gPSBNYXRoLm1heChNYXRoLm1pbihnZXRaZXJvKCd5JyksIHBvc01hcC54LmJvdHRvbSksIHBvc01hcC54LnRvcCk7XG4gICAgICAgIHBvc01hcC55Lm9uWmVybyA9IE1hdGgubWF4KE1hdGgubWluKGdldFplcm8oJ3gnKSwgcG9zTWFwLnkucmlnaHQpLCBwb3NNYXAueS5sZWZ0KTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRaZXJvKGRpbSwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgdGhlQXhpcyA9IGdyaWQuZ2V0QXhpcyhkaW0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoZUF4aXMudG9HbG9iYWxDb29yZCh0aGVBeGlzLmRhdGFUb0Nvb3JkKDApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF4aXMgcG9zaXRpb25cbiAgICAgICAgbGF5b3V0LnBvc2l0aW9uID0gW1xuICAgICAgICAgICAgYXhpc0RpbSA9PT0gJ3knID8gcG9zTWFwLnlbYXhpc1Bvc2l0aW9uXSA6IHJlY3RCb3VuZFswXSxcbiAgICAgICAgICAgIGF4aXNEaW0gPT09ICd4JyA/IHBvc01hcC54W2F4aXNQb3NpdGlvbl0gOiByZWN0Qm91bmRbM11cbiAgICAgICAgXTtcblxuICAgICAgICAvLyBBeGlzIHJvdGF0aW9uXG4gICAgICAgIGxheW91dC5yb3RhdGlvbiA9IE1hdGguUEkgLyAyICogKGF4aXNEaW0gPT09ICd4JyA/IDAgOiAxKTtcblxuICAgICAgICAvLyBUaWNrIGFuZCBsYWJlbCBkaXJlY3Rpb24sIHggeSBpcyBheGlzRGltXG4gICAgICAgIHZhciBkaXJNYXAgPSB7dG9wOiAtMSwgYm90dG9tOiAxLCBsZWZ0OiAtMSwgcmlnaHQ6IDF9O1xuXG4gICAgICAgIGxheW91dC5sYWJlbERpcmVjdGlvbiA9IGxheW91dC50aWNrRGlyZWN0aW9uID0gbGF5b3V0Lm5hbWVEaXJlY3Rpb24gPSBkaXJNYXBbcmF3QXhpc1Bvc2l0aW9uXTtcbiAgICAgICAgbGF5b3V0LmxhYmVsT2Zmc2V0ID0gYXhpcy5vblplcm8gPyBwb3NNYXBbYXhpc0RpbV1bcmF3QXhpc1Bvc2l0aW9uXSAtIHBvc01hcFtheGlzRGltXS5vblplcm8gOiAwO1xuXG4gICAgICAgIGlmIChheGlzTW9kZWwuZ2V0KCdheGlzVGljay5pbnNpZGUnKSkge1xuICAgICAgICAgICAgbGF5b3V0LnRpY2tEaXJlY3Rpb24gPSAtbGF5b3V0LnRpY2tEaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHpyVXRpbC5yZXRyaWV2ZShvcHQubGFiZWxJbnNpZGUsIGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5pbnNpZGUnKSkpIHtcbiAgICAgICAgICAgIGxheW91dC5sYWJlbERpcmVjdGlvbiA9IC1sYXlvdXQubGFiZWxEaXJlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTcGVjaWFsIGxhYmVsIHJvdGF0aW9uXG4gICAgICAgIHZhciBsYWJlbFJvdGF0ZSA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5yb3RhdGUnKTtcbiAgICAgICAgbGF5b3V0LmxhYmVsUm90YXRlID0gYXhpc1Bvc2l0aW9uID09PSAndG9wJyA/IC1sYWJlbFJvdGF0ZSA6IGxhYmVsUm90YXRlO1xuXG4gICAgICAgIC8vIGxhYmVsIGludGVydmFsIHdoZW4gYXV0byBtb2RlLlxuICAgICAgICBsYXlvdXQubGFiZWxJbnRlcnZhbCA9IGF4aXMuZ2V0TGFiZWxJbnRlcnZhbCgpO1xuXG4gICAgICAgIC8vIE92ZXIgc3BsaXRMaW5lIGFuZCBzcGxpdEFyZWFcbiAgICAgICAgbGF5b3V0LnoyID0gMTtcblxuICAgICAgICByZXR1cm4gbGF5b3V0O1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGhlbHBlcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL2NhcnRlc2lhbkF4aXNIZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n\n    var axisPointerModelHelper = __webpack_require__(131);\n\n    /**\n     * Base class of AxisView.\n     */\n    var AxisView = __webpack_require__(17).extendComponentView({\n\n        type: 'axis',\n\n        /**\n         * @private\n         */\n        _axisPointer: null,\n\n        /**\n         * @protected\n         * @type {string}\n         */\n        axisPointerClass: null,\n\n        /**\n         * @override\n         */\n        render: function (axisModel, ecModel, api, payload) {\n            // FIXME\n            // This process should proformed after coordinate systems updated\n            // (axis scale updated), and should be performed each time update.\n            // So put it here temporarily, although it is not appropriate to\n            // put a model-writing procedure in `view`.\n            this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);\n\n            AxisView.superApply(this, 'render', arguments);\n\n            updateAxisPointer(this, axisModel, ecModel, api, payload, true);\n        },\n\n        /**\n         * Action handler.\n         * @public\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/model/Global} ecModel\n         * @param {module:echarts/ExtensionAPI} api\n         * @param {Object} payload\n         */\n        updateAxisPointer: function (axisModel, ecModel, api, payload, force) {\n            updateAxisPointer(this, axisModel, ecModel, api, payload, false);\n        },\n\n        /**\n         * @override\n         */\n        remove: function (ecModel, api) {\n            var axisPointer = this._axisPointer;\n            axisPointer && axisPointer.remove(api);\n            AxisView.superApply(this, 'remove', arguments);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function (ecModel, api) {\n            disposeAxisPointer(this, api);\n            AxisView.superApply(this, 'dispose', arguments);\n        }\n\n    });\n\n    function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {\n        var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);\n        if (!Clazz) {\n            return;\n        }\n        var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);\n        axisPointerModel\n            ? (axisView._axisPointer || (axisView._axisPointer = new Clazz()))\n                .render(axisModel, axisPointerModel, api, forceRender)\n            : disposeAxisPointer(axisView, api);\n    }\n\n    function disposeAxisPointer(axisView, ecModel, api) {\n        var axisPointer = axisView._axisPointer;\n        axisPointer && axisPointer.dispose(ecModel, api);\n        axisView._axisPointer = null;\n    }\n\n    var axisPointerClazz = [];\n\n    AxisView.registerAxisPointerClass = function (type, clazz) {\n        if (__DEV__) {\n            if (axisPointerClazz[type]) {\n                throw new Error('axisPointer ' + type + ' exists');\n            }\n        }\n        axisPointerClazz[type] = clazz;\n    };\n\n    AxisView.getAxisPointerClass = function (type) {\n        return type && axisPointerClazz[type];\n    };\n\n    module.exports = AxisView;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL0F4aXNWaWV3LmpzP2Y4NTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5Q0FBeUM7QUFDNUQsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE0Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGF4aXNQb2ludGVyTW9kZWxIZWxwZXIgPSByZXF1aXJlKCcuLi9heGlzUG9pbnRlci9tb2RlbEhlbHBlcicpO1xuXG4gICAgLyoqXG4gICAgICogQmFzZSBjbGFzcyBvZiBBeGlzVmlldy5cbiAgICAgKi9cbiAgICB2YXIgQXhpc1ZpZXcgPSByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJykuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ2F4aXMnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2F4aXNQb2ludGVyOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBheGlzUG9pbnRlckNsYXNzOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgLy8gVGhpcyBwcm9jZXNzIHNob3VsZCBwcm9mb3JtZWQgYWZ0ZXIgY29vcmRpbmF0ZSBzeXN0ZW1zIHVwZGF0ZWRcbiAgICAgICAgICAgIC8vIChheGlzIHNjYWxlIHVwZGF0ZWQpLCBhbmQgc2hvdWxkIGJlIHBlcmZvcm1lZCBlYWNoIHRpbWUgdXBkYXRlLlxuICAgICAgICAgICAgLy8gU28gcHV0IGl0IGhlcmUgdGVtcG9yYXJpbHksIGFsdGhvdWdoIGl0IGlzIG5vdCBhcHByb3ByaWF0ZSB0b1xuICAgICAgICAgICAgLy8gcHV0IGEgbW9kZWwtd3JpdGluZyBwcm9jZWR1cmUgaW4gYHZpZXdgLlxuICAgICAgICAgICAgdGhpcy5heGlzUG9pbnRlckNsYXNzICYmIGF4aXNQb2ludGVyTW9kZWxIZWxwZXIuZml4VmFsdWUoYXhpc01vZGVsKTtcblxuICAgICAgICAgICAgQXhpc1ZpZXcuc3VwZXJBcHBseSh0aGlzLCAncmVuZGVyJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgdXBkYXRlQXhpc1BvaW50ZXIodGhpcywgYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBY3Rpb24gaGFuZGxlci5cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWx9IGF4aXNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVBeGlzUG9pbnRlcjogZnVuY3Rpb24gKGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkLCBmb3JjZSkge1xuICAgICAgICAgICAgdXBkYXRlQXhpc1BvaW50ZXIodGhpcywgYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQsIGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHZhciBheGlzUG9pbnRlciA9IHRoaXMuX2F4aXNQb2ludGVyO1xuICAgICAgICAgICAgYXhpc1BvaW50ZXIgJiYgYXhpc1BvaW50ZXIucmVtb3ZlKGFwaSk7XG4gICAgICAgICAgICBBeGlzVmlldy5zdXBlckFwcGx5KHRoaXMsICdyZW1vdmUnLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIGRpc3Bvc2VBeGlzUG9pbnRlcih0aGlzLCBhcGkpO1xuICAgICAgICAgICAgQXhpc1ZpZXcuc3VwZXJBcHBseSh0aGlzLCAnZGlzcG9zZScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlQXhpc1BvaW50ZXIoYXhpc1ZpZXcsIGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkLCBmb3JjZVJlbmRlcikge1xuICAgICAgICB2YXIgQ2xhenogPSBBeGlzVmlldy5nZXRBeGlzUG9pbnRlckNsYXNzKGF4aXNWaWV3LmF4aXNQb2ludGVyQ2xhc3MpO1xuICAgICAgICBpZiAoIUNsYXp6KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF4aXNQb2ludGVyTW9kZWwgPSBheGlzUG9pbnRlck1vZGVsSGVscGVyLmdldEF4aXNQb2ludGVyTW9kZWwoYXhpc01vZGVsKTtcbiAgICAgICAgYXhpc1BvaW50ZXJNb2RlbFxuICAgICAgICAgICAgPyAoYXhpc1ZpZXcuX2F4aXNQb2ludGVyIHx8IChheGlzVmlldy5fYXhpc1BvaW50ZXIgPSBuZXcgQ2xhenooKSkpXG4gICAgICAgICAgICAgICAgLnJlbmRlcihheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSwgZm9yY2VSZW5kZXIpXG4gICAgICAgICAgICA6IGRpc3Bvc2VBeGlzUG9pbnRlcihheGlzVmlldywgYXBpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXNwb3NlQXhpc1BvaW50ZXIoYXhpc1ZpZXcsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICB2YXIgYXhpc1BvaW50ZXIgPSBheGlzVmlldy5fYXhpc1BvaW50ZXI7XG4gICAgICAgIGF4aXNQb2ludGVyICYmIGF4aXNQb2ludGVyLmRpc3Bvc2UoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgYXhpc1ZpZXcuX2F4aXNQb2ludGVyID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYXhpc1BvaW50ZXJDbGF6eiA9IFtdO1xuXG4gICAgQXhpc1ZpZXcucmVnaXN0ZXJBeGlzUG9pbnRlckNsYXNzID0gZnVuY3Rpb24gKHR5cGUsIGNsYXp6KSB7XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoYXhpc1BvaW50ZXJDbGF6elt0eXBlXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXhpc1BvaW50ZXIgJyArIHR5cGUgKyAnIGV4aXN0cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF4aXNQb2ludGVyQ2xhenpbdHlwZV0gPSBjbGF6ejtcbiAgICB9O1xuXG4gICAgQXhpc1ZpZXcuZ2V0QXhpc1BvaW50ZXJDbGFzcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0eXBlICYmIGF4aXNQb2ludGVyQ2xhenpbdHlwZV07XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQXhpc1ZpZXc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvQXhpc1ZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n\n    __webpack_require__(17).extendComponentModel({\n\n        type: 'tooltip',\n\n        dependencies: ['axisPointer'],\n\n        defaultOption: {\n            zlevel: 0,\n\n            z: 8,\n\n            show: true,\n\n            // tooltip主体内容\n            showContent: true,\n\n            // 'trigger' only works on coordinate system.\n            // 'item' | 'axis' | 'none'\n            trigger: 'item',\n\n            // 'click' | 'mousemove' | 'none'\n            triggerOn: 'mousemove|click',\n\n            alwaysShowContent: false,\n\n            displayMode: 'single', // 'single' | 'multipleByCoordSys'\n\n            // 位置 {Array} | {Function}\n            // position: null\n            // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\n            // align: null,\n            // verticalAlign: null,\n\n            // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。\n            confine: false,\n\n            // 内容格式器：{string}（Template） ¦ {Function}\n            // formatter: null\n\n            showDelay: 0,\n\n            // 隐藏延迟，单位ms\n            hideDelay: 100,\n\n            // 动画变换时间，单位s\n            transitionDuration: 0.4,\n\n            enterable: false,\n\n            // 提示背景颜色，默认为透明度为0.7的黑色\n            backgroundColor: 'rgba(50,50,50,0.7)',\n\n            // 提示边框颜色\n            borderColor: '#333',\n\n            // 提示边框圆角，单位px，默认为4\n            borderRadius: 4,\n\n            // 提示边框线宽，单位px，默认为0（无边框）\n            borderWidth: 0,\n\n            // 提示内边距，单位px，默认各方向内边距为5，\n            // 接受数组分别设定上右下左边距，同css\n            padding: 5,\n\n            // Extra css text\n            extraCssText: '',\n\n            // 坐标轴指示器，坐标轴触发有效\n            axisPointer: {\n                // 默认为直线\n                // 可选为：'line' | 'shadow' | 'cross'\n                type: 'line',\n\n                // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选\n                // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'\n                // 默认 'auto'，会选择类型为 cateogry 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴\n                // 极坐标系会默认选择 angle 轴\n                axis: 'auto',\n\n                animation: 'auto',\n                animationDurationUpdate: 200,\n                animationEasingUpdate: 'exponentialOut',\n\n                crossStyle: {\n                    color: '#999',\n                    width: 1,\n                    type: 'dashed',\n\n                    // TODO formatter\n                    textStyle: {}\n                }\n\n                // lineStyle and shadowStyle should not be specified here,\n                // otherwise it will always override those styles on option.axisPointer.\n            },\n            textStyle: {\n                color: '#fff',\n                fontSize: 14\n            }\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBNb2RlbC5qcz8xOWFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixNQUFNLElBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsT0FBTyxjQUFjO0FBQzNDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiMTQzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJykuZXh0ZW5kQ29tcG9uZW50TW9kZWwoe1xuXG4gICAgICAgIHR5cGU6ICd0b29sdGlwJyxcblxuICAgICAgICBkZXBlbmRlbmNpZXM6IFsnYXhpc1BvaW50ZXInXSxcblxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICB6bGV2ZWw6IDAsXG5cbiAgICAgICAgICAgIHo6IDgsXG5cbiAgICAgICAgICAgIHNob3c6IHRydWUsXG5cbiAgICAgICAgICAgIC8vIHRvb2x0aXDkuLvkvZPlhoXlrrlcbiAgICAgICAgICAgIHNob3dDb250ZW50OiB0cnVlLFxuXG4gICAgICAgICAgICAvLyAndHJpZ2dlcicgb25seSB3b3JrcyBvbiBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgICAgICAgIC8vICdpdGVtJyB8ICdheGlzJyB8ICdub25lJ1xuICAgICAgICAgICAgdHJpZ2dlcjogJ2l0ZW0nLFxuXG4gICAgICAgICAgICAvLyAnY2xpY2snIHwgJ21vdXNlbW92ZScgfCAnbm9uZSdcbiAgICAgICAgICAgIHRyaWdnZXJPbjogJ21vdXNlbW92ZXxjbGljaycsXG5cbiAgICAgICAgICAgIGFsd2F5c1Nob3dDb250ZW50OiBmYWxzZSxcblxuICAgICAgICAgICAgZGlzcGxheU1vZGU6ICdzaW5nbGUnLCAvLyAnc2luZ2xlJyB8ICdtdWx0aXBsZUJ5Q29vcmRTeXMnXG5cbiAgICAgICAgICAgIC8vIOS9jee9riB7QXJyYXl9IHwge0Z1bmN0aW9ufVxuICAgICAgICAgICAgLy8gcG9zaXRpb246IG51bGxcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIHRyaWdnZXJlZCBmcm9tIGF4aXNQb2ludGVyIGhhbmRsZSwgdmVydGljYWxBbGlnbiBzaG91bGQgYmUgJ21pZGRsZSdcbiAgICAgICAgICAgIC8vIGFsaWduOiBudWxsLFxuICAgICAgICAgICAgLy8gdmVydGljYWxBbGlnbjogbnVsbCxcblxuICAgICAgICAgICAgLy8g5piv5ZCm57qm5p2fIGNvbnRlbnQg5ZyoIHZpZXdSZWN0IOS4reOAgum7mOiupCBmYWxzZSDmmK/kuLrkuoblhbzlrrnku6XliY3niYjmnKzjgIJcbiAgICAgICAgICAgIGNvbmZpbmU6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyDlhoXlrrnmoLzlvI/lmajvvJp7c3RyaW5nfe+8iFRlbXBsYXRl77yJIMKmIHtGdW5jdGlvbn1cbiAgICAgICAgICAgIC8vIGZvcm1hdHRlcjogbnVsbFxuXG4gICAgICAgICAgICBzaG93RGVsYXk6IDAsXG5cbiAgICAgICAgICAgIC8vIOmakOiXj+W7tui/n++8jOWNleS9jW1zXG4gICAgICAgICAgICBoaWRlRGVsYXk6IDEwMCxcblxuICAgICAgICAgICAgLy8g5Yqo55S75Y+Y5o2i5pe26Ze077yM5Y2V5L2Nc1xuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAwLjQsXG5cbiAgICAgICAgICAgIGVudGVyYWJsZTogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIOaPkOekuuiDjOaZr+minOiJsu+8jOm7mOiupOS4uumAj+aYjuW6puS4ujAuN+eahOm7keiJslxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSg1MCw1MCw1MCwwLjcpJyxcblxuICAgICAgICAgICAgLy8g5o+Q56S66L655qGG6aKc6ImyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyMzMzMnLFxuXG4gICAgICAgICAgICAvLyDmj5DnpLrovrnmoYblnIbop5LvvIzljZXkvY1weO+8jOm7mOiupOS4ujRcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogNCxcblxuICAgICAgICAgICAgLy8g5o+Q56S66L655qGG57q/5a6977yM5Y2V5L2NcHjvvIzpu5jorqTkuLow77yI5peg6L655qGG77yJXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogMCxcblxuICAgICAgICAgICAgLy8g5o+Q56S65YaF6L656Led77yM5Y2V5L2NcHjvvIzpu5jorqTlkITmlrnlkJHlhoXovrnot53kuLo177yMXG4gICAgICAgICAgICAvLyDmjqXlj5fmlbDnu4TliIbliKvorr7lrprkuIrlj7PkuIvlt6bovrnot53vvIzlkIxjc3NcbiAgICAgICAgICAgIHBhZGRpbmc6IDUsXG5cbiAgICAgICAgICAgIC8vIEV4dHJhIGNzcyB0ZXh0XG4gICAgICAgICAgICBleHRyYUNzc1RleHQ6ICcnLFxuXG4gICAgICAgICAgICAvLyDlnZDmoIfovbTmjIfnpLrlmajvvIzlnZDmoIfovbTop6blj5HmnInmlYhcbiAgICAgICAgICAgIGF4aXNQb2ludGVyOiB7XG4gICAgICAgICAgICAgICAgLy8g6buY6K6k5Li655u057q/XG4gICAgICAgICAgICAgICAgLy8g5Y+v6YCJ5Li677yaJ2xpbmUnIHwgJ3NoYWRvdycgfCAnY3Jvc3MnXG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuXG4gICAgICAgICAgICAgICAgLy8gdHlwZSDkuLogbGluZSDnmoTml7blgJnmnInmlYjvvIzmjIflrpogdG9vbHRpcCBsaW5lIOaJgOWcqOeahOi9tO+8jOWPr+mAiVxuICAgICAgICAgICAgICAgIC8vIOWPr+mAiSAneCcgfCAneScgfCAnYW5nbGUnIHwgJ3JhZGl1cycgfCAnYXV0bydcbiAgICAgICAgICAgICAgICAvLyDpu5jorqQgJ2F1dG8n77yM5Lya6YCJ5oup57G75Z6L5Li6IGNhdGVvZ3J5IOeahOi9tO+8jOWvueS6juWPjOaVsOWAvOi9tO+8jOesm+WNoeWwlOWdkOagh+ezu+S8mum7mOiupOmAieaLqSB4IOi9tFxuICAgICAgICAgICAgICAgIC8vIOaegeWdkOagh+ezu+S8mum7mOiupOmAieaLqSBhbmdsZSDovbRcbiAgICAgICAgICAgICAgICBheGlzOiAnYXV0bycsXG5cbiAgICAgICAgICAgICAgICBhbmltYXRpb246ICdhdXRvJyxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25EdXJhdGlvblVwZGF0ZTogMjAwLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkVhc2luZ1VwZGF0ZTogJ2V4cG9uZW50aWFsT3V0JyxcblxuICAgICAgICAgICAgICAgIGNyb3NzU3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjOTk5JyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkYXNoZWQnLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gZm9ybWF0dGVyXG4gICAgICAgICAgICAgICAgICAgIHRleHRTdHlsZToge31cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBsaW5lU3R5bGUgYW5kIHNoYWRvd1N0eWxlIHNob3VsZCBub3QgYmUgc3BlY2lmaWVkIGhlcmUsXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IHdpbGwgYWx3YXlzIG92ZXJyaWRlIHRob3NlIHN0eWxlcyBvbiBvcHRpb24uYXhpc1BvaW50ZXIuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n    var TooltipContent = __webpack_require__(145);\n    var zrUtil = __webpack_require__(20);\n    var formatUtil = __webpack_require__(22);\n    var numberUtil = __webpack_require__(23);\n    var graphic = __webpack_require__(34);\n    var findPointFromSeries = __webpack_require__(133);\n    var layoutUtil = __webpack_require__(87);\n    var env = __webpack_require__(18);\n    var Model = __webpack_require__(28);\n    var globalListener = __webpack_require__(136);\n    var axisHelper = __webpack_require__(117);\n    var axisPointerViewHelper = __webpack_require__(139);\n\n    var bind = zrUtil.bind;\n    var each = zrUtil.each;\n    var parsePercent = numberUtil.parsePercent;\n\n\n    var proxyRect = new graphic.Rect({\n        shape: {x: -1, y: -1, width: 2, height: 2}\n    });\n\n    __webpack_require__(17).extendComponentView({\n\n        type: 'tooltip',\n\n        init: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var tooltipContent = new TooltipContent(api.getDom(), api);\n            this._tooltipContent = tooltipContent;\n        },\n\n        render: function (tooltipModel, ecModel, api) {\n            if (env.node) {\n                return;\n            }\n\n            // Reset\n            this.group.removeAll();\n\n            /**\n             * @private\n             * @type {module:echarts/component/tooltip/TooltipModel}\n             */\n            this._tooltipModel = tooltipModel;\n\n            /**\n             * @private\n             * @type {module:echarts/model/Global}\n             */\n            this._ecModel = ecModel;\n\n            /**\n             * @private\n             * @type {module:echarts/ExtensionAPI}\n             */\n            this._api = api;\n\n            /**\n             * Should be cleaned when render.\n             * @private\n             * @type {Array.<Array.<Object>>}\n             */\n            this._lastDataByCoordSys = null;\n\n            /**\n             * @private\n             * @type {boolean}\n             */\n            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\n            var tooltipContent = this._tooltipContent;\n            tooltipContent.update();\n            tooltipContent.setEnterable(tooltipModel.get('enterable'));\n\n            this._initGlobalListener();\n\n            this._keepShow();\n        },\n\n        _initGlobalListener: function () {\n            var tooltipModel = this._tooltipModel;\n            var triggerOn = tooltipModel.get('triggerOn');\n\n            globalListener.register(\n                'itemTooltip',\n                this._api,\n                bind(function (currTrigger, e, dispatchAction) {\n                    // If 'none', it is not controlled by mouse totally.\n                    if (triggerOn !== 'none') {\n                        if (triggerOn.indexOf(currTrigger) >= 0) {\n                            this._tryShow(e, dispatchAction);\n                        }\n                        else if (currTrigger === 'leave') {\n                            this._hide(dispatchAction);\n                        }\n                    }\n                }, this)\n            );\n        },\n\n        _keepShow: function () {\n            var tooltipModel = this._tooltipModel;\n            var ecModel = this._ecModel;\n            var api = this._api;\n\n            // Try to keep the tooltip show when refreshing\n            if (this._lastX != null\n                && this._lastY != null\n                // When user is willing to control tooltip totally using API,\n                // self.manuallyShowTip({x, y}) might cause tooltip hide,\n                // which is not expected.\n                && tooltipModel.get('triggerOn') !== 'none'\n            ) {\n                var self = this;\n                clearTimeout(this._refreshUpdateTimeout);\n                this._refreshUpdateTimeout = setTimeout(function () {\n                    // Show tip next tick after other charts are rendered\n                    // In case highlight action has wrong result\n                    // FIXME\n                    self.manuallyShowTip(tooltipModel, ecModel, api, {\n                        x: self._lastX,\n                        y: self._lastY\n                    });\n                });\n            }\n        },\n\n        /**\n         * Show tip manually by\n         * dispatchAction({\n         *     type: 'showTip',\n         *     x: 10,\n         *     y: 10\n         * });\n         * Or\n         * dispatchAction({\n         *      type: 'showTip',\n         *      seriesIndex: 0,\n         *      dataIndex or dataIndexInside or name\n         * });\n         *\n         *  TODO Batch\n         */\n        manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n            if (payload.from === this.uid || env.node) {\n                return;\n            }\n\n            var dispatchAction = makeDispatchAction(payload, api);\n\n            // Reset ticket\n            this._ticket = '';\n\n            // When triggered from axisPointer.\n            var dataByCoordSys = payload.dataByCoordSys;\n\n            if (payload.tooltip && payload.x != null && payload.y != null) {\n                var el = proxyRect;\n                el.position = [payload.x, payload.y];\n                el.update();\n                el.tooltip = payload.tooltip;\n                // Manually show tooltip while view is not using zrender elements.\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    target: el\n                }, dispatchAction);\n            }\n            else if (dataByCoordSys) {\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    event: {},\n                    dataByCoordSys: payload.dataByCoordSys,\n                    tooltipOption: payload.tooltipOption\n                }, dispatchAction);\n            }\n            else if (payload.seriesIndex != null) {\n\n                if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n                    return;\n                }\n\n                var pointInfo = findPointFromSeries(payload, ecModel);\n                var cx = pointInfo.point[0];\n                var cy = pointInfo.point[1];\n                if (cx != null && cy != null) {\n                    this._tryShow({\n                        offsetX: cx,\n                        offsetY: cy,\n                        position: payload.position,\n                        target: pointInfo.el,\n                        event: {}\n                    }, dispatchAction);\n                }\n            }\n            else if (payload.x != null && payload.y != null) {\n                // FIXME\n                // should wrap dispatchAction like `axisPointer/globalListener` ?\n                api.dispatchAction({\n                    type: 'updateAxisPointer',\n                    x: payload.x,\n                    y: payload.y\n                });\n\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    target: api.getZr().findHover(payload.x, payload.y).target,\n                    event: {}\n                }, dispatchAction);\n            }\n        },\n\n        manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n            var tooltipContent = this._tooltipContent;\n\n            if (!this._alwaysShowContent) {\n                tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n            }\n\n            this._lastX = this._lastY = null;\n\n            if (payload.from !== this.uid) {\n                this._hide(makeDispatchAction(payload, api));\n            }\n        },\n\n        // Be compatible with previous design, that is, when tooltip.type is 'axis' and\n        // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer\n        // and tooltip.\n        _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {\n            var seriesIndex = payload.seriesIndex;\n            var dataIndex = payload.dataIndex;\n            var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n            if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n                return;\n            }\n\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n            if (!seriesModel) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var tooltipModel = buildTooltipModel([\n                data.getItemModel(dataIndex),\n                seriesModel,\n                (seriesModel.coordinateSystem || {}).model,\n                tooltipModel\n            ]);\n\n            if (tooltipModel.get('trigger') !== 'axis') {\n                return;\n            }\n\n            api.dispatchAction({\n                type: 'updateAxisPointer',\n                seriesIndex: seriesIndex,\n                dataIndex: dataIndex,\n                position: payload.position\n            });\n\n            return true;\n        },\n\n        _tryShow: function (e, dispatchAction) {\n            var el = e.target;\n            var tooltipModel = this._tooltipModel;\n\n            if (!tooltipModel) {\n                return;\n            }\n\n            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n            this._lastX = e.offsetX;\n            this._lastY = e.offsetY;\n\n            var dataByCoordSys = e.dataByCoordSys;\n            if (dataByCoordSys && dataByCoordSys.length) {\n                this._showAxisTooltip(dataByCoordSys, e);\n            }\n            // Always show item tooltip if mouse is on the element with dataIndex\n            else if (el && el.dataIndex != null) {\n                this._lastDataByCoordSys = null;\n                this._showSeriesItemTooltip(e, el, dispatchAction);\n            }\n            // Tooltip provided directly. Like legend.\n            else if (el && el.tooltip) {\n                this._lastDataByCoordSys = null;\n                this._showComponentItemTooltip(e, el, dispatchAction);\n            }\n            else {\n                this._lastDataByCoordSys = null;\n                this._hide(dispatchAction);\n            }\n        },\n\n        _showOrMove: function (tooltipModel, cb) {\n            // showDelay is used in this case: tooltip.enterable is set\n            // as true. User intent to move mouse into tooltip and click\n            // something. `showDelay` makes it easyer to enter the content\n            // but tooltip do not move immediately.\n            var delay = tooltipModel.get('showDelay');\n            cb = zrUtil.bind(cb, this);\n            clearTimeout(this._showTimout);\n            delay > 0\n                ? (this._showTimout = setTimeout(cb, delay))\n                : cb();\n        },\n\n        _showAxisTooltip: function (dataByCoordSys, e) {\n            var ecModel = this._ecModel;\n            var globalTooltipModel = this._tooltipModel;\n            var point = [e.offsetX, e.offsetY];\n            var singleDefaultHTML = [];\n            var singleParamsList = [];\n            var singleTooltipModel = buildTooltipModel([\n                e.tooltipOption,\n                globalTooltipModel\n            ]);\n\n            each(dataByCoordSys, function (itemCoordSys) {\n                // var coordParamList = [];\n                // var coordDefaultHTML = [];\n                // var coordTooltipModel = buildTooltipModel([\n                //     e.tooltipOption,\n                //     itemCoordSys.tooltipOption,\n                //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),\n                //     globalTooltipModel\n                // ]);\n                // var displayMode = coordTooltipModel.get('displayMode');\n                // var paramsList = displayMode === 'single' ? singleParamsList : [];\n\n                each(itemCoordSys.dataByAxis, function (item) {\n                    var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);\n                    var axisValue = item.value;\n                    var seriesDefaultHTML = [];\n\n                    if (!axisModel || axisValue == null) {\n                        return;\n                    }\n\n                    var valueLabel = axisPointerViewHelper.getValueLabel(\n                        axisValue, axisModel.axis, ecModel,\n                        item.seriesDataIndices,\n                        item.valueLabelOpt\n                    );\n\n                    zrUtil.each(item.seriesDataIndices, function (idxItem) {\n                        var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n                        var dataIndex = idxItem.dataIndexInside;\n                        var dataParams = series && series.getDataParams(dataIndex);\n                        dataParams.axisDim = item.axisDim;\n                        dataParams.axisIndex = item.axisIndex;\n                        dataParams.axisType = item.axisType;\n                        dataParams.axisId = item.axisId;\n                        dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);\n                        dataParams.axisValueLabel = valueLabel;\n\n                        if (dataParams) {\n                            singleParamsList.push(dataParams);\n                            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));\n                        }\n                    });\n\n                    // Default tooltip content\n                    // FIXME\n                    // (1) shold be the first data which has name?\n                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n                    var firstLine = valueLabel;\n                    singleDefaultHTML.push(\n                        (firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '')\n                        + seriesDefaultHTML.join('<br />')\n                    );\n                });\n            }, this);\n\n            // In most case, the second axis is shown upper than the first one.\n            singleDefaultHTML.reverse();\n            singleDefaultHTML = singleDefaultHTML.join('<br /><br />');\n\n            var positionExpr = e.position;\n            this._showOrMove(singleTooltipModel, function () {\n                if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {\n                    this._updatePosition(\n                        singleTooltipModel,\n                        positionExpr,\n                        point[0], point[1],\n                        this._tooltipContent,\n                        singleParamsList\n                    );\n                }\n                else {\n                    this._showTooltipContent(\n                        singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(),\n                        point[0], point[1], positionExpr\n                    );\n                }\n            });\n\n            // Do not trigger events here, because this branch only be entered\n            // from dispatchAction.\n        },\n\n        _showSeriesItemTooltip: function (e, el, dispatchAction) {\n            var ecModel = this._ecModel;\n            // Use dataModel in element if possible\n            // Used when mouseover on a element like markPoint or edge\n            // In which case, the data is not main data in series.\n            var seriesIndex = el.seriesIndex;\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n            // For example, graph link.\n            var dataModel = el.dataModel || seriesModel;\n            var dataIndex = el.dataIndex;\n            var dataType = el.dataType;\n            var data = dataModel.getData();\n\n            var tooltipModel = buildTooltipModel([\n                data.getItemModel(dataIndex),\n                dataModel,\n                seriesModel && (seriesModel.coordinateSystem || {}).model,\n                this._tooltipModel\n            ]);\n\n            var tooltipTrigger = tooltipModel.get('trigger');\n            if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n                return;\n            }\n\n            var params = dataModel.getDataParams(dataIndex, dataType);\n            var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);\n            var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n\n            this._showOrMove(tooltipModel, function () {\n                this._showTooltipContent(\n                    tooltipModel, defaultHtml, params, asyncTicket,\n                    e.offsetX, e.offsetY, e.position, e.target\n                );\n            });\n\n            // FIXME\n            // duplicated showtip if manuallyShowTip is called from dispatchAction.\n            dispatchAction({\n                type: 'showTip',\n                dataIndexInside: dataIndex,\n                dataIndex: data.getRawIndex(dataIndex),\n                seriesIndex: seriesIndex,\n                from: this.uid\n            });\n        },\n\n        _showComponentItemTooltip: function (e, el, dispatchAction) {\n            var tooltipOpt = el.tooltip;\n            if (typeof tooltipOpt === 'string') {\n                var content = tooltipOpt;\n                tooltipOpt = {\n                    content: content,\n                    // Fixed formatter\n                    formatter: content\n                };\n            }\n            var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);\n            var defaultHtml = subTooltipModel.get('content');\n            var asyncTicket = Math.random();\n\n            // Do not check whether `trigger` is 'none' here, because `trigger`\n            // only works on cooridinate system. In fact, we have not found case\n            // that requires setting `trigger` nothing on component yet.\n\n            this._showOrMove(subTooltipModel, function () {\n                this._showTooltipContent(\n                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n                    asyncTicket, e.offsetX, e.offsetY, e.position, el\n                );\n            });\n\n            // If not dispatch showTip, tip may be hide triggered by axis.\n            dispatchAction({\n                type: 'showTip',\n                from: this.uid\n            });\n        },\n\n        _showTooltipContent: function (\n            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el\n        ) {\n            // Reset ticket\n            this._ticket = '';\n\n            if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n                return;\n            }\n\n            var tooltipContent = this._tooltipContent;\n\n            var formatter = tooltipModel.get('formatter');\n            positionExpr = positionExpr || tooltipModel.get('position');\n            var html = defaultHtml;\n\n            if (formatter && typeof formatter === 'string') {\n                html = formatUtil.formatTpl(formatter, params, true);\n            }\n            else if (typeof formatter === 'function') {\n                var callback = bind(function (cbTicket, html) {\n                    if (cbTicket === this._ticket) {\n                        tooltipContent.setContent(html);\n                        this._updatePosition(\n                            tooltipModel, positionExpr, x, y, tooltipContent, params, el\n                        );\n                    }\n                }, this);\n                this._ticket = asyncTicket;\n                html = formatter(params, asyncTicket, callback);\n            }\n\n            tooltipContent.setContent(html);\n            tooltipContent.show(tooltipModel);\n\n            this._updatePosition(\n                tooltipModel, positionExpr, x, y, tooltipContent, params, el\n            );\n        },\n\n        /**\n         * @param  {string|Function|Array.<number>} positionExpr\n         * @param  {number} x Mouse x\n         * @param  {number} y Mouse y\n         * @param  {boolean} confine Whether confine tooltip content in view rect.\n         * @param  {Object|<Array.<Object>} params\n         * @param  {module:zrender/Element} el target element\n         * @param  {module:echarts/ExtensionAPI} api\n         * @return {Array.<number>}\n         */\n        _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {\n            var viewWidth = this._api.getWidth();\n            var viewHeight = this._api.getHeight();\n            positionExpr = positionExpr || tooltipModel.get('position');\n\n            var contentSize = content.getSize();\n            var align = tooltipModel.get('align');\n            var vAlign = tooltipModel.get('verticalAlign');\n            var rect = el && el.getBoundingRect().clone();\n            el && rect.applyTransform(el.transform);\n\n            if (typeof positionExpr === 'function') {\n                // Callback of position can be an array or a string specify the position\n                positionExpr = positionExpr([x, y], params, content.el, rect, {\n                    viewSize: [viewWidth, viewHeight],\n                    contentSize: contentSize.slice()\n                });\n            }\n\n            if (zrUtil.isArray(positionExpr)) {\n                x = parsePercent(positionExpr[0], viewWidth);\n                y = parsePercent(positionExpr[1], viewHeight);\n            }\n            else if (zrUtil.isObject(positionExpr)) {\n                positionExpr.width = contentSize[0];\n                positionExpr.height = contentSize[1];\n                var layoutRect = layoutUtil.getLayoutRect(\n                    positionExpr, {width: viewWidth, height: viewHeight}\n                );\n                x = layoutRect.x;\n                y = layoutRect.y;\n                align = null;\n                // When positionExpr is left/top/right/bottom,\n                // align and verticalAlign will not work.\n                vAlign = null;\n            }\n            // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n            else if (typeof positionExpr === 'string' && el) {\n                var pos = calcTooltipPosition(\n                    positionExpr, rect, contentSize\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n            else {\n                var pos = refixTooltipPosition(\n                    x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n\n            align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n            vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n\n            if (tooltipModel.get('confine')) {\n                var pos = confineTooltipPosition(\n                    x, y, content.el, viewWidth, viewHeight\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n\n            content.moveTo(x, y);\n        },\n\n        // FIXME\n        // Should we remove this but leave this to user?\n        _updateContentNotChangedOnAxis: function (dataByCoordSys) {\n            var lastCoordSys = this._lastDataByCoordSys;\n            var contentNotChanged = !!lastCoordSys\n                && lastCoordSys.length === dataByCoordSys.length;\n\n            contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n                var lastDataByAxis = lastItemCoordSys.dataByAxis || {};\n                var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n                var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n                contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;\n\n                contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {\n                    var thisItem = thisDataByAxis[indexAxis] || {};\n                    var lastIndices = lastItem.seriesDataIndices || [];\n                    var newIndices = thisItem.seriesDataIndices || [];\n\n                    contentNotChanged &=\n                        lastItem.value === thisItem.value\n                        && lastItem.axisType === thisItem.axisType\n                        && lastItem.axisId === thisItem.axisId\n                        && lastIndices.length === newIndices.length;\n\n                    contentNotChanged && each(lastIndices, function (lastIdxItem, j) {\n                        var newIdxItem = newIndices[j];\n                        contentNotChanged &=\n                            lastIdxItem.seriesIndex === newIdxItem.seriesIndex\n                            && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n                    });\n                });\n            });\n\n            this._lastDataByCoordSys = dataByCoordSys;\n\n            return !!contentNotChanged;\n        },\n\n        _hide: function (dispatchAction) {\n            // Do not directly hideLater here, because this behavior may be prevented\n            // in dispatchAction when showTip is dispatched.\n\n            // FIXME\n            // duplicated hideTip if manuallyHideTip is called from dispatchAction.\n            this._lastDataByCoordSys = null;\n            dispatchAction({\n                type: 'hideTip',\n                from: this.uid\n            });\n        },\n\n        dispose: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            this._tooltipContent.hide();\n            globalListener.unregister('itemTooltip', api);\n        }\n    });\n\n\n    /**\n     * @param {Array.<Object|module:echarts/model/Model>} modelCascade\n     * From top to bottom. (the last one should be globalTooltipModel);\n     */\n    function buildTooltipModel(modelCascade) {\n        var resultModel = modelCascade.pop();\n        while (modelCascade.length) {\n            var tooltipOpt = modelCascade.pop();\n            if (tooltipOpt) {\n                if (tooltipOpt instanceof Model) {\n                    tooltipOpt = tooltipOpt.get('tooltip', true);\n                }\n                // In each data item tooltip can be simply write:\n                // {\n                //  value: 10,\n                //  tooltip: 'Something you need to know'\n                // }\n                if (typeof tooltipOpt === 'string') {\n                    tooltipOpt = {formatter: tooltipOpt};\n                }\n                resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);\n            }\n        }\n        return resultModel;\n    }\n\n    function makeDispatchAction(payload, api) {\n        return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n    }\n\n    function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        if (gapH != null) {\n            if (x + width + gapH > viewWidth) {\n                x -= width + gapH;\n            }\n            else {\n                x += gapH;\n            }\n        }\n        if (gapV != null) {\n            if (y + height + gapV > viewHeight) {\n                y -= height + gapV;\n            }\n            else {\n                y += gapV;\n            }\n        }\n        return [x, y];\n    }\n\n    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        x = Math.min(x + width, viewWidth) - width;\n        y = Math.min(y + height, viewHeight) - height;\n        x = Math.max(x, 0);\n        y = Math.max(y, 0);\n\n        return [x, y];\n    }\n\n    function calcTooltipPosition(position, rect, contentSize) {\n        var domWidth = contentSize[0];\n        var domHeight = contentSize[1];\n        var gap = 5;\n        var x = 0;\n        var y = 0;\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n        switch (position) {\n            case 'inside':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'top':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y - domHeight - gap;\n                break;\n            case 'bottom':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight + gap;\n                break;\n            case 'left':\n                x = rect.x - domWidth - gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'right':\n                x = rect.x + rectWidth + gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n        }\n        return [x, y];\n    }\n\n    function isCenterAlign(align) {\n        return align === 'center' || align === 'middle';\n    }\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBWaWV3LmpzP2FlNTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQsb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLFFBQVE7QUFDNUIsb0JBQW9CLHVCQUF1QjtBQUMzQyxvQkFBb0IsdUJBQXVCO0FBQzNDLG9CQUFvQiw0QkFBNEI7QUFDaEQsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EsZUFBZSwwQ0FBMEM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBUb29sdGlwQ29udGVudCA9IHJlcXVpcmUoJy4vVG9vbHRpcENvbnRlbnQnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2Zvcm1hdCcpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciBmaW5kUG9pbnRGcm9tU2VyaWVzID0gcmVxdWlyZSgnLi4vYXhpc1BvaW50ZXIvZmluZFBvaW50RnJvbVNlcmllcycpO1xuICAgIHZhciBsYXlvdXRVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9sYXlvdXQnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9lbnYnKTtcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuLi8uLi9tb2RlbC9Nb2RlbCcpO1xuICAgIHZhciBnbG9iYWxMaXN0ZW5lciA9IHJlcXVpcmUoJy4uL2F4aXNQb2ludGVyL2dsb2JhbExpc3RlbmVyJyk7XG4gICAgdmFyIGF4aXNIZWxwZXIgPSByZXF1aXJlKCcuLi8uLi9jb29yZC9heGlzSGVscGVyJyk7XG4gICAgdmFyIGF4aXNQb2ludGVyVmlld0hlbHBlciA9IHJlcXVpcmUoJy4uL2F4aXNQb2ludGVyL3ZpZXdIZWxwZXInKTtcblxuICAgIHZhciBiaW5kID0genJVdGlsLmJpbmQ7XG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbiAgICB2YXIgcGFyc2VQZXJjZW50ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQ7XG5cblxuICAgIHZhciBwcm94eVJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgc2hhcGU6IHt4OiAtMSwgeTogLTEsIHdpZHRoOiAyLCBoZWlnaHQ6IDJ9XG4gICAgfSk7XG5cbiAgICByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJykuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ3Rvb2x0aXAnLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIGlmIChlbnYubm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b29sdGlwQ29udGVudCA9IG5ldyBUb29sdGlwQ29udGVudChhcGkuZ2V0RG9tKCksIGFwaSk7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwQ29udGVudCA9IHRvb2x0aXBDb250ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICBpZiAoZW52Lm5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlc2V0XG4gICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcE1vZGVsfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwTW9kZWwgPSB0b29sdGlwTW9kZWw7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2VjTW9kZWwgPSBlY01vZGVsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9hcGkgPSBhcGk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2hvdWxkIGJlIGNsZWFuZWQgd2hlbiByZW5kZXIuXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICogQHR5cGUge0FycmF5LjxBcnJheS48T2JqZWN0Pj59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IG51bGw7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9hbHdheXNTaG93Q29udGVudCA9IHRvb2x0aXBNb2RlbC5nZXQoJ2Fsd2F5c1Nob3dDb250ZW50Jyk7XG5cbiAgICAgICAgICAgIHZhciB0b29sdGlwQ29udGVudCA9IHRoaXMuX3Rvb2x0aXBDb250ZW50O1xuICAgICAgICAgICAgdG9vbHRpcENvbnRlbnQudXBkYXRlKCk7XG4gICAgICAgICAgICB0b29sdGlwQ29udGVudC5zZXRFbnRlcmFibGUodG9vbHRpcE1vZGVsLmdldCgnZW50ZXJhYmxlJykpO1xuXG4gICAgICAgICAgICB0aGlzLl9pbml0R2xvYmFsTGlzdGVuZXIoKTtcblxuICAgICAgICAgICAgdGhpcy5fa2VlcFNob3coKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdEdsb2JhbExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuICAgICAgICAgICAgdmFyIHRyaWdnZXJPbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXJPbicpO1xuXG4gICAgICAgICAgICBnbG9iYWxMaXN0ZW5lci5yZWdpc3RlcihcbiAgICAgICAgICAgICAgICAnaXRlbVRvb2x0aXAnLFxuICAgICAgICAgICAgICAgIHRoaXMuX2FwaSxcbiAgICAgICAgICAgICAgICBiaW5kKGZ1bmN0aW9uIChjdXJyVHJpZ2dlciwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgJ25vbmUnLCBpdCBpcyBub3QgY29udHJvbGxlZCBieSBtb3VzZSB0b3RhbGx5LlxuICAgICAgICAgICAgICAgICAgICBpZiAodHJpZ2dlck9uICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyT24uaW5kZXhPZihjdXJyVHJpZ2dlcikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyeVNob3coZSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VyclRyaWdnZXIgPT09ICdsZWF2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWRlKGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9rZWVwU2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRvb2x0aXBNb2RlbCA9IHRoaXMuX3Rvb2x0aXBNb2RlbDtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fZWNNb2RlbDtcbiAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG5cbiAgICAgICAgICAgIC8vIFRyeSB0byBrZWVwIHRoZSB0b29sdGlwIHNob3cgd2hlbiByZWZyZXNoaW5nXG4gICAgICAgICAgICBpZiAodGhpcy5fbGFzdFggIT0gbnVsbFxuICAgICAgICAgICAgICAgICYmIHRoaXMuX2xhc3RZICE9IG51bGxcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHVzZXIgaXMgd2lsbGluZyB0byBjb250cm9sIHRvb2x0aXAgdG90YWxseSB1c2luZyBBUEksXG4gICAgICAgICAgICAgICAgLy8gc2VsZi5tYW51YWxseVNob3dUaXAoe3gsIHl9KSBtaWdodCBjYXVzZSB0b29sdGlwIGhpZGUsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgbm90IGV4cGVjdGVkLlxuICAgICAgICAgICAgICAgICYmIHRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXJPbicpICE9PSAnbm9uZSdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVmcmVzaFVwZGF0ZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hVcGRhdGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3cgdGlwIG5leHQgdGljayBhZnRlciBvdGhlciBjaGFydHMgYXJlIHJlbmRlcmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgaGlnaGxpZ2h0IGFjdGlvbiBoYXMgd3JvbmcgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWFudWFsbHlTaG93VGlwKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLl9sYXN0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYuX2xhc3RZXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRpcCBtYW51YWxseSBieVxuICAgICAgICAgKiBkaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAqICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgICAgICAqICAgICB4OiAxMCxcbiAgICAgICAgICogICAgIHk6IDEwXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBPclxuICAgICAgICAgKiBkaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAqICAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgICAgICAgKiAgICAgIHNlcmllc0luZGV4OiAwLFxuICAgICAgICAgKiAgICAgIGRhdGFJbmRleCBvciBkYXRhSW5kZXhJbnNpZGUgb3IgbmFtZVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogIFRPRE8gQmF0Y2hcbiAgICAgICAgICovXG4gICAgICAgIG1hbnVhbGx5U2hvd1RpcDogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5mcm9tID09PSB0aGlzLnVpZCB8fCBlbnYubm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpc3BhdGNoQWN0aW9uID0gbWFrZURpc3BhdGNoQWN0aW9uKHBheWxvYWQsIGFwaSk7XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IHRpY2tldFxuICAgICAgICAgICAgdGhpcy5fdGlja2V0ID0gJyc7XG5cbiAgICAgICAgICAgIC8vIFdoZW4gdHJpZ2dlcmVkIGZyb20gYXhpc1BvaW50ZXIuXG4gICAgICAgICAgICB2YXIgZGF0YUJ5Q29vcmRTeXMgPSBwYXlsb2FkLmRhdGFCeUNvb3JkU3lzO1xuXG4gICAgICAgICAgICBpZiAocGF5bG9hZC50b29sdGlwICYmIHBheWxvYWQueCAhPSBudWxsICYmIHBheWxvYWQueSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gcHJveHlSZWN0O1xuICAgICAgICAgICAgICAgIGVsLnBvc2l0aW9uID0gW3BheWxvYWQueCwgcGF5bG9hZC55XTtcbiAgICAgICAgICAgICAgICBlbC51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICBlbC50b29sdGlwID0gcGF5bG9hZC50b29sdGlwO1xuICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IHNob3cgdG9vbHRpcCB3aGlsZSB2aWV3IGlzIG5vdCB1c2luZyB6cmVuZGVyIGVsZW1lbnRzLlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyeVNob3coe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRYOiBwYXlsb2FkLngsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFk6IHBheWxvYWQueSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBlbFxuICAgICAgICAgICAgICAgIH0sIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFCeUNvb3JkU3lzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5U2hvdyh7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFg6IHBheWxvYWQueCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogcGF5bG9hZC55LFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcGF5bG9hZC5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHt9LFxuICAgICAgICAgICAgICAgICAgICBkYXRhQnlDb29yZFN5czogcGF5bG9hZC5kYXRhQnlDb29yZFN5cyxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcE9wdGlvbjogcGF5bG9hZC50b29sdGlwT3B0aW9uXG4gICAgICAgICAgICAgICAgfSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGF5bG9hZC5zZXJpZXNJbmRleCAhPSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWFudWFsbHlBeGlzU2hvd1RpcCh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwb2ludEluZm8gPSBmaW5kUG9pbnRGcm9tU2VyaWVzKHBheWxvYWQsIGVjTW9kZWwpO1xuICAgICAgICAgICAgICAgIHZhciBjeCA9IHBvaW50SW5mby5wb2ludFswXTtcbiAgICAgICAgICAgICAgICB2YXIgY3kgPSBwb2ludEluZm8ucG9pbnRbMV07XG4gICAgICAgICAgICAgICAgaWYgKGN4ICE9IG51bGwgJiYgY3kgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cnlTaG93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFg6IGN4LFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcGF5bG9hZC5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogcG9pbnRJbmZvLmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXlsb2FkLnggIT0gbnVsbCAmJiBwYXlsb2FkLnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIHdyYXAgZGlzcGF0Y2hBY3Rpb24gbGlrZSBgYXhpc1BvaW50ZXIvZ2xvYmFsTGlzdGVuZXJgID9cbiAgICAgICAgICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgICAgICAgICAgICAgICB4OiBwYXlsb2FkLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IHBheWxvYWQueVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5U2hvdyh7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFg6IHBheWxvYWQueCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogcGF5bG9hZC55LFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcGF5bG9hZC5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBhcGkuZ2V0WnIoKS5maW5kSG92ZXIocGF5bG9hZC54LCBwYXlsb2FkLnkpLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHt9XG4gICAgICAgICAgICAgICAgfSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1hbnVhbGx5SGlkZVRpcDogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSB0aGlzLl90b29sdGlwQ29udGVudDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hbHdheXNTaG93Q29udGVudCkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LmhpZGVMYXRlcih0aGlzLl90b29sdGlwTW9kZWwuZ2V0KCdoaWRlRGVsYXknKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2xhc3RYID0gdGhpcy5fbGFzdFkgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAocGF5bG9hZC5mcm9tICE9PSB0aGlzLnVpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpZGUobWFrZURpc3BhdGNoQWN0aW9uKHBheWxvYWQsIGFwaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEJlIGNvbXBhdGlibGUgd2l0aCBwcmV2aW91cyBkZXNpZ24sIHRoYXQgaXMsIHdoZW4gdG9vbHRpcC50eXBlIGlzICdheGlzJyBhbmRcbiAgICAgICAgLy8gZGlzcGF0Y2hBY3Rpb24gJ3Nob3dUaXAnIHdpdGggc2VyaWVzSW5kZXggYW5kIGRhdGFJbmRleCB3aWxsIHRyaWdnZXIgYXhpcyBwb2ludGVyXG4gICAgICAgIC8vIGFuZCB0b29sdGlwLlxuICAgICAgICBfbWFudWFsbHlBeGlzU2hvd1RpcDogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzSW5kZXggPSBwYXlsb2FkLnNlcmllc0luZGV4O1xuICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IHBheWxvYWQuZGF0YUluZGV4O1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzQXhlc0luZm8gPSBlY01vZGVsLmdldENvbXBvbmVudCgnYXhpc1BvaW50ZXInKS5jb29yZFN5c0F4ZXNJbmZvO1xuXG4gICAgICAgICAgICBpZiAoc2VyaWVzSW5kZXggPT0gbnVsbCB8fCBkYXRhSW5kZXggPT0gbnVsbCB8fCBjb29yZFN5c0F4ZXNJbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChzZXJpZXNJbmRleCk7XG4gICAgICAgICAgICBpZiAoIXNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciB0b29sdGlwTW9kZWwgPSBidWlsZFRvb2x0aXBNb2RlbChbXG4gICAgICAgICAgICAgICAgZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KSxcbiAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbCxcbiAgICAgICAgICAgICAgICAoc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSB8fCB7fSkubW9kZWwsXG4gICAgICAgICAgICAgICAgdG9vbHRpcE1vZGVsXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgaWYgKHRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXInKSAhPT0gJ2F4aXMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgICAgIHR5cGU6ICd1cGRhdGVBeGlzUG9pbnRlcicsXG4gICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgIGRhdGFJbmRleDogZGF0YUluZGV4LFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwYXlsb2FkLnBvc2l0aW9uXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3RyeVNob3c6IGZ1bmN0aW9uIChlLCBkaXNwYXRjaEFjdGlvbikge1xuICAgICAgICAgICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuXG4gICAgICAgICAgICBpZiAoIXRvb2x0aXBNb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2F2ZSBtb3VzZSB4LCBtb3VzZSB5LiBTbyB3ZSBjYW4gdHJ5IHRvIGtlZXAgc2hvd2luZyB0aGUgdGlwIGlmIGNoYXJ0IGlzIHJlZnJlc2hlZFxuICAgICAgICAgICAgdGhpcy5fbGFzdFggPSBlLm9mZnNldFg7XG4gICAgICAgICAgICB0aGlzLl9sYXN0WSA9IGUub2Zmc2V0WTtcblxuICAgICAgICAgICAgdmFyIGRhdGFCeUNvb3JkU3lzID0gZS5kYXRhQnlDb29yZFN5cztcbiAgICAgICAgICAgIGlmIChkYXRhQnlDb29yZFN5cyAmJiBkYXRhQnlDb29yZFN5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG93QXhpc1Rvb2x0aXAoZGF0YUJ5Q29vcmRTeXMsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWx3YXlzIHNob3cgaXRlbSB0b29sdGlwIGlmIG1vdXNlIGlzIG9uIHRoZSBlbGVtZW50IHdpdGggZGF0YUluZGV4XG4gICAgICAgICAgICBlbHNlIGlmIChlbCAmJiBlbC5kYXRhSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd1Nlcmllc0l0ZW1Ub29sdGlwKGUsIGVsLCBkaXNwYXRjaEFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUb29sdGlwIHByb3ZpZGVkIGRpcmVjdGx5LiBMaWtlIGxlZ2VuZC5cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsICYmIGVsLnRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dDb21wb25lbnRJdGVtVG9vbHRpcChlLCBlbCwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWRlKGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfc2hvd09yTW92ZTogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgY2IpIHtcbiAgICAgICAgICAgIC8vIHNob3dEZWxheSBpcyB1c2VkIGluIHRoaXMgY2FzZTogdG9vbHRpcC5lbnRlcmFibGUgaXMgc2V0XG4gICAgICAgICAgICAvLyBhcyB0cnVlLiBVc2VyIGludGVudCB0byBtb3ZlIG1vdXNlIGludG8gdG9vbHRpcCBhbmQgY2xpY2tcbiAgICAgICAgICAgIC8vIHNvbWV0aGluZy4gYHNob3dEZWxheWAgbWFrZXMgaXQgZWFzeWVyIHRvIGVudGVyIHRoZSBjb250ZW50XG4gICAgICAgICAgICAvLyBidXQgdG9vbHRpcCBkbyBub3QgbW92ZSBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgIHZhciBkZWxheSA9IHRvb2x0aXBNb2RlbC5nZXQoJ3Nob3dEZWxheScpO1xuICAgICAgICAgICAgY2IgPSB6clV0aWwuYmluZChjYiwgdGhpcyk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc2hvd1RpbW91dCk7XG4gICAgICAgICAgICBkZWxheSA+IDBcbiAgICAgICAgICAgICAgICA/ICh0aGlzLl9zaG93VGltb3V0ID0gc2V0VGltZW91dChjYiwgZGVsYXkpKVxuICAgICAgICAgICAgICAgIDogY2IoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2hvd0F4aXNUb29sdGlwOiBmdW5jdGlvbiAoZGF0YUJ5Q29vcmRTeXMsIGUpIHtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fZWNNb2RlbDtcbiAgICAgICAgICAgIHZhciBnbG9iYWxUb29sdGlwTW9kZWwgPSB0aGlzLl90b29sdGlwTW9kZWw7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBbZS5vZmZzZXRYLCBlLm9mZnNldFldO1xuICAgICAgICAgICAgdmFyIHNpbmdsZURlZmF1bHRIVE1MID0gW107XG4gICAgICAgICAgICB2YXIgc2luZ2xlUGFyYW1zTGlzdCA9IFtdO1xuICAgICAgICAgICAgdmFyIHNpbmdsZVRvb2x0aXBNb2RlbCA9IGJ1aWxkVG9vbHRpcE1vZGVsKFtcbiAgICAgICAgICAgICAgICBlLnRvb2x0aXBPcHRpb24sXG4gICAgICAgICAgICAgICAgZ2xvYmFsVG9vbHRpcE1vZGVsXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgZWFjaChkYXRhQnlDb29yZFN5cywgZnVuY3Rpb24gKGl0ZW1Db29yZFN5cykge1xuICAgICAgICAgICAgICAgIC8vIHZhciBjb29yZFBhcmFtTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIHZhciBjb29yZERlZmF1bHRIVE1MID0gW107XG4gICAgICAgICAgICAgICAgLy8gdmFyIGNvb3JkVG9vbHRpcE1vZGVsID0gYnVpbGRUb29sdGlwTW9kZWwoW1xuICAgICAgICAgICAgICAgIC8vICAgICBlLnRvb2x0aXBPcHRpb24sXG4gICAgICAgICAgICAgICAgLy8gICAgIGl0ZW1Db29yZFN5cy50b29sdGlwT3B0aW9uLFxuICAgICAgICAgICAgICAgIC8vICAgICBlY01vZGVsLmdldENvbXBvbmVudChpdGVtQ29vcmRTeXMuY29vcmRTeXNNYWluVHlwZSwgaXRlbUNvb3JkU3lzLmNvb3JkU3lzSW5kZXgpLFxuICAgICAgICAgICAgICAgIC8vICAgICBnbG9iYWxUb29sdGlwTW9kZWxcbiAgICAgICAgICAgICAgICAvLyBdKTtcbiAgICAgICAgICAgICAgICAvLyB2YXIgZGlzcGxheU1vZGUgPSBjb29yZFRvb2x0aXBNb2RlbC5nZXQoJ2Rpc3BsYXlNb2RlJyk7XG4gICAgICAgICAgICAgICAgLy8gdmFyIHBhcmFtc0xpc3QgPSBkaXNwbGF5TW9kZSA9PT0gJ3NpbmdsZScgPyBzaW5nbGVQYXJhbXNMaXN0IDogW107XG5cbiAgICAgICAgICAgICAgICBlYWNoKGl0ZW1Db29yZFN5cy5kYXRhQnlBeGlzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoaXRlbS5heGlzRGltICsgJ0F4aXMnLCBpdGVtLmF4aXNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzVmFsdWUgPSBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VyaWVzRGVmYXVsdEhUTUwgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWF4aXNNb2RlbCB8fCBheGlzVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlTGFiZWwgPSBheGlzUG9pbnRlclZpZXdIZWxwZXIuZ2V0VmFsdWVMYWJlbChcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNWYWx1ZSwgYXhpc01vZGVsLmF4aXMsIGVjTW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNlcmllc0RhdGFJbmRpY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS52YWx1ZUxhYmVsT3B0XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgenJVdGlsLmVhY2goaXRlbS5zZXJpZXNEYXRhSW5kaWNlcywgZnVuY3Rpb24gKGlkeEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXJpZXMgPSBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoaWR4SXRlbS5zZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUluZGV4ID0gaWR4SXRlbS5kYXRhSW5kZXhJbnNpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YVBhcmFtcyA9IHNlcmllcyAmJiBzZXJpZXMuZ2V0RGF0YVBhcmFtcyhkYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVBhcmFtcy5heGlzRGltID0gaXRlbS5heGlzRGltO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVBhcmFtcy5heGlzSW5kZXggPSBpdGVtLmF4aXNJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQYXJhbXMuYXhpc1R5cGUgPSBpdGVtLmF4aXNUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVBhcmFtcy5heGlzSWQgPSBpdGVtLmF4aXNJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQYXJhbXMuYXhpc1ZhbHVlID0gYXhpc0hlbHBlci5nZXRBeGlzUmF3VmFsdWUoYXhpc01vZGVsLmF4aXMsIGF4aXNWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUGFyYW1zLmF4aXNWYWx1ZUxhYmVsID0gdmFsdWVMYWJlbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW5nbGVQYXJhbXNMaXN0LnB1c2goZGF0YVBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzRGVmYXVsdEhUTUwucHVzaChzZXJpZXMuZm9ybWF0VG9vbHRpcChkYXRhSW5kZXgsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB0b29sdGlwIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgLy8gKDEpIHNob2xkIGJlIHRoZSBmaXJzdCBkYXRhIHdoaWNoIGhhcyBuYW1lP1xuICAgICAgICAgICAgICAgICAgICAvLyAoMikgdGhlbWVSaXZlciwgZmlyc3REYXRhSW5kZXggaXMgYXJyYXksIGFuZCBmaXJzdCBsaW5lIGlzIHVubmVjZXNzYXJ5LlxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RMaW5lID0gdmFsdWVMYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlRGVmYXVsdEhUTUwucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIChmaXJzdExpbmUgPyBmb3JtYXRVdGlsLmVuY29kZUhUTUwoZmlyc3RMaW5lKSArICc8YnIgLz4nIDogJycpXG4gICAgICAgICAgICAgICAgICAgICAgICArIHNlcmllc0RlZmF1bHRIVE1MLmpvaW4oJzxiciAvPicpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gSW4gbW9zdCBjYXNlLCB0aGUgc2Vjb25kIGF4aXMgaXMgc2hvd24gdXBwZXIgdGhhbiB0aGUgZmlyc3Qgb25lLlxuICAgICAgICAgICAgc2luZ2xlRGVmYXVsdEhUTUwucmV2ZXJzZSgpO1xuICAgICAgICAgICAgc2luZ2xlRGVmYXVsdEhUTUwgPSBzaW5nbGVEZWZhdWx0SFRNTC5qb2luKCc8YnIgLz48YnIgLz4nKTtcblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uRXhwciA9IGUucG9zaXRpb247XG4gICAgICAgICAgICB0aGlzLl9zaG93T3JNb3ZlKHNpbmdsZVRvb2x0aXBNb2RlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91cGRhdGVDb250ZW50Tm90Q2hhbmdlZE9uQXhpcyhkYXRhQnlDb29yZFN5cykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5nbGVUb29sdGlwTW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludFswXSwgcG9pbnRbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwQ29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbmdsZVBhcmFtc0xpc3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dUb29sdGlwQ29udGVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbmdsZVRvb2x0aXBNb2RlbCwgc2luZ2xlRGVmYXVsdEhUTUwsIHNpbmdsZVBhcmFtc0xpc3QsIE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludFswXSwgcG9pbnRbMV0sIHBvc2l0aW9uRXhwclxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBEbyBub3QgdHJpZ2dlciBldmVudHMgaGVyZSwgYmVjYXVzZSB0aGlzIGJyYW5jaCBvbmx5IGJlIGVudGVyZWRcbiAgICAgICAgICAgIC8vIGZyb20gZGlzcGF0Y2hBY3Rpb24uXG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Nob3dTZXJpZXNJdGVtVG9vbHRpcDogZnVuY3Rpb24gKGUsIGVsLCBkaXNwYXRjaEFjdGlvbikge1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9lY01vZGVsO1xuICAgICAgICAgICAgLy8gVXNlIGRhdGFNb2RlbCBpbiBlbGVtZW50IGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAvLyBVc2VkIHdoZW4gbW91c2VvdmVyIG9uIGEgZWxlbWVudCBsaWtlIG1hcmtQb2ludCBvciBlZGdlXG4gICAgICAgICAgICAvLyBJbiB3aGljaCBjYXNlLCB0aGUgZGF0YSBpcyBub3QgbWFpbiBkYXRhIGluIHNlcmllcy5cbiAgICAgICAgICAgIHZhciBzZXJpZXNJbmRleCA9IGVsLnNlcmllc0luZGV4O1xuICAgICAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KHNlcmllc0luZGV4KTtcblxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGdyYXBoIGxpbmsuXG4gICAgICAgICAgICB2YXIgZGF0YU1vZGVsID0gZWwuZGF0YU1vZGVsIHx8IHNlcmllc01vZGVsO1xuICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGVsLmRhdGFJbmRleDtcbiAgICAgICAgICAgIHZhciBkYXRhVHlwZSA9IGVsLmRhdGFUeXBlO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgICAgICAgICB2YXIgdG9vbHRpcE1vZGVsID0gYnVpbGRUb29sdGlwTW9kZWwoW1xuICAgICAgICAgICAgICAgIGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCksXG4gICAgICAgICAgICAgICAgZGF0YU1vZGVsLFxuICAgICAgICAgICAgICAgIHNlcmllc01vZGVsICYmIChzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtIHx8IHt9KS5tb2RlbCxcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwTW9kZWxcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICB2YXIgdG9vbHRpcFRyaWdnZXIgPSB0b29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyJyk7XG4gICAgICAgICAgICBpZiAodG9vbHRpcFRyaWdnZXIgIT0gbnVsbCAmJiB0b29sdGlwVHJpZ2dlciAhPT0gJ2l0ZW0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gZGF0YU1vZGVsLmdldERhdGFQYXJhbXMoZGF0YUluZGV4LCBkYXRhVHlwZSk7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdEh0bWwgPSBkYXRhTW9kZWwuZm9ybWF0VG9vbHRpcChkYXRhSW5kZXgsIGZhbHNlLCBkYXRhVHlwZSk7XG4gICAgICAgICAgICB2YXIgYXN5bmNUaWNrZXQgPSAnaXRlbV8nICsgZGF0YU1vZGVsLm5hbWUgKyAnXycgKyBkYXRhSW5kZXg7XG5cbiAgICAgICAgICAgIHRoaXMuX3Nob3dPck1vdmUodG9vbHRpcE1vZGVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXBDb250ZW50KFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwTW9kZWwsIGRlZmF1bHRIdG1sLCBwYXJhbXMsIGFzeW5jVGlja2V0LFxuICAgICAgICAgICAgICAgICAgICBlLm9mZnNldFgsIGUub2Zmc2V0WSwgZS5wb3NpdGlvbiwgZS50YXJnZXRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyBkdXBsaWNhdGVkIHNob3d0aXAgaWYgbWFudWFsbHlTaG93VGlwIGlzIGNhbGxlZCBmcm9tIGRpc3BhdGNoQWN0aW9uLlxuICAgICAgICAgICAgZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzaG93VGlwJyxcbiAgICAgICAgICAgICAgICBkYXRhSW5kZXhJbnNpZGU6IGRhdGFJbmRleCxcbiAgICAgICAgICAgICAgICBkYXRhSW5kZXg6IGRhdGEuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KSxcbiAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgZnJvbTogdGhpcy51aWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zaG93Q29tcG9uZW50SXRlbVRvb2x0aXA6IGZ1bmN0aW9uIChlLCBlbCwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB0b29sdGlwT3B0ID0gZWwudG9vbHRpcDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9vbHRpcE9wdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IHRvb2x0aXBPcHQ7XG4gICAgICAgICAgICAgICAgdG9vbHRpcE9wdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZWQgZm9ybWF0dGVyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogY29udGVudFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3ViVG9vbHRpcE1vZGVsID0gbmV3IE1vZGVsKHRvb2x0aXBPcHQsIHRoaXMuX3Rvb2x0aXBNb2RlbCwgdGhpcy5fZWNNb2RlbCk7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdEh0bWwgPSBzdWJUb29sdGlwTW9kZWwuZ2V0KCdjb250ZW50Jyk7XG4gICAgICAgICAgICB2YXIgYXN5bmNUaWNrZXQgPSBNYXRoLnJhbmRvbSgpO1xuXG4gICAgICAgICAgICAvLyBEbyBub3QgY2hlY2sgd2hldGhlciBgdHJpZ2dlcmAgaXMgJ25vbmUnIGhlcmUsIGJlY2F1c2UgYHRyaWdnZXJgXG4gICAgICAgICAgICAvLyBvbmx5IHdvcmtzIG9uIGNvb3JpZGluYXRlIHN5c3RlbS4gSW4gZmFjdCwgd2UgaGF2ZSBub3QgZm91bmQgY2FzZVxuICAgICAgICAgICAgLy8gdGhhdCByZXF1aXJlcyBzZXR0aW5nIGB0cmlnZ2VyYCBub3RoaW5nIG9uIGNvbXBvbmVudCB5ZXQuXG5cbiAgICAgICAgICAgIHRoaXMuX3Nob3dPck1vdmUoc3ViVG9vbHRpcE1vZGVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXBDb250ZW50KFxuICAgICAgICAgICAgICAgICAgICBzdWJUb29sdGlwTW9kZWwsIGRlZmF1bHRIdG1sLCBzdWJUb29sdGlwTW9kZWwuZ2V0KCdmb3JtYXR0ZXJQYXJhbXMnKSB8fCB7fSxcbiAgICAgICAgICAgICAgICAgICAgYXN5bmNUaWNrZXQsIGUub2Zmc2V0WCwgZS5vZmZzZXRZLCBlLnBvc2l0aW9uLCBlbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSWYgbm90IGRpc3BhdGNoIHNob3dUaXAsIHRpcCBtYXkgYmUgaGlkZSB0cmlnZ2VyZWQgYnkgYXhpcy5cbiAgICAgICAgICAgIGRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgICAgICAgICAgICAgZnJvbTogdGhpcy51aWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zaG93VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIHRvb2x0aXBNb2RlbCwgZGVmYXVsdEh0bWwsIHBhcmFtcywgYXN5bmNUaWNrZXQsIHgsIHksIHBvc2l0aW9uRXhwciwgZWxcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBSZXNldCB0aWNrZXRcbiAgICAgICAgICAgIHRoaXMuX3RpY2tldCA9ICcnO1xuXG4gICAgICAgICAgICBpZiAoIXRvb2x0aXBNb2RlbC5nZXQoJ3Nob3dDb250ZW50JykgfHwgIXRvb2x0aXBNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvb2x0aXBDb250ZW50ID0gdGhpcy5fdG9vbHRpcENvbnRlbnQ7XG5cbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZXIgPSB0b29sdGlwTW9kZWwuZ2V0KCdmb3JtYXR0ZXInKTtcbiAgICAgICAgICAgIHBvc2l0aW9uRXhwciA9IHBvc2l0aW9uRXhwciB8fCB0b29sdGlwTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgICAgICAgICAgdmFyIGh0bWwgPSBkZWZhdWx0SHRtbDtcblxuICAgICAgICAgICAgaWYgKGZvcm1hdHRlciAmJiB0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGh0bWwgPSBmb3JtYXRVdGlsLmZvcm1hdFRwbChmb3JtYXR0ZXIsIHBhcmFtcywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYmluZChmdW5jdGlvbiAoY2JUaWNrZXQsIGh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNiVGlja2V0ID09PSB0aGlzLl90aWNrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LnNldENvbnRlbnQoaHRtbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwTW9kZWwsIHBvc2l0aW9uRXhwciwgeCwgeSwgdG9vbHRpcENvbnRlbnQsIHBhcmFtcywgZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90aWNrZXQgPSBhc3luY1RpY2tldDtcbiAgICAgICAgICAgICAgICBodG1sID0gZm9ybWF0dGVyKHBhcmFtcywgYXN5bmNUaWNrZXQsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9vbHRpcENvbnRlbnQuc2V0Q29udGVudChodG1sKTtcbiAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LnNob3codG9vbHRpcE1vZGVsKTtcblxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgdG9vbHRpcE1vZGVsLCBwb3NpdGlvbkV4cHIsIHgsIHksIHRvb2x0aXBDb250ZW50LCBwYXJhbXMsIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd8RnVuY3Rpb258QXJyYXkuPG51bWJlcj59IHBvc2l0aW9uRXhwclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggTW91c2UgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgTW91c2UgeVxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjb25maW5lIFdoZXRoZXIgY29uZmluZSB0b29sdGlwIGNvbnRlbnQgaW4gdmlldyByZWN0LlxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R8PEFycmF5LjxPYmplY3Q+fSBwYXJhbXNcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIHBvc2l0aW9uRXhwciwgeCwgeSwgY29udGVudCwgcGFyYW1zLCBlbCkge1xuICAgICAgICAgICAgdmFyIHZpZXdXaWR0aCA9IHRoaXMuX2FwaS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgdmFyIHZpZXdIZWlnaHQgPSB0aGlzLl9hcGkuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBwb3NpdGlvbkV4cHIgPSBwb3NpdGlvbkV4cHIgfHwgdG9vbHRpcE1vZGVsLmdldCgncG9zaXRpb24nKTtcblxuICAgICAgICAgICAgdmFyIGNvbnRlbnRTaXplID0gY29udGVudC5nZXRTaXplKCk7XG4gICAgICAgICAgICB2YXIgYWxpZ24gPSB0b29sdGlwTW9kZWwuZ2V0KCdhbGlnbicpO1xuICAgICAgICAgICAgdmFyIHZBbGlnbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ3ZlcnRpY2FsQWxpZ24nKTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gZWwgJiYgZWwuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcbiAgICAgICAgICAgIGVsICYmIHJlY3QuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbkV4cHIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxsYmFjayBvZiBwb3NpdGlvbiBjYW4gYmUgYW4gYXJyYXkgb3IgYSBzdHJpbmcgc3BlY2lmeSB0aGUgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIgPSBwb3NpdGlvbkV4cHIoW3gsIHldLCBwYXJhbXMsIGNvbnRlbnQuZWwsIHJlY3QsIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld1NpemU6IFt2aWV3V2lkdGgsIHZpZXdIZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50U2l6ZTogY29udGVudFNpemUuc2xpY2UoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXkocG9zaXRpb25FeHByKSkge1xuICAgICAgICAgICAgICAgIHggPSBwYXJzZVBlcmNlbnQocG9zaXRpb25FeHByWzBdLCB2aWV3V2lkdGgpO1xuICAgICAgICAgICAgICAgIHkgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25FeHByWzFdLCB2aWV3SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHpyVXRpbC5pc09iamVjdChwb3NpdGlvbkV4cHIpKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25FeHByLndpZHRoID0gY29udGVudFNpemVbMF07XG4gICAgICAgICAgICAgICAgcG9zaXRpb25FeHByLmhlaWdodCA9IGNvbnRlbnRTaXplWzFdO1xuICAgICAgICAgICAgICAgIHZhciBsYXlvdXRSZWN0ID0gbGF5b3V0VXRpbC5nZXRMYXlvdXRSZWN0KFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIsIHt3aWR0aDogdmlld1dpZHRoLCBoZWlnaHQ6IHZpZXdIZWlnaHR9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB4ID0gbGF5b3V0UmVjdC54O1xuICAgICAgICAgICAgICAgIHkgPSBsYXlvdXRSZWN0Lnk7XG4gICAgICAgICAgICAgICAgYWxpZ24gPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gcG9zaXRpb25FeHByIGlzIGxlZnQvdG9wL3JpZ2h0L2JvdHRvbSxcbiAgICAgICAgICAgICAgICAvLyBhbGlnbiBhbmQgdmVydGljYWxBbGlnbiB3aWxsIG5vdCB3b3JrLlxuICAgICAgICAgICAgICAgIHZBbGlnbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTcGVjaWZ5IHRvb2x0aXAgcG9zaXRpb24gYnkgc3RyaW5nICd0b3AnICdib3R0b20nICdsZWZ0JyAncmlnaHQnIGFyb3VuZCBncmFwaGljIGVsZW1lbnRcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwb3NpdGlvbkV4cHIgPT09ICdzdHJpbmcnICYmIGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IGNhbGNUb29sdGlwUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uRXhwciwgcmVjdCwgY29udGVudFNpemVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHggPSBwb3NbMF07XG4gICAgICAgICAgICAgICAgeSA9IHBvc1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSByZWZpeFRvb2x0aXBQb3NpdGlvbihcbiAgICAgICAgICAgICAgICAgICAgeCwgeSwgY29udGVudC5lbCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0LCBhbGlnbiA/IG51bGwgOiAyMCwgdkFsaWduID8gbnVsbCA6IDIwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB4ID0gcG9zWzBdO1xuICAgICAgICAgICAgICAgIHkgPSBwb3NbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFsaWduICYmICh4IC09IGlzQ2VudGVyQWxpZ24oYWxpZ24pID8gY29udGVudFNpemVbMF0gLyAyIDogYWxpZ24gPT09ICdyaWdodCcgPyBjb250ZW50U2l6ZVswXSA6IDApO1xuICAgICAgICAgICAgdkFsaWduICYmICh5IC09IGlzQ2VudGVyQWxpZ24odkFsaWduKSA/IGNvbnRlbnRTaXplWzFdIC8gMiA6IHZBbGlnbiA9PT0gJ2JvdHRvbScgPyBjb250ZW50U2l6ZVsxXSA6IDApO1xuXG4gICAgICAgICAgICBpZiAodG9vbHRpcE1vZGVsLmdldCgnY29uZmluZScpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IGNvbmZpbmVUb29sdGlwUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgIHgsIHksIGNvbnRlbnQuZWwsIHZpZXdXaWR0aCwgdmlld0hlaWdodFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgeCA9IHBvc1swXTtcbiAgICAgICAgICAgICAgICB5ID0gcG9zWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZW50Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBTaG91bGQgd2UgcmVtb3ZlIHRoaXMgYnV0IGxlYXZlIHRoaXMgdG8gdXNlcj9cbiAgICAgICAgX3VwZGF0ZUNvbnRlbnROb3RDaGFuZ2VkT25BeGlzOiBmdW5jdGlvbiAoZGF0YUJ5Q29vcmRTeXMpIHtcbiAgICAgICAgICAgIHZhciBsYXN0Q29vcmRTeXMgPSB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXM7XG4gICAgICAgICAgICB2YXIgY29udGVudE5vdENoYW5nZWQgPSAhIWxhc3RDb29yZFN5c1xuICAgICAgICAgICAgICAgICYmIGxhc3RDb29yZFN5cy5sZW5ndGggPT09IGRhdGFCeUNvb3JkU3lzLmxlbmd0aDtcblxuICAgICAgICAgICAgY29udGVudE5vdENoYW5nZWQgJiYgZWFjaChsYXN0Q29vcmRTeXMsIGZ1bmN0aW9uIChsYXN0SXRlbUNvb3JkU3lzLCBpbmRleENvb3JkU3lzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3REYXRhQnlBeGlzID0gbGFzdEl0ZW1Db29yZFN5cy5kYXRhQnlBeGlzIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciB0aGlzSXRlbUNvb3JkU3lzID0gZGF0YUJ5Q29vcmRTeXNbaW5kZXhDb29yZFN5c10gfHwge307XG4gICAgICAgICAgICAgICAgdmFyIHRoaXNEYXRhQnlBeGlzID0gdGhpc0l0ZW1Db29yZFN5cy5kYXRhQnlBeGlzIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbnRlbnROb3RDaGFuZ2VkICY9IGxhc3REYXRhQnlBeGlzLmxlbmd0aCA9PT0gdGhpc0RhdGFCeUF4aXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgY29udGVudE5vdENoYW5nZWQgJiYgZWFjaChsYXN0RGF0YUJ5QXhpcywgZnVuY3Rpb24gKGxhc3RJdGVtLCBpbmRleEF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoaXNJdGVtID0gdGhpc0RhdGFCeUF4aXNbaW5kZXhBeGlzXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RJbmRpY2VzID0gbGFzdEl0ZW0uc2VyaWVzRGF0YUluZGljZXMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdJbmRpY2VzID0gdGhpc0l0ZW0uc2VyaWVzRGF0YUluZGljZXMgfHwgW107XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGVudE5vdENoYW5nZWQgJj1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RJdGVtLnZhbHVlID09PSB0aGlzSXRlbS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgbGFzdEl0ZW0uYXhpc1R5cGUgPT09IHRoaXNJdGVtLmF4aXNUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBsYXN0SXRlbS5heGlzSWQgPT09IHRoaXNJdGVtLmF4aXNJZFxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgbGFzdEluZGljZXMubGVuZ3RoID09PSBuZXdJbmRpY2VzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBjb250ZW50Tm90Q2hhbmdlZCAmJiBlYWNoKGxhc3RJbmRpY2VzLCBmdW5jdGlvbiAobGFzdElkeEl0ZW0sIGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdJZHhJdGVtID0gbmV3SW5kaWNlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnROb3RDaGFuZ2VkICY9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdElkeEl0ZW0uc2VyaWVzSW5kZXggPT09IG5ld0lkeEl0ZW0uc2VyaWVzSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBsYXN0SWR4SXRlbS5kYXRhSW5kZXggPT09IG5ld0lkeEl0ZW0uZGF0YUluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBkYXRhQnlDb29yZFN5cztcblxuICAgICAgICAgICAgcmV0dXJuICEhY29udGVudE5vdENoYW5nZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2hpZGU6IGZ1bmN0aW9uIChkaXNwYXRjaEFjdGlvbikge1xuICAgICAgICAgICAgLy8gRG8gbm90IGRpcmVjdGx5IGhpZGVMYXRlciBoZXJlLCBiZWNhdXNlIHRoaXMgYmVoYXZpb3IgbWF5IGJlIHByZXZlbnRlZFxuICAgICAgICAgICAgLy8gaW4gZGlzcGF0Y2hBY3Rpb24gd2hlbiBzaG93VGlwIGlzIGRpc3BhdGNoZWQuXG5cbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyBkdXBsaWNhdGVkIGhpZGVUaXAgaWYgbWFudWFsbHlIaWRlVGlwIGlzIGNhbGxlZCBmcm9tIGRpc3BhdGNoQWN0aW9uLlxuICAgICAgICAgICAgdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzID0gbnVsbDtcbiAgICAgICAgICAgIGRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGlkZVRpcCcsXG4gICAgICAgICAgICAgICAgZnJvbTogdGhpcy51aWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIGlmIChlbnYubm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBDb250ZW50LmhpZGUoKTtcbiAgICAgICAgICAgIGdsb2JhbExpc3RlbmVyLnVucmVnaXN0ZXIoJ2l0ZW1Ub29sdGlwJywgYXBpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3R8bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWw+fSBtb2RlbENhc2NhZGVcbiAgICAgKiBGcm9tIHRvcCB0byBib3R0b20uICh0aGUgbGFzdCBvbmUgc2hvdWxkIGJlIGdsb2JhbFRvb2x0aXBNb2RlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gYnVpbGRUb29sdGlwTW9kZWwobW9kZWxDYXNjYWRlKSB7XG4gICAgICAgIHZhciByZXN1bHRNb2RlbCA9IG1vZGVsQ2FzY2FkZS5wb3AoKTtcbiAgICAgICAgd2hpbGUgKG1vZGVsQ2FzY2FkZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB0b29sdGlwT3B0ID0gbW9kZWxDYXNjYWRlLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHRvb2x0aXBPcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcE9wdCBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBPcHQgPSB0b29sdGlwT3B0LmdldCgndG9vbHRpcCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJbiBlYWNoIGRhdGEgaXRlbSB0b29sdGlwIGNhbiBiZSBzaW1wbHkgd3JpdGU6XG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICB2YWx1ZTogMTAsXG4gICAgICAgICAgICAgICAgLy8gIHRvb2x0aXA6ICdTb21ldGhpbmcgeW91IG5lZWQgdG8ga25vdydcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b29sdGlwT3B0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwT3B0ID0ge2Zvcm1hdHRlcjogdG9vbHRpcE9wdH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdE1vZGVsID0gbmV3IE1vZGVsKHRvb2x0aXBPcHQsIHJlc3VsdE1vZGVsLCByZXN1bHRNb2RlbC5lY01vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0TW9kZWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZURpc3BhdGNoQWN0aW9uKHBheWxvYWQsIGFwaSkge1xuICAgICAgICByZXR1cm4gcGF5bG9hZC5kaXNwYXRjaEFjdGlvbiB8fCB6clV0aWwuYmluZChhcGkuZGlzcGF0Y2hBY3Rpb24sIGFwaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVmaXhUb29sdGlwUG9zaXRpb24oeCwgeSwgZWwsIHZpZXdXaWR0aCwgdmlld0hlaWdodCwgZ2FwSCwgZ2FwVikge1xuICAgICAgICB2YXIgd2lkdGggPSBlbC5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcblxuICAgICAgICBpZiAoZ2FwSCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoeCArIHdpZHRoICsgZ2FwSCA+IHZpZXdXaWR0aCkge1xuICAgICAgICAgICAgICAgIHggLT0gd2lkdGggKyBnYXBIO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeCArPSBnYXBIO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChnYXBWICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh5ICsgaGVpZ2h0ICsgZ2FwViA+IHZpZXdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB5IC09IGhlaWdodCArIGdhcFY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ICs9IGdhcFY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maW5lVG9vbHRpcFBvc2l0aW9uKHgsIHksIGVsLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gZWwuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XG5cbiAgICAgICAgeCA9IE1hdGgubWluKHggKyB3aWR0aCwgdmlld1dpZHRoKSAtIHdpZHRoO1xuICAgICAgICB5ID0gTWF0aC5taW4oeSArIGhlaWdodCwgdmlld0hlaWdodCkgLSBoZWlnaHQ7XG4gICAgICAgIHggPSBNYXRoLm1heCh4LCAwKTtcbiAgICAgICAgeSA9IE1hdGgubWF4KHksIDApO1xuXG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY1Rvb2x0aXBQb3NpdGlvbihwb3NpdGlvbiwgcmVjdCwgY29udGVudFNpemUpIHtcbiAgICAgICAgdmFyIGRvbVdpZHRoID0gY29udGVudFNpemVbMF07XG4gICAgICAgIHZhciBkb21IZWlnaHQgPSBjb250ZW50U2l6ZVsxXTtcbiAgICAgICAgdmFyIGdhcCA9IDU7XG4gICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgdmFyIHkgPSAwO1xuICAgICAgICB2YXIgcmVjdFdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgdmFyIHJlY3RIZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlJzpcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoIC8gMiAtIGRvbVdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcmVjdEhlaWdodCAvIDIgLSBkb21IZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoIC8gMiAtIGRvbVdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55IC0gZG9tSGVpZ2h0IC0gZ2FwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoIC8gMiAtIGRvbVdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcmVjdEhlaWdodCArIGdhcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggLSBkb21XaWR0aCAtIGdhcDtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcmVjdEhlaWdodCAvIDIgLSBkb21IZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggKyByZWN0V2lkdGggKyBnYXA7XG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgLyAyIC0gZG9tSGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQ2VudGVyQWxpZ24oYWxpZ24pIHtcbiAgICAgICAgcmV0dXJuIGFsaWduID09PSAnY2VudGVyJyB8fCBhbGlnbiA9PT0gJ21pZGRsZSc7XG4gICAgfVxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcFZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDE0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("/**\n * @module echarts/component/tooltip/TooltipContent\n */\n\n\n    var zrUtil = __webpack_require__(20);\n    var zrColor = __webpack_require__(47);\n    var eventUtil = __webpack_require__(104);\n    var formatUtil = __webpack_require__(22);\n    var each = zrUtil.each;\n    var toCamelCase = formatUtil.toCamelCase;\n    var env = __webpack_require__(18);\n\n    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\n    /**\n     * @param {number} duration\n     * @return {string}\n     * @inner\n     */\n    function assembleTransition(duration) {\n        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n                            + 'top ' + duration + 's ' + transitionCurve;\n        return zrUtil.map(vendors, function (vendorPrefix) {\n            return vendorPrefix + 'transition:' + transitionText;\n        }).join(';');\n    }\n\n    /**\n     * @param {Object} textStyle\n     * @return {string}\n     * @inner\n     */\n    function assembleFont(textStyleModel) {\n        var cssText = [];\n\n        var fontSize = textStyleModel.get('fontSize');\n        var color = textStyleModel.getTextColor();\n\n        color && cssText.push('color:' + color);\n\n        cssText.push('font:' + textStyleModel.getFont());\n\n        fontSize &&\n            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\n        each(['decoration', 'align'], function (name) {\n            var val = textStyleModel.get(name);\n            val && cssText.push('text-' + name + ':' + val);\n        });\n\n        return cssText.join(';');\n    }\n\n    /**\n     * @param {Object} tooltipModel\n     * @return {string}\n     * @inner\n     */\n    function assembleCssText(tooltipModel) {\n\n        var cssText = [];\n\n        var transitionDuration = tooltipModel.get('transitionDuration');\n        var backgroundColor = tooltipModel.get('backgroundColor');\n        var textStyleModel = tooltipModel.getModel('textStyle');\n        var padding = tooltipModel.get('padding');\n\n        // Animation transition. Do not animate when transitionDuration is 0.\n        transitionDuration &&\n            cssText.push(assembleTransition(transitionDuration));\n\n        if (backgroundColor) {\n            if (env.canvasSupported) {\n                cssText.push('background-Color:' + backgroundColor);\n            }\n            else {\n                // for ie\n                cssText.push(\n                    'background-Color:#' + zrColor.toHex(backgroundColor)\n                );\n                cssText.push('filter:alpha(opacity=70)');\n            }\n        }\n\n        // Border style\n        each(['width', 'color', 'radius'], function (name) {\n            var borderName = 'border-' + name;\n            var camelCase = toCamelCase(borderName);\n            var val = tooltipModel.get(camelCase);\n            val != null &&\n                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n        });\n\n        // Text style\n        cssText.push(assembleFont(textStyleModel));\n\n        // Padding\n        if (padding != null) {\n            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n        }\n\n        return cssText.join(';') + ';';\n    }\n\n    /**\n     * @alias module:echarts/component/tooltip/TooltipContent\n     * @constructor\n     */\n    function TooltipContent(container, api) {\n        var el = document.createElement('div');\n        var zr = this._zr = api.getZr();\n\n        this.el = el;\n\n        this._x = api.getWidth() / 2;\n        this._y = api.getHeight() / 2;\n\n        container.appendChild(el);\n\n        this._container = container;\n\n        this._show = false;\n\n        /**\n         * @private\n         */\n        this._hideTimeout;\n\n        var self = this;\n        el.onmouseenter = function () {\n            // clear the timeout in hideLater and keep showing tooltip\n            if (self._enterable) {\n                clearTimeout(self._hideTimeout);\n                self._show = true;\n            }\n            self._inContent = true;\n        };\n        el.onmousemove = function (e) {\n            e = e || window.event;\n            if (!self._enterable) {\n                // Try trigger zrender event to avoid mouse\n                // in and out shape too frequently\n                var handler = zr.handler;\n                eventUtil.normalizeEvent(container, e, true);\n                handler.dispatch('mousemove', e);\n            }\n        };\n        el.onmouseleave = function () {\n            if (self._enterable) {\n                if (self._show) {\n                    self.hideLater(self._hideDelay);\n                }\n            }\n            self._inContent = false;\n        };\n    }\n\n    TooltipContent.prototype = {\n\n        constructor: TooltipContent,\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _enterable: true,\n\n        /**\n         * Update when tooltip is rendered\n         */\n        update: function () {\n            // FIXME\n            // Move this logic to ec main?\n            var container = this._container;\n            var stl = container.currentStyle\n                || document.defaultView.getComputedStyle(container);\n            var domStyle = container.style;\n            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n                domStyle.position = 'relative';\n            }\n            // Hide the tooltip\n            // PENDING\n            // this.hide();\n        },\n\n        show: function (tooltipModel) {\n            clearTimeout(this._hideTimeout);\n            var el = this.el;\n\n            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n                + (tooltipModel.get('extraCssText') || '');\n\n            el.style.display = el.innerHTML ?  'block' : 'none';\n\n            this._show = true;\n        },\n\n        setContent: function (content) {\n            this.el.innerHTML = content == null ? '' : content;\n        },\n\n        setEnterable: function (enterable) {\n            this._enterable = enterable;\n        },\n\n        getSize: function () {\n            var el = this.el;\n            return [el.clientWidth, el.clientHeight];\n        },\n\n        moveTo: function (x, y) {\n            // xy should be based on canvas root. But tooltipContent is\n            // the sibling of canvas root. So padding of ec container\n            // should be considered here.\n            var zr = this._zr;\n            var viewportRoot;\n            if (zr && zr.painter && (viewportRoot = zr.painter.getViewportRoot())) {\n                x += viewportRoot.offsetLeft || 0;\n                y += viewportRoot.offsetTop || 0;\n            }\n\n            var style = this.el.style;\n            style.left = x + 'px';\n            style.top = y + 'px';\n\n            this._x = x;\n            this._y = y;\n        },\n\n        hide: function () {\n            this.el.style.display = 'none';\n            this._show = false;\n        },\n\n        hideLater: function (time) {\n            if (this._show && !(this._inContent && this._enterable)) {\n                if (time) {\n                    this._hideDelay = time;\n                    // Set show false to avoid invoke hideLater mutiple times\n                    this._show = false;\n                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n                }\n                else {\n                    this.hide();\n                }\n            }\n        },\n\n        isShow: function () {\n            return this._show;\n        }\n    };\n\n    module.exports = TooltipContent;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBDb250ZW50LmpzPzJjNTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsY0FBYyxtQkFBbUIsbUJBQW1CLGdCQUFnQjs7QUFFMUc7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLE9BQU87QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QixzQkFBc0I7QUFDakU7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxNDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwQ29udGVudFxuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgenJDb2xvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvY29sb3InKTtcbiAgICB2YXIgZXZlbnRVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9ldmVudCcpO1xuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9mb3JtYXQnKTtcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciB0b0NhbWVsQ2FzZSA9IGZvcm1hdFV0aWwudG9DYW1lbENhc2U7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XG5cbiAgICB2YXIgdmVuZG9ycyA9IFsnJywgJy13ZWJraXQtJywgJy1tb3otJywgJy1vLSddO1xuXG4gICAgdmFyIGdDc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7Ym9yZGVyLXN0eWxlOnNvbGlkO3doaXRlLXNwYWNlOm5vd3JhcDt6LWluZGV4Ojk5OTk5OTk7JztcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlbWJsZVRyYW5zaXRpb24oZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25DdXJ2ZSA9ICdjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSknO1xuICAgICAgICB2YXIgdHJhbnNpdGlvblRleHQgPSAnbGVmdCAnICsgZHVyYXRpb24gKyAncyAnICsgdHJhbnNpdGlvbkN1cnZlICsgJywnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAndG9wICcgKyBkdXJhdGlvbiArICdzICcgKyB0cmFuc2l0aW9uQ3VydmU7XG4gICAgICAgIHJldHVybiB6clV0aWwubWFwKHZlbmRvcnMsIGZ1bmN0aW9uICh2ZW5kb3JQcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZW5kb3JQcmVmaXggKyAndHJhbnNpdGlvbjonICsgdHJhbnNpdGlvblRleHQ7XG4gICAgICAgIH0pLmpvaW4oJzsnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2VtYmxlRm9udCh0ZXh0U3R5bGVNb2RlbCkge1xuICAgICAgICB2YXIgY3NzVGV4dCA9IFtdO1xuXG4gICAgICAgIHZhciBmb250U2l6ZSA9IHRleHRTdHlsZU1vZGVsLmdldCgnZm9udFNpemUnKTtcbiAgICAgICAgdmFyIGNvbG9yID0gdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCk7XG5cbiAgICAgICAgY29sb3IgJiYgY3NzVGV4dC5wdXNoKCdjb2xvcjonICsgY29sb3IpO1xuXG4gICAgICAgIGNzc1RleHQucHVzaCgnZm9udDonICsgdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpKTtcblxuICAgICAgICBmb250U2l6ZSAmJlxuICAgICAgICAgICAgY3NzVGV4dC5wdXNoKCdsaW5lLWhlaWdodDonICsgTWF0aC5yb3VuZChmb250U2l6ZSAqIDMgLyAyKSArICdweCcpO1xuXG4gICAgICAgIGVhY2goWydkZWNvcmF0aW9uJywgJ2FsaWduJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gdGV4dFN0eWxlTW9kZWwuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgdmFsICYmIGNzc1RleHQucHVzaCgndGV4dC0nICsgbmFtZSArICc6JyArIHZhbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjc3NUZXh0LmpvaW4oJzsnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdG9vbHRpcE1vZGVsXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2VtYmxlQ3NzVGV4dCh0b29sdGlwTW9kZWwpIHtcblxuICAgICAgICB2YXIgY3NzVGV4dCA9IFtdO1xuXG4gICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSB0b29sdGlwTW9kZWwuZ2V0KCd0cmFuc2l0aW9uRHVyYXRpb24nKTtcbiAgICAgICAgdmFyIGJhY2tncm91bmRDb2xvciA9IHRvb2x0aXBNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpO1xuICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSB0b29sdGlwTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICAgICAgICB2YXIgcGFkZGluZyA9IHRvb2x0aXBNb2RlbC5nZXQoJ3BhZGRpbmcnKTtcblxuICAgICAgICAvLyBBbmltYXRpb24gdHJhbnNpdGlvbi4gRG8gbm90IGFuaW1hdGUgd2hlbiB0cmFuc2l0aW9uRHVyYXRpb24gaXMgMC5cbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uICYmXG4gICAgICAgICAgICBjc3NUZXh0LnB1c2goYXNzZW1ibGVUcmFuc2l0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikpO1xuXG4gICAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgIGlmIChlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgY3NzVGV4dC5wdXNoKCdiYWNrZ3JvdW5kLUNvbG9yOicgKyBiYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGllXG4gICAgICAgICAgICAgICAgY3NzVGV4dC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1Db2xvcjojJyArIHpyQ29sb3IudG9IZXgoYmFja2dyb3VuZENvbG9yKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY3NzVGV4dC5wdXNoKCdmaWx0ZXI6YWxwaGEob3BhY2l0eT03MCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJvcmRlciBzdHlsZVxuICAgICAgICBlYWNoKFsnd2lkdGgnLCAnY29sb3InLCAncmFkaXVzJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgYm9yZGVyTmFtZSA9ICdib3JkZXItJyArIG5hbWU7XG4gICAgICAgICAgICB2YXIgY2FtZWxDYXNlID0gdG9DYW1lbENhc2UoYm9yZGVyTmFtZSk7XG4gICAgICAgICAgICB2YXIgdmFsID0gdG9vbHRpcE1vZGVsLmdldChjYW1lbENhc2UpO1xuICAgICAgICAgICAgdmFsICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBjc3NUZXh0LnB1c2goYm9yZGVyTmFtZSArICc6JyArIHZhbCArIChuYW1lID09PSAnY29sb3InID8gJycgOiAncHgnKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRleHQgc3R5bGVcbiAgICAgICAgY3NzVGV4dC5wdXNoKGFzc2VtYmxlRm9udCh0ZXh0U3R5bGVNb2RlbCkpO1xuXG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgaWYgKHBhZGRpbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3NzVGV4dC5wdXNoKCdwYWRkaW5nOicgKyBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KHBhZGRpbmcpLmpvaW4oJ3B4ICcpICsgJ3B4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3NzVGV4dC5qb2luKCc7JykgKyAnOyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBDb250ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9vbHRpcENvbnRlbnQoY29udGFpbmVyLCBhcGkpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhciB6ciA9IHRoaXMuX3pyID0gYXBpLmdldFpyKCk7XG5cbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuXG4gICAgICAgIHRoaXMuX3ggPSBhcGkuZ2V0V2lkdGgoKSAvIDI7XG4gICAgICAgIHRoaXMuX3kgPSBhcGkuZ2V0SGVpZ2h0KCkgLyAyO1xuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG5cbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgICAgIHRoaXMuX3Nob3cgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hpZGVUaW1lb3V0O1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZWwub25tb3VzZWVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY2xlYXIgdGhlIHRpbWVvdXQgaW4gaGlkZUxhdGVyIGFuZCBrZWVwIHNob3dpbmcgdG9vbHRpcFxuICAgICAgICAgICAgaWYgKHNlbGYuX2VudGVyYWJsZSkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChzZWxmLl9oaWRlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgc2VsZi5fc2hvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9pbkNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBlbC5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICAgICAgICBpZiAoIXNlbGYuX2VudGVyYWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0cmlnZ2VyIHpyZW5kZXIgZXZlbnQgdG8gYXZvaWQgbW91c2VcbiAgICAgICAgICAgICAgICAvLyBpbiBhbmQgb3V0IHNoYXBlIHRvbyBmcmVxdWVudGx5XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB6ci5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIGV2ZW50VXRpbC5ub3JtYWxpemVFdmVudChjb250YWluZXIsIGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuZGlzcGF0Y2goJ21vdXNlbW92ZScsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlbC5vbm1vdXNlbGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fZW50ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3Nob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oaWRlTGF0ZXIoc2VsZi5faGlkZURlbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9pbkNvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBUb29sdGlwQ29udGVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFRvb2x0aXBDb250ZW50LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIF9lbnRlcmFibGU6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB3aGVuIHRvb2x0aXAgaXMgcmVuZGVyZWRcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIC8vIE1vdmUgdGhpcyBsb2dpYyB0byBlYyBtYWluP1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgICAgICAgIHZhciBzdGwgPSBjb250YWluZXIuY3VycmVudFN0eWxlXG4gICAgICAgICAgICAgICAgfHwgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgICAgICAgICAgdmFyIGRvbVN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xuICAgICAgICAgICAgaWYgKGRvbVN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHN0bC5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJykge1xuICAgICAgICAgICAgICAgIGRvbVN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhpZGUgdGhlIHRvb2x0aXBcbiAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgIC8vIHRoaXMuaGlkZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9oaWRlVGltZW91dCk7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gZ0Nzc1RleHQgKyBhc3NlbWJsZUNzc1RleHQodG9vbHRpcE1vZGVsKVxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjExMjU1ODcvY3NzMy10cmFuc2l0aW9uLW5vdC13b3JraW5nLWluLWNocm9tZS1hbnltb3JlXG4gICAgICAgICAgICAgICAgKyAnO2xlZnQ6JyArIHRoaXMuX3ggKyAncHg7dG9wOicgKyB0aGlzLl95ICsgJ3B4OydcbiAgICAgICAgICAgICAgICArICh0b29sdGlwTW9kZWwuZ2V0KCdleHRyYUNzc1RleHQnKSB8fCAnJyk7XG5cbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5pbm5lckhUTUwgPyAgJ2Jsb2NrJyA6ICdub25lJztcblxuICAgICAgICAgICAgdGhpcy5fc2hvdyA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gY29udGVudCA9PSBudWxsID8gJycgOiBjb250ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEVudGVyYWJsZTogZnVuY3Rpb24gKGVudGVyYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fZW50ZXJhYmxlID0gZW50ZXJhYmxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgICAgICAgICByZXR1cm4gW2VsLmNsaWVudFdpZHRoLCBlbC5jbGllbnRIZWlnaHRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1vdmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIC8vIHh5IHNob3VsZCBiZSBiYXNlZCBvbiBjYW52YXMgcm9vdC4gQnV0IHRvb2x0aXBDb250ZW50IGlzXG4gICAgICAgICAgICAvLyB0aGUgc2libGluZyBvZiBjYW52YXMgcm9vdC4gU28gcGFkZGluZyBvZiBlYyBjb250YWluZXJcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBjb25zaWRlcmVkIGhlcmUuXG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl96cjtcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydFJvb3Q7XG4gICAgICAgICAgICBpZiAoenIgJiYgenIucGFpbnRlciAmJiAodmlld3BvcnRSb290ID0genIucGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkpIHtcbiAgICAgICAgICAgICAgICB4ICs9IHZpZXdwb3J0Um9vdC5vZmZzZXRMZWZ0IHx8IDA7XG4gICAgICAgICAgICAgICAgeSArPSB2aWV3cG9ydFJvb3Qub2Zmc2V0VG9wIHx8IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZWwuc3R5bGU7XG4gICAgICAgICAgICBzdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICAgICAgICBzdHlsZS50b3AgPSB5ICsgJ3B4JztcblxuICAgICAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLl9zaG93ID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZUxhdGVyOiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3cgJiYgISh0aGlzLl9pbkNvbnRlbnQgJiYgdGhpcy5fZW50ZXJhYmxlKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVEZWxheSA9IHRpbWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBzaG93IGZhbHNlIHRvIGF2b2lkIGludm9rZSBoaWRlTGF0ZXIgbXV0aXBsZSB0aW1lc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVUaW1lb3V0ID0gc2V0VGltZW91dCh6clV0aWwuYmluZCh0aGlzLmhpZGUsIHRoaXMpLCB0aW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpc1Nob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaG93O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVG9vbHRpcENvbnRlbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcENvbnRlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("/**\n * Legend component entry file8\n */\n\n\n    __webpack_require__(147);\n    __webpack_require__(148);\n    __webpack_require__(149);\n\n    var echarts = __webpack_require__(17);\n    // Series Filter\n    echarts.registerProcessor(__webpack_require__(151));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQuanM/ZDg5MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTQ2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMZWdlbmQgY29tcG9uZW50IGVudHJ5IGZpbGU4XG4gKi9cblxuXG4gICAgcmVxdWlyZSgnLi9sZWdlbmQvTGVnZW5kTW9kZWwnKTtcbiAgICByZXF1aXJlKCcuL2xlZ2VuZC9sZWdlbmRBY3Rpb24nKTtcbiAgICByZXF1aXJlKCcuL2xlZ2VuZC9MZWdlbmRWaWV3Jyk7XG5cbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uL2VjaGFydHMnKTtcbiAgICAvLyBTZXJpZXMgRmlsdGVyXG4gICAgZWNoYXJ0cy5yZWdpc3RlclByb2Nlc3NvcihyZXF1aXJlKCcuL2xlZ2VuZC9sZWdlbmRGaWx0ZXInKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var zrUtil = __webpack_require__(20);\n    var Model = __webpack_require__(28);\n\n    var LegendModel = __webpack_require__(17).extendComponentModel({\n\n        type: 'legend',\n\n        dependencies: ['series'],\n\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n\n        init: function (option, parentModel, ecModel) {\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            option.selected = option.selected || {};\n        },\n\n        mergeOption: function (option) {\n            LegendModel.superCall(this, 'mergeOption', option);\n        },\n\n        optionUpdated: function () {\n            this._updateData(this.ecModel);\n\n            var legendData = this._data;\n\n            // If selectedMode is single, try to select one\n            if (legendData[0] && this.get('selectedMode') === 'single') {\n                var hasSelected = false;\n                // If has any selected in option.selected\n                for (var i = 0; i < legendData.length; i++) {\n                    var name = legendData[i].get('name');\n                    if (this.isSelected(name)) {\n                        // Force to unselect others\n                        this.select(name);\n                        hasSelected = true;\n                        break;\n                    }\n                }\n                // Try select the first if selectedMode is single\n                !hasSelected && this.select(legendData[0].get('name'));\n            }\n        },\n\n        _updateData: function (ecModel) {\n            var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n                // Can be string or number\n                if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n                    dataItem = {\n                        name: dataItem\n                    };\n                }\n                return new Model(dataItem, this, this.ecModel);\n            }, this);\n            this._data = legendData;\n\n            var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n                return series.name;\n            });\n            ecModel.eachSeries(function (seriesModel) {\n                if (seriesModel.legendDataProvider) {\n                    var data = seriesModel.legendDataProvider();\n                    availableNames = availableNames.concat(data.mapArray(data.getName));\n                }\n            });\n            /**\n             * @type {Array.<string>}\n             * @private\n             */\n            this._availableNames = availableNames;\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Model>}\n         */\n        getData: function () {\n            return this._data;\n        },\n\n        /**\n         * @param {string} name\n         */\n        select: function (name) {\n            var selected = this.option.selected;\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                var data = this._data;\n                zrUtil.each(data, function (dataItem) {\n                    selected[dataItem.get('name')] = false;\n                });\n            }\n            selected[name] = true;\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            if (this.get('selectedMode') !== 'single') {\n                this.option.selected[name] = false;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var selected = this.option.selected;\n            // Default is true\n            if (!selected.hasOwnProperty(name)) {\n                selected[name] = true;\n            }\n            this[selected[name] ? 'unSelect' : 'select'](name);\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var selected = this.option.selected;\n            return !(selected.hasOwnProperty(name) && !selected[name])\n                && zrUtil.indexOf(this._availableNames, name) >= 0;\n        },\n\n        defaultOption: {\n            // 一级层叠\n            zlevel: 0,\n            // 二级层叠\n            z: 4,\n            show: true,\n\n            // 布局方式，默认为水平布局，可选为：\n            // 'horizontal' | 'vertical'\n            orient: 'horizontal',\n\n            left: 'center',\n            // right: 'center',\n\n            top: 'top',\n            // bottom: 'top',\n\n            // 水平对齐\n            // 'auto' | 'left' | 'right'\n            // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐\n            align: 'auto',\n\n            backgroundColor: 'rgba(0,0,0,0)',\n            // 图例边框颜色\n            borderColor: '#ccc',\n            // 图例边框线宽，单位px，默认为0（无边框）\n            borderWidth: 0,\n            // 图例内边距，单位px，默认各方向内边距为5，\n            // 接受数组分别设定上右下左边距，同css\n            padding: 5,\n            // 各个item之间的间隔，单位px，默认为10，\n            // 横向布局时为水平间隔，纵向布局时为纵向间隔\n            itemGap: 10,\n            // 图例图形宽度\n            itemWidth: 25,\n            // 图例图形高度\n            itemHeight: 14,\n\n            // 图例关闭时候的颜色\n            inactiveColor: '#ccc',\n\n            textStyle: {\n                // 图例文字颜色\n                color: '#333'\n            },\n            // formatter: '',\n            // 选择模式，默认开启图例开关\n            selectedMode: true,\n            // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入\n            // selected: null,\n            // 图例内容（详见legend.data，数组中每一项代表一个item\n            // data: [],\n\n            // Tooltip 相关配置\n            tooltip: {\n                show: false\n            }\n        }\n    });\n\n    module.exports = LegendModel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kTW9kZWwuanM/YmJlNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwiLCJmaWxlIjoiMTQ3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvTW9kZWwnKTtcblxuICAgIHZhciBMZWdlbmRNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRDb21wb25lbnRNb2RlbCh7XG5cbiAgICAgICAgdHlwZTogJ2xlZ2VuZCcsXG5cbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbJ3NlcmllcyddLFxuXG4gICAgICAgIGxheW91dE1vZGU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdib3gnLFxuICAgICAgICAgICAgaWdub3JlU2l6ZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLm1lcmdlRGVmYXVsdEFuZFRoZW1lKG9wdGlvbiwgZWNNb2RlbCk7XG5cbiAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IG9wdGlvbi5zZWxlY3RlZCB8fCB7fTtcbiAgICAgICAgfSxcblxuICAgICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgTGVnZW5kTW9kZWwuc3VwZXJDYWxsKHRoaXMsICdtZXJnZU9wdGlvbicsIG9wdGlvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3B0aW9uVXBkYXRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGF0YSh0aGlzLmVjTW9kZWwpO1xuXG4gICAgICAgICAgICB2YXIgbGVnZW5kRGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgICAgIC8vIElmIHNlbGVjdGVkTW9kZSBpcyBzaW5nbGUsIHRyeSB0byBzZWxlY3Qgb25lXG4gICAgICAgICAgICBpZiAobGVnZW5kRGF0YVswXSAmJiB0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJykgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gSWYgaGFzIGFueSBzZWxlY3RlZCBpbiBvcHRpb24uc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZ2VuZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBsZWdlbmREYXRhW2ldLmdldCgnbmFtZScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGVkKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JjZSB0byB1bnNlbGVjdCBvdGhlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHNlbGVjdCB0aGUgZmlyc3QgaWYgc2VsZWN0ZWRNb2RlIGlzIHNpbmdsZVxuICAgICAgICAgICAgICAgICFoYXNTZWxlY3RlZCAmJiB0aGlzLnNlbGVjdChsZWdlbmREYXRhWzBdLmdldCgnbmFtZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlRGF0YTogZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBsZWdlbmREYXRhID0genJVdGlsLm1hcCh0aGlzLmdldCgnZGF0YScpIHx8IFtdLCBmdW5jdGlvbiAoZGF0YUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvLyBDYW4gYmUgc3RyaW5nIG9yIG51bWJlclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YUl0ZW0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkYXRhSXRlbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBkYXRhSXRlbVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1vZGVsKGRhdGFJdGVtLCB0aGlzLCB0aGlzLmVjTW9kZWwpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gbGVnZW5kRGF0YTtcblxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZU5hbWVzID0genJVdGlsLm1hcChlY01vZGVsLmdldFNlcmllcygpLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllcy5uYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcigpO1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVOYW1lcyA9IGF2YWlsYWJsZU5hbWVzLmNvbmNhdChkYXRhLm1hcEFycmF5KGRhdGEuZ2V0TmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9hdmFpbGFibGVOYW1lcyA9IGF2YWlsYWJsZU5hbWVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWw+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbi5zZWxlY3RlZDtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZE1vZGUgPSB0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJyk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRNb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChkYXRhLCBmdW5jdGlvbiAoZGF0YUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRbZGF0YUl0ZW0uZ2V0KCduYW1lJyldID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3RlZFtuYW1lXSA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICB1blNlbGVjdDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJykgIT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb24uc2VsZWN0ZWRbbmFtZV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIHRvZ2dsZVNlbGVjdGVkOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gdGhpcy5vcHRpb24uc2VsZWN0ZWQ7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGlzIHRydWVcbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW3NlbGVjdGVkW25hbWVdID8gJ3VuU2VsZWN0JyA6ICdzZWxlY3QnXShuYW1lKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbi5zZWxlY3RlZDtcbiAgICAgICAgICAgIHJldHVybiAhKHNlbGVjdGVkLmhhc093blByb3BlcnR5KG5hbWUpICYmICFzZWxlY3RlZFtuYW1lXSlcbiAgICAgICAgICAgICAgICAmJiB6clV0aWwuaW5kZXhPZih0aGlzLl9hdmFpbGFibGVOYW1lcywgbmFtZSkgPj0gMDtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICAvLyDkuIDnuqflsYLlj6BcbiAgICAgICAgICAgIHpsZXZlbDogMCxcbiAgICAgICAgICAgIC8vIOS6jOe6p+WxguWPoFxuICAgICAgICAgICAgejogNCxcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG5cbiAgICAgICAgICAgIC8vIOW4g+WxgOaWueW8j++8jOm7mOiupOS4uuawtOW5s+W4g+WxgO+8jOWPr+mAieS4uu+8mlxuICAgICAgICAgICAgLy8gJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJ1xuICAgICAgICAgICAgb3JpZW50OiAnaG9yaXpvbnRhbCcsXG5cbiAgICAgICAgICAgIGxlZnQ6ICdjZW50ZXInLFxuICAgICAgICAgICAgLy8gcmlnaHQ6ICdjZW50ZXInLFxuXG4gICAgICAgICAgICB0b3A6ICd0b3AnLFxuICAgICAgICAgICAgLy8gYm90dG9tOiAndG9wJyxcblxuICAgICAgICAgICAgLy8g5rC05bmz5a+56b2QXG4gICAgICAgICAgICAvLyAnYXV0bycgfCAnbGVmdCcgfCAncmlnaHQnXG4gICAgICAgICAgICAvLyDpu5jorqTkuLogJ2F1dG8nLCDmoLnmja4geCDnmoTkvY3nva7liKTmlq3mmK/lt6blr7npvZDov5jmmK/lj7Plr7npvZBcbiAgICAgICAgICAgIGFsaWduOiAnYXV0bycsXG5cbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgICAgICAgICAgLy8g5Zu+5L6L6L655qGG6aKc6ImyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyNjY2MnLFxuICAgICAgICAgICAgLy8g5Zu+5L6L6L655qGG57q/5a6977yM5Y2V5L2NcHjvvIzpu5jorqTkuLow77yI5peg6L655qGG77yJXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgICAgICAgIC8vIOWbvuS+i+WGhei+uei3ne+8jOWNleS9jXB477yM6buY6K6k5ZCE5pa55ZCR5YaF6L656Led5Li6Ne+8jFxuICAgICAgICAgICAgLy8g5o6l5Y+X5pWw57uE5YiG5Yir6K6+5a6a5LiK5Y+z5LiL5bem6L656Led77yM5ZCMY3NzXG4gICAgICAgICAgICBwYWRkaW5nOiA1LFxuICAgICAgICAgICAgLy8g5ZCE5LiqaXRlbeS5i+mXtOeahOmXtOmalO+8jOWNleS9jXB477yM6buY6K6k5Li6MTDvvIxcbiAgICAgICAgICAgIC8vIOaoquWQkeW4g+WxgOaXtuS4uuawtOW5s+mXtOmalO+8jOe6teWQkeW4g+WxgOaXtuS4uue6teWQkemXtOmalFxuICAgICAgICAgICAgaXRlbUdhcDogMTAsXG4gICAgICAgICAgICAvLyDlm77kvovlm77lvaLlrr3luqZcbiAgICAgICAgICAgIGl0ZW1XaWR0aDogMjUsXG4gICAgICAgICAgICAvLyDlm77kvovlm77lvaLpq5jluqZcbiAgICAgICAgICAgIGl0ZW1IZWlnaHQ6IDE0LFxuXG4gICAgICAgICAgICAvLyDlm77kvovlhbPpl63ml7blgJnnmoTpopzoibJcbiAgICAgICAgICAgIGluYWN0aXZlQ29sb3I6ICcjY2NjJyxcblxuICAgICAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgLy8g5Zu+5L6L5paH5a2X6aKc6ImyXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMzMzJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGZvcm1hdHRlcjogJycsXG4gICAgICAgICAgICAvLyDpgInmi6nmqKHlvI/vvIzpu5jorqTlvIDlkK/lm77kvovlvIDlhbNcbiAgICAgICAgICAgIHNlbGVjdGVkTW9kZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIOmFjee9rum7mOiupOmAieS4reeKtuaAge+8jOWPr+mFjeWQiExFR0VORC5TRUxFQ1RFROS6i+S7tuWBmuWKqOaAgeaVsOaNrui9veWFpVxuICAgICAgICAgICAgLy8gc2VsZWN0ZWQ6IG51bGwsXG4gICAgICAgICAgICAvLyDlm77kvovlhoXlrrnvvIjor6bop4FsZWdlbmQuZGF0Ye+8jOaVsOe7hOS4reavj+S4gOmhueS7o+ihqOS4gOS4qml0ZW1cbiAgICAgICAgICAgIC8vIGRhdGE6IFtdLFxuXG4gICAgICAgICAgICAvLyBUb29sdGlwIOebuOWFs+mFjee9rlxuICAgICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gTGVnZW5kTW9kZWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9MZWdlbmRNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("/**\n * @file Legend action\n */\n\n\n    var echarts = __webpack_require__(17);\n    var zrUtil = __webpack_require__(20);\n\n    function legendSelectActionHandler(methodName, payload, ecModel) {\n        var selectedMap = {};\n        var isToggleSelect = methodName === 'toggleSelected';\n        var isSelected;\n        // Update all legend components\n        ecModel.eachComponent('legend', function (legendModel) {\n            if (isToggleSelect && isSelected != null) {\n                // Force other legend has same selected status\n                // Or the first is toggled to true and other are toggled to false\n                // In the case one legend has some item unSelected in option. And if other legend\n                // doesn't has the item, they will assume it is selected.\n                legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n            }\n            else {\n                legendModel[methodName](payload.name);\n                isSelected = legendModel.isSelected(payload.name);\n            }\n            var legendData = legendModel.getData();\n            zrUtil.each(legendData, function (model) {\n                var name = model.get('name');\n                // Wrap element\n                if (name === '\\n' || name === '') {\n                    return;\n                }\n                var isItemSelected = legendModel.isSelected(name);\n                if (selectedMap.hasOwnProperty(name)) {\n                    // Unselected if any legend is unselected\n                    selectedMap[name] = selectedMap[name] && isItemSelected;\n                }\n                else {\n                    selectedMap[name] = isItemSelected;\n                }\n            });\n        });\n        // Return the event explicitly\n        return {\n            name: payload.name,\n            selected: selectedMap\n        };\n    }\n    /**\n     * @event legendToggleSelect\n     * @type {Object}\n     * @property {string} type 'legendToggleSelect'\n     * @property {string} [from]\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendToggleSelect', 'legendselectchanged',\n        zrUtil.curry(legendSelectActionHandler, 'toggleSelected')\n    );\n\n    /**\n     * @event legendSelect\n     * @type {Object}\n     * @property {string} type 'legendSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendSelect', 'legendselected',\n        zrUtil.curry(legendSelectActionHandler, 'select')\n    );\n\n    /**\n     * @event legendUnSelect\n     * @type {Object}\n     * @property {string} type 'legendUnSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendUnSelect', 'legendunselected',\n        zrUtil.curry(legendSelectActionHandler, 'unSelect')\n    );\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kQWN0aW9uLmpzP2I3YTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE0OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgTGVnZW5kIGFjdGlvblxuICovXG5cblxuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIGZ1bmN0aW9uIGxlZ2VuZFNlbGVjdEFjdGlvbkhhbmRsZXIobWV0aG9kTmFtZSwgcGF5bG9hZCwgZWNNb2RlbCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRNYXAgPSB7fTtcbiAgICAgICAgdmFyIGlzVG9nZ2xlU2VsZWN0ID0gbWV0aG9kTmFtZSA9PT0gJ3RvZ2dsZVNlbGVjdGVkJztcbiAgICAgICAgdmFyIGlzU2VsZWN0ZWQ7XG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgbGVnZW5kIGNvbXBvbmVudHNcbiAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdsZWdlbmQnLCBmdW5jdGlvbiAobGVnZW5kTW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChpc1RvZ2dsZVNlbGVjdCAmJiBpc1NlbGVjdGVkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBvdGhlciBsZWdlbmQgaGFzIHNhbWUgc2VsZWN0ZWQgc3RhdHVzXG4gICAgICAgICAgICAgICAgLy8gT3IgdGhlIGZpcnN0IGlzIHRvZ2dsZWQgdG8gdHJ1ZSBhbmQgb3RoZXIgYXJlIHRvZ2dsZWQgdG8gZmFsc2VcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvbmUgbGVnZW5kIGhhcyBzb21lIGl0ZW0gdW5TZWxlY3RlZCBpbiBvcHRpb24uIEFuZCBpZiBvdGhlciBsZWdlbmRcbiAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IGhhcyB0aGUgaXRlbSwgdGhleSB3aWxsIGFzc3VtZSBpdCBpcyBzZWxlY3RlZC5cbiAgICAgICAgICAgICAgICBsZWdlbmRNb2RlbFtpc1NlbGVjdGVkID8gJ3NlbGVjdCcgOiAndW5TZWxlY3QnXShwYXlsb2FkLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGVnZW5kTW9kZWxbbWV0aG9kTmFtZV0ocGF5bG9hZC5uYW1lKTtcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGVkID0gbGVnZW5kTW9kZWwuaXNTZWxlY3RlZChwYXlsb2FkLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlZ2VuZERhdGEgPSBsZWdlbmRNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChsZWdlbmREYXRhLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG1vZGVsLmdldCgnbmFtZScpO1xuICAgICAgICAgICAgICAgIC8vIFdyYXAgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnXFxuJyB8fCBuYW1lID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpc0l0ZW1TZWxlY3RlZCA9IGxlZ2VuZE1vZGVsLmlzU2VsZWN0ZWQobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkTWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuc2VsZWN0ZWQgaWYgYW55IGxlZ2VuZCBpcyB1bnNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkTWFwW25hbWVdID0gc2VsZWN0ZWRNYXBbbmFtZV0gJiYgaXNJdGVtU2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE1hcFtuYW1lXSA9IGlzSXRlbVNlbGVjdGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBldmVudCBleHBsaWNpdGx5XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBwYXlsb2FkLm5hbWUsXG4gICAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRNYXBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGV2ZW50IGxlZ2VuZFRvZ2dsZVNlbGVjdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgJ2xlZ2VuZFRvZ2dsZVNlbGVjdCdcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2Zyb21dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgU2VyaWVzIG5hbWUgb3IgZGF0YSBpdGVtIG5hbWVcbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKFxuICAgICAgICAnbGVnZW5kVG9nZ2xlU2VsZWN0JywgJ2xlZ2VuZHNlbGVjdGNoYW5nZWQnLFxuICAgICAgICB6clV0aWwuY3VycnkobGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlciwgJ3RvZ2dsZVNlbGVjdGVkJylcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IGxlZ2VuZFNlbGVjdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgJ2xlZ2VuZFNlbGVjdCdcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBTZXJpZXMgbmFtZSBvciBkYXRhIGl0ZW0gbmFtZVxuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJBY3Rpb24oXG4gICAgICAgICdsZWdlbmRTZWxlY3QnLCAnbGVnZW5kc2VsZWN0ZWQnLFxuICAgICAgICB6clV0aWwuY3VycnkobGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlciwgJ3NlbGVjdCcpXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBsZWdlbmRVblNlbGVjdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgJ2xlZ2VuZFVuU2VsZWN0J1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIFNlcmllcyBuYW1lIG9yIGRhdGEgaXRlbSBuYW1lXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlckFjdGlvbihcbiAgICAgICAgJ2xlZ2VuZFVuU2VsZWN0JywgJ2xlZ2VuZHVuc2VsZWN0ZWQnLFxuICAgICAgICB6clV0aWwuY3VycnkobGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlciwgJ3VuU2VsZWN0JylcbiAgICApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n    var symbolCreator = __webpack_require__(127);\n    var graphic = __webpack_require__(34);\n    var listComponentHelper = __webpack_require__(150);\n\n    var curry = zrUtil.curry;\n\n    function dispatchSelectAction(name, api) {\n        api.dispatchAction({\n            type: 'legendToggleSelect',\n            name: name\n        });\n    }\n\n    function dispatchHighlightAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'highlight',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    function dispatchDownplayAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'downplay',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    module.exports = __webpack_require__(17).extendComponentView({\n\n        type: 'legend',\n\n        init: function () {\n            this._symbolTypeStore = {};\n        },\n\n        render: function (legendModel, ecModel, api) {\n            var group = this.group;\n            group.removeAll();\n\n            if (!legendModel.get('show')) {\n                return;\n            }\n\n            var selectMode = legendModel.get('selectedMode');\n            var itemAlign = legendModel.get('align');\n\n            if (itemAlign === 'auto') {\n                itemAlign = (legendModel.get('left') === 'right'\n                    && legendModel.get('orient') === 'vertical')\n                    ? 'right' : 'left';\n            }\n\n            var legendDrawedMap = zrUtil.createHashMap();\n\n            zrUtil.each(legendModel.getData(), function (itemModel) {\n                var name = itemModel.get('name');\n\n                // Use empty string or \\n as a newline string\n                if (name === '' || name === '\\n') {\n                    group.add(new graphic.Group({\n                        newline: true\n                    }));\n                    return;\n                }\n\n                var seriesModel = ecModel.getSeriesByName(name)[0];\n\n                if (legendDrawedMap.get(name)) {\n                    // Have been drawed\n                    return;\n                }\n\n                // Series legend\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var color = data.getVisual('color');\n\n                    // If color is a callback function\n                    if (typeof color === 'function') {\n                        // Use the first data\n                        color = color(seriesModel.getDataParams(0));\n                    }\n\n                    // Using rect symbol defaultly\n                    var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n                    var symbolType = data.getVisual('symbol');\n\n                    var itemGroup = this._createItem(\n                        name, itemModel, legendModel,\n                        legendSymbolType, symbolType,\n                        itemAlign, color,\n                        selectMode\n                    );\n\n                    itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                        .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api))\n                        .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n\n                    legendDrawedMap.set(name, true);\n                }\n                else {\n                    // Data legend of pie, funnel\n                    ecModel.eachRawSeries(function (seriesModel) {\n                        // In case multiple series has same data name\n                        if (legendDrawedMap.get(name)) {\n                            return;\n                        }\n                        if (seriesModel.legendDataProvider) {\n                            var data = seriesModel.legendDataProvider();\n                            var idx = data.indexOfName(name);\n                            if (idx < 0) {\n                                return;\n                            }\n\n                            var color = data.getItemVisual(idx, 'color');\n\n                            var legendSymbolType = 'roundRect';\n\n                            var itemGroup = this._createItem(\n                                name, itemModel, legendModel,\n                                legendSymbolType, null,\n                                itemAlign, color,\n                                selectMode\n                            );\n\n                            itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                                // FIXME Should not specify the series name\n                                .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api))\n                                .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n\n                            legendDrawedMap.set(name, true);\n                        }\n                    }, this);\n                }\n\n                if (__DEV__) {\n                    if (!legendDrawedMap.get(name)) {\n                        console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n                    }\n                }\n            }, this);\n\n            listComponentHelper.layout(group, legendModel, api);\n            // Render background after group is layout\n            // FIXME\n            listComponentHelper.addBackground(group, legendModel);\n        },\n\n        _createItem: function (\n            name, itemModel, legendModel,\n            legendSymbolType, symbolType,\n            itemAlign, color, selectMode\n        ) {\n            var itemWidth = legendModel.get('itemWidth');\n            var itemHeight = legendModel.get('itemHeight');\n            var inactiveColor = legendModel.get('inactiveColor');\n\n            var isSelected = legendModel.isSelected(name);\n            var itemGroup = new graphic.Group();\n\n            var textStyleModel = itemModel.getModel('textStyle');\n\n            var itemIcon = itemModel.get('icon');\n\n            var tooltipModel = itemModel.getModel('tooltip');\n            var legendGlobalTooltipModel = tooltipModel.parentModel;\n\n            // Use user given icon first\n            legendSymbolType = itemIcon || legendSymbolType;\n            itemGroup.add(symbolCreator.createSymbol(\n                legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor\n            ));\n\n            // Compose symbols\n            // PENDING\n            if (!itemIcon && symbolType\n                // At least show one symbol, can't be all none\n                && ((symbolType !== legendSymbolType) || symbolType == 'none')\n            ) {\n                var size = itemHeight * 0.8;\n                if (symbolType === 'none') {\n                    symbolType = 'circle';\n                }\n                // Put symbol in the center\n                itemGroup.add(symbolCreator.createSymbol(\n                    symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n                    isSelected ? color : inactiveColor\n                ));\n            }\n\n            // Text\n            var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n            var textAlign = itemAlign;\n\n            var formatter = legendModel.get('formatter');\n            var content = name;\n            if (typeof formatter === 'string' && formatter) {\n                content = formatter.replace('{name}', name != null ? name : '');\n            }\n            else if (typeof formatter === 'function') {\n                content = formatter(name);\n            }\n\n            var text = new graphic.Text({\n                style: {\n                    text: content,\n                    x: textX,\n                    y: itemHeight / 2,\n                    fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n                    textFont: textStyleModel.getFont(),\n                    textAlign: textAlign,\n                    textVerticalAlign: 'middle'\n                }\n            });\n            itemGroup.add(text);\n\n            // Add a invisible rect to increase the area of mouse hover\n            var hitRect = new graphic.Rect({\n                shape: itemGroup.getBoundingRect(),\n                invisible: true,\n                tooltip: tooltipModel.get('show') ? zrUtil.extend({\n                    content: name,\n                    // Defaul formatter\n                    formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n                        return name;\n                    },\n                    formatterParams: {\n                        componentType: 'legend',\n                        legendIndex: legendModel.componentIndex,\n                        name: name,\n                        $vars: ['name']\n                    }\n                }, tooltipModel.option) : null\n            });\n            itemGroup.add(hitRect);\n\n            itemGroup.eachChild(function (child) {\n                child.silent = true;\n            });\n\n            hitRect.silent = !selectMode;\n\n\n\n            this.group.add(itemGroup);\n\n            graphic.setHoverStyle(itemGroup);\n\n            return itemGroup;\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kVmlldy5qcz8xMjRmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxLQUFLO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiMTQ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIHN5bWJvbENyZWF0b3IgPSByZXF1aXJlKCcuLi8uLi91dGlsL3N5bWJvbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIGxpc3RDb21wb25lbnRIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvbGlzdENvbXBvbmVudCcpO1xuXG4gICAgdmFyIGN1cnJ5ID0genJVdGlsLmN1cnJ5O1xuXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hTZWxlY3RBY3Rpb24obmFtZSwgYXBpKSB7XG4gICAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICB0eXBlOiAnbGVnZW5kVG9nZ2xlU2VsZWN0JyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hIaWdobGlnaHRBY3Rpb24oc2VyaWVzTW9kZWwsIGRhdGFOYW1lLCBhcGkpIHtcbiAgICAgICAgLy8gSWYgZWxlbWVudCBob3ZlciB3aWxsIG1vdmUgdG8gYSBob3ZlckxheWVyLlxuICAgICAgICB2YXIgZWwgPSBhcGkuZ2V0WnIoKS5zdG9yYWdlLmdldERpc3BsYXlMaXN0KClbMF07XG4gICAgICAgIGlmICghKGVsICYmIGVsLnVzZUhvdmVyTGF5ZXIpKSB7XG4gICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXQoJ2xlZ2VuZEhvdmVyTGluaycpICYmIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hpZ2hsaWdodCcsXG4gICAgICAgICAgICAgICAgc2VyaWVzTmFtZTogc2VyaWVzTW9kZWwubmFtZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBkYXRhTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXNwYXRjaERvd25wbGF5QWN0aW9uKHNlcmllc01vZGVsLCBkYXRhTmFtZSwgYXBpKSB7XG4gICAgICAgIC8vIElmIGVsZW1lbnQgaG92ZXIgd2lsbCBtb3ZlIHRvIGEgaG92ZXJMYXllci5cbiAgICAgICAgdmFyIGVsID0gYXBpLmdldFpyKCkuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpWzBdO1xuICAgICAgICBpZiAoIShlbCAmJiBlbC51c2VIb3ZlckxheWVyKSkge1xuICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCdsZWdlbmRIb3ZlckxpbmsnKSAmJiBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkb3ducGxheScsXG4gICAgICAgICAgICAgICAgc2VyaWVzTmFtZTogc2VyaWVzTW9kZWwubmFtZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBkYXRhTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRDb21wb25lbnRWaWV3KHtcblxuICAgICAgICB0eXBlOiAnbGVnZW5kJyxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9zeW1ib2xUeXBlU3RvcmUgPSB7fTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChsZWdlbmRNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICAgICAgZ3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgICAgIGlmICghbGVnZW5kTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZWxlY3RNb2RlID0gbGVnZW5kTW9kZWwuZ2V0KCdzZWxlY3RlZE1vZGUnKTtcbiAgICAgICAgICAgIHZhciBpdGVtQWxpZ24gPSBsZWdlbmRNb2RlbC5nZXQoJ2FsaWduJyk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtQWxpZ24gPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgIGl0ZW1BbGlnbiA9IChsZWdlbmRNb2RlbC5nZXQoJ2xlZnQnKSA9PT0gJ3JpZ2h0J1xuICAgICAgICAgICAgICAgICAgICAmJiBsZWdlbmRNb2RlbC5nZXQoJ29yaWVudCcpID09PSAndmVydGljYWwnKVxuICAgICAgICAgICAgICAgICAgICA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsZWdlbmREcmF3ZWRNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuXG4gICAgICAgICAgICB6clV0aWwuZWFjaChsZWdlbmRNb2RlbC5nZXREYXRhKCksIGZ1bmN0aW9uIChpdGVtTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGl0ZW1Nb2RlbC5nZXQoJ25hbWUnKTtcblxuICAgICAgICAgICAgICAgIC8vIFVzZSBlbXB0eSBzdHJpbmcgb3IgXFxuIGFzIGEgbmV3bGluZSBzdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJycgfHwgbmFtZSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKG5ldyBncmFwaGljLkdyb3VwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld2xpbmU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeU5hbWUobmFtZSlbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAobGVnZW5kRHJhd2VkTWFwLmdldChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYXZlIGJlZW4gZHJhd2VkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZXJpZXMgbGVnZW5kXG4gICAgICAgICAgICAgICAgaWYgKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBkYXRhLmdldFZpc3VhbCgnY29sb3InKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjb2xvciBpcyBhIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZmlyc3QgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBjb2xvcihzZXJpZXNNb2RlbC5nZXREYXRhUGFyYW1zKDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzaW5nIHJlY3Qgc3ltYm9sIGRlZmF1bHRseVxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVnZW5kU3ltYm9sVHlwZSA9IGRhdGEuZ2V0VmlzdWFsKCdsZWdlbmRTeW1ib2wnKSB8fCAncm91bmRSZWN0JztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBkYXRhLmdldFZpc3VhbCgnc3ltYm9sJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Hcm91cCA9IHRoaXMuX2NyZWF0ZUl0ZW0oXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLCBpdGVtTW9kZWwsIGxlZ2VuZE1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVnZW5kU3ltYm9sVHlwZSwgc3ltYm9sVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1BbGlnbiwgY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RNb2RlXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbUdyb3VwLm9uKCdjbGljaycsIGN1cnJ5KGRpc3BhdGNoU2VsZWN0QWN0aW9uLCBuYW1lLCBhcGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBjdXJyeShkaXNwYXRjaEhpZ2hsaWdodEFjdGlvbiwgc2VyaWVzTW9kZWwsIG51bGwsIGFwaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgY3VycnkoZGlzcGF0Y2hEb3ducGxheUFjdGlvbiwgc2VyaWVzTW9kZWwsIG51bGwsIGFwaSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZERyYXdlZE1hcC5zZXQobmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBEYXRhIGxlZ2VuZCBvZiBwaWUsIGZ1bm5lbFxuICAgICAgICAgICAgICAgICAgICBlY01vZGVsLmVhY2hSYXdTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIG11bHRpcGxlIHNlcmllcyBoYXMgc2FtZSBkYXRhIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWdlbmREcmF3ZWRNYXAuZ2V0KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwubGVnZW5kRGF0YVByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IGRhdGEuaW5kZXhPZk5hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZ2VuZFN5bWJvbFR5cGUgPSAncm91bmRSZWN0JztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtR3JvdXAgPSB0aGlzLl9jcmVhdGVJdGVtKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLCBpdGVtTW9kZWwsIGxlZ2VuZE1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmRTeW1ib2xUeXBlLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQWxpZ24sIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RNb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Hcm91cC5vbignY2xpY2snLCBjdXJyeShkaXNwYXRjaFNlbGVjdEFjdGlvbiwgbmFtZSwgYXBpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgU2hvdWxkIG5vdCBzcGVjaWZ5IHRoZSBzZXJpZXMgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGN1cnJ5KGRpc3BhdGNoSGlnaGxpZ2h0QWN0aW9uLCBzZXJpZXNNb2RlbCwgbmFtZSwgYXBpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGN1cnJ5KGRpc3BhdGNoRG93bnBsYXlBY3Rpb24sIHNlcmllc01vZGVsLCBuYW1lLCBhcGkpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2VuZERyYXdlZE1hcC5zZXQobmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVnZW5kRHJhd2VkTWFwLmdldChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG5hbWUgKyAnIHNlcmllcyBub3QgZXhpc3RzLiBMZWdlbmQgZGF0YSBzaG91bGQgYmUgc2FtZSB3aXRoIHNlcmllcyBuYW1lIG9yIGRhdGEgbmFtZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBsaXN0Q29tcG9uZW50SGVscGVyLmxheW91dChncm91cCwgbGVnZW5kTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICAvLyBSZW5kZXIgYmFja2dyb3VuZCBhZnRlciBncm91cCBpcyBsYXlvdXRcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBsaXN0Q29tcG9uZW50SGVscGVyLmFkZEJhY2tncm91bmQoZ3JvdXAsIGxlZ2VuZE1vZGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfY3JlYXRlSXRlbTogZnVuY3Rpb24gKFxuICAgICAgICAgICAgbmFtZSwgaXRlbU1vZGVsLCBsZWdlbmRNb2RlbCxcbiAgICAgICAgICAgIGxlZ2VuZFN5bWJvbFR5cGUsIHN5bWJvbFR5cGUsXG4gICAgICAgICAgICBpdGVtQWxpZ24sIGNvbG9yLCBzZWxlY3RNb2RlXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGl0ZW1XaWR0aCA9IGxlZ2VuZE1vZGVsLmdldCgnaXRlbVdpZHRoJyk7XG4gICAgICAgICAgICB2YXIgaXRlbUhlaWdodCA9IGxlZ2VuZE1vZGVsLmdldCgnaXRlbUhlaWdodCcpO1xuICAgICAgICAgICAgdmFyIGluYWN0aXZlQ29sb3IgPSBsZWdlbmRNb2RlbC5nZXQoJ2luYWN0aXZlQ29sb3InKTtcblxuICAgICAgICAgICAgdmFyIGlzU2VsZWN0ZWQgPSBsZWdlbmRNb2RlbC5pc1NlbGVjdGVkKG5hbWUpO1xuICAgICAgICAgICAgdmFyIGl0ZW1Hcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG5cbiAgICAgICAgICAgIHZhciBpdGVtSWNvbiA9IGl0ZW1Nb2RlbC5nZXQoJ2ljb24nKTtcblxuICAgICAgICAgICAgdmFyIHRvb2x0aXBNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgndG9vbHRpcCcpO1xuICAgICAgICAgICAgdmFyIGxlZ2VuZEdsb2JhbFRvb2x0aXBNb2RlbCA9IHRvb2x0aXBNb2RlbC5wYXJlbnRNb2RlbDtcblxuICAgICAgICAgICAgLy8gVXNlIHVzZXIgZ2l2ZW4gaWNvbiBmaXJzdFxuICAgICAgICAgICAgbGVnZW5kU3ltYm9sVHlwZSA9IGl0ZW1JY29uIHx8IGxlZ2VuZFN5bWJvbFR5cGU7XG4gICAgICAgICAgICBpdGVtR3JvdXAuYWRkKHN5bWJvbENyZWF0b3IuY3JlYXRlU3ltYm9sKFxuICAgICAgICAgICAgICAgIGxlZ2VuZFN5bWJvbFR5cGUsIDAsIDAsIGl0ZW1XaWR0aCwgaXRlbUhlaWdodCwgaXNTZWxlY3RlZCA/IGNvbG9yIDogaW5hY3RpdmVDb2xvclxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIC8vIENvbXBvc2Ugc3ltYm9sc1xuICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgaWYgKCFpdGVtSWNvbiAmJiBzeW1ib2xUeXBlXG4gICAgICAgICAgICAgICAgLy8gQXQgbGVhc3Qgc2hvdyBvbmUgc3ltYm9sLCBjYW4ndCBiZSBhbGwgbm9uZVxuICAgICAgICAgICAgICAgICYmICgoc3ltYm9sVHlwZSAhPT0gbGVnZW5kU3ltYm9sVHlwZSkgfHwgc3ltYm9sVHlwZSA9PSAnbm9uZScpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGl0ZW1IZWlnaHQgKiAwLjg7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbFR5cGUgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xUeXBlID0gJ2NpcmNsZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFB1dCBzeW1ib2wgaW4gdGhlIGNlbnRlclxuICAgICAgICAgICAgICAgIGl0ZW1Hcm91cC5hZGQoc3ltYm9sQ3JlYXRvci5jcmVhdGVTeW1ib2woXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFR5cGUsIChpdGVtV2lkdGggLSBzaXplKSAvIDIsIChpdGVtSGVpZ2h0IC0gc2l6ZSkgLyAyLCBzaXplLCBzaXplLFxuICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGVkID8gY29sb3IgOiBpbmFjdGl2ZUNvbG9yXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRleHRcbiAgICAgICAgICAgIHZhciB0ZXh0WCA9IGl0ZW1BbGlnbiA9PT0gJ2xlZnQnID8gaXRlbVdpZHRoICsgNSA6IC01O1xuICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IGl0ZW1BbGlnbjtcblxuICAgICAgICAgICAgdmFyIGZvcm1hdHRlciA9IGxlZ2VuZE1vZGVsLmdldCgnZm9ybWF0dGVyJyk7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IG5hbWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycgJiYgZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IGZvcm1hdHRlci5yZXBsYWNlKCd7bmFtZX0nLCBuYW1lICE9IG51bGwgPyBuYW1lIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBmb3JtYXR0ZXIobmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgeDogdGV4dFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGl0ZW1IZWlnaHQgLyAyLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBpc1NlbGVjdGVkID8gdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCkgOiBpbmFjdGl2ZUNvbG9yLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdGVtR3JvdXAuYWRkKHRleHQpO1xuXG4gICAgICAgICAgICAvLyBBZGQgYSBpbnZpc2libGUgcmVjdCB0byBpbmNyZWFzZSB0aGUgYXJlYSBvZiBtb3VzZSBob3ZlclxuICAgICAgICAgICAgdmFyIGhpdFJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgICAgICBzaGFwZTogaXRlbUdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLFxuICAgICAgICAgICAgICAgIGludmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiB0b29sdGlwTW9kZWwuZ2V0KCdzaG93JykgPyB6clV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsIGZvcm1hdHRlclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGxlZ2VuZEdsb2JhbFRvb2x0aXBNb2RlbC5nZXQoJ2Zvcm1hdHRlcicsIHRydWUpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXJQYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6ICdsZWdlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVnZW5kSW5kZXg6IGxlZ2VuZE1vZGVsLmNvbXBvbmVudEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICR2YXJzOiBbJ25hbWUnXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdG9vbHRpcE1vZGVsLm9wdGlvbikgOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0ZW1Hcm91cC5hZGQoaGl0UmVjdCk7XG5cbiAgICAgICAgICAgIGl0ZW1Hcm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBoaXRSZWN0LnNpbGVudCA9ICFzZWxlY3RNb2RlO1xuXG5cblxuICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoaXRlbUdyb3VwKTtcblxuICAgICAgICAgICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKGl0ZW1Hcm91cCk7XG5cbiAgICAgICAgICAgIHJldHVybiBpdGVtR3JvdXA7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL0xlZ2VuZFZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("\n    // List layout\n    var layout = __webpack_require__(87);\n    var formatUtil = __webpack_require__(22);\n    var graphic = __webpack_require__(34);\n\n    function positionGroup(group, model, api) {\n        layout.positionElement(\n            group, model.getBoxLayoutParams(),\n            {\n                width: api.getWidth(),\n                height: api.getHeight()\n            },\n            model.get('padding')\n        );\n    }\n\n    module.exports = {\n        /**\n         * Layout list like component.\n         * It will box layout each items in group of component and then position the whole group in the viewport\n         * @param {module:zrender/group/Group} group\n         * @param {module:echarts/model/Component} componentModel\n         * @param {module:echarts/ExtensionAPI}\n         */\n        layout: function (group, componentModel, api) {\n            var rect = layout.getLayoutRect(componentModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }, componentModel.get('padding'));\n            layout.box(\n                componentModel.get('orient'),\n                group,\n                componentModel.get('itemGap'),\n                rect.width,\n                rect.height\n            );\n\n            positionGroup(group, componentModel, api);\n        },\n\n        addBackground: function (group, componentModel) {\n            var padding = formatUtil.normalizeCssArray(\n                componentModel.get('padding')\n            );\n            var boundingRect = group.getBoundingRect();\n            var style = componentModel.getItemStyle(['color', 'opacity']);\n            style.fill = componentModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: boundingRect.x - padding[3],\n                    y: boundingRect.y - padding[0],\n                    width: boundingRect.width + padding[1] + padding[3],\n                    height: boundingRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true,\n                z2: -1\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvbGlzdENvbXBvbmVudC5qcz81NjZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QyxtQkFBbUIsK0JBQStCO0FBQ2xELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjE1MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuICAgIC8vIExpc3QgbGF5b3V0XG4gICAgdmFyIGxheW91dCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbGF5b3V0Jyk7XG4gICAgdmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2Zvcm1hdCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG5cbiAgICBmdW5jdGlvbiBwb3NpdGlvbkdyb3VwKGdyb3VwLCBtb2RlbCwgYXBpKSB7XG4gICAgICAgIGxheW91dC5wb3NpdGlvbkVsZW1lbnQoXG4gICAgICAgICAgICBncm91cCwgbW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW9kZWwuZ2V0KCdwYWRkaW5nJylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExheW91dCBsaXN0IGxpa2UgY29tcG9uZW50LlxuICAgICAgICAgKiBJdCB3aWxsIGJveCBsYXlvdXQgZWFjaCBpdGVtcyBpbiBncm91cCBvZiBjb21wb25lbnQgYW5kIHRoZW4gcG9zaXRpb24gdGhlIHdob2xlIGdyb3VwIGluIHRoZSB2aWV3cG9ydFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyb3VwL0dyb3VwfSBncm91cFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gY29tcG9uZW50TW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9XG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IGZ1bmN0aW9uIChncm91cCwgY29tcG9uZW50TW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBsYXlvdXQuZ2V0TGF5b3V0UmVjdChjb21wb25lbnRNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKSwge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgICAgICAgICAgfSwgY29tcG9uZW50TW9kZWwuZ2V0KCdwYWRkaW5nJykpO1xuICAgICAgICAgICAgbGF5b3V0LmJveChcbiAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5nZXQoJ29yaWVudCcpLFxuICAgICAgICAgICAgICAgIGdyb3VwLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLmdldCgnaXRlbUdhcCcpLFxuICAgICAgICAgICAgICAgIHJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgcmVjdC5oZWlnaHRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uR3JvdXAoZ3JvdXAsIGNvbXBvbmVudE1vZGVsLCBhcGkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZEJhY2tncm91bmQ6IGZ1bmN0aW9uIChncm91cCwgY29tcG9uZW50TW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheShcbiAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5nZXQoJ3BhZGRpbmcnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGNvbXBvbmVudE1vZGVsLmdldEl0ZW1TdHlsZShbJ2NvbG9yJywgJ29wYWNpdHknXSk7XG4gICAgICAgICAgICBzdHlsZS5maWxsID0gY29tcG9uZW50TW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogYm91bmRpbmdSZWN0LnggLSBwYWRkaW5nWzNdLFxuICAgICAgICAgICAgICAgICAgICB5OiBib3VuZGluZ1JlY3QueSAtIHBhZGRpbmdbMF0sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBib3VuZGluZ1JlY3Qud2lkdGggKyBwYWRkaW5nWzFdICsgcGFkZGluZ1szXSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ1JlY3QuaGVpZ2h0ICsgcGFkZGluZ1swXSArIHBhZGRpbmdbMl1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgejI6IC0xXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZVJlY3QocmVjdCk7XG5cbiAgICAgICAgICAgIGdyb3VwLmFkZChyZWN0KTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9saXN0Q29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("\n   module.exports = function (ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (legendModels && legendModels.length) {\n            ecModel.filterSeries(function (series) {\n                // If in any legend component the status is not selected.\n                // Because in legend series is assumed selected when it is not in the legend data.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(series.name)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kRmlsdGVyLmpzPzkzYjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5QkFBeUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBIiwiZmlsZSI6IjE1MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgICAgICB2YXIgbGVnZW5kTW9kZWxzID0gZWNNb2RlbC5maW5kQ29tcG9uZW50cyh7XG4gICAgICAgICAgICBtYWluVHlwZTogJ2xlZ2VuZCdcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsZWdlbmRNb2RlbHMgJiYgbGVnZW5kTW9kZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgZWNNb2RlbC5maWx0ZXJTZXJpZXMoZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgICAgICAgICAgIC8vIElmIGluIGFueSBsZWdlbmQgY29tcG9uZW50IHRoZSBzdGF0dXMgaXMgbm90IHNlbGVjdGVkLlxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgaW4gbGVnZW5kIHNlcmllcyBpcyBhc3N1bWVkIHNlbGVjdGVkIHdoZW4gaXQgaXMgbm90IGluIHRoZSBsZWdlbmQgZGF0YS5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZ2VuZE1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxlZ2VuZE1vZGVsc1tpXS5pc1NlbGVjdGVkKHNlcmllcy5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n\n    __webpack_require__(153);\n\n    __webpack_require__(161);\n    __webpack_require__(163);\n\n    var barLayoutGrid = __webpack_require__(166);\n    var echarts = __webpack_require__(17);\n\n    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n\n    // Visual coding for legend\n    echarts.registerVisual(function (ecModel) {\n        ecModel.eachSeriesByType('bar', function (seriesModel) {\n            var data = seriesModel.getData();\n            data.setVisual('legendSymbol', 'roundRect');\n        });\n    });\n\n    // In case developer forget to include grid component\n    __webpack_require__(167);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2Jhci5qcz85MzFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBIiwiZmlsZSI6IjE1Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgcmVxdWlyZSgnLi4vY29vcmQvY2FydGVzaWFuL0dyaWQnKTtcblxuICAgIHJlcXVpcmUoJy4vYmFyL0JhclNlcmllcycpO1xuICAgIHJlcXVpcmUoJy4vYmFyL0JhclZpZXcnKTtcblxuICAgIHZhciBiYXJMYXlvdXRHcmlkID0gcmVxdWlyZSgnLi4vbGF5b3V0L2JhckdyaWQnKTtcbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uL2VjaGFydHMnKTtcblxuICAgIGVjaGFydHMucmVnaXN0ZXJMYXlvdXQoenJVdGlsLmN1cnJ5KGJhckxheW91dEdyaWQsICdiYXInKSk7XG5cbiAgICAvLyBWaXN1YWwgY29kaW5nIGZvciBsZWdlbmRcbiAgICBlY2hhcnRzLnJlZ2lzdGVyVmlzdWFsKGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgnYmFyJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIGRhdGEuc2V0VmlzdWFsKCdsZWdlbmRTeW1ib2wnLCAncm91bmRSZWN0Jyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gSW4gY2FzZSBkZXZlbG9wZXIgZm9yZ2V0IHRvIGluY2x1ZGUgZ3JpZCBjb21wb25lbnRcbiAgICByZXF1aXJlKCcuLi9jb21wb25lbnQvZ3JpZFNpbXBsZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NoYXJ0L2Jhci5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\nvar factory = exports;\n\n    var layout = __webpack_require__(87);\n    var axisHelper = __webpack_require__(117);\n\n    var zrUtil = __webpack_require__(20);\n    var Cartesian2D = __webpack_require__(154);\n    var Axis2D = __webpack_require__(156);\n\n    var each = zrUtil.each;\n\n    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n    var niceScaleExtent = axisHelper.niceScaleExtent;\n\n    // 依赖 GridModel, AxisModel 做预处理\n    __webpack_require__(157);\n\n    /**\n     * Check if the axis is used in the specified grid\n     * @inner\n     */\n    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n        return axisModel.getCoordSysModel() === gridModel;\n    }\n\n    function getLabelUnionRect(axis) {\n        var axisModel = axis.model;\n        var labels = axisModel.getFormattedLabels();\n        var textStyleModel = axisModel.getModel('axisLabel.textStyle');\n        var rect;\n        var step = 1;\n        var labelCount = labels.length;\n        if (labelCount > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.ceil(labelCount / 40);\n        }\n        for (var i = 0; i < labelCount; i += step) {\n            if (!axis.isLabelIgnored(i)) {\n                var singleRect = textStyleModel.getTextRect(labels[i]);\n                // FIXME consider label rotate\n                rect ? rect.union(singleRect) : (rect = singleRect);\n            }\n        }\n        return rect;\n    }\n\n    function Grid(gridModel, ecModel, api) {\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n         * @private\n         */\n        this._coordsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n         * @private\n         */\n        this._coordsList = [];\n\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesList = [];\n\n        this._initCartesian(gridModel, ecModel, api);\n\n        this.model = gridModel;\n    }\n\n    var gridProto = Grid.prototype;\n\n    gridProto.type = 'grid';\n\n    gridProto.axisPointerEnabled = true;\n\n    gridProto.getRect = function () {\n        return this._rect;\n    };\n\n    gridProto.update = function (ecModel, api) {\n\n        var axesMap = this._axesMap;\n\n        this._updateScale(ecModel, this.model);\n\n        function ifAxisCanNotOnZero(otherAxisDim) {\n            var axes = axesMap[otherAxisDim];\n            for (var idx in axes) {\n                if (axes.hasOwnProperty(idx)) {\n                    var axis = axes[idx];\n                    if (axis && (\n                        axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis)\n                    )) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        each(axesMap.x, function (xAxis) {\n            niceScaleExtent(xAxis.scale, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n            niceScaleExtent(yAxis.scale, yAxis.model);\n        });\n        // Fix configuration\n        each(axesMap.x, function (xAxis) {\n            // onZero can not be enabled in these two situations\n            // 1. When any other axis is a category axis\n            // 2. When any other axis not across 0 point\n            if (ifAxisCanNotOnZero('y')) {\n                xAxis.onZero = false;\n            }\n        });\n        each(axesMap.y, function (yAxis) {\n            if (ifAxisCanNotOnZero('x')) {\n                yAxis.onZero = false;\n            }\n        });\n\n        // Resize again if containLabel is enabled\n        // FIXME It may cause getting wrong grid size in data processing stage\n        this.resize(this.model, api);\n    };\n\n    /**\n     * Resize the grid\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    gridProto.resize = function (gridModel, api, ignoreContainLabel) {\n\n        var gridRect = layout.getLayoutRect(\n            gridModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n\n        this._rect = gridRect;\n\n        var axesList = this._axesList;\n\n        adjustAxes();\n\n        // Minus label size\n        if (!ignoreContainLabel && gridModel.get('containLabel')) {\n            each(axesList, function (axis) {\n                if (!axis.model.get('axisLabel.inside')) {\n                    var labelUnionRect = getLabelUnionRect(axis);\n                    if (labelUnionRect) {\n                        var dim = axis.isHorizontal() ? 'height' : 'width';\n                        var margin = axis.model.get('axisLabel.margin');\n                        gridRect[dim] -= labelUnionRect[dim] + margin;\n                        if (axis.position === 'top') {\n                            gridRect.y += labelUnionRect.height + margin;\n                        }\n                        else if (axis.position === 'left')  {\n                            gridRect.x += labelUnionRect.width + margin;\n                        }\n                    }\n                }\n            });\n\n            adjustAxes();\n        }\n\n        function adjustAxes() {\n            each(axesList, function (axis) {\n                var isHorizontal = axis.isHorizontal();\n                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n                var idx = axis.inverse ? 1 : 0;\n                axis.setExtent(extent[idx], extent[1 - idx]);\n                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n            });\n        }\n    };\n\n    /**\n     * @param {string} axisType\n     * @param {ndumber} [axisIndex]\n     */\n    gridProto.getAxis = function (axisType, axisIndex) {\n        var axesMapOnDim = this._axesMap[axisType];\n        if (axesMapOnDim != null) {\n            if (axisIndex == null) {\n                // Find first axis\n                for (var name in axesMapOnDim) {\n                    if (axesMapOnDim.hasOwnProperty(name)) {\n                        return axesMapOnDim[name];\n                    }\n                }\n            }\n            return axesMapOnDim[axisIndex];\n        }\n    };\n\n    /**\n     * @return {Array.<module:echarts/coord/Axis>}\n     */\n    gridProto.getAxes = function () {\n        return this._axesList.slice();\n    };\n\n    /**\n     * Usage:\n     *      grid.getCartesian(xAxisIndex, yAxisIndex);\n     *      grid.getCartesian(xAxisIndex);\n     *      grid.getCartesian(null, yAxisIndex);\n     *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n     *\n     * @param {number|Object} [xAxisIndex]\n     * @param {number} [yAxisIndex]\n     */\n    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            return this._coordsMap[key];\n        }\n\n        if (zrUtil.isObject(xAxisIndex)) {\n            yAxisIndex = xAxisIndex.yAxisIndex;\n            xAxisIndex = xAxisIndex.xAxisIndex;\n        }\n        // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n        for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n            if (coordList[i].getAxis('x').index === xAxisIndex\n                || coordList[i].getAxis('y').index === yAxisIndex\n            ) {\n                return coordList[i];\n            }\n        }\n    };\n\n    gridProto.getCartesians = function () {\n        return this._coordsList.slice();\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertToPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.dataToPoint(value)\n            : target.axis\n            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n            : null;\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertFromPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.pointToData(value)\n            : target.axis\n            ? target.axis.coordToData(target.axis.toLocalCoord(value))\n            : null;\n    };\n\n    /**\n     * @inner\n     */\n    gridProto._findConvertTarget = function (ecModel, finder) {\n        var seriesModel = finder.seriesModel;\n        var xAxisModel = finder.xAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n        var yAxisModel = finder.yAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n        var gridModel = finder.gridModel;\n        var coordsList = this._coordsList;\n        var cartesian;\n        var axis;\n\n        if (seriesModel) {\n            cartesian = seriesModel.coordinateSystem;\n            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n        }\n        else if (xAxisModel && yAxisModel) {\n            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        }\n        else if (xAxisModel) {\n            axis = this.getAxis('x', xAxisModel.componentIndex);\n        }\n        else if (yAxisModel) {\n            axis = this.getAxis('y', yAxisModel.componentIndex);\n        }\n        // Lowest priority.\n        else if (gridModel) {\n            var grid = gridModel.coordinateSystem;\n            if (grid === this) {\n                cartesian = this._coordsList[0];\n            }\n        }\n\n        return {cartesian: cartesian, axis: axis};\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.containPoint = function (point) {\n        var coord = this._coordsList[0];\n        if (coord) {\n            return coord.containPoint(point);\n        }\n    };\n\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    gridProto._initCartesian = function (gridModel, ecModel, api) {\n        var axisPositionUsed = {\n            left: false,\n            right: false,\n            top: false,\n            bottom: false\n        };\n\n        var axesMap = {\n            x: {},\n            y: {}\n        };\n        var axesCount = {\n            x: 0,\n            y: 0\n        };\n\n        /// Create axis\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n        if (!axesCount.x || !axesCount.y) {\n            // Roll back when there no either x or y axis\n            this._axesMap = {};\n            this._axesList = [];\n            return;\n        }\n\n        this._axesMap = axesMap;\n\n        /// Create cartesian2d\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n            each(axesMap.y, function (yAxis, yAxisIndex) {\n                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n                var cartesian = new Cartesian2D(key);\n\n                cartesian.grid = this;\n                cartesian.model = gridModel;\n\n                this._coordsMap[key] = cartesian;\n                this._coordsList.push(cartesian);\n\n                cartesian.addAxis(xAxis);\n                cartesian.addAxis(yAxis);\n            }, this);\n        }, this);\n\n        function createAxisCreator(axisType) {\n            return function (axisModel, idx) {\n                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                    return;\n                }\n\n                var axisPosition = axisModel.get('position');\n                if (axisType === 'x') {\n                    // Fix position\n                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                        // Default bottom of X\n                        axisPosition = 'bottom';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                        }\n                    }\n                }\n                else {\n                    // Fix position\n                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n                        // Default left of Y\n                        axisPosition = 'left';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                        }\n                    }\n                }\n                axisPositionUsed[axisPosition] = true;\n\n                var axis = new Axis2D(\n                    axisType, axisHelper.createScaleByModel(axisModel),\n                    [0, 0],\n                    axisModel.get('type'),\n                    axisPosition\n                );\n\n                var isCategory = axis.type === 'category';\n                axis.onBand = isCategory && axisModel.get('boundaryGap');\n                axis.inverse = axisModel.get('inverse');\n\n                axis.onZero = axisModel.get('axisLine.onZero');\n\n                // Inject axis into axisModel\n                axisModel.axis = axis;\n\n                // Inject axisModel into axis\n                axis.model = axisModel;\n\n                // Inject grid info axis\n                axis.grid = this;\n\n                // Index of axis, can be used as key\n                axis.index = idx;\n\n                this._axesList.push(axis);\n\n                axesMap[axisType][idx] = axis;\n                axesCount[axisType]++;\n            };\n        }\n    };\n\n    /**\n     * Update cartesian properties from series\n     * @param  {module:echarts/model/Option} option\n     * @private\n     */\n    gridProto._updateScale = function (ecModel, gridModel) {\n        // Reset scale\n        zrUtil.each(this._axesList, function (axis) {\n            axis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCartesian2D(seriesModel)) {\n                var axesModels = findAxesModels(seriesModel, ecModel);\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n\n                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n                 ) {\n                    return;\n                }\n\n                var cartesian = this.getCartesian(\n                    xAxisModel.componentIndex, yAxisModel.componentIndex\n                );\n                var data = seriesModel.getData();\n                var xAxis = cartesian.getAxis('x');\n                var yAxis = cartesian.getAxis('y');\n\n                if (data.type === 'list') {\n                    unionExtent(data, xAxis, seriesModel);\n                    unionExtent(data, yAxis, seriesModel);\n                }\n            }\n        }, this);\n\n        function unionExtent(data, axis, seriesModel) {\n            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n                axis.scale.unionExtentFromData(data, dim);\n            });\n        }\n    };\n\n    /**\n     * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n     * @return {Object} {baseAxes: [], otherAxes: []}\n     */\n    gridProto.getTooltipAxes = function (dim) {\n        var baseAxes = [];\n        var otherAxes = [];\n\n        each(this.getCartesians(), function (cartesian) {\n            var baseAxis = (dim != null && dim !== 'auto')\n                ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n            var otherAxis = cartesian.getOtherAxis(baseAxis);\n            zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n            zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n        });\n\n        return {baseAxes: baseAxes, otherAxes: otherAxes};\n    };\n\n    /**\n     * @inner\n     */\n    function updateAxisTransfrom(axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\n        // Fast transform\n        axis.toGlobalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord + coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n        axis.toLocalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord - coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n    }\n\n    var axesTypes = ['xAxis', 'yAxis'];\n    /**\n     * @inner\n     */\n    function findAxesModels(seriesModel, ecModel) {\n        return zrUtil.map(axesTypes, function (axisType) {\n            var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\n            if (__DEV__) {\n                if (!axisModel) {\n                    throw new Error(axisType + ' \"' + zrUtil.retrieve(\n                        seriesModel.get(axisType + 'Index'),\n                        seriesModel.get(axisType + 'Id'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n            return axisModel;\n        });\n    }\n\n    /**\n     * @inner\n     */\n    function isCartesian2D(seriesModel) {\n        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n\n    Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n            var grid = new Grid(gridModel, ecModel, api);\n            grid.name = 'grid_' + idx;\n            // dataSampling requires axis extent, so resize\n            // should be performed in create stage.\n            grid.resize(gridModel, api, true);\n\n            gridModel.coordinateSystem = grid;\n\n            grids.push(grid);\n        });\n\n        // Inject the coordinateSystems into seriesModel\n        ecModel.eachSeries(function (seriesModel) {\n            if (!isCartesian2D(seriesModel)) {\n                return;\n            }\n\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            var gridModel = xAxisModel.getCoordSysModel();\n\n            if (__DEV__) {\n                if (!gridModel) {\n                    throw new Error(\n                        'Grid \"' + zrUtil.retrieve(\n                            xAxisModel.get('gridIndex'),\n                            xAxisModel.get('gridId'),\n                            0\n                        ) + '\" not found'\n                    );\n                }\n                if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n                    throw new Error('xAxis and yAxis must use the same grid');\n                }\n            }\n\n            var grid = gridModel.coordinateSystem;\n\n            seriesModel.coordinateSystem = grid.getCartesian(\n                xAxisModel.componentIndex, yAxisModel.componentIndex\n            );\n        });\n\n        return grids;\n    };\n\n    // For deciding which dimensions to use when creating list data\n    Grid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\n\n    __webpack_require__(92).register('cartesian2d', Grid);\n\n    module.exports = Grid;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkLmpzP2YxNjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHlDQUF5QztBQUN4RCxlQUFlLDRCQUE0QjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlDQUFpQztBQUNoRTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsc0JBQXNCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTyxFQUFFO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiIxNTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdyaWQgaXMgYSByZWdpb24gd2hpY2ggY29udGFpbnMgYXQgbW9zdCA0IGNhcnRlc2lhbiBzeXN0ZW1zXG4gKlxuICogVE9ETyBEZWZhdWx0IGNhcnRlc2lhblxuICovXG52YXIgZmFjdG9yeSA9IGV4cG9ydHM7XG5cbiAgICB2YXIgbGF5b3V0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9sYXlvdXQnKTtcbiAgICB2YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoJy4uLy4uL2Nvb3JkL2F4aXNIZWxwZXInKTtcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgQ2FydGVzaWFuMkQgPSByZXF1aXJlKCcuL0NhcnRlc2lhbjJEJyk7XG4gICAgdmFyIEF4aXMyRCA9IHJlcXVpcmUoJy4vQXhpczJEJyk7XG5cbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuXG4gICAgdmFyIGlmQXhpc0Nyb3NzWmVybyA9IGF4aXNIZWxwZXIuaWZBeGlzQ3Jvc3NaZXJvO1xuICAgIHZhciBuaWNlU2NhbGVFeHRlbnQgPSBheGlzSGVscGVyLm5pY2VTY2FsZUV4dGVudDtcblxuICAgIC8vIOS+nei1liBHcmlkTW9kZWwsIEF4aXNNb2RlbCDlgZrpooTlpITnkIZcbiAgICByZXF1aXJlKCcuL0dyaWRNb2RlbCcpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGF4aXMgaXMgdXNlZCBpbiB0aGUgc3BlY2lmaWVkIGdyaWRcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0F4aXNVc2VkSW5UaGVHcmlkKGF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBlY01vZGVsKSB7XG4gICAgICAgIHJldHVybiBheGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpID09PSBncmlkTW9kZWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TGFiZWxVbmlvblJlY3QoYXhpcykge1xuICAgICAgICB2YXIgYXhpc01vZGVsID0gYXhpcy5tb2RlbDtcbiAgICAgICAgdmFyIGxhYmVscyA9IGF4aXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbHMoKTtcbiAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwudGV4dFN0eWxlJyk7XG4gICAgICAgIHZhciByZWN0O1xuICAgICAgICB2YXIgc3RlcCA9IDE7XG4gICAgICAgIHZhciBsYWJlbENvdW50ID0gbGFiZWxzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxhYmVsQ291bnQgPiA0MCkge1xuICAgICAgICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvbiBmb3IgbGFyZ2UgYW1vdW50IG9mIGxhYmVsc1xuICAgICAgICAgICAgc3RlcCA9IE1hdGguY2VpbChsYWJlbENvdW50IC8gNDApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxDb3VudDsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICBpZiAoIWF4aXMuaXNMYWJlbElnbm9yZWQoaSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlUmVjdCA9IHRleHRTdHlsZU1vZGVsLmdldFRleHRSZWN0KGxhYmVsc1tpXSk7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgY29uc2lkZXIgbGFiZWwgcm90YXRlXG4gICAgICAgICAgICAgICAgcmVjdCA/IHJlY3QudW5pb24oc2luZ2xlUmVjdCkgOiAocmVjdCA9IHNpbmdsZVJlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEdyaWQoZ3JpZE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbjJEPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Nvb3Jkc01hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29vcmRzTGlzdCA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYXhlc01hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYXhlc0xpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9pbml0Q2FydGVzaWFuKGdyaWRNb2RlbCwgZWNNb2RlbCwgYXBpKTtcblxuICAgICAgICB0aGlzLm1vZGVsID0gZ3JpZE1vZGVsO1xuICAgIH1cblxuICAgIHZhciBncmlkUHJvdG8gPSBHcmlkLnByb3RvdHlwZTtcblxuICAgIGdyaWRQcm90by50eXBlID0gJ2dyaWQnO1xuXG4gICAgZ3JpZFByb3RvLmF4aXNQb2ludGVyRW5hYmxlZCA9IHRydWU7XG5cbiAgICBncmlkUHJvdG8uZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gICAgfTtcblxuICAgIGdyaWRQcm90by51cGRhdGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgdmFyIGF4ZXNNYXAgPSB0aGlzLl9heGVzTWFwO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVNjYWxlKGVjTW9kZWwsIHRoaXMubW9kZWwpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlmQXhpc0Nhbk5vdE9uWmVybyhvdGhlckF4aXNEaW0pIHtcbiAgICAgICAgICAgIHZhciBheGVzID0gYXhlc01hcFtvdGhlckF4aXNEaW1dO1xuICAgICAgICAgICAgZm9yICh2YXIgaWR4IGluIGF4ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhlcy5oYXNPd25Qcm9wZXJ0eShpZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzID0gYXhlc1tpZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXhpcyAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgfHwgYXhpcy50eXBlID09PSAndGltZScgfHwgIWlmQXhpc0Nyb3NzWmVybyhheGlzKVxuICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhY2goYXhlc01hcC54LCBmdW5jdGlvbiAoeEF4aXMpIHtcbiAgICAgICAgICAgIG5pY2VTY2FsZUV4dGVudCh4QXhpcy5zY2FsZSwgeEF4aXMubW9kZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaChheGVzTWFwLnksIGZ1bmN0aW9uICh5QXhpcykge1xuICAgICAgICAgICAgbmljZVNjYWxlRXh0ZW50KHlBeGlzLnNjYWxlLCB5QXhpcy5tb2RlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGaXggY29uZmlndXJhdGlvblxuICAgICAgICBlYWNoKGF4ZXNNYXAueCwgZnVuY3Rpb24gKHhBeGlzKSB7XG4gICAgICAgICAgICAvLyBvblplcm8gY2FuIG5vdCBiZSBlbmFibGVkIGluIHRoZXNlIHR3byBzaXR1YXRpb25zXG4gICAgICAgICAgICAvLyAxLiBXaGVuIGFueSBvdGhlciBheGlzIGlzIGEgY2F0ZWdvcnkgYXhpc1xuICAgICAgICAgICAgLy8gMi4gV2hlbiBhbnkgb3RoZXIgYXhpcyBub3QgYWNyb3NzIDAgcG9pbnRcbiAgICAgICAgICAgIGlmIChpZkF4aXNDYW5Ob3RPblplcm8oJ3knKSkge1xuICAgICAgICAgICAgICAgIHhBeGlzLm9uWmVybyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWFjaChheGVzTWFwLnksIGZ1bmN0aW9uICh5QXhpcykge1xuICAgICAgICAgICAgaWYgKGlmQXhpc0Nhbk5vdE9uWmVybygneCcpKSB7XG4gICAgICAgICAgICAgICAgeUF4aXMub25aZXJvID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlc2l6ZSBhZ2FpbiBpZiBjb250YWluTGFiZWwgaXMgZW5hYmxlZFxuICAgICAgICAvLyBGSVhNRSBJdCBtYXkgY2F1c2UgZ2V0dGluZyB3cm9uZyBncmlkIHNpemUgaW4gZGF0YSBwcm9jZXNzaW5nIHN0YWdlXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMubW9kZWwsIGFwaSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSB0aGUgZ3JpZFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWRNb2RlbH0gZ3JpZE1vZGVsXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAqL1xuICAgIGdyaWRQcm90by5yZXNpemUgPSBmdW5jdGlvbiAoZ3JpZE1vZGVsLCBhcGksIGlnbm9yZUNvbnRhaW5MYWJlbCkge1xuXG4gICAgICAgIHZhciBncmlkUmVjdCA9IGxheW91dC5nZXRMYXlvdXRSZWN0KFxuICAgICAgICAgICAgZ3JpZE1vZGVsLmdldEJveExheW91dFBhcmFtcygpLCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9yZWN0ID0gZ3JpZFJlY3Q7XG5cbiAgICAgICAgdmFyIGF4ZXNMaXN0ID0gdGhpcy5fYXhlc0xpc3Q7XG5cbiAgICAgICAgYWRqdXN0QXhlcygpO1xuXG4gICAgICAgIC8vIE1pbnVzIGxhYmVsIHNpemVcbiAgICAgICAgaWYgKCFpZ25vcmVDb250YWluTGFiZWwgJiYgZ3JpZE1vZGVsLmdldCgnY29udGFpbkxhYmVsJykpIHtcbiAgICAgICAgICAgIGVhY2goYXhlc0xpc3QsIGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFheGlzLm1vZGVsLmdldCgnYXhpc0xhYmVsLmluc2lkZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbFVuaW9uUmVjdCA9IGdldExhYmVsVW5pb25SZWN0KGF4aXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxVbmlvblJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaW0gPSBheGlzLmlzSG9yaXpvbnRhbCgpID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmdpbiA9IGF4aXMubW9kZWwuZ2V0KCdheGlzTGFiZWwubWFyZ2luJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmlkUmVjdFtkaW1dIC09IGxhYmVsVW5pb25SZWN0W2RpbV0gKyBtYXJnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXhpcy5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkUmVjdC55ICs9IGxhYmVsVW5pb25SZWN0LmhlaWdodCArIG1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF4aXMucG9zaXRpb24gPT09ICdsZWZ0JykgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkUmVjdC54ICs9IGxhYmVsVW5pb25SZWN0LndpZHRoICsgbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGFkanVzdEF4ZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkanVzdEF4ZXMoKSB7XG4gICAgICAgICAgICBlYWNoKGF4ZXNMaXN0LCBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgICAgIHZhciBpc0hvcml6b250YWwgPSBheGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgICAgICAgICAgIHZhciBleHRlbnQgPSBpc0hvcml6b250YWwgPyBbMCwgZ3JpZFJlY3Qud2lkdGhdIDogWzAsIGdyaWRSZWN0LmhlaWdodF07XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGF4aXMuaW52ZXJzZSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIGF4aXMuc2V0RXh0ZW50KGV4dGVudFtpZHhdLCBleHRlbnRbMSAtIGlkeF0pO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUF4aXNUcmFuc2Zyb20oYXhpcywgaXNIb3Jpem9udGFsID8gZ3JpZFJlY3QueCA6IGdyaWRSZWN0LnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF4aXNUeXBlXG4gICAgICogQHBhcmFtIHtuZHVtYmVyfSBbYXhpc0luZGV4XVxuICAgICAqL1xuICAgIGdyaWRQcm90by5nZXRBeGlzID0gZnVuY3Rpb24gKGF4aXNUeXBlLCBheGlzSW5kZXgpIHtcbiAgICAgICAgdmFyIGF4ZXNNYXBPbkRpbSA9IHRoaXMuX2F4ZXNNYXBbYXhpc1R5cGVdO1xuICAgICAgICBpZiAoYXhlc01hcE9uRGltICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChheGlzSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgZmlyc3QgYXhpc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gYXhlc01hcE9uRGltKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChheGVzTWFwT25EaW0uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBheGVzTWFwT25EaW1bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXhlc01hcE9uRGltW2F4aXNJbmRleF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL2Nvb3JkL0F4aXM+fVxuICAgICAqL1xuICAgIGdyaWRQcm90by5nZXRBeGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXhlc0xpc3Quc2xpY2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNhZ2U6XG4gICAgICogICAgICBncmlkLmdldENhcnRlc2lhbih4QXhpc0luZGV4LCB5QXhpc0luZGV4KTtcbiAgICAgKiAgICAgIGdyaWQuZ2V0Q2FydGVzaWFuKHhBeGlzSW5kZXgpO1xuICAgICAqICAgICAgZ3JpZC5nZXRDYXJ0ZXNpYW4obnVsbCwgeUF4aXNJbmRleCk7XG4gICAgICogICAgICBncmlkLmdldENhcnRlc2lhbih7eEF4aXNJbmRleDogLi4uLCB5QXhpc0luZGV4OiAuLi59KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfE9iamVjdH0gW3hBeGlzSW5kZXhdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5QXhpc0luZGV4XVxuICAgICAqL1xuICAgIGdyaWRQcm90by5nZXRDYXJ0ZXNpYW4gPSBmdW5jdGlvbiAoeEF4aXNJbmRleCwgeUF4aXNJbmRleCkge1xuICAgICAgICBpZiAoeEF4aXNJbmRleCAhPSBudWxsICYmIHlBeGlzSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGtleSA9ICd4JyArIHhBeGlzSW5kZXggKyAneScgKyB5QXhpc0luZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nvb3Jkc01hcFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdCh4QXhpc0luZGV4KSkge1xuICAgICAgICAgICAgeUF4aXNJbmRleCA9IHhBeGlzSW5kZXgueUF4aXNJbmRleDtcbiAgICAgICAgICAgIHhBeGlzSW5kZXggPSB4QXhpc0luZGV4LnhBeGlzSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiBvbmx5IHhBeGlzSW5kZXggb3IgeUF4aXNJbmRleCBnaXZlbiwgZmluZCBpdHMgZmlyc3QgY2FydGVzaWFuLlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgY29vcmRMaXN0ID0gdGhpcy5fY29vcmRzTGlzdDsgaSA8IGNvb3JkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvb3JkTGlzdFtpXS5nZXRBeGlzKCd4JykuaW5kZXggPT09IHhBeGlzSW5kZXhcbiAgICAgICAgICAgICAgICB8fCBjb29yZExpc3RbaV0uZ2V0QXhpcygneScpLmluZGV4ID09PSB5QXhpc0luZGV4XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29vcmRMaXN0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGdyaWRQcm90by5nZXRDYXJ0ZXNpYW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29vcmRzTGlzdC5zbGljZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAaW1wbGVtZW50c1xuICAgICAqIHNlZSB7bW9kdWxlOmVjaGFydHMvQ29vZGluYXRlU3lzdGVtfVxuICAgICAqL1xuICAgIGdyaWRQcm90by5jb252ZXJ0VG9QaXhlbCA9IGZ1bmN0aW9uIChlY01vZGVsLCBmaW5kZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9maW5kQ29udmVydFRhcmdldChlY01vZGVsLCBmaW5kZXIpO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQuY2FydGVzaWFuXG4gICAgICAgICAgICA/IHRhcmdldC5jYXJ0ZXNpYW4uZGF0YVRvUG9pbnQodmFsdWUpXG4gICAgICAgICAgICA6IHRhcmdldC5heGlzXG4gICAgICAgICAgICA/IHRhcmdldC5heGlzLnRvR2xvYmFsQ29vcmQodGFyZ2V0LmF4aXMuZGF0YVRvQ29vcmQodmFsdWUpKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAaW1wbGVtZW50c1xuICAgICAqIHNlZSB7bW9kdWxlOmVjaGFydHMvQ29vZGluYXRlU3lzdGVtfVxuICAgICAqL1xuICAgIGdyaWRQcm90by5jb252ZXJ0RnJvbVBpeGVsID0gZnVuY3Rpb24gKGVjTW9kZWwsIGZpbmRlciwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX2ZpbmRDb252ZXJ0VGFyZ2V0KGVjTW9kZWwsIGZpbmRlcik7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldC5jYXJ0ZXNpYW5cbiAgICAgICAgICAgID8gdGFyZ2V0LmNhcnRlc2lhbi5wb2ludFRvRGF0YSh2YWx1ZSlcbiAgICAgICAgICAgIDogdGFyZ2V0LmF4aXNcbiAgICAgICAgICAgID8gdGFyZ2V0LmF4aXMuY29vcmRUb0RhdGEodGFyZ2V0LmF4aXMudG9Mb2NhbENvb3JkKHZhbHVlKSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZ3JpZFByb3RvLl9maW5kQ29udmVydFRhcmdldCA9IGZ1bmN0aW9uIChlY01vZGVsLCBmaW5kZXIpIHtcbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZmluZGVyLnNlcmllc01vZGVsO1xuICAgICAgICB2YXIgeEF4aXNNb2RlbCA9IGZpbmRlci54QXhpc01vZGVsXG4gICAgICAgICAgICB8fCAoc2VyaWVzTW9kZWwgJiYgc2VyaWVzTW9kZWwuZ2V0UmVmZXJyaW5nQ29tcG9uZW50cygneEF4aXMnKVswXSk7XG4gICAgICAgIHZhciB5QXhpc01vZGVsID0gZmluZGVyLnlBeGlzTW9kZWxcbiAgICAgICAgICAgIHx8IChzZXJpZXNNb2RlbCAmJiBzZXJpZXNNb2RlbC5nZXRSZWZlcnJpbmdDb21wb25lbnRzKCd5QXhpcycpWzBdKTtcbiAgICAgICAgdmFyIGdyaWRNb2RlbCA9IGZpbmRlci5ncmlkTW9kZWw7XG4gICAgICAgIHZhciBjb29yZHNMaXN0ID0gdGhpcy5fY29vcmRzTGlzdDtcbiAgICAgICAgdmFyIGNhcnRlc2lhbjtcbiAgICAgICAgdmFyIGF4aXM7XG5cbiAgICAgICAgaWYgKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgenJVdGlsLmluZGV4T2YoY29vcmRzTGlzdCwgY2FydGVzaWFuKSA8IDAgJiYgKGNhcnRlc2lhbiA9IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHhBeGlzTW9kZWwgJiYgeUF4aXNNb2RlbCkge1xuICAgICAgICAgICAgY2FydGVzaWFuID0gdGhpcy5nZXRDYXJ0ZXNpYW4oeEF4aXNNb2RlbC5jb21wb25lbnRJbmRleCwgeUF4aXNNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeEF4aXNNb2RlbCkge1xuICAgICAgICAgICAgYXhpcyA9IHRoaXMuZ2V0QXhpcygneCcsIHhBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHlBeGlzTW9kZWwpIHtcbiAgICAgICAgICAgIGF4aXMgPSB0aGlzLmdldEF4aXMoJ3knLCB5QXhpc01vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb3dlc3QgcHJpb3JpdHkuXG4gICAgICAgIGVsc2UgaWYgKGdyaWRNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGdyaWQgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIGlmIChncmlkID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgY2FydGVzaWFuID0gdGhpcy5fY29vcmRzTGlzdFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7Y2FydGVzaWFuOiBjYXJ0ZXNpYW4sIGF4aXM6IGF4aXN9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAaW1wbGVtZW50c1xuICAgICAqIHNlZSB7bW9kdWxlOmVjaGFydHMvQ29vZGluYXRlU3lzdGVtfVxuICAgICAqL1xuICAgIGdyaWRQcm90by5jb250YWluUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgdmFyIGNvb3JkID0gdGhpcy5fY29vcmRzTGlzdFswXTtcbiAgICAgICAgaWYgKGNvb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29vcmQuY29udGFpblBvaW50KHBvaW50KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGNhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdyaWRQcm90by5faW5pdENhcnRlc2lhbiA9IGZ1bmN0aW9uIChncmlkTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICB2YXIgYXhpc1Bvc2l0aW9uVXNlZCA9IHtcbiAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgcmlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgdG9wOiBmYWxzZSxcbiAgICAgICAgICAgIGJvdHRvbTogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYXhlc01hcCA9IHtcbiAgICAgICAgICAgIHg6IHt9LFxuICAgICAgICAgICAgeToge31cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGF4ZXNDb3VudCA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8vIENyZWF0ZSBheGlzXG4gICAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgneEF4aXMnLCBjcmVhdGVBeGlzQ3JlYXRvcigneCcpLCB0aGlzKTtcbiAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCd5QXhpcycsIGNyZWF0ZUF4aXNDcmVhdG9yKCd5JyksIHRoaXMpO1xuXG4gICAgICAgIGlmICghYXhlc0NvdW50LnggfHwgIWF4ZXNDb3VudC55KSB7XG4gICAgICAgICAgICAvLyBSb2xsIGJhY2sgd2hlbiB0aGVyZSBubyBlaXRoZXIgeCBvciB5IGF4aXNcbiAgICAgICAgICAgIHRoaXMuX2F4ZXNNYXAgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2F4ZXNMaXN0ID0gW107XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9heGVzTWFwID0gYXhlc01hcDtcblxuICAgICAgICAvLy8gQ3JlYXRlIGNhcnRlc2lhbjJkXG4gICAgICAgIGVhY2goYXhlc01hcC54LCBmdW5jdGlvbiAoeEF4aXMsIHhBeGlzSW5kZXgpIHtcbiAgICAgICAgICAgIGVhY2goYXhlc01hcC55LCBmdW5jdGlvbiAoeUF4aXMsIHlBeGlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gJ3gnICsgeEF4aXNJbmRleCArICd5JyArIHlBeGlzSW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIGNhcnRlc2lhbiA9IG5ldyBDYXJ0ZXNpYW4yRChrZXkpO1xuXG4gICAgICAgICAgICAgICAgY2FydGVzaWFuLmdyaWQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGNhcnRlc2lhbi5tb2RlbCA9IGdyaWRNb2RlbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvb3Jkc01hcFtrZXldID0gY2FydGVzaWFuO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvb3Jkc0xpc3QucHVzaChjYXJ0ZXNpYW4pO1xuXG4gICAgICAgICAgICAgICAgY2FydGVzaWFuLmFkZEF4aXMoeEF4aXMpO1xuICAgICAgICAgICAgICAgIGNhcnRlc2lhbi5hZGRBeGlzKHlBeGlzKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVBeGlzQ3JlYXRvcihheGlzVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChheGlzTW9kZWwsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNBeGlzVXNlZEluVGhlR3JpZChheGlzTW9kZWwsIGdyaWRNb2RlbCwgZWNNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBheGlzUG9zaXRpb24gPSBheGlzTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgICAgICAgICAgICAgIGlmIChheGlzVHlwZSA9PT0gJ3gnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoYXhpc1Bvc2l0aW9uICE9PSAndG9wJyAmJiBheGlzUG9zaXRpb24gIT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGJvdHRvbSBvZiBYXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzUG9zaXRpb24gPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChheGlzUG9zaXRpb25Vc2VkW2F4aXNQb3NpdGlvbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzUG9zaXRpb24gPSBheGlzUG9zaXRpb24gPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzUG9zaXRpb24gIT09ICdsZWZ0JyAmJiBheGlzUG9zaXRpb24gIT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgbGVmdCBvZiBZXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzUG9zaXRpb24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXhpc1Bvc2l0aW9uVXNlZFtheGlzUG9zaXRpb25dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc1Bvc2l0aW9uID0gYXhpc1Bvc2l0aW9uID09PSAnbGVmdCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF4aXNQb3NpdGlvblVzZWRbYXhpc1Bvc2l0aW9uXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IG5ldyBBeGlzMkQoXG4gICAgICAgICAgICAgICAgICAgIGF4aXNUeXBlLCBheGlzSGVscGVyLmNyZWF0ZVNjYWxlQnlNb2RlbChheGlzTW9kZWwpLFxuICAgICAgICAgICAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgIGF4aXNNb2RlbC5nZXQoJ3R5cGUnKSxcbiAgICAgICAgICAgICAgICAgICAgYXhpc1Bvc2l0aW9uXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHZhciBpc0NhdGVnb3J5ID0gYXhpcy50eXBlID09PSAnY2F0ZWdvcnknO1xuICAgICAgICAgICAgICAgIGF4aXMub25CYW5kID0gaXNDYXRlZ29yeSAmJiBheGlzTW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpO1xuICAgICAgICAgICAgICAgIGF4aXMuaW52ZXJzZSA9IGF4aXNNb2RlbC5nZXQoJ2ludmVyc2UnKTtcblxuICAgICAgICAgICAgICAgIGF4aXMub25aZXJvID0gYXhpc01vZGVsLmdldCgnYXhpc0xpbmUub25aZXJvJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBJbmplY3QgYXhpcyBpbnRvIGF4aXNNb2RlbFxuICAgICAgICAgICAgICAgIGF4aXNNb2RlbC5heGlzID0gYXhpcztcblxuICAgICAgICAgICAgICAgIC8vIEluamVjdCBheGlzTW9kZWwgaW50byBheGlzXG4gICAgICAgICAgICAgICAgYXhpcy5tb2RlbCA9IGF4aXNNb2RlbDtcblxuICAgICAgICAgICAgICAgIC8vIEluamVjdCBncmlkIGluZm8gYXhpc1xuICAgICAgICAgICAgICAgIGF4aXMuZ3JpZCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAvLyBJbmRleCBvZiBheGlzLCBjYW4gYmUgdXNlZCBhcyBrZXlcbiAgICAgICAgICAgICAgICBheGlzLmluZGV4ID0gaWR4O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fYXhlc0xpc3QucHVzaChheGlzKTtcblxuICAgICAgICAgICAgICAgIGF4ZXNNYXBbYXhpc1R5cGVdW2lkeF0gPSBheGlzO1xuICAgICAgICAgICAgICAgIGF4ZXNDb3VudFtheGlzVHlwZV0rKztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNhcnRlc2lhbiBwcm9wZXJ0aWVzIGZyb20gc2VyaWVzXG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvT3B0aW9ufSBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdyaWRQcm90by5fdXBkYXRlU2NhbGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZ3JpZE1vZGVsKSB7XG4gICAgICAgIC8vIFJlc2V0IHNjYWxlXG4gICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuX2F4ZXNMaXN0LCBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgYXhpcy5zY2FsZS5zZXRFeHRlbnQoSW5maW5pdHksIC1JbmZpbml0eSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICBpZiAoaXNDYXJ0ZXNpYW4yRChzZXJpZXNNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhlc01vZGVscyA9IGZpbmRBeGVzTW9kZWxzKHNlcmllc01vZGVsLCBlY01vZGVsKTtcbiAgICAgICAgICAgICAgICB2YXIgeEF4aXNNb2RlbCA9IGF4ZXNNb2RlbHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIHlBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc0F4aXNVc2VkSW5UaGVHcmlkKHhBeGlzTW9kZWwsIGdyaWRNb2RlbCwgZWNNb2RlbClcbiAgICAgICAgICAgICAgICAgICAgfHwgIWlzQXhpc1VzZWRJblRoZUdyaWQoeUF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBlY01vZGVsKVxuICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjYXJ0ZXNpYW4gPSB0aGlzLmdldENhcnRlc2lhbihcbiAgICAgICAgICAgICAgICAgICAgeEF4aXNNb2RlbC5jb21wb25lbnRJbmRleCwgeUF4aXNNb2RlbC5jb21wb25lbnRJbmRleFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICAgICAgdmFyIHhBeGlzID0gY2FydGVzaWFuLmdldEF4aXMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgeUF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QXhpcygneScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaW9uRXh0ZW50KGRhdGEsIHhBeGlzLCBzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIHVuaW9uRXh0ZW50KGRhdGEsIHlBeGlzLCBzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBmdW5jdGlvbiB1bmlvbkV4dGVudChkYXRhLCBheGlzLCBzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgZWFjaChzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShheGlzLmRpbSksIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgICAgICAgICBheGlzLnNjYWxlLnVuaW9uRXh0ZW50RnJvbURhdGEoZGF0YSwgZGltKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZGltXSAneCcgb3IgJ3knIG9yICdhdXRvJyBvciBudWxsL3VuZGVmaW5lZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0ge2Jhc2VBeGVzOiBbXSwgb3RoZXJBeGVzOiBbXX1cbiAgICAgKi9cbiAgICBncmlkUHJvdG8uZ2V0VG9vbHRpcEF4ZXMgPSBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIHZhciBiYXNlQXhlcyA9IFtdO1xuICAgICAgICB2YXIgb3RoZXJBeGVzID0gW107XG5cbiAgICAgICAgZWFjaCh0aGlzLmdldENhcnRlc2lhbnMoKSwgZnVuY3Rpb24gKGNhcnRlc2lhbikge1xuICAgICAgICAgICAgdmFyIGJhc2VBeGlzID0gKGRpbSAhPSBudWxsICYmIGRpbSAhPT0gJ2F1dG8nKVxuICAgICAgICAgICAgICAgID8gY2FydGVzaWFuLmdldEF4aXMoZGltKSA6IGNhcnRlc2lhbi5nZXRCYXNlQXhpcygpO1xuICAgICAgICAgICAgdmFyIG90aGVyQXhpcyA9IGNhcnRlc2lhbi5nZXRPdGhlckF4aXMoYmFzZUF4aXMpO1xuICAgICAgICAgICAgenJVdGlsLmluZGV4T2YoYmFzZUF4ZXMsIGJhc2VBeGlzKSA8IDAgJiYgYmFzZUF4ZXMucHVzaChiYXNlQXhpcyk7XG4gICAgICAgICAgICB6clV0aWwuaW5kZXhPZihvdGhlckF4ZXMsIG90aGVyQXhpcykgPCAwICYmIG90aGVyQXhlcy5wdXNoKG90aGVyQXhpcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7YmFzZUF4ZXM6IGJhc2VBeGVzLCBvdGhlckF4ZXM6IG90aGVyQXhlc307XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUF4aXNUcmFuc2Zyb20oYXhpcywgY29vcmRCYXNlKSB7XG4gICAgICAgIHZhciBheGlzRXh0ZW50ID0gYXhpcy5nZXRFeHRlbnQoKTtcbiAgICAgICAgdmFyIGF4aXNFeHRlbnRTdW0gPSBheGlzRXh0ZW50WzBdICsgYXhpc0V4dGVudFsxXTtcblxuICAgICAgICAvLyBGYXN0IHRyYW5zZm9ybVxuICAgICAgICBheGlzLnRvR2xvYmFsQ29vcmQgPSBheGlzLmRpbSA9PT0gJ3gnXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb29yZCArIGNvb3JkQmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF4aXNFeHRlbnRTdW0gLSBjb29yZCArIGNvb3JkQmFzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGF4aXMudG9Mb2NhbENvb3JkID0gYXhpcy5kaW0gPT09ICd4J1xuICAgICAgICAgICAgPyBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29vcmQgLSBjb29yZEJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBheGlzRXh0ZW50U3VtIC0gY29vcmQgKyBjb29yZEJhc2U7XG4gICAgICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBheGVzVHlwZXMgPSBbJ3hBeGlzJywgJ3lBeGlzJ107XG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEF4ZXNNb2RlbHMoc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAoYXhlc1R5cGVzLCBmdW5jdGlvbiAoYXhpc1R5cGUpIHtcbiAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRSZWZlcnJpbmdDb21wb25lbnRzKGF4aXNUeXBlKVswXTtcblxuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXhpc1R5cGUgKyAnIFwiJyArIHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldChheGlzVHlwZSArICdJbmRleCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KGF4aXNUeXBlICsgJ0lkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICkgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF4aXNNb2RlbDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNDYXJ0ZXNpYW4yRChzZXJpZXNNb2RlbCkge1xuICAgICAgICByZXR1cm4gc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJykgPT09ICdjYXJ0ZXNpYW4yZCc7XG4gICAgfVxuXG4gICAgR3JpZC5jcmVhdGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHZhciBncmlkcyA9IFtdO1xuICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ2dyaWQnLCBmdW5jdGlvbiAoZ3JpZE1vZGVsLCBpZHgpIHtcbiAgICAgICAgICAgIHZhciBncmlkID0gbmV3IEdyaWQoZ3JpZE1vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgICAgICAgICAgZ3JpZC5uYW1lID0gJ2dyaWRfJyArIGlkeDtcbiAgICAgICAgICAgIC8vIGRhdGFTYW1wbGluZyByZXF1aXJlcyBheGlzIGV4dGVudCwgc28gcmVzaXplXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgcGVyZm9ybWVkIGluIGNyZWF0ZSBzdGFnZS5cbiAgICAgICAgICAgIGdyaWQucmVzaXplKGdyaWRNb2RlbCwgYXBpLCB0cnVlKTtcblxuICAgICAgICAgICAgZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSBncmlkO1xuXG4gICAgICAgICAgICBncmlkcy5wdXNoKGdyaWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJbmplY3QgdGhlIGNvb3JkaW5hdGVTeXN0ZW1zIGludG8gc2VyaWVzTW9kZWxcbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgaWYgKCFpc0NhcnRlc2lhbjJEKHNlcmllc01vZGVsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF4ZXNNb2RlbHMgPSBmaW5kQXhlc01vZGVscyhzZXJpZXNNb2RlbCwgZWNNb2RlbCk7XG4gICAgICAgICAgICB2YXIgeEF4aXNNb2RlbCA9IGF4ZXNNb2RlbHNbMF07XG4gICAgICAgICAgICB2YXIgeUF4aXNNb2RlbCA9IGF4ZXNNb2RlbHNbMV07XG5cbiAgICAgICAgICAgIHZhciBncmlkTW9kZWwgPSB4QXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKTtcblxuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWdyaWRNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAnR3JpZCBcIicgKyB6clV0aWwucmV0cmlldmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeEF4aXNNb2RlbC5nZXQoJ2dyaWRJbmRleCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhBeGlzTW9kZWwuZ2V0KCdncmlkSWQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgICApICsgJ1wiIG5vdCBmb3VuZCdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHhBeGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpICE9PSB5QXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3hBeGlzIGFuZCB5QXhpcyBtdXN0IHVzZSB0aGUgc2FtZSBncmlkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ3JpZCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgICAgICAgICBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtID0gZ3JpZC5nZXRDYXJ0ZXNpYW4oXG4gICAgICAgICAgICAgICAgeEF4aXNNb2RlbC5jb21wb25lbnRJbmRleCwgeUF4aXNNb2RlbC5jb21wb25lbnRJbmRleFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGdyaWRzO1xuICAgIH07XG5cbiAgICAvLyBGb3IgZGVjaWRpbmcgd2hpY2ggZGltZW5zaW9ucyB0byB1c2Ugd2hlbiBjcmVhdGluZyBsaXN0IGRhdGFcbiAgICBHcmlkLmRpbWVuc2lvbnMgPSBHcmlkLnByb3RvdHlwZS5kaW1lbnNpb25zID0gQ2FydGVzaWFuMkQucHJvdG90eXBlLmRpbWVuc2lvbnM7XG5cbiAgICByZXF1aXJlKCcuLi8uLi9Db29yZGluYXRlU3lzdGVtJykucmVnaXN0ZXIoJ2NhcnRlc2lhbjJkJywgR3JpZCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdyaWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0dyaWQuanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var zrUtil = __webpack_require__(20);\n    var Cartesian = __webpack_require__(155);\n\n    function Cartesian2D(name) {\n\n        Cartesian.call(this, name);\n    }\n\n    Cartesian2D.prototype = {\n\n        constructor: Cartesian2D,\n\n        type: 'cartesian2d',\n\n        /**\n         * @type {Array.<string>}\n         * @readOnly\n         */\n        dimensions: ['x', 'y'],\n\n        /**\n         * Base axis will be used on stacking.\n         *\n         * @return {module:echarts/coord/cartesian/Axis2D}\n         */\n        getBaseAxis: function () {\n            return this.getAxesByScale('ordinal')[0]\n                || this.getAxesByScale('time')[0]\n                || this.getAxis('x');\n        },\n\n        /**\n         * If contain point\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        containPoint: function (point) {\n            var axisX = this.getAxis('x');\n            var axisY = this.getAxis('y');\n            return axisX.contain(axisX.toLocalCoord(point[0]))\n                && axisY.contain(axisY.toLocalCoord(point[1]));\n        },\n\n        /**\n         * If contain data\n         * @param {Array.<number>} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.getAxis('x').containData(data[0])\n                && this.getAxis('y').containData(data[1]);\n        },\n\n        /**\n         * Convert series data to an array of points\n         * @param {module:echarts/data/List} data\n         * @param {boolean} stack\n         * @return {Array}\n         *  Return array of points. For example:\n         *  `[[10, 10], [20, 20], [30, 30]]`\n         */\n        dataToPoints: function (data, stack) {\n            return data.mapArray(['x', 'y'], function (x, y) {\n                return this.dataToPoint([x, y]);\n            }, stack, this);\n        },\n\n        /**\n         * @param {Array.<number>} data\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        dataToPoint: function (data, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n            ];\n        },\n\n        /**\n         * @param {Array.<number>} point\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        pointToData: function (point, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n            ];\n        },\n\n        /**\n         * Get other axis\n         * @param {module:echarts/coord/cartesian/Axis2D} axis\n         */\n        getOtherAxis: function (axis) {\n            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n        }\n\n    };\n\n    zrUtil.inherits(Cartesian2D, Cartesian);\n\n    module.exports = Cartesian2D;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRC5qcz8xMDNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUMsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBIiwiZmlsZSI6IjE1NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBDYXJ0ZXNpYW4gPSByZXF1aXJlKCcuL0NhcnRlc2lhbicpO1xuXG4gICAgZnVuY3Rpb24gQ2FydGVzaWFuMkQobmFtZSkge1xuXG4gICAgICAgIENhcnRlc2lhbi5jYWxsKHRoaXMsIG5hbWUpO1xuICAgIH1cblxuICAgIENhcnRlc2lhbjJELnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQ2FydGVzaWFuMkQsXG5cbiAgICAgICAgdHlwZTogJ2NhcnRlc2lhbjJkJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGRpbWVuc2lvbnM6IFsneCcsICd5J10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhc2UgYXhpcyB3aWxsIGJlIHVzZWQgb24gc3RhY2tpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRCYXNlQXhpczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXhlc0J5U2NhbGUoJ29yZGluYWwnKVswXVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuZ2V0QXhlc0J5U2NhbGUoJ3RpbWUnKVswXVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuZ2V0QXhpcygneCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBjb250YWluIHBvaW50XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgdmFyIGF4aXNYID0gdGhpcy5nZXRBeGlzKCd4Jyk7XG4gICAgICAgICAgICB2YXIgYXhpc1kgPSB0aGlzLmdldEF4aXMoJ3knKTtcbiAgICAgICAgICAgIHJldHVybiBheGlzWC5jb250YWluKGF4aXNYLnRvTG9jYWxDb29yZChwb2ludFswXSkpXG4gICAgICAgICAgICAgICAgJiYgYXhpc1kuY29udGFpbihheGlzWS50b0xvY2FsQ29vcmQocG9pbnRbMV0pKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgY29udGFpbiBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRhdGFcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5EYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXhpcygneCcpLmNvbnRhaW5EYXRhKGRhdGFbMF0pXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5nZXRBeGlzKCd5JykuY29udGFpbkRhdGEoZGF0YVsxXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgc2VyaWVzIGRhdGEgdG8gYW4gYXJyYXkgb2YgcG9pbnRzXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhY2tcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAgICAqICBSZXR1cm4gYXJyYXkgb2YgcG9pbnRzLiBGb3IgZXhhbXBsZTpcbiAgICAgICAgICogIGBbWzEwLCAxMF0sIFsyMCwgMjBdLCBbMzAsIDMwXV1gXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhVG9Qb2ludHM6IGZ1bmN0aW9uIChkYXRhLCBzdGFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwQXJyYXkoWyd4JywgJ3knXSwgZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhVG9Qb2ludChbeCwgeV0pO1xuICAgICAgICAgICAgfSwgc3RhY2ssIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NsYW1wPWZhbHNlXVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGRhdGFUb1BvaW50OiBmdW5jdGlvbiAoZGF0YSwgY2xhbXApIHtcbiAgICAgICAgICAgIHZhciB4QXhpcyA9IHRoaXMuZ2V0QXhpcygneCcpO1xuICAgICAgICAgICAgdmFyIHlBeGlzID0gdGhpcy5nZXRBeGlzKCd5Jyk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHhBeGlzLnRvR2xvYmFsQ29vcmQoeEF4aXMuZGF0YVRvQ29vcmQoZGF0YVswXSwgY2xhbXApKSxcbiAgICAgICAgICAgICAgICB5QXhpcy50b0dsb2JhbENvb3JkKHlBeGlzLmRhdGFUb0Nvb3JkKGRhdGFbMV0sIGNsYW1wKSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NsYW1wPWZhbHNlXVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHBvaW50VG9EYXRhOiBmdW5jdGlvbiAocG9pbnQsIGNsYW1wKSB7XG4gICAgICAgICAgICB2YXIgeEF4aXMgPSB0aGlzLmdldEF4aXMoJ3gnKTtcbiAgICAgICAgICAgIHZhciB5QXhpcyA9IHRoaXMuZ2V0QXhpcygneScpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB4QXhpcy5jb29yZFRvRGF0YSh4QXhpcy50b0xvY2FsQ29vcmQocG9pbnRbMF0pLCBjbGFtcCksXG4gICAgICAgICAgICAgICAgeUF4aXMuY29vcmRUb0RhdGEoeUF4aXMudG9Mb2NhbENvb3JkKHBvaW50WzFdKSwgY2xhbXApXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgb3RoZXIgYXhpc1xuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkR9IGF4aXNcbiAgICAgICAgICovXG4gICAgICAgIGdldE90aGVyQXhpczogZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF4aXMoYXhpcy5kaW0gPT09ICd4JyA/ICd5JyA6ICd4Jyk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoQ2FydGVzaWFuMkQsIENhcnRlc2lhbik7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENhcnRlc2lhbjJEO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRC5qc1xuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("'use strict';\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\n\n\n    var zrUtil = __webpack_require__(20);\n\n    function dimAxisMapper(dim) {\n        return this._axes[dim];\n    }\n\n    /**\n     * @alias module:echarts/coord/Cartesian\n     * @constructor\n     */\n    var Cartesian = function (name) {\n        this._axes = {};\n\n        this._dimList = [];\n\n        /**\n         * @type {string}\n         */\n        this.name = name || '';\n    };\n\n    Cartesian.prototype = {\n\n        constructor: Cartesian,\n\n        type: 'cartesian',\n\n        /**\n         * Get axis\n         * @param  {number|string} dim\n         * @return {module:echarts/coord/Cartesian~Axis}\n         */\n        getAxis: function (dim) {\n            return this._axes[dim];\n        },\n\n        /**\n         * Get axes list\n         * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n         */\n        getAxes: function () {\n            return zrUtil.map(this._dimList, dimAxisMapper, this);\n        },\n\n        /**\n         * Get axes list by given scale type\n         */\n        getAxesByScale: function (scaleType) {\n            scaleType = scaleType.toLowerCase();\n            return zrUtil.filter(\n                this.getAxes(),\n                function (axis) {\n                    return axis.scale.type === scaleType;\n                }\n            );\n        },\n\n        /**\n         * Add axis\n         * @param {module:echarts/coord/Cartesian.Axis}\n         */\n        addAxis: function (axis) {\n            var dim = axis.dim;\n\n            this._axes[dim] = axis;\n\n            this._dimList.push(dim);\n        },\n\n        /**\n         * Convert data to coord in nd space\n         * @param {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        dataToCoord: function (val) {\n            return this._dataCoordConvert(val, 'dataToCoord');\n        },\n\n        /**\n         * Convert coord in nd space to data\n         * @param  {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        coordToData: function (val) {\n            return this._dataCoordConvert(val, 'coordToData');\n        },\n\n        _dataCoordConvert: function (input, method) {\n            var dimList = this._dimList;\n\n            var output = input instanceof Array ? [] : {};\n\n            for (var i = 0; i < dimList.length; i++) {\n                var dim = dimList[i];\n                var axis = this._axes[dim];\n\n                output[dim] = axis[method](input[dim]);\n            }\n\n            return output;\n        }\n    };\n\n    module.exports = Cartesian;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4uanM/OTI0NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsdUNBQXVDO0FBQzFELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE1NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQ2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtXG4gKiBAbW9kdWxlICBlY2hhcnRzL2Nvb3JkL0NhcnRlc2lhblxuICpcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICBmdW5jdGlvbiBkaW1BeGlzTWFwcGVyKGRpbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXhlc1tkaW1dO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9DYXJ0ZXNpYW5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQ2FydGVzaWFuID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fYXhlcyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2RpbUxpc3QgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgJyc7XG4gICAgfTtcblxuICAgIENhcnRlc2lhbi5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IENhcnRlc2lhbixcblxuICAgICAgICB0eXBlOiAnY2FydGVzaWFuJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGF4aXNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfHN0cmluZ30gZGltXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2Nvb3JkL0NhcnRlc2lhbn5BeGlzfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXhpczogZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F4ZXNbZGltXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGF4ZXMgbGlzdFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvY29vcmQvQ2FydGVzaWFufkF4aXM+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXhlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAodGhpcy5fZGltTGlzdCwgZGltQXhpc01hcHBlciwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBheGVzIGxpc3QgYnkgZ2l2ZW4gc2NhbGUgdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXhlc0J5U2NhbGU6IGZ1bmN0aW9uIChzY2FsZVR5cGUpIHtcbiAgICAgICAgICAgIHNjYWxlVHlwZSA9IHNjYWxlVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBeGVzKCksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF4aXMuc2NhbGUudHlwZSA9PT0gc2NhbGVUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBheGlzXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvQ2FydGVzaWFuLkF4aXN9XG4gICAgICAgICAqL1xuICAgICAgICBhZGRBeGlzOiBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgdmFyIGRpbSA9IGF4aXMuZGltO1xuXG4gICAgICAgICAgICB0aGlzLl9heGVzW2RpbV0gPSBheGlzO1xuXG4gICAgICAgICAgICB0aGlzLl9kaW1MaXN0LnB1c2goZGltKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCBkYXRhIHRvIGNvb3JkIGluIG5kIHNwYWNlXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj58T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHZhbFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPnxPYmplY3QuPHN0cmluZywgbnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGRhdGFUb0Nvb3JkOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNvb3JkQ29udmVydCh2YWwsICdkYXRhVG9Db29yZCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IGNvb3JkIGluIG5kIHNwYWNlIHRvIGRhdGFcbiAgICAgICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj58T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHZhbFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPnxPYmplY3QuPHN0cmluZywgbnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGNvb3JkVG9EYXRhOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNvb3JkQ29udmVydCh2YWwsICdjb29yZFRvRGF0YScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kYXRhQ29vcmRDb252ZXJ0OiBmdW5jdGlvbiAoaW5wdXQsIG1ldGhvZCkge1xuICAgICAgICAgICAgdmFyIGRpbUxpc3QgPSB0aGlzLl9kaW1MaXN0O1xuXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gaW5wdXQgaW5zdGFuY2VvZiBBcnJheSA/IFtdIDoge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBkaW0gPSBkaW1MaXN0W2ldO1xuICAgICAgICAgICAgICAgIHZhciBheGlzID0gdGhpcy5fYXhlc1tkaW1dO1xuXG4gICAgICAgICAgICAgICAgb3V0cHV0W2RpbV0gPSBheGlzW21ldGhvZF0oaW5wdXRbZGltXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDYXJ0ZXNpYW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbi5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n    var Axis = __webpack_require__(116);\n\n    /**\n     * Extend axis 2d\n     * @constructor module:echarts/coord/cartesian/Axis2D\n     * @extends {module:echarts/coord/cartesian/Axis}\n     * @param {string} dim\n     * @param {*} scale\n     * @param {Array.<number>} coordExtent\n     * @param {string} axisType\n     * @param {string} position\n     */\n    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n        Axis.call(this, dim, scale, coordExtent);\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = axisType || 'value';\n\n        /**\n         * Axis position\n         *  - 'top'\n         *  - 'bottom'\n         *  - 'left'\n         *  - 'right'\n         */\n        this.position = position || 'bottom';\n    };\n\n    Axis2D.prototype = {\n\n        constructor: Axis2D,\n\n        /**\n         * Index of axis, can be used as key\n         */\n        index: 0,\n        /**\n         * If axis is on the zero position of the other axis\n         * @type {boolean}\n         */\n        onZero: false,\n\n        /**\n         * Axis model\n         * @param {module:echarts/coord/cartesian/AxisModel}\n         */\n        model: null,\n\n        isHorizontal: function () {\n            var position = this.position;\n            return position === 'top' || position === 'bottom';\n        },\n\n        /**\n         * Each item cooresponds to this.getExtent(), which\n         * means globalExtent[0] may greater than globalExtent[1],\n         * unless `asc` is input.\n         *\n         * @param {boolean} [asc]\n         * @return {Array.<number>}\n         */\n        getGlobalExtent: function (asc) {\n            var ret = this.getExtent();\n            ret[0] = this.toGlobalCoord(ret[0]);\n            ret[1] = this.toGlobalCoord(ret[1]);\n            asc && ret[0] > ret[1] && ret.reverse();\n            return ret;\n        },\n\n        getOtherAxis: function () {\n            this.grid.getOtherAxis();\n        },\n\n        /**\n         * If label is ignored.\n         * Automatically used when axis is category and label can not be all shown\n         * @param  {number}  idx\n         * @return {boolean}\n         */\n        isLabelIgnored: function (idx) {\n            if (this.type === 'category') {\n                var labelInterval = this.getLabelInterval();\n                return ((typeof labelInterval === 'function')\n                    && !labelInterval(idx, this.scale.getLabel(idx)))\n                    || idx % (labelInterval + 1);\n            }\n        },\n\n        /**\n         * @override\n         */\n        pointToData: function (point, clamp) {\n            return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n        },\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var localCoord = axis.toLocalCoord(80);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toLocalCoord: null,\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var globalCoord = axis.toLocalCoord(40);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toGlobalCoord: null\n\n    };\n    zrUtil.inherits(Axis2D, Axis);\n\n    module.exports = Axis2D;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkQuanM/OTM0NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIxNTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgQXhpcyA9IHJlcXVpcmUoJy4uL0F4aXMnKTtcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBheGlzIDJkXG4gICAgICogQGNvbnN0cnVjdG9yIG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkRcbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXN9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICAgICAqIEBwYXJhbSB7Kn0gc2NhbGVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBjb29yZEV4dGVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBheGlzVHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvblxuICAgICAqL1xuICAgIHZhciBBeGlzMkQgPSBmdW5jdGlvbiAoZGltLCBzY2FsZSwgY29vcmRFeHRlbnQsIGF4aXNUeXBlLCBwb3NpdGlvbikge1xuICAgICAgICBBeGlzLmNhbGwodGhpcywgZGltLCBzY2FsZSwgY29vcmRFeHRlbnQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXhpcyB0eXBlXG4gICAgICAgICAqICAtICdjYXRlZ29yeSdcbiAgICAgICAgICogIC0gJ3ZhbHVlJ1xuICAgICAgICAgKiAgLSAndGltZSdcbiAgICAgICAgICogIC0gJ2xvZydcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IGF4aXNUeXBlIHx8ICd2YWx1ZSc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF4aXMgcG9zaXRpb25cbiAgICAgICAgICogIC0gJ3RvcCdcbiAgICAgICAgICogIC0gJ2JvdHRvbSdcbiAgICAgICAgICogIC0gJ2xlZnQnXG4gICAgICAgICAqICAtICdyaWdodCdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbiB8fCAnYm90dG9tJztcbiAgICB9O1xuXG4gICAgQXhpczJELnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQXhpczJELFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRleCBvZiBheGlzLCBjYW4gYmUgdXNlZCBhcyBrZXlcbiAgICAgICAgICovXG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYXhpcyBpcyBvbiB0aGUgemVybyBwb3NpdGlvbiBvZiB0aGUgb3RoZXIgYXhpc1xuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIG9uWmVybzogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF4aXMgbW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWw6IG51bGwsXG5cbiAgICAgICAgaXNIb3Jpem9udGFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVhY2ggaXRlbSBjb29yZXNwb25kcyB0byB0aGlzLmdldEV4dGVudCgpLCB3aGljaFxuICAgICAgICAgKiBtZWFucyBnbG9iYWxFeHRlbnRbMF0gbWF5IGdyZWF0ZXIgdGhhbiBnbG9iYWxFeHRlbnRbMV0sXG4gICAgICAgICAqIHVubGVzcyBgYXNjYCBpcyBpbnB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbYXNjXVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEdsb2JhbEV4dGVudDogZnVuY3Rpb24gKGFzYykge1xuICAgICAgICAgICAgdmFyIHJldCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgICAgICAgICByZXRbMF0gPSB0aGlzLnRvR2xvYmFsQ29vcmQocmV0WzBdKTtcbiAgICAgICAgICAgIHJldFsxXSA9IHRoaXMudG9HbG9iYWxDb29yZChyZXRbMV0pO1xuICAgICAgICAgICAgYXNjICYmIHJldFswXSA+IHJldFsxXSAmJiByZXQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRPdGhlckF4aXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5nZXRPdGhlckF4aXMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbGFiZWwgaXMgaWdub3JlZC5cbiAgICAgICAgICogQXV0b21hdGljYWxseSB1c2VkIHdoZW4gYXhpcyBpcyBjYXRlZ29yeSBhbmQgbGFiZWwgY2FuIG5vdCBiZSBhbGwgc2hvd25cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgaWR4XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc0xhYmVsSWdub3JlZDogZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbEludGVydmFsID0gdGhpcy5nZXRMYWJlbEludGVydmFsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgodHlwZW9mIGxhYmVsSW50ZXJ2YWwgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICYmICFsYWJlbEludGVydmFsKGlkeCwgdGhpcy5zY2FsZS5nZXRMYWJlbChpZHgpKSlcbiAgICAgICAgICAgICAgICAgICAgfHwgaWR4ICUgKGxhYmVsSW50ZXJ2YWwgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBwb2ludFRvRGF0YTogZnVuY3Rpb24gKHBvaW50LCBjbGFtcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29vcmRUb0RhdGEodGhpcy50b0xvY2FsQ29vcmQocG9pbnRbdGhpcy5kaW0gPT09ICd4JyA/IDAgOiAxXSksIGNsYW1wKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJhbnNmb3JtIGdsb2JhbCBjb29yZCB0byBsb2NhbCBjb29yZCxcbiAgICAgICAgICogaS5lLiB2YXIgbG9jYWxDb29yZCA9IGF4aXMudG9Mb2NhbENvb3JkKDgwKTtcbiAgICAgICAgICogZGVzaWduYXRlIGJ5IG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkLlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0b0xvY2FsQ29vcmQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zZm9ybSBnbG9iYWwgY29vcmQgdG8gbG9jYWwgY29vcmQsXG4gICAgICAgICAqIGkuZS4gdmFyIGdsb2JhbENvb3JkID0gYXhpcy50b0xvY2FsQ29vcmQoNDApO1xuICAgICAgICAgKiBkZXNpZ25hdGUgYnkgbW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWQuXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRvR2xvYmFsQ29vcmQ6IG51bGxcblxuICAgIH07XG4gICAgenJVdGlsLmluaGVyaXRzKEF4aXMyRCwgQXhpcyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEF4aXMyRDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vQXhpczJELmpzXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n// Grid 是在有直角坐标系的时候必须要存在的\n// 所以这里也要被 Cartesian2D 依赖\n\n\n    __webpack_require__(158);\n\n    var ComponentModel = __webpack_require__(85);\n\n    module.exports = ComponentModel.extend({\n\n        type: 'grid',\n\n        dependencies: ['xAxis', 'yAxis'],\n\n        layoutMode: 'box',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Grid}\n         */\n        coordinateSystem: null,\n\n        defaultOption: {\n            show: false,\n            zlevel: 0,\n            z: 0,\n            left: '10%',\n            top: 60,\n            right: '10%',\n            bottom: 60,\n            // If grid size contain label\n            containLabel: false,\n            // width: {totalWidth} - left - right,\n            // height: {totalHeight} - top - bottom,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 1,\n            borderColor: '#ccc'\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWwuanM/MTgxNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQyx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiMTU3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gR3JpZCDmmK/lnKjmnInnm7Top5LlnZDmoIfns7vnmoTml7blgJnlv4XpobvopoHlrZjlnKjnmoRcbi8vIOaJgOS7pei/memHjOS5n+imgeiiqyBDYXJ0ZXNpYW4yRCDkvp3otZZcblxuXG4gICAgcmVxdWlyZSgnLi9BeGlzTW9kZWwnKTtcblxuICAgIHZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL0NvbXBvbmVudCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnRNb2RlbC5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdncmlkJyxcblxuICAgICAgICBkZXBlbmRlbmNpZXM6IFsneEF4aXMnLCAneUF4aXMnXSxcblxuICAgICAgICBsYXlvdXRNb2RlOiAnYm94JyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkfVxuICAgICAgICAgKi9cbiAgICAgICAgY29vcmRpbmF0ZVN5c3RlbTogbnVsbCxcblxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgIHpsZXZlbDogMCxcbiAgICAgICAgICAgIHo6IDAsXG4gICAgICAgICAgICBsZWZ0OiAnMTAlJyxcbiAgICAgICAgICAgIHRvcDogNjAsXG4gICAgICAgICAgICByaWdodDogJzEwJScsXG4gICAgICAgICAgICBib3R0b206IDYwLFxuICAgICAgICAgICAgLy8gSWYgZ3JpZCBzaXplIGNvbnRhaW4gbGFiZWxcbiAgICAgICAgICAgIGNvbnRhaW5MYWJlbDogZmFsc2UsXG4gICAgICAgICAgICAvLyB3aWR0aDoge3RvdGFsV2lkdGh9IC0gbGVmdCAtIHJpZ2h0LFxuICAgICAgICAgICAgLy8gaGVpZ2h0OiB7dG90YWxIZWlnaHR9IC0gdG9wIC0gYm90dG9tLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnI2NjYydcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDE1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var ComponentModel = __webpack_require__(85);\n    var zrUtil = __webpack_require__(20);\n    var axisModelCreator = __webpack_require__(159);\n\n    var AxisModel = ComponentModel.extend({\n\n        type: 'cartesian2dAxis',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Axis2D}\n         */\n        axis: null,\n\n        /**\n         * @override\n         */\n        init: function () {\n            AxisModel.superApply(this, 'init', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function () {\n            AxisModel.superApply(this, 'mergeOption', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        restoreData: function () {\n            AxisModel.superApply(this, 'restoreData', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         * @return {module:echarts/model/Component}\n         */\n        getCoordSysModel: function () {\n            return this.ecModel.queryComponents({\n                mainType: 'grid',\n                index: this.option.gridIndex,\n                id: this.option.gridId\n            })[0];\n        }\n\n    });\n\n    function getAxisType(axisDim, option) {\n        // Default axis with data is category axis\n        return option.type || (option.data ? 'category' : 'value');\n    }\n\n    zrUtil.merge(AxisModel.prototype, __webpack_require__(128));\n\n    var extraOption = {\n        // gridIndex: 0,\n        // gridId: '',\n\n        // Offset is for multiple axis on the same position\n        offset: 0\n    };\n\n    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\n    module.exports = AxisModel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWwuanM/MDU3MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTU4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKCcuLi8uLi9tb2RlbC9Db21wb25lbnQnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGF4aXNNb2RlbENyZWF0b3IgPSByZXF1aXJlKCcuLi9heGlzTW9kZWxDcmVhdG9yJyk7XG5cbiAgICB2YXIgQXhpc01vZGVsID0gQ29tcG9uZW50TW9kZWwuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnY2FydGVzaWFuMmRBeGlzJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkR9XG4gICAgICAgICAqL1xuICAgICAgICBheGlzOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIEF4aXNNb2RlbC5zdXBlckFwcGx5KHRoaXMsICdpbml0JywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRSYW5nZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBBeGlzTW9kZWwuc3VwZXJBcHBseSh0aGlzLCAnbWVyZ2VPcHRpb24nLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFJhbmdlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzdG9yZURhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIEF4aXNNb2RlbC5zdXBlckFwcGx5KHRoaXMsICdyZXN0b3JlRGF0YScsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0UmFuZ2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH1cbiAgICAgICAgICovXG4gICAgICAgIGdldENvb3JkU3lzTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgICAgICAgICBtYWluVHlwZTogJ2dyaWQnLFxuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLm9wdGlvbi5ncmlkSW5kZXgsXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMub3B0aW9uLmdyaWRJZFxuICAgICAgICAgICAgfSlbMF07XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZ2V0QXhpc1R5cGUoYXhpc0RpbSwgb3B0aW9uKSB7XG4gICAgICAgIC8vIERlZmF1bHQgYXhpcyB3aXRoIGRhdGEgaXMgY2F0ZWdvcnkgYXhpc1xuICAgICAgICByZXR1cm4gb3B0aW9uLnR5cGUgfHwgKG9wdGlvbi5kYXRhID8gJ2NhdGVnb3J5JyA6ICd2YWx1ZScpO1xuICAgIH1cblxuICAgIHpyVXRpbC5tZXJnZShBeGlzTW9kZWwucHJvdG90eXBlLCByZXF1aXJlKCcuLi9heGlzTW9kZWxDb21tb25NaXhpbicpKTtcblxuICAgIHZhciBleHRyYU9wdGlvbiA9IHtcbiAgICAgICAgLy8gZ3JpZEluZGV4OiAwLFxuICAgICAgICAvLyBncmlkSWQ6ICcnLFxuXG4gICAgICAgIC8vIE9mZnNldCBpcyBmb3IgbXVsdGlwbGUgYXhpcyBvbiB0aGUgc2FtZSBwb3NpdGlvblxuICAgICAgICBvZmZzZXQ6IDBcbiAgICB9O1xuXG4gICAgYXhpc01vZGVsQ3JlYXRvcigneCcsIEF4aXNNb2RlbCwgZ2V0QXhpc1R5cGUsIGV4dHJhT3B0aW9uKTtcbiAgICBheGlzTW9kZWxDcmVhdG9yKCd5JywgQXhpc01vZGVsLCBnZXRBeGlzVHlwZSwgZXh0cmFPcHRpb24pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBeGlzTW9kZWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("\n\n    var axisDefault = __webpack_require__(160);\n    var zrUtil = __webpack_require__(20);\n    var ComponentModel = __webpack_require__(85);\n    var layout = __webpack_require__(87);\n\n    // FIXME axisType is fixed ?\n    var AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\n    /**\n     * Generate sub axis model class\n     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n     * @param {module:echarts/model/Component} BaseAxisModelClass\n     * @param {Function} axisTypeDefaulter\n     * @param {Object} [extraDefaultOption]\n     */\n    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\n        zrUtil.each(AXIS_TYPES, function (axisType) {\n\n            BaseAxisModelClass.extend({\n\n                type: axisName + 'Axis.' + axisType,\n\n                mergeDefaultAndTheme: function (option, ecModel) {\n                    var layoutMode = this.layoutMode;\n                    var inputPositionParams = layoutMode\n                        ? layout.getLayoutParams(option) : {};\n\n                    var themeModel = ecModel.getTheme();\n                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n                    zrUtil.merge(option, this.getDefaultOption());\n\n                    option.type = axisTypeDefaulter(axisName, option);\n\n                    if (layoutMode) {\n                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                    }\n                },\n\n                defaultOption: zrUtil.mergeAll(\n                    [\n                        {},\n                        axisDefault[axisType + 'Axis'],\n                        extraDefaultOption\n                    ],\n                    true\n                )\n            });\n        });\n\n        ComponentModel.registerSubTypeDefaulter(\n            axisName + 'Axis',\n            zrUtil.curry(axisTypeDefaulter, axisName)\n        );\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2Nvb3JkL2F4aXNNb2RlbENyZWF0b3IuanM/MzRlNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLCtCQUErQjtBQUM5QyxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBheGlzRGVmYXVsdCA9IHJlcXVpcmUoJy4vYXhpc0RlZmF1bHQnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWwvQ29tcG9uZW50Jyk7XG4gICAgdmFyIGxheW91dCA9IHJlcXVpcmUoJy4uL3V0aWwvbGF5b3V0Jyk7XG5cbiAgICAvLyBGSVhNRSBheGlzVHlwZSBpcyBmaXhlZCA/XG4gICAgdmFyIEFYSVNfVFlQRVMgPSBbJ3ZhbHVlJywgJ2NhdGVnb3J5JywgJ3RpbWUnLCAnbG9nJ107XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBzdWIgYXhpcyBtb2RlbCBjbGFzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBheGlzTmFtZSAneCcgJ3knICdyYWRpdXMnICdhbmdsZScgJ3BhcmFsbGVsJ1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBCYXNlQXhpc01vZGVsQ2xhc3NcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBheGlzVHlwZURlZmF1bHRlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0cmFEZWZhdWx0T3B0aW9uXVxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGF4aXNOYW1lLCBCYXNlQXhpc01vZGVsQ2xhc3MsIGF4aXNUeXBlRGVmYXVsdGVyLCBleHRyYURlZmF1bHRPcHRpb24pIHtcblxuICAgICAgICB6clV0aWwuZWFjaChBWElTX1RZUEVTLCBmdW5jdGlvbiAoYXhpc1R5cGUpIHtcblxuICAgICAgICAgICAgQmFzZUF4aXNNb2RlbENsYXNzLmV4dGVuZCh7XG5cbiAgICAgICAgICAgICAgICB0eXBlOiBheGlzTmFtZSArICdBeGlzLicgKyBheGlzVHlwZSxcblxuICAgICAgICAgICAgICAgIG1lcmdlRGVmYXVsdEFuZFRoZW1lOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGxheW91dE1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbGF5b3V0LmdldExheW91dFBhcmFtcyhvcHRpb24pIDoge307XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZW1lTW9kZWwgPSBlY01vZGVsLmdldFRoZW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoZW1lTW9kZWwuZ2V0KGF4aXNUeXBlICsgJ0F4aXMnKSk7XG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpKTtcblxuICAgICAgICAgICAgICAgICAgICBvcHRpb24udHlwZSA9IGF4aXNUeXBlRGVmYXVsdGVyKGF4aXNOYW1lLCBvcHRpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbShvcHRpb24sIGlucHV0UG9zaXRpb25QYXJhbXMsIGxheW91dE1vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb246IHpyVXRpbC5tZXJnZUFsbChcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzRGVmYXVsdFtheGlzVHlwZSArICdBeGlzJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYURlZmF1bHRPcHRpb25cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBDb21wb25lbnRNb2RlbC5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIoXG4gICAgICAgICAgICBheGlzTmFtZSArICdBeGlzJyxcbiAgICAgICAgICAgIHpyVXRpbC5jdXJyeShheGlzVHlwZURlZmF1bHRlciwgYXhpc05hbWUpXG4gICAgICAgICk7XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jb29yZC9heGlzTW9kZWxDcmVhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n\n    var defaultOption = {\n        show: true,\n        zlevel: 0,                  // 一级层叠\n        z: 0,                       // 二级层叠\n        // 反向坐标轴\n        inverse: false,\n\n        // 坐标轴名字，默认为空\n        name: '',\n        // 坐标轴名字位置，支持'start' | 'middle' | 'end'\n        nameLocation: 'end',\n        // 坐标轴名字旋转，degree。\n        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n        nameTruncate: {\n            maxWidth: null,\n            ellipsis: '...',\n            placeholder: '.'\n        },\n        // 坐标轴文字样式，默认取全局样式\n        nameTextStyle: {},\n        // 文字与轴线距离\n        nameGap: 15,\n\n        silent: false, // Default false to support tooltip.\n        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\n        tooltip: {\n            show: false\n        },\n\n        axisPointer: {},\n\n        // 坐标轴线\n        axisLine: {\n            // 默认显示，属性show控制显示与否\n            show: true,\n            onZero: true,\n            // 属性lineStyle控制线条样式\n            lineStyle: {\n                color: '#333',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // 坐标轴小标记\n        axisTick: {\n            // 属性show控制显示与否，默认显示\n            show: true,\n            // 控制小标记是否在grid里\n            inside: false,\n            // 属性length控制线长\n            length: 5,\n            // 属性lineStyle控制线条样式\n            lineStyle: {\n                width: 1\n            }\n        },\n        // 坐标轴文本标签，详见axis.axisLabel\n        axisLabel: {\n            show: true,\n            // 控制文本标签是否在grid里\n            inside: false,\n            rotate: 0,\n            showMinLabel: null, // true | false | null (auto)\n            showMaxLabel: null, // true | false | null (auto)\n            margin: 8,\n            // formatter: null,\n            // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n            textStyle: {\n                fontSize: 12\n            }\n        },\n        // 分隔线\n        splitLine: {\n            // 默认显示，属性show控制显示与否\n            show: true,\n            // 属性lineStyle（详见lineStyle）控制线条样式\n            lineStyle: {\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // 分隔区域\n        splitArea: {\n            // 默认不显示，属性show控制显示与否\n            show: false,\n            // 属性areaStyle（详见areaStyle）控制区域样式\n            areaStyle: {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    };\n\n    var categoryAxis = zrUtil.merge({\n        // 类目起始和结束两端空白策略\n        boundaryGap: true,\n        // splitArea: {\n            // show: false\n        // },\n        splitLine: {\n            show: false\n        },\n        // 坐标轴小标记\n        axisTick: {\n            // If tick is align with label when boundaryGap is true\n            alignWithLabel: false,\n            interval: 'auto'\n        },\n        // 坐标轴文本标签，详见axis.axisLabel\n        axisLabel: {\n            interval: 'auto'\n        }\n    }, defaultOption);\n\n    var valueAxis = zrUtil.merge({\n        // 数值起始和结束两端空白策略\n        boundaryGap: [0, 0],\n        // 最小值, 设置成 'dataMin' 则从数据中计算最小值\n        // min: null,\n        // 最大值，设置成 'dataMax' 则从数据中计算最大值\n        // max: null,\n        // Readonly prop, specifies start value of the range when using data zoom.\n        // rangeStart: null\n        // Readonly prop, specifies end value of the range when using data zoom.\n        // rangeEnd: null\n        // 脱离0值比例，放大聚焦到最终_min，_max区间\n        // scale: false,\n        // 分割段数，默认为5\n        splitNumber: 5\n        // Minimum interval\n        // minInterval: null\n    }, defaultOption);\n\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n        scale: true,\n        min: 'dataMin',\n        max: 'dataMax'\n    }, valueAxis);\n\n    var logAxis = zrUtil.defaults({\n        scale: true,\n        logBase: 10\n    }, valueAxis);\n\n    module.exports = {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2Nvb3JkL2F4aXNEZWZhdWx0LmpzPzQ0OTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVULHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTYwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgemxldmVsOiAwLCAgICAgICAgICAgICAgICAgIC8vIOS4gOe6p+WxguWPoFxuICAgICAgICB6OiAwLCAgICAgICAgICAgICAgICAgICAgICAgLy8g5LqM57qn5bGC5Y+gXG4gICAgICAgIC8vIOWPjeWQkeWdkOagh+i9tFxuICAgICAgICBpbnZlcnNlOiBmYWxzZSxcblxuICAgICAgICAvLyDlnZDmoIfovbTlkI3lrZfvvIzpu5jorqTkuLrnqbpcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIC8vIOWdkOagh+i9tOWQjeWtl+S9jee9ru+8jOaUr+aMgSdzdGFydCcgfCAnbWlkZGxlJyB8ICdlbmQnXG4gICAgICAgIG5hbWVMb2NhdGlvbjogJ2VuZCcsXG4gICAgICAgIC8vIOWdkOagh+i9tOWQjeWtl+aXi+i9rO+8jGRlZ3JlZeOAglxuICAgICAgICBuYW1lUm90YXRlOiBudWxsLCAvLyBBZGFwdCB0byBheGlzIHJvdGF0ZSwgd2hlbiBuYW1lTG9jYXRpb24gaXMgJ21pZGRsZScuXG4gICAgICAgIG5hbWVUcnVuY2F0ZToge1xuICAgICAgICAgICAgbWF4V2lkdGg6IG51bGwsXG4gICAgICAgICAgICBlbGxpcHNpczogJy4uLicsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogJy4nXG4gICAgICAgIH0sXG4gICAgICAgIC8vIOWdkOagh+i9tOaWh+Wtl+agt+W8j++8jOm7mOiupOWPluWFqOWxgOagt+W8j1xuICAgICAgICBuYW1lVGV4dFN0eWxlOiB7fSxcbiAgICAgICAgLy8g5paH5a2X5LiO6L2057q/6Led56a7XG4gICAgICAgIG5hbWVHYXA6IDE1LFxuXG4gICAgICAgIHNpbGVudDogZmFsc2UsIC8vIERlZmF1bHQgZmFsc2UgdG8gc3VwcG9ydCB0b29sdGlwLlxuICAgICAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlLCAvLyBEZWZhdWx0IGZhbHNlIHRvIGF2b2lkIGxlZ2FjeSB1c2VyIGV2ZW50IGxpc3RlbmVyIGZhaWwuXG5cbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICBheGlzUG9pbnRlcjoge30sXG5cbiAgICAgICAgLy8g5Z2Q5qCH6L2057q/XG4gICAgICAgIGF4aXNMaW5lOiB7XG4gICAgICAgICAgICAvLyDpu5jorqTmmL7npLrvvIzlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCmXG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgb25aZXJvOiB0cnVlLFxuICAgICAgICAgICAgLy8g5bGe5oCnbGluZVN0eWxl5o6n5Yi257q/5p2h5qC35byPXG4gICAgICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMzMzMnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8g5Z2Q5qCH6L205bCP5qCH6K6wXG4gICAgICAgIGF4aXNUaWNrOiB7XG4gICAgICAgICAgICAvLyDlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCm77yM6buY6K6k5pi+56S6XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgLy8g5o6n5Yi25bCP5qCH6K6w5piv5ZCm5ZyoZ3JpZOmHjFxuICAgICAgICAgICAgaW5zaWRlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIOWxnuaAp2xlbmd0aOaOp+WItue6v+mVv1xuICAgICAgICAgICAgbGVuZ3RoOiA1LFxuICAgICAgICAgICAgLy8g5bGe5oCnbGluZVN0eWxl5o6n5Yi257q/5p2h5qC35byPXG4gICAgICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyDlnZDmoIfovbTmlofmnKzmoIfnrb7vvIzor6bop4FheGlzLmF4aXNMYWJlbFxuICAgICAgICBheGlzTGFiZWw6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAvLyDmjqfliLbmlofmnKzmoIfnrb7mmK/lkKblnKhncmlk6YeMXG4gICAgICAgICAgICBpbnNpZGU6IGZhbHNlLFxuICAgICAgICAgICAgcm90YXRlOiAwLFxuICAgICAgICAgICAgc2hvd01pbkxhYmVsOiBudWxsLCAvLyB0cnVlIHwgZmFsc2UgfCBudWxsIChhdXRvKVxuICAgICAgICAgICAgc2hvd01heExhYmVsOiBudWxsLCAvLyB0cnVlIHwgZmFsc2UgfCBudWxsIChhdXRvKVxuICAgICAgICAgICAgbWFyZ2luOiA4LFxuICAgICAgICAgICAgLy8gZm9ybWF0dGVyOiBudWxsLFxuICAgICAgICAgICAgLy8g5YW25L2Z5bGe5oCn6buY6K6k5L2/55So5YWo5bGA5paH5pys5qC35byP77yM6K+m6KeBVEVYVFNUWUxFXG4gICAgICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8g5YiG6ZqU57q/XG4gICAgICAgIHNwbGl0TGluZToge1xuICAgICAgICAgICAgLy8g6buY6K6k5pi+56S677yM5bGe5oCnc2hvd+aOp+WItuaYvuekuuS4juWQplxuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIOWxnuaAp2xpbmVTdHlsZe+8iOivpuingWxpbmVTdHlsZe+8ieaOp+WItue6v+adoeagt+W8j1xuICAgICAgICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IFsnI2NjYyddLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8g5YiG6ZqU5Yy65Z+fXG4gICAgICAgIHNwbGl0QXJlYToge1xuICAgICAgICAgICAgLy8g6buY6K6k5LiN5pi+56S677yM5bGe5oCnc2hvd+aOp+WItuaYvuekuuS4juWQplxuICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICAvLyDlsZ7mgKdhcmVhU3R5bGXvvIjor6bop4FhcmVhU3R5bGXvvInmjqfliLbljLrln5/moLflvI9cbiAgICAgICAgICAgIGFyZWFTdHlsZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBbJ3JnYmEoMjUwLDI1MCwyNTAsMC4zKScsJ3JnYmEoMjAwLDIwMCwyMDAsMC4zKSddXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNhdGVnb3J5QXhpcyA9IHpyVXRpbC5tZXJnZSh7XG4gICAgICAgIC8vIOexu+ebrui1t+Wni+WSjOe7k+adn+S4pOerr+epuueZveetlueVpVxuICAgICAgICBib3VuZGFyeUdhcDogdHJ1ZSxcbiAgICAgICAgLy8gc3BsaXRBcmVhOiB7XG4gICAgICAgICAgICAvLyBzaG93OiBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICBzcGxpdExpbmU6IHtcbiAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIC8vIOWdkOagh+i9tOWwj+agh+iusFxuICAgICAgICBheGlzVGljazoge1xuICAgICAgICAgICAgLy8gSWYgdGljayBpcyBhbGlnbiB3aXRoIGxhYmVsIHdoZW4gYm91bmRhcnlHYXAgaXMgdHJ1ZVxuICAgICAgICAgICAgYWxpZ25XaXRoTGFiZWw6IGZhbHNlLFxuICAgICAgICAgICAgaW50ZXJ2YWw6ICdhdXRvJ1xuICAgICAgICB9LFxuICAgICAgICAvLyDlnZDmoIfovbTmlofmnKzmoIfnrb7vvIzor6bop4FheGlzLmF4aXNMYWJlbFxuICAgICAgICBheGlzTGFiZWw6IHtcbiAgICAgICAgICAgIGludGVydmFsOiAnYXV0bydcbiAgICAgICAgfVxuICAgIH0sIGRlZmF1bHRPcHRpb24pO1xuXG4gICAgdmFyIHZhbHVlQXhpcyA9IHpyVXRpbC5tZXJnZSh7XG4gICAgICAgIC8vIOaVsOWAvOi1t+Wni+WSjOe7k+adn+S4pOerr+epuueZveetlueVpVxuICAgICAgICBib3VuZGFyeUdhcDogWzAsIDBdLFxuICAgICAgICAvLyDmnIDlsI/lgLwsIOiuvue9ruaIkCAnZGF0YU1pbicg5YiZ5LuO5pWw5o2u5Lit6K6h566X5pyA5bCP5YC8XG4gICAgICAgIC8vIG1pbjogbnVsbCxcbiAgICAgICAgLy8g5pyA5aSn5YC877yM6K6+572u5oiQICdkYXRhTWF4JyDliJnku47mlbDmja7kuK3orqHnrpfmnIDlpKflgLxcbiAgICAgICAgLy8gbWF4OiBudWxsLFxuICAgICAgICAvLyBSZWFkb25seSBwcm9wLCBzcGVjaWZpZXMgc3RhcnQgdmFsdWUgb2YgdGhlIHJhbmdlIHdoZW4gdXNpbmcgZGF0YSB6b29tLlxuICAgICAgICAvLyByYW5nZVN0YXJ0OiBudWxsXG4gICAgICAgIC8vIFJlYWRvbmx5IHByb3AsIHNwZWNpZmllcyBlbmQgdmFsdWUgb2YgdGhlIHJhbmdlIHdoZW4gdXNpbmcgZGF0YSB6b29tLlxuICAgICAgICAvLyByYW5nZUVuZDogbnVsbFxuICAgICAgICAvLyDohLHnprsw5YC85q+U5L6L77yM5pS+5aSn6IGa54Sm5Yiw5pyA57uIX21pbu+8jF9tYXjljLrpl7RcbiAgICAgICAgLy8gc2NhbGU6IGZhbHNlLFxuICAgICAgICAvLyDliIblibLmrrXmlbDvvIzpu5jorqTkuLo1XG4gICAgICAgIHNwbGl0TnVtYmVyOiA1XG4gICAgICAgIC8vIE1pbmltdW0gaW50ZXJ2YWxcbiAgICAgICAgLy8gbWluSW50ZXJ2YWw6IG51bGxcbiAgICB9LCBkZWZhdWx0T3B0aW9uKTtcblxuICAgIC8vIEZJWE1FXG4gICAgdmFyIHRpbWVBeGlzID0genJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgc2NhbGU6IHRydWUsXG4gICAgICAgIG1pbjogJ2RhdGFNaW4nLFxuICAgICAgICBtYXg6ICdkYXRhTWF4J1xuICAgIH0sIHZhbHVlQXhpcyk7XG5cbiAgICB2YXIgbG9nQXhpcyA9IHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgIHNjYWxlOiB0cnVlLFxuICAgICAgICBsb2dCYXNlOiAxMFxuICAgIH0sIHZhbHVlQXhpcyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgY2F0ZWdvcnlBeGlzOiBjYXRlZ29yeUF4aXMsXG4gICAgICAgIHZhbHVlQXhpczogdmFsdWVBeGlzLFxuICAgICAgICB0aW1lQXhpczogdGltZUF4aXMsXG4gICAgICAgIGxvZ0F4aXM6IGxvZ0F4aXNcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2Nvb3JkL2F4aXNEZWZhdWx0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\n\n    module.exports = __webpack_require__(162).extend({\n\n        type: 'series.bar',\n\n        dependencies: ['grid', 'polar'],\n\n        brushSelector: 'rect'\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2Jhci9CYXJTZXJpZXMuanM/NjFjZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSyIsImZpbGUiOiIxNjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9CYXNlQmFyU2VyaWVzJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnc2VyaWVzLmJhcicsXG5cbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbJ2dyaWQnLCAncG9sYXInXSxcblxuICAgICAgICBicnVzaFNlbGVjdG9yOiAncmVjdCdcbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jaGFydC9iYXIvQmFyU2VyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var SeriesModel = __webpack_require__(94);\n    var createListFromArray = __webpack_require__(125);\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.__base_bar__',\n\n        getInitialData: function (option, ecModel) {\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        getMarkerPosition: function (value) {\n            var coordSys = this.coordinateSystem;\n            if (coordSys) {\n                // PENDING if clamp ?\n                var pt = coordSys.dataToPoint(value, true);\n                var data = this.getData();\n                var offset = data.getLayout('offset');\n                var size = data.getLayout('size');\n                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n                pt[offsetIndex] += offset + size / 2;\n                return pt;\n            }\n            return [NaN, NaN];\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // 一级层叠\n            z: 2,                       // 二级层叠\n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n            // stack: null\n\n            // Cartesian coordinate system\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // 最小高度改为0\n            barMinHeight: 0,\n            // 最小角度为0，仅对极坐标系下的柱状图有效\n            barMinAngle: 0,\n            // cursor: null,\n\n            // barMaxWidth: null,\n            // 默认自适应\n            // barWidth: null,\n            // 柱间距离，默认为柱形宽度的30%，可设固定值\n            // barGap: '30%',\n            // 类目间柱形距离，默认为类目间距的20%，可设固定值\n            // barCategoryGap: '20%',\n            // label: {\n            //     normal: {\n            //         show: false\n            //     }\n            // },\n            itemStyle: {\n                normal: {\n                    // color: '各异'\n                },\n                emphasis: {}\n            }\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2Jhci9CYXNlQmFyU2VyaWVzLmpzPzcyZjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLIiwiZmlsZSI6IjE2Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIFNlcmllc01vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvU2VyaWVzJyk7XG4gICAgdmFyIGNyZWF0ZUxpc3RGcm9tQXJyYXkgPSByZXF1aXJlKCcuLi9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTZXJpZXNNb2RlbC5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdzZXJpZXMuX19iYXNlX2Jhcl9fJyxcblxuICAgICAgICBnZXRJbml0aWFsRGF0YTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpc3RGcm9tQXJyYXkob3B0aW9uLmRhdGEsIHRoaXMsIGVjTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldE1hcmtlclBvc2l0aW9uOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIGlmIChjb29yZFN5cykge1xuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgaWYgY2xhbXAgP1xuICAgICAgICAgICAgICAgIHZhciBwdCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBkYXRhLmdldExheW91dCgnb2Zmc2V0Jyk7XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBkYXRhLmdldExheW91dCgnc2l6ZScpO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRJbmRleCA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCkuaXNIb3Jpem9udGFsKCkgPyAwIDogMTtcbiAgICAgICAgICAgICAgICBwdFtvZmZzZXRJbmRleF0gKz0gb2Zmc2V0ICsgc2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtOYU4sIE5hTl07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xuICAgICAgICAgICAgemxldmVsOiAwLCAgICAgICAgICAgICAgICAgIC8vIOS4gOe6p+WxguWPoFxuICAgICAgICAgICAgejogMiwgICAgICAgICAgICAgICAgICAgICAgIC8vIOS6jOe6p+WxguWPoFxuICAgICAgICAgICAgY29vcmRpbmF0ZVN5c3RlbTogJ2NhcnRlc2lhbjJkJyxcbiAgICAgICAgICAgIGxlZ2VuZEhvdmVyTGluazogdHJ1ZSxcbiAgICAgICAgICAgIC8vIHN0YWNrOiBudWxsXG5cbiAgICAgICAgICAgIC8vIENhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbVxuICAgICAgICAgICAgLy8geEF4aXNJbmRleDogMCxcbiAgICAgICAgICAgIC8vIHlBeGlzSW5kZXg6IDAsXG5cbiAgICAgICAgICAgIC8vIOacgOWwj+mrmOW6puaUueS4ujBcbiAgICAgICAgICAgIGJhck1pbkhlaWdodDogMCxcbiAgICAgICAgICAgIC8vIOacgOWwj+inkuW6puS4ujDvvIzku4Xlr7nmnoHlnZDmoIfns7vkuIvnmoTmn7Hnirblm77mnInmlYhcbiAgICAgICAgICAgIGJhck1pbkFuZ2xlOiAwLFxuICAgICAgICAgICAgLy8gY3Vyc29yOiBudWxsLFxuXG4gICAgICAgICAgICAvLyBiYXJNYXhXaWR0aDogbnVsbCxcbiAgICAgICAgICAgIC8vIOm7mOiupOiHqumAguW6lFxuICAgICAgICAgICAgLy8gYmFyV2lkdGg6IG51bGwsXG4gICAgICAgICAgICAvLyDmn7Hpl7Tot53nprvvvIzpu5jorqTkuLrmn7HlvaLlrr3luqbnmoQzMCXvvIzlj6/orr7lm7rlrprlgLxcbiAgICAgICAgICAgIC8vIGJhckdhcDogJzMwJScsXG4gICAgICAgICAgICAvLyDnsbvnm67pl7Tmn7HlvaLot53nprvvvIzpu5jorqTkuLrnsbvnm67pl7Tot53nmoQyMCXvvIzlj6/orr7lm7rlrprlgLxcbiAgICAgICAgICAgIC8vIGJhckNhdGVnb3J5R2FwOiAnMjAlJyxcbiAgICAgICAgICAgIC8vIGxhYmVsOiB7XG4gICAgICAgICAgICAvLyAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAvLyAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfSxcbiAgICAgICAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2xvcjogJ+WQhOW8gidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVtcGhhc2lzOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY2hhcnQvYmFyL0Jhc2VCYXJTZXJpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var zrUtil = __webpack_require__(20);\n    var graphic = __webpack_require__(34);\n    var helper = __webpack_require__(164);\n\n    var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth'];\n\n    // FIXME\n    // Just for compatible with ec2.\n    zrUtil.extend(__webpack_require__(28).prototype, __webpack_require__(165));\n\n    var BarView = __webpack_require__(17).extendChartView({\n\n        type: 'bar',\n\n        render: function (seriesModel, ecModel, api) {\n            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n            if (coordinateSystemType === 'cartesian2d'\n                || coordinateSystemType === 'polar'\n            ) {\n                this._render(seriesModel, ecModel, api);\n            }\n            else if (__DEV__) {\n                console.warn('Only cartesian2d and polar supported for bar.');\n            }\n\n            return this.group;\n        },\n\n        dispose: zrUtil.noop,\n\n        _render: function (seriesModel, ecModel, api) {\n            var group = this.group;\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            var coord = seriesModel.coordinateSystem;\n            var baseAxis = coord.getBaseAxis();\n            var isHorizontalOrRadial;\n\n            if (coord.type === 'cartesian2d') {\n                isHorizontalOrRadial = baseAxis.isHorizontal();\n            }\n            else if (coord.type === 'polar') {\n                isHorizontalOrRadial = baseAxis.dim === 'angle';\n            }\n\n            var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n\n            data.diff(oldData)\n                .add(function (dataIndex) {\n                    if (!data.hasValue(dataIndex)) {\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(dataIndex);\n                    var layout = getLayout[coord.type](data, dataIndex, itemModel);\n                    var el = elementCreator[coord.type](\n                        data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel\n                    );\n                    data.setItemGraphicEl(dataIndex, el);\n                    group.add(el);\n\n                    updateStyle(\n                        el, data, dataIndex, itemModel, layout,\n                        seriesModel, isHorizontalOrRadial, coord.type === 'polar'\n                    );\n                })\n                .update(function (newIndex, oldIndex) {\n                    var el = oldData.getItemGraphicEl(oldIndex);\n\n                    if (!data.hasValue(newIndex)) {\n                        group.remove(el);\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(newIndex);\n                    var layout = getLayout[coord.type](data, newIndex, itemModel);\n\n                    if (el) {\n                        graphic.updateProps(el, {shape: layout}, animationModel, newIndex);\n                    }\n                    else {\n                        el = elementCreator[coord.type](\n                            data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true\n                        );\n                    }\n\n                    data.setItemGraphicEl(newIndex, el);\n                    // Add back\n                    group.add(el);\n\n                    updateStyle(\n                        el, data, newIndex, itemModel, layout,\n                        seriesModel, isHorizontalOrRadial, coord.type === 'polar'\n                    );\n                })\n                .remove(function (dataIndex) {\n                    var el = oldData.getItemGraphicEl(dataIndex);\n                    if (coord.type === 'cartesian2d') {\n                        el && removeRect(dataIndex, animationModel, el);\n                    }\n                    else {\n                        el && removeSector(dataIndex, animationModel, el);\n                    }\n                })\n                .execute();\n\n            this._data = data;\n        },\n\n        remove: function (ecModel, api) {\n            var group = this.group;\n            var data = this._data;\n            if (ecModel.get('animation')) {\n                if (data) {\n                    data.eachItemGraphicEl(function (el) {\n                        if (el.type === 'sector') {\n                            removeSector(el.dataIndex, ecModel, el);\n                        }\n                        else {\n                            removeRect(el.dataIndex, ecModel, el);\n                        }\n                    });\n                }\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    });\n\n    var elementCreator = {\n\n        cartesian2d: function (\n            data, dataIndex, itemModel, layout, isHorizontal,\n            animationModel, isUpdate\n        ) {\n            var rect = new graphic.Rect({shape: zrUtil.extend({}, layout)});\n\n            // Animation\n            if (animationModel) {\n                var rectShape = rect.shape;\n                var animateProperty = isHorizontal ? 'height' : 'width';\n                var animateTarget = {};\n                rectShape[animateProperty] = 0;\n                animateTarget[animateProperty] = layout[animateProperty];\n                graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n                    shape: animateTarget\n                }, animationModel, dataIndex);\n            }\n\n            return rect;\n        },\n\n        polar: function (\n            data, dataIndex, itemModel, layout, isRadial,\n            animationModel, isUpdate\n        ) {\n            var sector = new graphic.Sector({shape: zrUtil.extend({}, layout)});\n\n            // Animation\n            if (animationModel) {\n                var sectorShape = sector.shape;\n                var animateProperty = isRadial ? 'r' : 'endAngle';\n                var animateTarget = {};\n                sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n                animateTarget[animateProperty] = layout[animateProperty];\n                graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {\n                    shape: animateTarget\n                }, animationModel, dataIndex);\n            }\n\n            return sector;\n        }\n    };\n\n    function removeRect(dataIndex, animationModel, el) {\n        // Not show text when animating\n        el.style.text = '';\n        graphic.updateProps(el, {\n            shape: {\n                width: 0\n            }\n        }, animationModel, dataIndex, function () {\n            el.parent && el.parent.remove(el);\n        });\n    }\n\n    function removeSector(dataIndex, animationModel, el) {\n        // Not show text when animating\n        el.style.text = '';\n        graphic.updateProps(el, {\n            shape: {\n                r: el.shape.r0\n            }\n        }, animationModel, dataIndex, function () {\n            el.parent && el.parent.remove(el);\n        });\n    }\n\n    var getLayout = {\n        cartesian2d: function (data, dataIndex, itemModel) {\n            var layout = data.getItemLayout(dataIndex);\n            var fixedLineWidth = getLineWidth(itemModel, layout);\n\n            // fix layout with lineWidth\n            var signX = layout.width > 0 ? 1 : -1;\n            var signY = layout.height > 0 ? 1 : -1;\n            return {\n                x: layout.x + signX * fixedLineWidth / 2,\n                y: layout.y + signY * fixedLineWidth / 2,\n                width: layout.width - signX * fixedLineWidth,\n                height: layout.height - signY * fixedLineWidth\n            };\n        },\n\n        polar: function (data, dataIndex, itemModel) {\n            var layout = data.getItemLayout(dataIndex);\n            return {\n                cx: layout.cx,\n                cy: layout.cy,\n                r0: layout.r0,\n                r: layout.r,\n                startAngle: layout.startAngle,\n                endAngle: layout.endAngle\n            };\n        }\n    };\n\n    function updateStyle(\n        el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar\n    ) {\n        var color = data.getItemVisual(dataIndex, 'color');\n        var opacity = data.getItemVisual(dataIndex, 'opacity');\n        var itemStyleModel = itemModel.getModel('itemStyle.normal');\n        var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n        if (!isPolar) {\n            el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n        }\n\n        el.useStyle(zrUtil.defaults(\n            {\n                fill: color,\n                opacity: opacity\n            },\n            itemStyleModel.getBarItemStyle()\n        ));\n\n        var cursorStyle = itemModel.getShallow('cursor');\n        cursorStyle && el.attr('cursor', cursorStyle);\n\n        var labelPositionOutside = isHorizontal\n            ? (layout.height > 0 ? 'bottom' : 'top')\n            : (layout.width > 0 ? 'left' : 'right');\n\n        if (!isPolar) {\n            helper.setLabel(\n                el.style, hoverStyle, itemModel, color,\n                seriesModel, dataIndex, labelPositionOutside\n            );\n        }\n\n        graphic.setHoverStyle(el, hoverStyle);\n    }\n\n    // In case width or height are too small.\n    function getLineWidth(itemModel, rawLayout) {\n        var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n        return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n    }\n\n    module.exports = BarView;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2Jhci9CYXJWaWV3LmpzPzIwZmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELGNBQWM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx1QkFBdUIsVUFBVTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1QkFBdUIsVUFBVTs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE2My5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIGhlbHBlciA9IHJlcXVpcmUoJy4vaGVscGVyJyk7XG5cbiAgICB2YXIgQkFSX0JPUkRFUl9XSURUSF9RVUVSWSA9IFsnaXRlbVN0eWxlJywgJ25vcm1hbCcsICdiYXJCb3JkZXJXaWR0aCddO1xuXG4gICAgLy8gRklYTUVcbiAgICAvLyBKdXN0IGZvciBjb21wYXRpYmxlIHdpdGggZWMyLlxuICAgIHpyVXRpbC5leHRlbmQocmVxdWlyZSgnLi4vLi4vbW9kZWwvTW9kZWwnKS5wcm90b3R5cGUsIHJlcXVpcmUoJy4vYmFySXRlbVN0eWxlJykpO1xuXG4gICAgdmFyIEJhclZpZXcgPSByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJykuZXh0ZW5kQ2hhcnRWaWV3KHtcblxuICAgICAgICB0eXBlOiAnYmFyJyxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZVN5c3RlbVR5cGUgPSBzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKTtcblxuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGVTeXN0ZW1UeXBlID09PSAnY2FydGVzaWFuMmQnXG4gICAgICAgICAgICAgICAgfHwgY29vcmRpbmF0ZVN5c3RlbVR5cGUgPT09ICdwb2xhcidcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcihzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ09ubHkgY2FydGVzaWFuMmQgYW5kIHBvbGFyIHN1cHBvcnRlZCBmb3IgYmFyLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncm91cDtcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiB6clV0aWwubm9vcCxcblxuICAgICAgICBfcmVuZGVyOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgICAgICB2YXIgY29vcmQgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmQuZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgICAgIHZhciBpc0hvcml6b250YWxPclJhZGlhbDtcblxuICAgICAgICAgICAgaWYgKGNvb3JkLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgICAgICAgICAgICBpc0hvcml6b250YWxPclJhZGlhbCA9IGJhc2VBeGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29vcmQudHlwZSA9PT0gJ3BvbGFyJykge1xuICAgICAgICAgICAgICAgIGlzSG9yaXpvbnRhbE9yUmFkaWFsID0gYmFzZUF4aXMuZGltID09PSAnYW5nbGUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uTW9kZWwgPSBzZXJpZXNNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKSA/IHNlcmllc01vZGVsIDogbnVsbDtcblxuICAgICAgICAgICAgZGF0YS5kaWZmKG9sZERhdGEpXG4gICAgICAgICAgICAgICAgLmFkZChmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5oYXNWYWx1ZShkYXRhSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheW91dCA9IGdldExheW91dFtjb29yZC50eXBlXShkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGVsZW1lbnRDcmVhdG9yW2Nvb3JkLnR5cGVdKFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgaXNIb3Jpem9udGFsT3JSYWRpYWwsIGFuaW1hdGlvbk1vZGVsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKGVsKTtcblxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTdHlsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLCBkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwsIGlzSG9yaXpvbnRhbE9yUmFkaWFsLCBjb29yZC50eXBlID09PSAncG9sYXInXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKGZ1bmN0aW9uIChuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZEluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEuaGFzVmFsdWUobmV3SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKG5ld0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheW91dCA9IGdldExheW91dFtjb29yZC50eXBlXShkYXRhLCBuZXdJbmRleCwgaXRlbU1vZGVsKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoZWwsIHtzaGFwZTogbGF5b3V0fSwgYW5pbWF0aW9uTW9kZWwsIG5ld0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZWxlbWVudENyZWF0b3JbY29vcmQudHlwZV0oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSwgbmV3SW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBpc0hvcml6b250YWxPclJhZGlhbCwgYW5pbWF0aW9uTW9kZWwsIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SW5kZXgsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKGVsKTtcblxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTdHlsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLCBkYXRhLCBuZXdJbmRleCwgaXRlbU1vZGVsLCBsYXlvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbCwgaXNIb3Jpem9udGFsT3JSYWRpYWwsIGNvb3JkLnR5cGUgPT09ICdwb2xhcidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3JkLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsICYmIHJlbW92ZVJlY3QoZGF0YUluZGV4LCBhbmltYXRpb25Nb2RlbCwgZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgJiYgcmVtb3ZlU2VjdG9yKGRhdGFJbmRleCwgYW5pbWF0aW9uTW9kZWwsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmV4ZWN1dGUoKTtcblxuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICAgICAgaWYgKGVjTW9kZWwuZ2V0KCdhbmltYXRpb24nKSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwudHlwZSA9PT0gJ3NlY3RvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVTZWN0b3IoZWwuZGF0YUluZGV4LCBlY01vZGVsLCBlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVSZWN0KGVsLmRhdGFJbmRleCwgZWNNb2RlbCwgZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBncm91cC5yZW1vdmVBbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGVsZW1lbnRDcmVhdG9yID0ge1xuXG4gICAgICAgIGNhcnRlc2lhbjJkOiBmdW5jdGlvbiAoXG4gICAgICAgICAgICBkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBpc0hvcml6b250YWwsXG4gICAgICAgICAgICBhbmltYXRpb25Nb2RlbCwgaXNVcGRhdGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe3NoYXBlOiB6clV0aWwuZXh0ZW5kKHt9LCBsYXlvdXQpfSk7XG5cbiAgICAgICAgICAgIC8vIEFuaW1hdGlvblxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbk1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3RTaGFwZSA9IHJlY3Quc2hhcGU7XG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGVQcm9wZXJ0eSA9IGlzSG9yaXpvbnRhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0ZVRhcmdldCA9IHt9O1xuICAgICAgICAgICAgICAgIHJlY3RTaGFwZVthbmltYXRlUHJvcGVydHldID0gMDtcbiAgICAgICAgICAgICAgICBhbmltYXRlVGFyZ2V0W2FuaW1hdGVQcm9wZXJ0eV0gPSBsYXlvdXRbYW5pbWF0ZVByb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBncmFwaGljW2lzVXBkYXRlID8gJ3VwZGF0ZVByb3BzJyA6ICdpbml0UHJvcHMnXShyZWN0LCB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiBhbmltYXRlVGFyZ2V0XG4gICAgICAgICAgICAgICAgfSwgYW5pbWF0aW9uTW9kZWwsIGRhdGFJbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBvbGFyOiBmdW5jdGlvbiAoXG4gICAgICAgICAgICBkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBpc1JhZGlhbCxcbiAgICAgICAgICAgIGFuaW1hdGlvbk1vZGVsLCBpc1VwZGF0ZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBzZWN0b3IgPSBuZXcgZ3JhcGhpYy5TZWN0b3Ioe3NoYXBlOiB6clV0aWwuZXh0ZW5kKHt9LCBsYXlvdXQpfSk7XG5cbiAgICAgICAgICAgIC8vIEFuaW1hdGlvblxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbk1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlY3RvclNoYXBlID0gc2VjdG9yLnNoYXBlO1xuICAgICAgICAgICAgICAgIHZhciBhbmltYXRlUHJvcGVydHkgPSBpc1JhZGlhbCA/ICdyJyA6ICdlbmRBbmdsZSc7XG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGVUYXJnZXQgPSB7fTtcbiAgICAgICAgICAgICAgICBzZWN0b3JTaGFwZVthbmltYXRlUHJvcGVydHldID0gaXNSYWRpYWwgPyAwIDogbGF5b3V0LnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgYW5pbWF0ZVRhcmdldFthbmltYXRlUHJvcGVydHldID0gbGF5b3V0W2FuaW1hdGVQcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgZ3JhcGhpY1tpc1VwZGF0ZSA/ICd1cGRhdGVQcm9wcycgOiAnaW5pdFByb3BzJ10oc2VjdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiBhbmltYXRlVGFyZ2V0XG4gICAgICAgICAgICAgICAgfSwgYW5pbWF0aW9uTW9kZWwsIGRhdGFJbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWN0b3I7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlUmVjdChkYXRhSW5kZXgsIGFuaW1hdGlvbk1vZGVsLCBlbCkge1xuICAgICAgICAvLyBOb3Qgc2hvdyB0ZXh0IHdoZW4gYW5pbWF0aW5nXG4gICAgICAgIGVsLnN0eWxlLnRleHQgPSAnJztcbiAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBhbmltYXRpb25Nb2RlbCwgZGF0YUluZGV4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbC5wYXJlbnQgJiYgZWwucGFyZW50LnJlbW92ZShlbCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVNlY3RvcihkYXRhSW5kZXgsIGFuaW1hdGlvbk1vZGVsLCBlbCkge1xuICAgICAgICAvLyBOb3Qgc2hvdyB0ZXh0IHdoZW4gYW5pbWF0aW5nXG4gICAgICAgIGVsLnN0eWxlLnRleHQgPSAnJztcbiAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICByOiBlbC5zaGFwZS5yMFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBhbmltYXRpb25Nb2RlbCwgZGF0YUluZGV4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbC5wYXJlbnQgJiYgZWwucGFyZW50LnJlbW92ZShlbCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBnZXRMYXlvdXQgPSB7XG4gICAgICAgIGNhcnRlc2lhbjJkOiBmdW5jdGlvbiAoZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KTtcbiAgICAgICAgICAgIHZhciBmaXhlZExpbmVXaWR0aCA9IGdldExpbmVXaWR0aChpdGVtTW9kZWwsIGxheW91dCk7XG5cbiAgICAgICAgICAgIC8vIGZpeCBsYXlvdXQgd2l0aCBsaW5lV2lkdGhcbiAgICAgICAgICAgIHZhciBzaWduWCA9IGxheW91dC53aWR0aCA+IDAgPyAxIDogLTE7XG4gICAgICAgICAgICB2YXIgc2lnblkgPSBsYXlvdXQuaGVpZ2h0ID4gMCA/IDEgOiAtMTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogbGF5b3V0LnggKyBzaWduWCAqIGZpeGVkTGluZVdpZHRoIC8gMixcbiAgICAgICAgICAgICAgICB5OiBsYXlvdXQueSArIHNpZ25ZICogZml4ZWRMaW5lV2lkdGggLyAyLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBsYXlvdXQud2lkdGggLSBzaWduWCAqIGZpeGVkTGluZVdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogbGF5b3V0LmhlaWdodCAtIHNpZ25ZICogZml4ZWRMaW5lV2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9sYXI6IGZ1bmN0aW9uIChkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCkge1xuICAgICAgICAgICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChkYXRhSW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjeDogbGF5b3V0LmN4LFxuICAgICAgICAgICAgICAgIGN5OiBsYXlvdXQuY3ksXG4gICAgICAgICAgICAgICAgcjA6IGxheW91dC5yMCxcbiAgICAgICAgICAgICAgICByOiBsYXlvdXQucixcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBsYXlvdXQuc3RhcnRBbmdsZSxcbiAgICAgICAgICAgICAgICBlbmRBbmdsZTogbGF5b3V0LmVuZEFuZ2xlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKFxuICAgICAgICBlbCwgZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgc2VyaWVzTW9kZWwsIGlzSG9yaXpvbnRhbCwgaXNQb2xhclxuICAgICkge1xuICAgICAgICB2YXIgY29sb3IgPSBkYXRhLmdldEl0ZW1WaXN1YWwoZGF0YUluZGV4LCAnY29sb3InKTtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSBkYXRhLmdldEl0ZW1WaXN1YWwoZGF0YUluZGV4LCAnb3BhY2l0eScpO1xuICAgICAgICB2YXIgaXRlbVN0eWxlTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZS5ub3JtYWwnKTtcbiAgICAgICAgdmFyIGhvdmVyU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZS5lbXBoYXNpcycpLmdldEJhckl0ZW1TdHlsZSgpO1xuXG4gICAgICAgIGlmICghaXNQb2xhcikge1xuICAgICAgICAgICAgZWwuc2V0U2hhcGUoJ3InLCBpdGVtU3R5bGVNb2RlbC5nZXQoJ2JhckJvcmRlclJhZGl1cycpIHx8IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwudXNlU3R5bGUoenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZpbGw6IGNvbG9yLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpdGVtU3R5bGVNb2RlbC5nZXRCYXJJdGVtU3R5bGUoKVxuICAgICAgICApKTtcblxuICAgICAgICB2YXIgY3Vyc29yU3R5bGUgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnY3Vyc29yJyk7XG4gICAgICAgIGN1cnNvclN0eWxlICYmIGVsLmF0dHIoJ2N1cnNvcicsIGN1cnNvclN0eWxlKTtcblxuICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbk91dHNpZGUgPSBpc0hvcml6b250YWxcbiAgICAgICAgICAgID8gKGxheW91dC5oZWlnaHQgPiAwID8gJ2JvdHRvbScgOiAndG9wJylcbiAgICAgICAgICAgIDogKGxheW91dC53aWR0aCA+IDAgPyAnbGVmdCcgOiAncmlnaHQnKTtcblxuICAgICAgICBpZiAoIWlzUG9sYXIpIHtcbiAgICAgICAgICAgIGhlbHBlci5zZXRMYWJlbChcbiAgICAgICAgICAgICAgICBlbC5zdHlsZSwgaG92ZXJTdHlsZSwgaXRlbU1vZGVsLCBjb2xvcixcbiAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbCwgZGF0YUluZGV4LCBsYWJlbFBvc2l0aW9uT3V0c2lkZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZShlbCwgaG92ZXJTdHlsZSk7XG4gICAgfVxuXG4gICAgLy8gSW4gY2FzZSB3aWR0aCBvciBoZWlnaHQgYXJlIHRvbyBzbWFsbC5cbiAgICBmdW5jdGlvbiBnZXRMaW5lV2lkdGgoaXRlbU1vZGVsLCByYXdMYXlvdXQpIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IGl0ZW1Nb2RlbC5nZXQoQkFSX0JPUkRFUl9XSURUSF9RVUVSWSkgfHwgMDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKGxpbmVXaWR0aCwgTWF0aC5hYnMocmF3TGF5b3V0LndpZHRoKSwgTWF0aC5hYnMocmF3TGF5b3V0LmhlaWdodCkpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gQmFyVmlldztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jaGFydC9iYXIvQmFyVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n    var graphic = __webpack_require__(34);\n\n    var helper = {};\n\n    helper.setLabel = function (\n        normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside\n    ) {\n        var labelModel = itemModel.getModel('label.normal');\n        var hoverLabelModel = itemModel.getModel('label.emphasis');\n\n        if (labelModel.get('show')) {\n            setLabel(\n                normalStyle, labelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'normal'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            normalStyle.text = '';\n        }\n\n        if (hoverLabelModel.get('show')) {\n            setLabel(\n                hoverStyle, hoverLabelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'emphasis'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            hoverStyle.text = '';\n        }\n    };\n\n    function setLabel(style, model, color, labelText, labelPositionOutside) {\n        graphic.setText(style, model, color);\n        style.text = labelText;\n        if (style.textPosition === 'outside') {\n            style.textPosition = labelPositionOutside;\n        }\n    }\n\n    module.exports = helper;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2Jhci9oZWxwZXIuanM/MjVkMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE2NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG5cbiAgICB2YXIgaGVscGVyID0ge307XG5cbiAgICBoZWxwZXIuc2V0TGFiZWwgPSBmdW5jdGlvbiAoXG4gICAgICAgIG5vcm1hbFN0eWxlLCBob3ZlclN0eWxlLCBpdGVtTW9kZWwsIGNvbG9yLCBzZXJpZXNNb2RlbCwgZGF0YUluZGV4LCBsYWJlbFBvc2l0aW9uT3V0c2lkZVxuICAgICkge1xuICAgICAgICB2YXIgbGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwubm9ybWFsJyk7XG4gICAgICAgIHZhciBob3ZlckxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLmVtcGhhc2lzJyk7XG5cbiAgICAgICAgaWYgKGxhYmVsTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgIHNldExhYmVsKFxuICAgICAgICAgICAgICAgIG5vcm1hbFN0eWxlLCBsYWJlbE1vZGVsLCBjb2xvcixcbiAgICAgICAgICAgICAgICB6clV0aWwucmV0cmlldmUoXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldEZvcm1hdHRlZExhYmVsKGRhdGFJbmRleCwgJ25vcm1hbCcpLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShkYXRhSW5kZXgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uT3V0c2lkZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbFN0eWxlLnRleHQgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChob3ZlckxhYmVsTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgIHNldExhYmVsKFxuICAgICAgICAgICAgICAgIGhvdmVyU3R5bGUsIGhvdmVyTGFiZWxNb2RlbCwgY29sb3IsXG4gICAgICAgICAgICAgICAgenJVdGlsLnJldHJpZXZlKFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChkYXRhSW5kZXgsICdlbXBoYXNpcycpLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShkYXRhSW5kZXgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uT3V0c2lkZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvdmVyU3R5bGUudGV4dCA9ICcnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNldExhYmVsKHN0eWxlLCBtb2RlbCwgY29sb3IsIGxhYmVsVGV4dCwgbGFiZWxQb3NpdGlvbk91dHNpZGUpIHtcbiAgICAgICAgZ3JhcGhpYy5zZXRUZXh0KHN0eWxlLCBtb2RlbCwgY29sb3IpO1xuICAgICAgICBzdHlsZS50ZXh0ID0gbGFiZWxUZXh0O1xuICAgICAgICBpZiAoc3R5bGUudGV4dFBvc2l0aW9uID09PSAnb3V0c2lkZScpIHtcbiAgICAgICAgICAgIHN0eWxlLnRleHRQb3NpdGlvbiA9IGxhYmVsUG9zaXRpb25PdXRzaWRlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBoZWxwZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY2hhcnQvYmFyL2hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n\n    var getBarItemStyle = __webpack_require__(31)(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            // Compatitable with 2\n            ['stroke', 'barBorderColor'],\n            ['lineWidth', 'barBorderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getBarItemStyle: function (excludes) {\n            var style = getBarItemStyle.call(this, excludes);\n            if (this.getBorderLineDash) {\n                var lineDash = this.getBorderLineDash();\n                lineDash && (style.lineDash = lineDash);\n            }\n            return style;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2Jhci9iYXJJdGVtU3R5bGUuanM/MTVkOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuXG4gICAgdmFyIGdldEJhckl0ZW1TdHlsZSA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL21peGluL21ha2VTdHlsZU1hcHBlcicpKFxuICAgICAgICBbXG4gICAgICAgICAgICBbJ2ZpbGwnLCAnY29sb3InXSxcbiAgICAgICAgICAgIFsnc3Ryb2tlJywgJ2JvcmRlckNvbG9yJ10sXG4gICAgICAgICAgICBbJ2xpbmVXaWR0aCcsICdib3JkZXJXaWR0aCddLFxuICAgICAgICAgICAgLy8gQ29tcGF0aXRhYmxlIHdpdGggMlxuICAgICAgICAgICAgWydzdHJva2UnLCAnYmFyQm9yZGVyQ29sb3InXSxcbiAgICAgICAgICAgIFsnbGluZVdpZHRoJywgJ2JhckJvcmRlcldpZHRoJ10sXG4gICAgICAgICAgICBbJ29wYWNpdHknXSxcbiAgICAgICAgICAgIFsnc2hhZG93Qmx1ciddLFxuICAgICAgICAgICAgWydzaGFkb3dPZmZzZXRYJ10sXG4gICAgICAgICAgICBbJ3NoYWRvd09mZnNldFknXSxcbiAgICAgICAgICAgIFsnc2hhZG93Q29sb3InXVxuICAgICAgICBdXG4gICAgKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZ2V0QmFySXRlbVN0eWxlOiBmdW5jdGlvbiAoZXhjbHVkZXMpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGdldEJhckl0ZW1TdHlsZS5jYWxsKHRoaXMsIGV4Y2x1ZGVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEJvcmRlckxpbmVEYXNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gdGhpcy5nZXRCb3JkZXJMaW5lRGFzaCgpO1xuICAgICAgICAgICAgICAgIGxpbmVEYXNoICYmIChzdHlsZS5saW5lRGFzaCA9IGxpbmVEYXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY2hhcnQvYmFyL2Jhckl0ZW1TdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var zrUtil = __webpack_require__(20);\n    var numberUtil = __webpack_require__(23);\n    var parsePercent = numberUtil.parsePercent;\n\n    var STACK_PREFIX = '__ec_stack_';\n\n    function getSeriesStackId(seriesModel) {\n        return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n    }\n\n    function getAxisKey(axis) {\n        return axis.dim + axis.index;\n    }\n\n    /**\n     * @param {Object} opt\n     * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n     * @param {number} opt.count Positive interger.\n     * @param {number} [opt.barWidth]\n     * @param {number} [opt.barMaxWidth]\n     * @param {number} [opt.barGap]\n     * @param {number} [opt.barCategoryGap]\n     * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n     */\n    function getLayoutOnAxis(opt, api) {\n        var params = [];\n        var baseAxis = opt.axis;\n        var axisKey = 'axis0';\n\n        if (baseAxis.type !== 'category') {\n            return;\n        }\n        var bandWidth = baseAxis.getBandWidth();\n\n        for (var i = 0; i < opt.count || 0; i++) {\n            params.push(zrUtil.defaults({\n                bandWidth: bandWidth,\n                axisKey: axisKey,\n                stackId: STACK_PREFIX + i\n            }, opt));\n        }\n        var widthAndOffsets = doCalBarWidthAndOffset(params, api);\n\n        var result = [];\n        for (var i = 0; i < opt.count; i++) {\n            var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n            item.offsetCenter = item.offset + item.width / 2;\n            result.push(item);\n        }\n\n        return result;\n    }\n\n    function calBarWidthAndOffset(barSeries, api) {\n        var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var axisExtent = baseAxis.getExtent();\n            var bandWidth = baseAxis.type === 'category'\n                ? baseAxis.getBandWidth()\n                : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());\n\n            var barWidth = parsePercent(\n                seriesModel.get('barWidth'), bandWidth\n            );\n            var barMaxWidth = parsePercent(\n                seriesModel.get('barMaxWidth'), bandWidth\n            );\n            var barGap = seriesModel.get('barGap');\n            var barCategoryGap = seriesModel.get('barCategoryGap');\n\n            return {\n                bandWidth: bandWidth,\n                barWidth: barWidth,\n                barMaxWidth: barMaxWidth,\n                barGap: barGap,\n                barCategoryGap: barCategoryGap,\n                axisKey: getAxisKey(baseAxis),\n                stackId: getSeriesStackId(seriesModel)\n            };\n        });\n\n        return doCalBarWidthAndOffset(seriesInfoList, api);\n    }\n\n    function doCalBarWidthAndOffset(seriesInfoList, api) {\n        // Columns info on each category axis. Key is cartesian name\n        var columnsMap = {};\n\n        zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n            var axisKey = seriesInfo.axisKey;\n            var bandWidth = seriesInfo.bandWidth;\n            var columnsOnAxis = columnsMap[axisKey] || {\n                bandWidth: bandWidth,\n                remainedWidth: bandWidth,\n                autoWidthCount: 0,\n                categoryGap: '20%',\n                gap: '30%',\n                stacks: {}\n            };\n            var stacks = columnsOnAxis.stacks;\n            columnsMap[axisKey] = columnsOnAxis;\n\n            var stackId = seriesInfo.stackId;\n\n            if (!stacks[stackId]) {\n                columnsOnAxis.autoWidthCount++;\n            }\n            stacks[stackId] = stacks[stackId] || {\n                width: 0,\n                maxWidth: 0\n            };\n\n            // Caution: In a single coordinate system, these barGrid attributes\n            // will be shared by series. Consider that they have default values,\n            // only the attributes set on the last series will work.\n            // Do not change this fact unless there will be a break change.\n\n            // TODO\n            var barWidth = seriesInfo.barWidth;\n            if (barWidth && !stacks[stackId].width) {\n                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n                stacks[stackId].width = barWidth;\n                columnsOnAxis.remainedWidth -= barWidth;\n            }\n\n            var barMaxWidth = seriesInfo.barMaxWidth;\n            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n            var barGap = seriesInfo.barGap;\n            (barGap != null) && (columnsOnAxis.gap = barGap);\n            var barCategoryGap = seriesInfo.barCategoryGap;\n            (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);\n        });\n\n        var result = {};\n\n        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\n            result[coordSysName] = {};\n\n            var stacks = columnsOnAxis.stacks;\n            var bandWidth = columnsOnAxis.bandWidth;\n            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\n            var remainedWidth = columnsOnAxis.remainedWidth;\n            var autoWidthCount = columnsOnAxis.autoWidthCount;\n            var autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            // Find if any auto calculated bar exceeded maxBarWidth\n            zrUtil.each(stacks, function (column, stack) {\n                var maxWidth = column.maxWidth;\n                if (maxWidth && maxWidth < autoWidth) {\n                    maxWidth = Math.min(maxWidth, remainedWidth);\n                    if (column.width) {\n                        maxWidth = Math.min(maxWidth, column.width);\n                    }\n                    remainedWidth -= maxWidth;\n                    column.width = maxWidth;\n                    autoWidthCount--;\n                }\n            });\n\n            // Recalculate width again\n            autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            var widthSum = 0;\n            var lastColumn;\n            zrUtil.each(stacks, function (column, idx) {\n                if (!column.width) {\n                    column.width = autoWidth;\n                }\n                lastColumn = column;\n                widthSum += column.width * (1 + barGapPercent);\n            });\n            if (lastColumn) {\n                widthSum -= lastColumn.width * barGapPercent;\n            }\n\n            var offset = -widthSum / 2;\n            zrUtil.each(stacks, function (column, stackId) {\n                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                    offset: offset,\n                    width: column.width\n                };\n\n                offset += column.width * (1 + barGapPercent);\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * @param {string} seriesType\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function barLayoutGrid(seriesType, ecModel, api) {\n\n        var barWidthAndOffset = calBarWidthAndOffset(\n            zrUtil.filter(\n                ecModel.getSeriesByType(seriesType),\n                function (seriesModel) {\n                    return !ecModel.isSeriesFiltered(seriesModel)\n                        && seriesModel.coordinateSystem\n                        && seriesModel.coordinateSystem.type === 'cartesian2d';\n                }\n            )\n        );\n\n        var lastStackCoords = {};\n        var lastStackCoordsOrigin = {};\n\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\n            // Check series coordinate, do layout for cartesian2d only\n            if (seriesModel.coordinateSystem.type !== 'cartesian2d') {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n\n            var stackId = getSeriesStackId(seriesModel);\n            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n            var columnOffset = columnLayoutInfo.offset;\n            var columnWidth = columnLayoutInfo.width;\n            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\n            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\n            var valueAxisStart = baseAxis.onZero\n                ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))\n                : valueAxis.getGlobalExtent()[0];\n\n            var coords = cartesian.dataToPoints(data, true);\n            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n            lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n            data.setLayout({\n                offset: columnOffset,\n                size: columnWidth\n            });\n\n            data.each(valueAxis.dim, function (value, idx) {\n                if (isNaN(value)) {\n                    return;\n                }\n\n                if (!lastStackCoords[stackId][idx]) {\n                    lastStackCoords[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                    lastStackCoordsOrigin[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                }\n                var sign = value >= 0 ? 'p' : 'n';\n                var coord = coords[idx];\n                var lastCoord = lastStackCoords[stackId][idx][sign];\n                var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n                var x;\n                var y;\n                var width;\n                var height;\n\n                if (valueAxis.isHorizontal()) {\n                    x = lastCoord;\n                    y = coord[1] + columnOffset;\n                    width = coord[0] - lastCoordOrigin;\n                    height = columnWidth;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += width;\n                    if (Math.abs(width) < barMinHeight) {\n                        width = (width < 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += width;\n                }\n                else {\n                    x = coord[0] + columnOffset;\n                    y = lastCoord;\n                    width = columnWidth;\n                    height = coord[1] - lastCoordOrigin;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += height;\n                    if (Math.abs(height) < barMinHeight) {\n                        // Include zero to has a positive bar\n                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += height;\n                }\n\n                data.setItemLayout(idx, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }, true);\n\n        }, this);\n    }\n\n    barLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;\n\n    module.exports = barLayoutGrid;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2xheW91dC9iYXJHcmlkLmpzP2QyM2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU8sRUFBRSw0QkFBNEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLDRCQUE0QjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrRkFBa0Y7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWIsU0FBUztBQUNUOztBQUVBOztBQUVBIiwiZmlsZSI6IjE2Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgcGFyc2VQZXJjZW50ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQ7XG5cbiAgICB2YXIgU1RBQ0tfUFJFRklYID0gJ19fZWNfc3RhY2tfJztcblxuICAgIGZ1bmN0aW9uIGdldFNlcmllc1N0YWNrSWQoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHNlcmllc01vZGVsLmdldCgnc3RhY2snKSB8fCBTVEFDS19QUkVGSVggKyBzZXJpZXNNb2RlbC5zZXJpZXNJbmRleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBeGlzS2V5KGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIGF4aXMuZGltICsgYXhpcy5pbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9BeGlzfSBvcHQuYXhpcyBPbmx5IHN1cHBvcnQgY2F0ZWdvcnkgYXhpcyBjdXJyZW50bHkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdC5jb3VudCBQb3NpdGl2ZSBpbnRlcmdlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5iYXJXaWR0aF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5iYXJNYXhXaWR0aF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5iYXJHYXBdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuYmFyQ2F0ZWdvcnlHYXBdXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB7d2lkdGgsIG9mZnNldCwgb2Zmc2V0Q2VudGVyfSBJZiBheGlzLnR5cGUgaXMgbm90ICdjYXRlZ29yeScsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TGF5b3V0T25BeGlzKG9wdCwgYXBpKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgdmFyIGJhc2VBeGlzID0gb3B0LmF4aXM7XG4gICAgICAgIHZhciBheGlzS2V5ID0gJ2F4aXMwJztcblxuICAgICAgICBpZiAoYmFzZUF4aXMudHlwZSAhPT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYW5kV2lkdGggPSBiYXNlQXhpcy5nZXRCYW5kV2lkdGgoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdC5jb3VudCB8fCAwOyBpKyspIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgICAgYmFuZFdpZHRoOiBiYW5kV2lkdGgsXG4gICAgICAgICAgICAgICAgYXhpc0tleTogYXhpc0tleSxcbiAgICAgICAgICAgICAgICBzdGFja0lkOiBTVEFDS19QUkVGSVggKyBpXG4gICAgICAgICAgICB9LCBvcHQpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2lkdGhBbmRPZmZzZXRzID0gZG9DYWxCYXJXaWR0aEFuZE9mZnNldChwYXJhbXMsIGFwaSk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdC5jb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHdpZHRoQW5kT2Zmc2V0c1theGlzS2V5XVtTVEFDS19QUkVGSVggKyBpXTtcbiAgICAgICAgICAgIGl0ZW0ub2Zmc2V0Q2VudGVyID0gaXRlbS5vZmZzZXQgKyBpdGVtLndpZHRoIC8gMjtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxCYXJXaWR0aEFuZE9mZnNldChiYXJTZXJpZXMsIGFwaSkge1xuICAgICAgICB2YXIgc2VyaWVzSW5mb0xpc3QgPSB6clV0aWwubWFwKGJhclNlcmllcywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgdmFyIGJhc2VBeGlzID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG4gICAgICAgICAgICB2YXIgYXhpc0V4dGVudCA9IGJhc2VBeGlzLmdldEV4dGVudCgpO1xuICAgICAgICAgICAgdmFyIGJhbmRXaWR0aCA9IGJhc2VBeGlzLnR5cGUgPT09ICdjYXRlZ29yeSdcbiAgICAgICAgICAgICAgICA/IGJhc2VBeGlzLmdldEJhbmRXaWR0aCgpXG4gICAgICAgICAgICAgICAgOiAoTWF0aC5hYnMoYXhpc0V4dGVudFsxXSAtIGF4aXNFeHRlbnRbMF0pIC8gZGF0YS5jb3VudCgpKTtcblxuICAgICAgICAgICAgdmFyIGJhcldpZHRoID0gcGFyc2VQZXJjZW50KFxuICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgnYmFyV2lkdGgnKSwgYmFuZFdpZHRoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGJhck1heFdpZHRoID0gcGFyc2VQZXJjZW50KFxuICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgnYmFyTWF4V2lkdGgnKSwgYmFuZFdpZHRoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGJhckdhcCA9IHNlcmllc01vZGVsLmdldCgnYmFyR2FwJyk7XG4gICAgICAgICAgICB2YXIgYmFyQ2F0ZWdvcnlHYXAgPSBzZXJpZXNNb2RlbC5nZXQoJ2JhckNhdGVnb3J5R2FwJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmFuZFdpZHRoOiBiYW5kV2lkdGgsXG4gICAgICAgICAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgICAgIGJhck1heFdpZHRoOiBiYXJNYXhXaWR0aCxcbiAgICAgICAgICAgICAgICBiYXJHYXA6IGJhckdhcCxcbiAgICAgICAgICAgICAgICBiYXJDYXRlZ29yeUdhcDogYmFyQ2F0ZWdvcnlHYXAsXG4gICAgICAgICAgICAgICAgYXhpc0tleTogZ2V0QXhpc0tleShiYXNlQXhpcyksXG4gICAgICAgICAgICAgICAgc3RhY2tJZDogZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkb0NhbEJhcldpZHRoQW5kT2Zmc2V0KHNlcmllc0luZm9MaXN0LCBhcGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvQ2FsQmFyV2lkdGhBbmRPZmZzZXQoc2VyaWVzSW5mb0xpc3QsIGFwaSkge1xuICAgICAgICAvLyBDb2x1bW5zIGluZm8gb24gZWFjaCBjYXRlZ29yeSBheGlzLiBLZXkgaXMgY2FydGVzaWFuIG5hbWVcbiAgICAgICAgdmFyIGNvbHVtbnNNYXAgPSB7fTtcblxuICAgICAgICB6clV0aWwuZWFjaChzZXJpZXNJbmZvTGlzdCwgZnVuY3Rpb24gKHNlcmllc0luZm8sIGlkeCkge1xuICAgICAgICAgICAgdmFyIGF4aXNLZXkgPSBzZXJpZXNJbmZvLmF4aXNLZXk7XG4gICAgICAgICAgICB2YXIgYmFuZFdpZHRoID0gc2VyaWVzSW5mby5iYW5kV2lkdGg7XG4gICAgICAgICAgICB2YXIgY29sdW1uc09uQXhpcyA9IGNvbHVtbnNNYXBbYXhpc0tleV0gfHwge1xuICAgICAgICAgICAgICAgIGJhbmRXaWR0aDogYmFuZFdpZHRoLFxuICAgICAgICAgICAgICAgIHJlbWFpbmVkV2lkdGg6IGJhbmRXaWR0aCxcbiAgICAgICAgICAgICAgICBhdXRvV2lkdGhDb3VudDogMCxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUdhcDogJzIwJScsXG4gICAgICAgICAgICAgICAgZ2FwOiAnMzAlJyxcbiAgICAgICAgICAgICAgICBzdGFja3M6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHN0YWNrcyA9IGNvbHVtbnNPbkF4aXMuc3RhY2tzO1xuICAgICAgICAgICAgY29sdW1uc01hcFtheGlzS2V5XSA9IGNvbHVtbnNPbkF4aXM7XG5cbiAgICAgICAgICAgIHZhciBzdGFja0lkID0gc2VyaWVzSW5mby5zdGFja0lkO1xuXG4gICAgICAgICAgICBpZiAoIXN0YWNrc1tzdGFja0lkXSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbnNPbkF4aXMuYXV0b1dpZHRoQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrc1tzdGFja0lkXSA9IHN0YWNrc1tzdGFja0lkXSB8fCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIENhdXRpb246IEluIGEgc2luZ2xlIGNvb3JkaW5hdGUgc3lzdGVtLCB0aGVzZSBiYXJHcmlkIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgc2hhcmVkIGJ5IHNlcmllcy4gQ29uc2lkZXIgdGhhdCB0aGV5IGhhdmUgZGVmYXVsdCB2YWx1ZXMsXG4gICAgICAgICAgICAvLyBvbmx5IHRoZSBhdHRyaWJ1dGVzIHNldCBvbiB0aGUgbGFzdCBzZXJpZXMgd2lsbCB3b3JrLlxuICAgICAgICAgICAgLy8gRG8gbm90IGNoYW5nZSB0aGlzIGZhY3QgdW5sZXNzIHRoZXJlIHdpbGwgYmUgYSBicmVhayBjaGFuZ2UuXG5cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIHZhciBiYXJXaWR0aCA9IHNlcmllc0luZm8uYmFyV2lkdGg7XG4gICAgICAgICAgICBpZiAoYmFyV2lkdGggJiYgIXN0YWNrc1tzdGFja0lkXS53aWR0aCkge1xuICAgICAgICAgICAgICAgIGJhcldpZHRoID0gTWF0aC5taW4oY29sdW1uc09uQXhpcy5yZW1haW5lZFdpZHRoLCBiYXJXaWR0aCk7XG4gICAgICAgICAgICAgICAgc3RhY2tzW3N0YWNrSWRdLndpZHRoID0gYmFyV2lkdGg7XG4gICAgICAgICAgICAgICAgY29sdW1uc09uQXhpcy5yZW1haW5lZFdpZHRoIC09IGJhcldpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYmFyTWF4V2lkdGggPSBzZXJpZXNJbmZvLmJhck1heFdpZHRoO1xuICAgICAgICAgICAgYmFyTWF4V2lkdGggJiYgKHN0YWNrc1tzdGFja0lkXS5tYXhXaWR0aCA9IGJhck1heFdpZHRoKTtcbiAgICAgICAgICAgIHZhciBiYXJHYXAgPSBzZXJpZXNJbmZvLmJhckdhcDtcbiAgICAgICAgICAgIChiYXJHYXAgIT0gbnVsbCkgJiYgKGNvbHVtbnNPbkF4aXMuZ2FwID0gYmFyR2FwKTtcbiAgICAgICAgICAgIHZhciBiYXJDYXRlZ29yeUdhcCA9IHNlcmllc0luZm8uYmFyQ2F0ZWdvcnlHYXA7XG4gICAgICAgICAgICAoYmFyQ2F0ZWdvcnlHYXAgIT0gbnVsbCkgJiYgKGNvbHVtbnNPbkF4aXMuY2F0ZWdvcnlHYXAgPSBiYXJDYXRlZ29yeUdhcCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICB6clV0aWwuZWFjaChjb2x1bW5zTWFwLCBmdW5jdGlvbiAoY29sdW1uc09uQXhpcywgY29vcmRTeXNOYW1lKSB7XG5cbiAgICAgICAgICAgIHJlc3VsdFtjb29yZFN5c05hbWVdID0ge307XG5cbiAgICAgICAgICAgIHZhciBzdGFja3MgPSBjb2x1bW5zT25BeGlzLnN0YWNrcztcbiAgICAgICAgICAgIHZhciBiYW5kV2lkdGggPSBjb2x1bW5zT25BeGlzLmJhbmRXaWR0aDtcbiAgICAgICAgICAgIHZhciBjYXRlZ29yeUdhcCA9IHBhcnNlUGVyY2VudChjb2x1bW5zT25BeGlzLmNhdGVnb3J5R2FwLCBiYW5kV2lkdGgpO1xuICAgICAgICAgICAgdmFyIGJhckdhcFBlcmNlbnQgPSBwYXJzZVBlcmNlbnQoY29sdW1uc09uQXhpcy5nYXAsIDEpO1xuXG4gICAgICAgICAgICB2YXIgcmVtYWluZWRXaWR0aCA9IGNvbHVtbnNPbkF4aXMucmVtYWluZWRXaWR0aDtcbiAgICAgICAgICAgIHZhciBhdXRvV2lkdGhDb3VudCA9IGNvbHVtbnNPbkF4aXMuYXV0b1dpZHRoQ291bnQ7XG4gICAgICAgICAgICB2YXIgYXV0b1dpZHRoID0gKHJlbWFpbmVkV2lkdGggLSBjYXRlZ29yeUdhcClcbiAgICAgICAgICAgICAgICAvIChhdXRvV2lkdGhDb3VudCArIChhdXRvV2lkdGhDb3VudCAtIDEpICogYmFyR2FwUGVyY2VudCk7XG4gICAgICAgICAgICBhdXRvV2lkdGggPSBNYXRoLm1heChhdXRvV2lkdGgsIDApO1xuXG4gICAgICAgICAgICAvLyBGaW5kIGlmIGFueSBhdXRvIGNhbGN1bGF0ZWQgYmFyIGV4Y2VlZGVkIG1heEJhcldpZHRoXG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdGFja3MsIGZ1bmN0aW9uIChjb2x1bW4sIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heFdpZHRoID0gY29sdW1uLm1heFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChtYXhXaWR0aCAmJiBtYXhXaWR0aCA8IGF1dG9XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKG1heFdpZHRoLCByZW1haW5lZFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbihtYXhXaWR0aCwgY29sdW1uLndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZW1haW5lZFdpZHRoIC09IG1heFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ud2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYXV0b1dpZHRoQ291bnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgd2lkdGggYWdhaW5cbiAgICAgICAgICAgIGF1dG9XaWR0aCA9IChyZW1haW5lZFdpZHRoIC0gY2F0ZWdvcnlHYXApXG4gICAgICAgICAgICAgICAgLyAoYXV0b1dpZHRoQ291bnQgKyAoYXV0b1dpZHRoQ291bnQgLSAxKSAqIGJhckdhcFBlcmNlbnQpO1xuICAgICAgICAgICAgYXV0b1dpZHRoID0gTWF0aC5tYXgoYXV0b1dpZHRoLCAwKTtcblxuICAgICAgICAgICAgdmFyIHdpZHRoU3VtID0gMDtcbiAgICAgICAgICAgIHZhciBsYXN0Q29sdW1uO1xuICAgICAgICAgICAgenJVdGlsLmVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbHVtbi53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ud2lkdGggPSBhdXRvV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RDb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgd2lkdGhTdW0gKz0gY29sdW1uLndpZHRoICogKDEgKyBiYXJHYXBQZXJjZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGxhc3RDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICB3aWR0aFN1bSAtPSBsYXN0Q29sdW1uLndpZHRoICogYmFyR2FwUGVyY2VudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IC13aWR0aFN1bSAvIDI7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdGFja3MsIGZ1bmN0aW9uIChjb2x1bW4sIHN0YWNrSWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbY29vcmRTeXNOYW1lXVtzdGFja0lkXSA9IHJlc3VsdFtjb29yZFN5c05hbWVdW3N0YWNrSWRdIHx8IHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2x1bW4ud2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGNvbHVtbi53aWR0aCAqICgxICsgYmFyR2FwUGVyY2VudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VyaWVzVHlwZVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhckxheW91dEdyaWQoc2VyaWVzVHlwZSwgZWNNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgdmFyIGJhcldpZHRoQW5kT2Zmc2V0ID0gY2FsQmFyV2lkdGhBbmRPZmZzZXQoXG4gICAgICAgICAgICB6clV0aWwuZmlsdGVyKFxuICAgICAgICAgICAgICAgIGVjTW9kZWwuZ2V0U2VyaWVzQnlUeXBlKHNlcmllc1R5cGUpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0udHlwZSA9PT0gJ2NhcnRlc2lhbjJkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIGxhc3RTdGFja0Nvb3JkcyA9IHt9O1xuICAgICAgICB2YXIgbGFzdFN0YWNrQ29vcmRzT3JpZ2luID0ge307XG5cbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBzZXJpZXMgY29vcmRpbmF0ZSwgZG8gbGF5b3V0IGZvciBjYXJ0ZXNpYW4yZCBvbmx5XG4gICAgICAgICAgICBpZiAoc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS50eXBlICE9PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgdmFyIGJhc2VBeGlzID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG5cbiAgICAgICAgICAgIHZhciBzdGFja0lkID0gZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICB2YXIgY29sdW1uTGF5b3V0SW5mbyA9IGJhcldpZHRoQW5kT2Zmc2V0W2dldEF4aXNLZXkoYmFzZUF4aXMpXVtzdGFja0lkXTtcbiAgICAgICAgICAgIHZhciBjb2x1bW5PZmZzZXQgPSBjb2x1bW5MYXlvdXRJbmZvLm9mZnNldDtcbiAgICAgICAgICAgIHZhciBjb2x1bW5XaWR0aCA9IGNvbHVtbkxheW91dEluZm8ud2lkdGg7XG4gICAgICAgICAgICB2YXIgdmFsdWVBeGlzID0gY2FydGVzaWFuLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG5cbiAgICAgICAgICAgIHZhciBiYXJNaW5IZWlnaHQgPSBzZXJpZXNNb2RlbC5nZXQoJ2Jhck1pbkhlaWdodCcpIHx8IDA7XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZUF4aXNTdGFydCA9IGJhc2VBeGlzLm9uWmVyb1xuICAgICAgICAgICAgICAgID8gdmFsdWVBeGlzLnRvR2xvYmFsQ29vcmQodmFsdWVBeGlzLmRhdGFUb0Nvb3JkKDApKVxuICAgICAgICAgICAgICAgIDogdmFsdWVBeGlzLmdldEdsb2JhbEV4dGVudCgpWzBdO1xuXG4gICAgICAgICAgICB2YXIgY29vcmRzID0gY2FydGVzaWFuLmRhdGFUb1BvaW50cyhkYXRhLCB0cnVlKTtcbiAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXSA9IGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXSB8fCBbXTtcbiAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXSA9IGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXSB8fCBbXTsgLy8gRml4ICM0MjQzXG5cbiAgICAgICAgICAgIGRhdGEuc2V0TGF5b3V0KHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGNvbHVtbk9mZnNldCxcbiAgICAgICAgICAgICAgICBzaXplOiBjb2x1bW5XaWR0aFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRhdGEuZWFjaCh2YWx1ZUF4aXMuZGltLCBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwOiB2YWx1ZUF4aXNTdGFydCwgLy8gUG9zaXRpdmUgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIG46IHZhbHVlQXhpc1N0YXJ0ICAvLyBOZWdhdGl2ZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhY2tDb29yZHNPcmlnaW5bc3RhY2tJZF1baWR4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHA6IHZhbHVlQXhpc1N0YXJ0LCAvLyBQb3NpdGl2ZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICAgICAgbjogdmFsdWVBeGlzU3RhcnQgIC8vIE5lZ2F0aXZlIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzaWduID0gdmFsdWUgPj0gMCA/ICdwJyA6ICduJztcbiAgICAgICAgICAgICAgICB2YXIgY29vcmQgPSBjb29yZHNbaWR4XTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdENvb3JkID0gbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF1bc2lnbl07XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RDb29yZE9yaWdpbiA9IGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXVtpZHhdW3NpZ25dO1xuICAgICAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgICAgIHZhciB5O1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlQXhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gbGFzdENvb3JkO1xuICAgICAgICAgICAgICAgICAgICB5ID0gY29vcmRbMV0gKyBjb2x1bW5PZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gY29vcmRbMF0gLSBsYXN0Q29vcmRPcmlnaW47XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGNvbHVtbldpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXVtpZHhdW3NpZ25dICs9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMod2lkdGgpIDwgYmFyTWluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9ICh3aWR0aCA8IDAgPyAtMSA6IDEpICogYmFyTWluSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtpZHhdW3NpZ25dICs9IHdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGNvb3JkWzBdICsgY29sdW1uT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB5ID0gbGFzdENvb3JkO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGNvbHVtbldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBjb29yZFsxXSAtIGxhc3RDb29yZE9yaWdpbjtcblxuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhY2tDb29yZHNPcmlnaW5bc3RhY2tJZF1baWR4XVtzaWduXSArPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhoZWlnaHQpIDwgYmFyTWluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIHplcm8gdG8gaGFzIGEgcG9zaXRpdmUgYmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSAoaGVpZ2h0IDw9IDAgPyAtMSA6IDEpICogYmFyTWluSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtpZHhdW3NpZ25dICs9IGhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIGJhckxheW91dEdyaWQuZ2V0TGF5b3V0T25BeGlzID0gZ2V0TGF5b3V0T25BeGlzO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBiYXJMYXlvdXRHcmlkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2xheW91dC9iYXJHcmlkLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var graphic = __webpack_require__(34);\n    var zrUtil = __webpack_require__(20);\n    var echarts = __webpack_require__(17);\n\n    __webpack_require__(153);\n\n    __webpack_require__(168);\n\n    // Grid view\n    echarts.extendComponentView({\n\n        type: 'grid',\n\n        render: function (gridModel, ecModel) {\n            this.group.removeAll();\n            if (gridModel.get('show')) {\n                this.group.add(new graphic.Rect({\n                    shape: gridModel.coordinateSystem.getRect(),\n                    style: zrUtil.defaults({\n                        fill: gridModel.get('backgroundColor')\n                    }, gridModel.getItemStyle()),\n                    silent: true,\n                    z2: -1\n                }));\n            }\n        }\n\n    });\n\n    echarts.registerPreprocessor(function (option) {\n        // Only create grid when need\n        if (option.xAxis && option.yAxis && !option.grid) {\n            option.grid = {};\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9ncmlkU2ltcGxlLmpzP2VlYzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLIiwiZmlsZSI6IjE2Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGVjaGFydHMgPSByZXF1aXJlKCcuLi9lY2hhcnRzJyk7XG5cbiAgICByZXF1aXJlKCcuLi9jb29yZC9jYXJ0ZXNpYW4vR3JpZCcpO1xuXG4gICAgcmVxdWlyZSgnLi9heGlzJyk7XG5cbiAgICAvLyBHcmlkIHZpZXdcbiAgICBlY2hhcnRzLmV4dGVuZENvbXBvbmVudFZpZXcoe1xuXG4gICAgICAgIHR5cGU6ICdncmlkJyxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChncmlkTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICBpZiAoZ3JpZE1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCksXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZ3JpZE1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJylcbiAgICAgICAgICAgICAgICAgICAgfSwgZ3JpZE1vZGVsLmdldEl0ZW1TdHlsZSgpKSxcbiAgICAgICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB6MjogLTFcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlclByZXByb2Nlc3NvcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIGdyaWQgd2hlbiBuZWVkXG4gICAgICAgIGlmIChvcHRpb24ueEF4aXMgJiYgb3B0aW9uLnlBeGlzICYmICFvcHRpb24uZ3JpZCkge1xuICAgICAgICAgICAgb3B0aW9uLmdyaWQgPSB7fTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9ncmlkU2ltcGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n// TODO boundaryGap\n\n\n    __webpack_require__(158);\n\n    __webpack_require__(169);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzLmpzPzhhODciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7O0FBRUEiLCJmaWxlIjoiMTY4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gVE9ETyBib3VuZGFyeUdhcFxuXG5cbiAgICByZXF1aXJlKCcuLi9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsJyk7XG5cbiAgICByZXF1aXJlKCcuL2F4aXMvQ2FydGVzaWFuQXhpc1ZpZXcnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n    var graphic = __webpack_require__(34);\n    var AxisBuilder = __webpack_require__(140);\n    var AxisView = __webpack_require__(142);\n    var cartesianAxisHelper = __webpack_require__(141);\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n    var getInterval = AxisBuilder.getInterval;\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n    var selfBuilderAttrs = [\n        'splitArea', 'splitLine'\n    ];\n\n    // function getAlignWithLabel(model, axisModel) {\n    //     var alignWithLabel = model.get('alignWithLabel');\n    //     if (alignWithLabel === 'auto') {\n    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n    //     }\n    //     return alignWithLabel;\n    // }\n\n    var CartesianAxisView = AxisView.extend({\n\n        type: 'cartesianAxis',\n\n        axisPointerClass: 'CartesianAxisPointer',\n\n        /**\n         * @override\n         */\n        render: function (axisModel, ecModel, api, payload) {\n\n            this.group.removeAll();\n\n            var oldAxisGroup = this._axisGroup;\n            this._axisGroup = new graphic.Group();\n\n            this.group.add(this._axisGroup);\n\n            if (!axisModel.get('show')) {\n                return;\n            }\n\n            var gridModel = axisModel.getCoordSysModel();\n\n            var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n\n            var axisBuilder = new AxisBuilder(axisModel, layout);\n\n            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n            this._axisGroup.add(axisBuilder.getGroup());\n\n            zrUtil.each(selfBuilderAttrs, function (name) {\n                if (axisModel.get(name + '.show')) {\n                    this['_' + name](axisModel, gridModel, layout.labelInterval);\n                }\n            }, this);\n\n            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n\n            CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitLine: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.scale.isBlank()) {\n                return;\n            }\n\n            var splitLineModel = axisModel.getModel('splitLine');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var lineColors = lineStyleModel.get('color');\n\n            var lineInterval = getInterval(splitLineModel, labelInterval);\n\n            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n            var isHorizontal = axis.isHorizontal();\n\n            var lineCount = 0;\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitLineModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var p1 = [];\n            var p2 = [];\n            // Simple optimization\n            // Batching the lines if color are the same\n            var lineStyle = lineStyleModel.getLineStyle();\n            for (var i = 0; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, lineInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                if (isHorizontal) {\n                    p1[0] = tickCoord;\n                    p1[1] = gridRect.y;\n                    p2[0] = tickCoord;\n                    p2[1] = gridRect.y + gridRect.height;\n                }\n                else {\n                    p1[0] = gridRect.x;\n                    p1[1] = tickCoord;\n                    p2[0] = gridRect.x + gridRect.width;\n                    p2[1] = tickCoord;\n                }\n\n                var colorIndex = (lineCount++) % lineColors.length;\n                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                    anid: 'line_' + ticks[i],\n\n                    shape: {\n                        x1: p1[0],\n                        y1: p1[1],\n                        x2: p2[0],\n                        y2: p2[1]\n                    },\n                    style: zrUtil.defaults({\n                        stroke: lineColors[colorIndex]\n                    }, lineStyle),\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitArea: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.scale.isBlank()) {\n                return;\n            }\n\n            var splitAreaModel = axisModel.getModel('splitArea');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n            var areaColors = areaStyleModel.get('color');\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitAreaModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var prevX = axis.toGlobalCoord(ticksCoords[0]);\n            var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\n            var count = 0;\n\n            var areaInterval = getInterval(splitAreaModel, labelInterval);\n\n            var areaStyle = areaStyleModel.getAreaStyle();\n            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n            for (var i = 1; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, areaInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                var x;\n                var y;\n                var width;\n                var height;\n                if (axis.isHorizontal()) {\n                    x = prevX;\n                    y = gridRect.y;\n                    width = tickCoord - x;\n                    height = gridRect.height;\n                }\n                else {\n                    x = gridRect.x;\n                    y = prevY;\n                    width = gridRect.width;\n                    height = tickCoord - y;\n                }\n\n                var colorIndex = (count++) % areaColors.length;\n                this._axisGroup.add(new graphic.Rect({\n                    anid: 'area_' + ticks[i],\n\n                    shape: {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    },\n                    style: zrUtil.defaults({\n                        fill: areaColors[colorIndex]\n                    }, areaStyle),\n                    silent: true\n                }));\n\n                prevX = x + width;\n                prevY = y + height;\n            }\n        }\n    });\n\n    CartesianAxisView.extend({\n        type: 'xAxis'\n    });\n    CartesianAxisView.extend({\n        type: 'yAxis'\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL0NhcnRlc2lhbkF4aXNWaWV3LmpzPzA3NmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQix5Q0FBeUM7QUFDNUQsbUJBQW1CLHlDQUF5QztBQUM1RCxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLHlDQUF5QztBQUM1RCxtQkFBbUIseUNBQXlDO0FBQzVELG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiMTY5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgQXhpc0J1aWxkZXIgPSByZXF1aXJlKCcuL0F4aXNCdWlsZGVyJyk7XG4gICAgdmFyIEF4aXNWaWV3ID0gcmVxdWlyZSgnLi9BeGlzVmlldycpO1xuICAgIHZhciBjYXJ0ZXNpYW5BeGlzSGVscGVyID0gcmVxdWlyZSgnLi9jYXJ0ZXNpYW5BeGlzSGVscGVyJyk7XG4gICAgdmFyIGlmSWdub3JlT25UaWNrID0gQXhpc0J1aWxkZXIuaWZJZ25vcmVPblRpY2s7XG4gICAgdmFyIGdldEludGVydmFsID0gQXhpc0J1aWxkZXIuZ2V0SW50ZXJ2YWw7XG5cbiAgICB2YXIgYXhpc0J1aWxkZXJBdHRycyA9IFtcbiAgICAgICAgJ2F4aXNMaW5lJywgJ2F4aXNMYWJlbCcsICdheGlzVGljaycsICdheGlzTmFtZSdcbiAgICBdO1xuICAgIHZhciBzZWxmQnVpbGRlckF0dHJzID0gW1xuICAgICAgICAnc3BsaXRBcmVhJywgJ3NwbGl0TGluZSdcbiAgICBdO1xuXG4gICAgLy8gZnVuY3Rpb24gZ2V0QWxpZ25XaXRoTGFiZWwobW9kZWwsIGF4aXNNb2RlbCkge1xuICAgIC8vICAgICB2YXIgYWxpZ25XaXRoTGFiZWwgPSBtb2RlbC5nZXQoJ2FsaWduV2l0aExhYmVsJyk7XG4gICAgLy8gICAgIGlmIChhbGlnbldpdGhMYWJlbCA9PT0gJ2F1dG8nKSB7XG4gICAgLy8gICAgICAgICBhbGlnbldpdGhMYWJlbCA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNUaWNrLmFsaWduV2l0aExhYmVsJyk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgcmV0dXJuIGFsaWduV2l0aExhYmVsO1xuICAgIC8vIH1cblxuICAgIHZhciBDYXJ0ZXNpYW5BeGlzVmlldyA9IEF4aXNWaWV3LmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2NhcnRlc2lhbkF4aXMnLFxuXG4gICAgICAgIGF4aXNQb2ludGVyQ2xhc3M6ICdDYXJ0ZXNpYW5BeGlzUG9pbnRlcicsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcblxuICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcblxuICAgICAgICAgICAgdmFyIG9sZEF4aXNHcm91cCA9IHRoaXMuX2F4aXNHcm91cDtcbiAgICAgICAgICAgIHRoaXMuX2F4aXNHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2F4aXNHcm91cCk7XG5cbiAgICAgICAgICAgIGlmICghYXhpc01vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ3JpZE1vZGVsID0gYXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKTtcblxuICAgICAgICAgICAgdmFyIGxheW91dCA9IGNhcnRlc2lhbkF4aXNIZWxwZXIubGF5b3V0KGdyaWRNb2RlbCwgYXhpc01vZGVsKTtcblxuICAgICAgICAgICAgdmFyIGF4aXNCdWlsZGVyID0gbmV3IEF4aXNCdWlsZGVyKGF4aXNNb2RlbCwgbGF5b3V0KTtcblxuICAgICAgICAgICAgenJVdGlsLmVhY2goYXhpc0J1aWxkZXJBdHRycywgYXhpc0J1aWxkZXIuYWRkLCBheGlzQnVpbGRlcik7XG5cbiAgICAgICAgICAgIHRoaXMuX2F4aXNHcm91cC5hZGQoYXhpc0J1aWxkZXIuZ2V0R3JvdXAoKSk7XG5cbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHNlbGZCdWlsZGVyQXR0cnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNNb2RlbC5nZXQobmFtZSArICcuc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgbmFtZV0oYXhpc01vZGVsLCBncmlkTW9kZWwsIGxheW91dC5sYWJlbEludGVydmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgZ3JhcGhpYy5ncm91cFRyYW5zaXRpb24ob2xkQXhpc0dyb3VwLCB0aGlzLl9heGlzR3JvdXAsIGF4aXNNb2RlbCk7XG5cbiAgICAgICAgICAgIENhcnRlc2lhbkF4aXNWaWV3LnN1cGVyQ2FsbCh0aGlzLCAncmVuZGVyJywgYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWx9IGF4aXNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWx9IGdyaWRNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxGdW5jdGlvbn0gbGFiZWxJbnRlcnZhbFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3NwbGl0TGluZTogZnVuY3Rpb24gKGF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBsYWJlbEludGVydmFsKSB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuXG4gICAgICAgICAgICBpZiAoYXhpcy5zY2FsZS5pc0JsYW5rKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzcGxpdExpbmVNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnc3BsaXRMaW5lJyk7XG4gICAgICAgICAgICB2YXIgbGluZVN0eWxlTW9kZWwgPSBzcGxpdExpbmVNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJyk7XG4gICAgICAgICAgICB2YXIgbGluZUNvbG9ycyA9IGxpbmVTdHlsZU1vZGVsLmdldCgnY29sb3InKTtcblxuICAgICAgICAgICAgdmFyIGxpbmVJbnRlcnZhbCA9IGdldEludGVydmFsKHNwbGl0TGluZU1vZGVsLCBsYWJlbEludGVydmFsKTtcblxuICAgICAgICAgICAgbGluZUNvbG9ycyA9IHpyVXRpbC5pc0FycmF5KGxpbmVDb2xvcnMpID8gbGluZUNvbG9ycyA6IFtsaW5lQ29sb3JzXTtcblxuICAgICAgICAgICAgdmFyIGdyaWRSZWN0ID0gZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpO1xuICAgICAgICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGF4aXMuaXNIb3Jpem9udGFsKCk7XG5cbiAgICAgICAgICAgIHZhciBsaW5lQ291bnQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgdGlja3NDb29yZHMgPSBheGlzLmdldFRpY2tzQ29vcmRzKFxuICAgICAgICAgICAgICAgIC8vIHNwbGl0TGluZU1vZGVsLmdldCgnYWxpZ25XaXRoTGFiZWwnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciB0aWNrcyA9IGF4aXMuc2NhbGUuZ2V0VGlja3MoKTtcblxuICAgICAgICAgICAgdmFyIHAxID0gW107XG4gICAgICAgICAgICB2YXIgcDIgPSBbXTtcbiAgICAgICAgICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIC8vIEJhdGNoaW5nIHRoZSBsaW5lcyBpZiBjb2xvciBhcmUgdGhlIHNhbWVcbiAgICAgICAgICAgIHZhciBsaW5lU3R5bGUgPSBsaW5lU3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3NDb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaWZJZ25vcmVPblRpY2soYXhpcywgaSwgbGluZUludGVydmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGlja0Nvb3JkID0gYXhpcy50b0dsb2JhbENvb3JkKHRpY2tzQ29vcmRzW2ldKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcDFbMF0gPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAgICAgICAgIHAxWzFdID0gZ3JpZFJlY3QueTtcbiAgICAgICAgICAgICAgICAgICAgcDJbMF0gPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAgICAgICAgIHAyWzFdID0gZ3JpZFJlY3QueSArIGdyaWRSZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAxWzBdID0gZ3JpZFJlY3QueDtcbiAgICAgICAgICAgICAgICAgICAgcDFbMV0gPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAgICAgICAgIHAyWzBdID0gZ3JpZFJlY3QueCArIGdyaWRSZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBwMlsxXSA9IHRpY2tDb29yZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sb3JJbmRleCA9IChsaW5lQ291bnQrKykgJSBsaW5lQ29sb3JzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9heGlzR3JvdXAuYWRkKG5ldyBncmFwaGljLkxpbmUoZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSh7XG4gICAgICAgICAgICAgICAgICAgIGFuaWQ6ICdsaW5lXycgKyB0aWNrc1tpXSxcblxuICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDE6IHAxWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTE6IHAxWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDI6IHAyWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTI6IHAyWzFdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5lQ29sb3JzW2NvbG9ySW5kZXhdXG4gICAgICAgICAgICAgICAgICAgIH0sIGxpbmVTdHlsZSksXG4gICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbH0gYXhpc01vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWRNb2RlbH0gZ3JpZE1vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfEZ1bmN0aW9ufSBsYWJlbEludGVydmFsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfc3BsaXRBcmVhOiBmdW5jdGlvbiAoYXhpc01vZGVsLCBncmlkTW9kZWwsIGxhYmVsSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG5cbiAgICAgICAgICAgIGlmIChheGlzLnNjYWxlLmlzQmxhbmsoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNwbGl0QXJlYU1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdzcGxpdEFyZWEnKTtcbiAgICAgICAgICAgIHZhciBhcmVhU3R5bGVNb2RlbCA9IHNwbGl0QXJlYU1vZGVsLmdldE1vZGVsKCdhcmVhU3R5bGUnKTtcbiAgICAgICAgICAgIHZhciBhcmVhQ29sb3JzID0gYXJlYVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuXG4gICAgICAgICAgICB2YXIgZ3JpZFJlY3QgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCk7XG5cbiAgICAgICAgICAgIHZhciB0aWNrc0Nvb3JkcyA9IGF4aXMuZ2V0VGlja3NDb29yZHMoXG4gICAgICAgICAgICAgICAgLy8gc3BsaXRBcmVhTW9kZWwuZ2V0KCdhbGlnbldpdGhMYWJlbCcpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIHRpY2tzID0gYXhpcy5zY2FsZS5nZXRUaWNrcygpO1xuXG4gICAgICAgICAgICB2YXIgcHJldlggPSBheGlzLnRvR2xvYmFsQ29vcmQodGlja3NDb29yZHNbMF0pO1xuICAgICAgICAgICAgdmFyIHByZXZZID0gYXhpcy50b0dsb2JhbENvb3JkKHRpY2tzQ29vcmRzWzBdKTtcblxuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcblxuICAgICAgICAgICAgdmFyIGFyZWFJbnRlcnZhbCA9IGdldEludGVydmFsKHNwbGl0QXJlYU1vZGVsLCBsYWJlbEludGVydmFsKTtcblxuICAgICAgICAgICAgdmFyIGFyZWFTdHlsZSA9IGFyZWFTdHlsZU1vZGVsLmdldEFyZWFTdHlsZSgpO1xuICAgICAgICAgICAgYXJlYUNvbG9ycyA9IHpyVXRpbC5pc0FycmF5KGFyZWFDb2xvcnMpID8gYXJlYUNvbG9ycyA6IFthcmVhQ29sb3JzXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aWNrc0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpZklnbm9yZU9uVGljayhheGlzLCBpLCBhcmVhSW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLnRvR2xvYmFsQ29vcmQodGlja3NDb29yZHNbaV0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgICAgICAgdmFyIHk7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHByZXZYO1xuICAgICAgICAgICAgICAgICAgICB5ID0gZ3JpZFJlY3QueTtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSB0aWNrQ29vcmQgLSB4O1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBncmlkUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4ID0gZ3JpZFJlY3QueDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHByZXZZO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGdyaWRSZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aWNrQ29vcmQgLSB5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjb2xvckluZGV4ID0gKGNvdW50KyspICUgYXJlYUNvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXhpc0dyb3VwLmFkZChuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgYW5pZDogJ2FyZWFfJyArIHRpY2tzW2ldLFxuXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogYXJlYUNvbG9yc1tjb2xvckluZGV4XVxuICAgICAgICAgICAgICAgICAgICB9LCBhcmVhU3R5bGUpLFxuICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICBwcmV2WCA9IHggKyB3aWR0aDtcbiAgICAgICAgICAgICAgICBwcmV2WSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIENhcnRlc2lhbkF4aXNWaWV3LmV4dGVuZCh7XG4gICAgICAgIHR5cGU6ICd4QXhpcydcbiAgICB9KTtcbiAgICBDYXJ0ZXNpYW5BeGlzVmlldy5leHRlbmQoe1xuICAgICAgICB0eXBlOiAneUF4aXMnXG4gICAgfSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9DYXJ0ZXNpYW5BeGlzVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n    var echarts = __webpack_require__(17);\n    var PRIORITY = echarts.PRIORITY;\n\n    __webpack_require__(171);\n    __webpack_require__(172);\n\n    echarts.registerVisual(zrUtil.curry(\n        __webpack_require__(178), 'line', 'circle', 'line'\n    ));\n    echarts.registerLayout(zrUtil.curry(\n        __webpack_require__(179), 'line'\n    ));\n\n    // Down sample after filter\n    echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(\n        __webpack_require__(180), 'line'\n    ));\n\n    // In case developer forget to include grid component\n    __webpack_require__(167);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2xpbmUuanM/ZjI1MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjE3MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vZWNoYXJ0cycpO1xuICAgIHZhciBQUklPUklUWSA9IGVjaGFydHMuUFJJT1JJVFk7XG5cbiAgICByZXF1aXJlKCcuL2xpbmUvTGluZVNlcmllcycpO1xuICAgIHJlcXVpcmUoJy4vbGluZS9MaW5lVmlldycpO1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlclZpc3VhbCh6clV0aWwuY3VycnkoXG4gICAgICAgIHJlcXVpcmUoJy4uL3Zpc3VhbC9zeW1ib2wnKSwgJ2xpbmUnLCAnY2lyY2xlJywgJ2xpbmUnXG4gICAgKSk7XG4gICAgZWNoYXJ0cy5yZWdpc3RlckxheW91dCh6clV0aWwuY3VycnkoXG4gICAgICAgIHJlcXVpcmUoJy4uL2xheW91dC9wb2ludHMnKSwgJ2xpbmUnXG4gICAgKSk7XG5cbiAgICAvLyBEb3duIHNhbXBsZSBhZnRlciBmaWx0ZXJcbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJvY2Vzc29yKFBSSU9SSVRZLlBST0NFU1NPUi5TVEFUSVNUSUMsIHpyVXRpbC5jdXJyeShcbiAgICAgICAgcmVxdWlyZSgnLi4vcHJvY2Vzc29yL2RhdGFTYW1wbGUnKSwgJ2xpbmUnXG4gICAgKSk7XG5cbiAgICAvLyBJbiBjYXNlIGRldmVsb3BlciBmb3JnZXQgdG8gaW5jbHVkZSBncmlkIGNvbXBvbmVudFxuICAgIHJlcXVpcmUoJy4uL2NvbXBvbmVudC9ncmlkU2ltcGxlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY2hhcnQvbGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var createListFromArray = __webpack_require__(125);\n    var SeriesModel = __webpack_require__(94);\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.line',\n\n        dependencies: ['grid', 'polar'],\n\n        getInitialData: function (option, ecModel) {\n            if (__DEV__) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {\n                    throw new Error('Line not support coordinateSystem besides cartesian and polar');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // 一级层叠\n            z: 2,                       // 二级层叠\n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // stack: null\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // polarIndex: 0,\n\n            // If clip the overflow value\n            clipOverflow: true,\n            // cursor: null,\n\n            label: {\n                normal: {\n                    position: 'top'\n                }\n            },\n            // itemStyle: {\n            //     normal: {},\n            //     emphasis: {}\n            // },\n            lineStyle: {\n                normal: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            // areaStyle: {},\n            // false, 'start', 'end', 'middle'\n            step: false,\n\n            // Disabled if step is true\n            smooth: false,\n            smoothMonotone: null,\n            // 拐点图形类型\n            symbol: 'emptyCircle',\n            // 拐点图形大小\n            symbolSize: 4,\n            // 拐点图形旋转控制\n            symbolRotate: null,\n\n            // 是否显示 symbol, 只有在 tooltip hover 的时候显示\n            showSymbol: true,\n            // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）\n            showAllSymbol: false,\n\n            // 是否连接断点\n            connectNulls: false,\n\n            // 数据过滤，'average', 'max', 'min', 'sum'\n            sampling: 'none',\n\n            animationEasing: 'linear',\n\n            // Disable progressive\n            progressive: 0,\n            hoverLayerThreshold: Infinity\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvTGluZVNlcmllcy5qcz82ZjY2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiMTcxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgY3JlYXRlTGlzdEZyb21BcnJheSA9IHJlcXVpcmUoJy4uL2hlbHBlci9jcmVhdGVMaXN0RnJvbUFycmF5Jyk7XG4gICAgdmFyIFNlcmllc01vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvU2VyaWVzJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNlcmllc01vZGVsLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3Nlcmllcy5saW5lJyxcblxuICAgICAgICBkZXBlbmRlbmNpZXM6IFsnZ3JpZCcsICdwb2xhciddLFxuXG4gICAgICAgIGdldEluaXRpYWxEYXRhOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IG9wdGlvbi5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgICAgIGlmIChjb29yZFN5cyAhPT0gJ3BvbGFyJyAmJiBjb29yZFN5cyAhPT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmUgbm90IHN1cHBvcnQgY29vcmRpbmF0ZVN5c3RlbSBiZXNpZGVzIGNhcnRlc2lhbiBhbmQgcG9sYXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTGlzdEZyb21BcnJheShvcHRpb24uZGF0YSwgdGhpcywgZWNNb2RlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xuICAgICAgICAgICAgemxldmVsOiAwLCAgICAgICAgICAgICAgICAgIC8vIOS4gOe6p+WxguWPoFxuICAgICAgICAgICAgejogMiwgICAgICAgICAgICAgICAgICAgICAgIC8vIOS6jOe6p+WxguWPoFxuICAgICAgICAgICAgY29vcmRpbmF0ZVN5c3RlbTogJ2NhcnRlc2lhbjJkJyxcbiAgICAgICAgICAgIGxlZ2VuZEhvdmVyTGluazogdHJ1ZSxcblxuICAgICAgICAgICAgaG92ZXJBbmltYXRpb246IHRydWUsXG4gICAgICAgICAgICAvLyBzdGFjazogbnVsbFxuICAgICAgICAgICAgLy8geEF4aXNJbmRleDogMCxcbiAgICAgICAgICAgIC8vIHlBeGlzSW5kZXg6IDAsXG5cbiAgICAgICAgICAgIC8vIHBvbGFySW5kZXg6IDAsXG5cbiAgICAgICAgICAgIC8vIElmIGNsaXAgdGhlIG92ZXJmbG93IHZhbHVlXG4gICAgICAgICAgICBjbGlwT3ZlcmZsb3c6IHRydWUsXG4gICAgICAgICAgICAvLyBjdXJzb3I6IG51bGwsXG5cbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAndG9wJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBpdGVtU3R5bGU6IHtcbiAgICAgICAgICAgIC8vICAgICBub3JtYWw6IHt9LFxuICAgICAgICAgICAgLy8gICAgIGVtcGhhc2lzOiB7fVxuICAgICAgICAgICAgLy8gfSxcbiAgICAgICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBhcmVhU3R5bGU6IHt9LFxuICAgICAgICAgICAgLy8gZmFsc2UsICdzdGFydCcsICdlbmQnLCAnbWlkZGxlJ1xuICAgICAgICAgICAgc3RlcDogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIERpc2FibGVkIGlmIHN0ZXAgaXMgdHJ1ZVxuICAgICAgICAgICAgc21vb3RoOiBmYWxzZSxcbiAgICAgICAgICAgIHNtb290aE1vbm90b25lOiBudWxsLFxuICAgICAgICAgICAgLy8g5ouQ54K55Zu+5b2i57G75Z6LXG4gICAgICAgICAgICBzeW1ib2w6ICdlbXB0eUNpcmNsZScsXG4gICAgICAgICAgICAvLyDmi5Dngrnlm77lvaLlpKflsI9cbiAgICAgICAgICAgIHN5bWJvbFNpemU6IDQsXG4gICAgICAgICAgICAvLyDmi5Dngrnlm77lvaLml4vovazmjqfliLZcbiAgICAgICAgICAgIHN5bWJvbFJvdGF0ZTogbnVsbCxcblxuICAgICAgICAgICAgLy8g5piv5ZCm5pi+56S6IHN5bWJvbCwg5Y+q5pyJ5ZyoIHRvb2x0aXAgaG92ZXIg55qE5pe25YCZ5pi+56S6XG4gICAgICAgICAgICBzaG93U3ltYm9sOiB0cnVlLFxuICAgICAgICAgICAgLy8g5qCH5b+X5Zu+5b2i6buY6K6k5Y+q5pyJ5Li76L205pi+56S677yI6ZqP5Li76L205qCH562+6Ze06ZqU6ZqQ6JeP562W55Wl77yJXG4gICAgICAgICAgICBzaG93QWxsU3ltYm9sOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8g5piv5ZCm6L+e5o6l5pat54K5XG4gICAgICAgICAgICBjb25uZWN0TnVsbHM6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyDmlbDmja7ov4fmu6TvvIwnYXZlcmFnZScsICdtYXgnLCAnbWluJywgJ3N1bSdcbiAgICAgICAgICAgIHNhbXBsaW5nOiAnbm9uZScsXG5cbiAgICAgICAgICAgIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcicsXG5cbiAgICAgICAgICAgIC8vIERpc2FibGUgcHJvZ3Jlc3NpdmVcbiAgICAgICAgICAgIHByb2dyZXNzaXZlOiAwLFxuICAgICAgICAgICAgaG92ZXJMYXllclRocmVzaG9sZDogSW5maW5pdHlcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvTGluZVNlcmllcy5qc1xuLy8gbW9kdWxlIGlkID0gMTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("'use strict';\n// FIXME step not support polar\n\n\n    var zrUtil = __webpack_require__(20);\n    var SymbolDraw = __webpack_require__(173);\n    var Symbol = __webpack_require__(174);\n    var lineAnimationDiff = __webpack_require__(176);\n    var graphic = __webpack_require__(34);\n    var modelUtil = __webpack_require__(21);\n    var polyHelper = __webpack_require__(177);\n    var ChartView = __webpack_require__(96);\n\n    function isPointsSame(points1, points2) {\n        if (points1.length !== points2.length) {\n            return;\n        }\n        for (var i = 0; i < points1.length; i++) {\n            var p1 = points1[i];\n            var p2 = points2[i];\n            if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n                return;\n            }\n        }\n        return true;\n    }\n\n    function getSmooth(smooth) {\n        return typeof (smooth) === 'number' ? smooth : (smooth ? 0.3 : 0);\n    }\n\n    function getAxisExtentWithGap(axis) {\n        var extent = axis.getGlobalExtent();\n        if (axis.onBand) {\n            // Remove extra 1px to avoid line miter in clipped edge\n            var halfBandWidth = axis.getBandWidth() / 2 - 1;\n            var dir = extent[1] > extent[0] ? 1 : -1;\n            extent[0] += dir * halfBandWidth;\n            extent[1] -= dir * halfBandWidth;\n        }\n        return extent;\n    }\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n    /**\n     * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n     * @param {module:echarts/data/List} data\n     * @param {Array.<Array.<number>>} points\n     * @private\n     */\n    function getStackedOnPoints(coordSys, data) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        return data.mapArray([valueDim], function (val, idx) {\n            var stackedOnSameSign;\n            var stackedOn = data.stackedOn;\n            // Find first stacked value with same sign\n            while (stackedOn &&\n                sign(stackedOn.get(valueDim, idx)) === sign(val)\n            ) {\n                stackedOnSameSign = stackedOn;\n                break;\n            }\n            var stackedData = [];\n            stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n            stackedData[1 - baseDataOffset] = stackedOnSameSign\n                ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n            return coordSys.dataToPoint(stackedData);\n        }, true);\n    }\n\n    function createGridClipShape(cartesian, hasAnimation, seriesModel) {\n        var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n        var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n        var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n\n        var x = Math.min(xExtent[0], xExtent[1]);\n        var y = Math.min(yExtent[0], yExtent[1]);\n        var width = Math.max(xExtent[0], xExtent[1]) - x;\n        var height = Math.max(yExtent[0], yExtent[1]) - y;\n        var lineWidth = seriesModel.get('lineStyle.normal.width') || 2;\n        // Expand clip shape to avoid clipping when line value exceeds axis\n        var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n        if (isHorizontal) {\n            y -= expandSize;\n            height += expandSize * 2;\n        }\n        else {\n            x -= expandSize;\n            width += expandSize * 2;\n        }\n\n        var clipPath = new graphic.Rect({\n            shape: {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n            graphic.initProps(clipPath, {\n                shape: {\n                    width: width,\n                    height: height\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createPolarClipShape(polar, hasAnimation, seriesModel) {\n        var angleAxis = polar.getAngleAxis();\n        var radiusAxis = polar.getRadiusAxis();\n\n        var radiusExtent = radiusAxis.getExtent();\n        var angleExtent = angleAxis.getExtent();\n\n        var RADIAN = Math.PI / 180;\n\n        var clipPath = new graphic.Sector({\n            shape: {\n                cx: polar.cx,\n                cy: polar.cy,\n                r0: radiusExtent[0],\n                r: radiusExtent[1],\n                startAngle: -angleExtent[0] * RADIAN,\n                endAngle: -angleExtent[1] * RADIAN,\n                clockwise: angleAxis.inverse\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: -angleExtent[1] * RADIAN\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createClipShape(coordSys, hasAnimation, seriesModel) {\n        return coordSys.type === 'polar'\n            ? createPolarClipShape(coordSys, hasAnimation, seriesModel)\n            : createGridClipShape(coordSys, hasAnimation, seriesModel);\n    }\n\n    function turnPointsIntoStep(points, coordSys, stepTurnAt) {\n        var baseAxis = coordSys.getBaseAxis();\n        var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\n        var stepPoints = [];\n        for (var i = 0; i < points.length - 1; i++) {\n            var nextPt = points[i + 1];\n            var pt = points[i];\n            stepPoints.push(pt);\n\n            var stepPt = [];\n            switch (stepTurnAt) {\n                case 'end':\n                    stepPt[baseIndex] = nextPt[baseIndex];\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n                    break;\n                case 'middle':\n                    // default is start\n                    var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n                    var stepPt2 = [];\n                    stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n                    stepPoints.push(stepPt);\n                    stepPoints.push(stepPt2);\n                    break;\n                default:\n                    stepPt[baseIndex] = pt[baseIndex];\n                    stepPt[1 - baseIndex] = nextPt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n            }\n        }\n        // Last points\n        points[i] && stepPoints.push(points[i]);\n        return stepPoints;\n    }\n\n    function getVisualGradient(data, coordSys) {\n        var visualMetaList = data.getVisual('visualMeta');\n        if (!visualMetaList || !visualMetaList.length || !data.count()) {\n            // When data.count() is 0, gradient range can not be calculated.\n            return;\n        }\n\n        var visualMeta;\n        for (var i = visualMetaList.length - 1; i >= 0; i--) {\n            // Can only be x or y\n            if (visualMetaList[i].dimension < 2) {\n                visualMeta = visualMetaList[i];\n                break;\n            }\n        }\n        if (!visualMeta || coordSys.type !== 'cartesian2d') {\n            if (__DEV__) {\n                console.warn('Visual map on line style only support x or y dimension.');\n            }\n            return;\n        }\n\n        // If the area to be rendered is bigger than area defined by LinearGradient,\n        // the canvas spec prescribes that the color of the first stop and the last\n        // stop should be used. But if two stops are added at offset 0, in effect\n        // browsers use the color of the second stop to render area outside\n        // LinearGradient. So we can only infinitesimally extend area defined in\n        // LinearGradient to render `outerColors`.\n\n        var dimension = visualMeta.dimension;\n        var dimName = data.dimensions[dimension];\n        var axis = coordSys.getAxis(dimName);\n\n        // dataToCoor mapping may not be linear, but must be monotonic.\n        var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n            return {\n                coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n                color: stop.color\n            };\n        });\n        var stopLen = colorStops.length;\n        var outerColors = visualMeta.outerColors.slice();\n\n        if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n            colorStops.reverse();\n            outerColors.reverse();\n        }\n\n        var tinyExtent = 10; // Arbitrary value: 10px\n        var minCoord = colorStops[0].coord - tinyExtent;\n        var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n        var coordSpan = maxCoord - minCoord;\n\n        if (coordSpan < 1e-3) {\n            return 'transparent';\n        }\n\n        zrUtil.each(colorStops, function (stop) {\n            stop.offset = (stop.coord - minCoord) / coordSpan;\n        });\n        colorStops.push({\n            offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n            color: outerColors[1] || 'transparent'\n        });\n        colorStops.unshift({ // notice colorStops.length have been changed.\n            offset: stopLen ? colorStops[0].offset : 0.5,\n            color: outerColors[0] || 'transparent'\n        });\n\n        // zrUtil.each(colorStops, function (colorStop) {\n        //     // Make sure each offset has rounded px to avoid not sharp edge\n        //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n        // });\n\n        var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n        gradient[dimName] = minCoord;\n        gradient[dimName + '2'] = maxCoord;\n\n        return gradient;\n    }\n\n    module.exports = ChartView.extend({\n\n        type: 'line',\n\n        init: function () {\n            var lineGroup = new graphic.Group();\n\n            var symbolDraw = new SymbolDraw();\n            this.group.add(symbolDraw.group);\n\n            this._symbolDraw = symbolDraw;\n            this._lineGroup = lineGroup;\n        },\n\n        render: function (seriesModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var group = this.group;\n            var data = seriesModel.getData();\n            var lineStyleModel = seriesModel.getModel('lineStyle.normal');\n            var areaStyleModel = seriesModel.getModel('areaStyle.normal');\n\n            var points = data.mapArray(data.getItemLayout, true);\n\n            var isCoordSysPolar = coordSys.type === 'polar';\n            var prevCoordSys = this._coordSys;\n\n            var symbolDraw = this._symbolDraw;\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n\n            var lineGroup = this._lineGroup;\n\n            var hasAnimation = seriesModel.get('animation');\n\n            var isAreaChart = !areaStyleModel.isEmpty();\n            var stackedOnPoints = getStackedOnPoints(coordSys, data);\n\n            var showSymbol = seriesModel.get('showSymbol');\n\n            var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol')\n                && this._getSymbolIgnoreFunc(data, coordSys);\n\n            // Remove temporary symbols\n            var oldData = this._data;\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            // Remove previous created symbols if showSymbol changed to false\n            if (!showSymbol) {\n                symbolDraw.remove();\n            }\n\n            group.add(lineGroup);\n\n            // FIXME step not support polar\n            var step = !isCoordSysPolar && seriesModel.get('step');\n            // Initialization animation or coordinate system changed\n            if (\n                !(polyline && prevCoordSys.type === coordSys.type && step === this._step)\n            ) {\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                if (step) {\n                    // TODO If stacked series is not step\n                    points = turnPointsIntoStep(points, coordSys, step);\n                    stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                }\n\n                polyline = this._newPolyline(points, coordSys, hasAnimation);\n                if (isAreaChart) {\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n            }\n            else {\n                if (isAreaChart && !polygon) {\n                    // If areaStyle is added\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                else if (polygon && !isAreaChart) {\n                    // If areaStyle is removed\n                    lineGroup.remove(polygon);\n                    polygon = this._polygon = null;\n                }\n\n                // Update clipPath\n                lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));\n\n                // Always update, or it is wrong in the case turning on legend\n                // because points are not changed\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                // Stop symbol animation and sync with line points\n                // FIXME performance?\n                data.eachItemGraphicEl(function (el) {\n                    el.stopAnimation(true);\n                });\n\n                // In the case data zoom triggerred refreshing frequently\n                // Data may not change if line has a category axis. So it should animate nothing\n                if (!isPointsSame(this._stackedOnPoints, stackedOnPoints)\n                    || !isPointsSame(this._points, points)\n                ) {\n                    if (hasAnimation) {\n                        this._updateAnimation(\n                            data, stackedOnPoints, coordSys, api, step\n                        );\n                    }\n                    else {\n                        // Not do it in update with animation\n                        if (step) {\n                            // TODO If stacked series is not step\n                            points = turnPointsIntoStep(points, coordSys, step);\n                            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                        }\n\n                        polyline.setShape({\n                            points: points\n                        });\n                        polygon && polygon.setShape({\n                            points: points,\n                            stackedOnPoints: stackedOnPoints\n                        });\n                    }\n                }\n            }\n\n            var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n\n            polyline.useStyle(zrUtil.defaults(\n                // Use color in lineStyle first\n                lineStyleModel.getLineStyle(),\n                {\n                    fill: 'none',\n                    stroke: visualColor,\n                    lineJoin: 'bevel'\n                }\n            ));\n\n            var smooth = seriesModel.get('smooth');\n            smooth = getSmooth(seriesModel.get('smooth'));\n            polyline.setShape({\n                smooth: smooth,\n                smoothMonotone: seriesModel.get('smoothMonotone'),\n                connectNulls: seriesModel.get('connectNulls')\n            });\n\n            if (polygon) {\n                var stackedOn = data.stackedOn;\n                var stackedOnSmooth = 0;\n\n                polygon.useStyle(zrUtil.defaults(\n                    areaStyleModel.getAreaStyle(),\n                    {\n                        fill: visualColor,\n                        opacity: 0.7,\n                        lineJoin: 'bevel'\n                    }\n                ));\n\n                if (stackedOn) {\n                    var stackedOnSeries = stackedOn.hostModel;\n                    stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n                }\n\n                polygon.setShape({\n                    smooth: smooth,\n                    stackedOnSmooth: stackedOnSmooth,\n                    smoothMonotone: seriesModel.get('smoothMonotone'),\n                    connectNulls: seriesModel.get('connectNulls')\n                });\n            }\n\n            this._data = data;\n            // Save the coordinate system for transition animation when data changed\n            this._coordSys = coordSys;\n            this._stackedOnPoints = stackedOnPoints;\n            this._points = points;\n            this._step = step;\n        },\n\n        dispose: function () {},\n\n        highlight: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n            if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (!symbol) {\n                    // Create a temporary symbol if it is not exists\n                    var pt = data.getItemLayout(dataIndex);\n                    if (!pt) {\n                        // Null data\n                        return;\n                    }\n                    symbol = new Symbol(data, dataIndex);\n                    symbol.position = pt;\n                    symbol.setZ(\n                        seriesModel.get('zlevel'),\n                        seriesModel.get('z')\n                    );\n                    symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n                    symbol.__temp = true;\n                    data.setItemGraphicEl(dataIndex, symbol);\n\n                    // Stop scale animation\n                    symbol.stopSymbolAnimation(true);\n\n                    this.group.add(symbol);\n                }\n                symbol.highlight();\n            }\n            else {\n                // Highlight whole series\n                ChartView.prototype.highlight.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        downplay: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n            if (dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (symbol) {\n                    if (symbol.__temp) {\n                        data.setItemGraphicEl(dataIndex, null);\n                        this.group.remove(symbol);\n                    }\n                    else {\n                        symbol.downplay();\n                    }\n                }\n            }\n            else {\n                // FIXME\n                // can not downplay completely.\n                // Downplay whole series\n                ChartView.prototype.downplay.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolyline: function (points) {\n            var polyline = this._polyline;\n            // Remove previous created polyline\n            if (polyline) {\n                this._lineGroup.remove(polyline);\n            }\n\n            polyline = new polyHelper.Polyline({\n                shape: {\n                    points: points\n                },\n                silent: true,\n                z2: 10\n            });\n\n            this._lineGroup.add(polyline);\n\n            this._polyline = polyline;\n\n            return polyline;\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} stackedOnPoints\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolygon: function (points, stackedOnPoints) {\n            var polygon = this._polygon;\n            // Remove previous created polygon\n            if (polygon) {\n                this._lineGroup.remove(polygon);\n            }\n\n            polygon = new polyHelper.Polygon({\n                shape: {\n                    points: points,\n                    stackedOnPoints: stackedOnPoints\n                },\n                silent: true\n            });\n\n            this._lineGroup.add(polygon);\n\n            this._polygon = polygon;\n            return polygon;\n        },\n        /**\n         * @private\n         */\n        _getSymbolIgnoreFunc: function (data, coordSys) {\n            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n            // `getLabelInterval` is provided by echarts/component/axis\n            if (categoryAxis && categoryAxis.isLabelIgnored) {\n                return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n            }\n        },\n\n        /**\n         * @private\n         */\n        // FIXME Two value axis\n        _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n            var seriesModel = data.hostModel;\n\n            var diff = lineAnimationDiff(\n                this._data, data,\n                this._stackedOnPoints, stackedOnPoints,\n                this._coordSys, coordSys\n            );\n\n            var current = diff.current;\n            var stackedOnCurrent = diff.stackedOnCurrent;\n            var next = diff.next;\n            var stackedOnNext = diff.stackedOnNext;\n            if (step) {\n                // TODO If stacked series is not step\n                current = turnPointsIntoStep(diff.current, coordSys, step);\n                stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n                next = turnPointsIntoStep(diff.next, coordSys, step);\n                stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n            }\n            // `diff.current` is subset of `current` (which should be ensured by\n            // turnPointsIntoStep), so points in `__points` can be updated when\n            // points in `current` are update during animation.\n            polyline.shape.__points = diff.current;\n            polyline.shape.points = current;\n\n            graphic.updateProps(polyline, {\n                shape: {\n                    points: next\n                }\n            }, seriesModel);\n\n            if (polygon) {\n                polygon.setShape({\n                    points: current,\n                    stackedOnPoints: stackedOnCurrent\n                });\n                graphic.updateProps(polygon, {\n                    shape: {\n                        points: next,\n                        stackedOnPoints: stackedOnNext\n                    }\n                }, seriesModel);\n            }\n\n            var updatedDataInfo = [];\n            var diffStatus = diff.status;\n\n            for (var i = 0; i < diffStatus.length; i++) {\n                var cmd = diffStatus[i].cmd;\n                if (cmd === '=') {\n                    var el = data.getItemGraphicEl(diffStatus[i].idx1);\n                    if (el) {\n                        updatedDataInfo.push({\n                            el: el,\n                            ptIdx: i    // Index of points\n                        });\n                    }\n                }\n            }\n\n            if (polyline.animators && polyline.animators.length) {\n                polyline.animators[0].during(function () {\n                    for (var i = 0; i < updatedDataInfo.length; i++) {\n                        var el = updatedDataInfo[i].el;\n                        el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n                    }\n                });\n            }\n        },\n\n        remove: function (ecModel) {\n            var group = this.group;\n            var oldData = this._data;\n            this._lineGroup.removeAll();\n            this._symbolDraw.remove(true);\n            // Remove temporary created elements when highlighting\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            this._polyline =\n            this._polygon =\n            this._coordSys =\n            this._points =\n            this._stackedOnPoints =\n            this._data = null;\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvTGluZVZpZXcuanM/MDE4ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0RUFBNEU7QUFDM0YsZUFBZSx5QkFBeUI7QUFDeEMsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQiwrQkFBK0I7QUFDbEQsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xELG1CQUFtQix1QkFBdUI7QUFDMUMsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiMTcyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gRklYTUUgc3RlcCBub3Qgc3VwcG9ydCBwb2xhclxuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIFN5bWJvbERyYXcgPSByZXF1aXJlKCcuLi9oZWxwZXIvU3ltYm9sRHJhdycpO1xuICAgIHZhciBTeW1ib2wgPSByZXF1aXJlKCcuLi9oZWxwZXIvU3ltYm9sJyk7XG4gICAgdmFyIGxpbmVBbmltYXRpb25EaWZmID0gcmVxdWlyZSgnLi9saW5lQW5pbWF0aW9uRGlmZicpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoJy4vcG9seScpO1xuICAgIHZhciBDaGFydFZpZXcgPSByZXF1aXJlKCcuLi8uLi92aWV3L0NoYXJ0Jyk7XG5cbiAgICBmdW5jdGlvbiBpc1BvaW50c1NhbWUocG9pbnRzMSwgcG9pbnRzMikge1xuICAgICAgICBpZiAocG9pbnRzMS5sZW5ndGggIT09IHBvaW50czIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcDEgPSBwb2ludHMxW2ldO1xuICAgICAgICAgICAgdmFyIHAyID0gcG9pbnRzMltpXTtcbiAgICAgICAgICAgIGlmIChwMVswXSAhPT0gcDJbMF0gfHwgcDFbMV0gIT09IHAyWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNtb290aChzbW9vdGgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiAoc21vb3RoKSA9PT0gJ251bWJlcicgPyBzbW9vdGggOiAoc21vb3RoID8gMC4zIDogMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXhpc0V4dGVudFdpdGhHYXAoYXhpcykge1xuICAgICAgICB2YXIgZXh0ZW50ID0gYXhpcy5nZXRHbG9iYWxFeHRlbnQoKTtcbiAgICAgICAgaWYgKGF4aXMub25CYW5kKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgZXh0cmEgMXB4IHRvIGF2b2lkIGxpbmUgbWl0ZXIgaW4gY2xpcHBlZCBlZGdlXG4gICAgICAgICAgICB2YXIgaGFsZkJhbmRXaWR0aCA9IGF4aXMuZ2V0QmFuZFdpZHRoKCkgLyAyIC0gMTtcbiAgICAgICAgICAgIHZhciBkaXIgPSBleHRlbnRbMV0gPiBleHRlbnRbMF0gPyAxIDogLTE7XG4gICAgICAgICAgICBleHRlbnRbMF0gKz0gZGlyICogaGFsZkJhbmRXaWR0aDtcbiAgICAgICAgICAgIGV4dGVudFsxXSAtPSBkaXIgKiBoYWxmQmFuZFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2lnbih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+PSAwID8gMSA6IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRHxtb2R1bGU6ZWNoYXJ0cy9jb29yZC9wb2xhci9Qb2xhcn0gY29vcmRTeXNcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gcG9pbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTdGFja2VkT25Qb2ludHMoY29vcmRTeXMsIGRhdGEpIHtcbiAgICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgdmFyIHZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gICAgICAgIHZhciB2YWx1ZVN0YXJ0ID0gYmFzZUF4aXMub25aZXJvXG4gICAgICAgICAgICA/IDAgOiB2YWx1ZUF4aXMuc2NhbGUuZ2V0RXh0ZW50KClbMF07XG5cbiAgICAgICAgdmFyIHZhbHVlRGltID0gdmFsdWVBeGlzLmRpbTtcblxuICAgICAgICB2YXIgYmFzZURhdGFPZmZzZXQgPSB2YWx1ZURpbSA9PT0gJ3gnIHx8IHZhbHVlRGltID09PSAncmFkaXVzJyA/IDEgOiAwO1xuXG4gICAgICAgIHJldHVybiBkYXRhLm1hcEFycmF5KFt2YWx1ZURpbV0sIGZ1bmN0aW9uICh2YWwsIGlkeCkge1xuICAgICAgICAgICAgdmFyIHN0YWNrZWRPblNhbWVTaWduO1xuICAgICAgICAgICAgdmFyIHN0YWNrZWRPbiA9IGRhdGEuc3RhY2tlZE9uO1xuICAgICAgICAgICAgLy8gRmluZCBmaXJzdCBzdGFja2VkIHZhbHVlIHdpdGggc2FtZSBzaWduXG4gICAgICAgICAgICB3aGlsZSAoc3RhY2tlZE9uICYmXG4gICAgICAgICAgICAgICAgc2lnbihzdGFja2VkT24uZ2V0KHZhbHVlRGltLCBpZHgpKSA9PT0gc2lnbih2YWwpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzdGFja2VkT25TYW1lU2lnbiA9IHN0YWNrZWRPbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFja2VkRGF0YSA9IFtdO1xuICAgICAgICAgICAgc3RhY2tlZERhdGFbYmFzZURhdGFPZmZzZXRdID0gZGF0YS5nZXQoYmFzZUF4aXMuZGltLCBpZHgpO1xuICAgICAgICAgICAgc3RhY2tlZERhdGFbMSAtIGJhc2VEYXRhT2Zmc2V0XSA9IHN0YWNrZWRPblNhbWVTaWduXG4gICAgICAgICAgICAgICAgPyBzdGFja2VkT25TYW1lU2lnbi5nZXQodmFsdWVEaW0sIGlkeCwgdHJ1ZSkgOiB2YWx1ZVN0YXJ0O1xuXG4gICAgICAgICAgICByZXR1cm4gY29vcmRTeXMuZGF0YVRvUG9pbnQoc3RhY2tlZERhdGEpO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVHcmlkQ2xpcFNoYXBlKGNhcnRlc2lhbiwgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCkge1xuICAgICAgICB2YXIgeEV4dGVudCA9IGdldEF4aXNFeHRlbnRXaXRoR2FwKGNhcnRlc2lhbi5nZXRBeGlzKCd4JykpO1xuICAgICAgICB2YXIgeUV4dGVudCA9IGdldEF4aXNFeHRlbnRXaXRoR2FwKGNhcnRlc2lhbi5nZXRBeGlzKCd5JykpO1xuICAgICAgICB2YXIgaXNIb3Jpem9udGFsID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCkuaXNIb3Jpem9udGFsKCk7XG5cbiAgICAgICAgdmFyIHggPSBNYXRoLm1pbih4RXh0ZW50WzBdLCB4RXh0ZW50WzFdKTtcbiAgICAgICAgdmFyIHkgPSBNYXRoLm1pbih5RXh0ZW50WzBdLCB5RXh0ZW50WzFdKTtcbiAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5tYXgoeEV4dGVudFswXSwgeEV4dGVudFsxXSkgLSB4O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoeUV4dGVudFswXSwgeUV4dGVudFsxXSkgLSB5O1xuICAgICAgICB2YXIgbGluZVdpZHRoID0gc2VyaWVzTW9kZWwuZ2V0KCdsaW5lU3R5bGUubm9ybWFsLndpZHRoJykgfHwgMjtcbiAgICAgICAgLy8gRXhwYW5kIGNsaXAgc2hhcGUgdG8gYXZvaWQgY2xpcHBpbmcgd2hlbiBsaW5lIHZhbHVlIGV4Y2VlZHMgYXhpc1xuICAgICAgICB2YXIgZXhwYW5kU2l6ZSA9IHNlcmllc01vZGVsLmdldCgnY2xpcE92ZXJmbG93JykgPyBsaW5lV2lkdGggLyAyIDogTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIHkgLT0gZXhwYW5kU2l6ZTtcbiAgICAgICAgICAgIGhlaWdodCArPSBleHBhbmRTaXplICogMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHggLT0gZXhwYW5kU2l6ZTtcbiAgICAgICAgICAgIHdpZHRoICs9IGV4cGFuZFNpemUgKiAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNsaXBQYXRoID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc0FuaW1hdGlvbikge1xuICAgICAgICAgICAgY2xpcFBhdGguc2hhcGVbaXNIb3Jpem9udGFsID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSA9IDA7XG4gICAgICAgICAgICBncmFwaGljLmluaXRQcm9wcyhjbGlwUGF0aCwge1xuICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xpcFBhdGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUG9sYXJDbGlwU2hhcGUocG9sYXIsIGhhc0FuaW1hdGlvbiwgc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgdmFyIGFuZ2xlQXhpcyA9IHBvbGFyLmdldEFuZ2xlQXhpcygpO1xuICAgICAgICB2YXIgcmFkaXVzQXhpcyA9IHBvbGFyLmdldFJhZGl1c0F4aXMoKTtcblxuICAgICAgICB2YXIgcmFkaXVzRXh0ZW50ID0gcmFkaXVzQXhpcy5nZXRFeHRlbnQoKTtcbiAgICAgICAgdmFyIGFuZ2xlRXh0ZW50ID0gYW5nbGVBeGlzLmdldEV4dGVudCgpO1xuXG4gICAgICAgIHZhciBSQURJQU4gPSBNYXRoLlBJIC8gMTgwO1xuXG4gICAgICAgIHZhciBjbGlwUGF0aCA9IG5ldyBncmFwaGljLlNlY3Rvcih7XG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgIGN4OiBwb2xhci5jeCxcbiAgICAgICAgICAgICAgICBjeTogcG9sYXIuY3ksXG4gICAgICAgICAgICAgICAgcjA6IHJhZGl1c0V4dGVudFswXSxcbiAgICAgICAgICAgICAgICByOiByYWRpdXNFeHRlbnRbMV0sXG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogLWFuZ2xlRXh0ZW50WzBdICogUkFESUFOLFxuICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiAtYW5nbGVFeHRlbnRbMV0gKiBSQURJQU4sXG4gICAgICAgICAgICAgICAgY2xvY2t3aXNlOiBhbmdsZUF4aXMuaW52ZXJzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaGFzQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBjbGlwUGF0aC5zaGFwZS5lbmRBbmdsZSA9IC1hbmdsZUV4dGVudFswXSAqIFJBRElBTjtcbiAgICAgICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKGNsaXBQYXRoLCB7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZW5kQW5nbGU6IC1hbmdsZUV4dGVudFsxXSAqIFJBRElBTlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGlwUGF0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDbGlwU2hhcGUoY29vcmRTeXMsIGhhc0FuaW1hdGlvbiwgc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkU3lzLnR5cGUgPT09ICdwb2xhcidcbiAgICAgICAgICAgID8gY3JlYXRlUG9sYXJDbGlwU2hhcGUoY29vcmRTeXMsIGhhc0FuaW1hdGlvbiwgc2VyaWVzTW9kZWwpXG4gICAgICAgICAgICA6IGNyZWF0ZUdyaWRDbGlwU2hhcGUoY29vcmRTeXMsIGhhc0FuaW1hdGlvbiwgc2VyaWVzTW9kZWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHR1cm5Qb2ludHNJbnRvU3RlcChwb2ludHMsIGNvb3JkU3lzLCBzdGVwVHVybkF0KSB7XG4gICAgICAgIHZhciBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gICAgICAgIHZhciBiYXNlSW5kZXggPSBiYXNlQXhpcy5kaW0gPT09ICd4JyB8fCBiYXNlQXhpcy5kaW0gPT09ICdyYWRpdXMnID8gMCA6IDE7XG5cbiAgICAgICAgdmFyIHN0ZXBQb2ludHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFB0ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIHN0ZXBQb2ludHMucHVzaChwdCk7XG5cbiAgICAgICAgICAgIHZhciBzdGVwUHQgPSBbXTtcbiAgICAgICAgICAgIHN3aXRjaCAoc3RlcFR1cm5BdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBQdFtiYXNlSW5kZXhdID0gbmV4dFB0W2Jhc2VJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBQdFsxIC0gYmFzZUluZGV4XSA9IHB0WzEgLSBiYXNlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGlzIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBQb2ludHMucHVzaChzdGVwUHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGlzIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaWRkbGUgPSAocHRbYmFzZUluZGV4XSArIG5leHRQdFtiYXNlSW5kZXhdKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGVwUHQyID0gW107XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBQdFtiYXNlSW5kZXhdID0gc3RlcFB0MltiYXNlSW5kZXhdID0gbWlkZGxlO1xuICAgICAgICAgICAgICAgICAgICBzdGVwUHRbMSAtIGJhc2VJbmRleF0gPSBwdFsxIC0gYmFzZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgc3RlcFB0MlsxIC0gYmFzZUluZGV4XSA9IG5leHRQdFsxIC0gYmFzZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdCk7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBQb2ludHMucHVzaChzdGVwUHQyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc3RlcFB0W2Jhc2VJbmRleF0gPSBwdFtiYXNlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBzdGVwUHRbMSAtIGJhc2VJbmRleF0gPSBuZXh0UHRbMSAtIGJhc2VJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgaXMgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGFzdCBwb2ludHNcbiAgICAgICAgcG9pbnRzW2ldICYmIHN0ZXBQb2ludHMucHVzaChwb2ludHNbaV0pO1xuICAgICAgICByZXR1cm4gc3RlcFBvaW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWaXN1YWxHcmFkaWVudChkYXRhLCBjb29yZFN5cykge1xuICAgICAgICB2YXIgdmlzdWFsTWV0YUxpc3QgPSBkYXRhLmdldFZpc3VhbCgndmlzdWFsTWV0YScpO1xuICAgICAgICBpZiAoIXZpc3VhbE1ldGFMaXN0IHx8ICF2aXN1YWxNZXRhTGlzdC5sZW5ndGggfHwgIWRhdGEuY291bnQoKSkge1xuICAgICAgICAgICAgLy8gV2hlbiBkYXRhLmNvdW50KCkgaXMgMCwgZ3JhZGllbnQgcmFuZ2UgY2FuIG5vdCBiZSBjYWxjdWxhdGVkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZpc3VhbE1ldGE7XG4gICAgICAgIGZvciAodmFyIGkgPSB2aXN1YWxNZXRhTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgLy8gQ2FuIG9ubHkgYmUgeCBvciB5XG4gICAgICAgICAgICBpZiAodmlzdWFsTWV0YUxpc3RbaV0uZGltZW5zaW9uIDwgMikge1xuICAgICAgICAgICAgICAgIHZpc3VhbE1ldGEgPSB2aXN1YWxNZXRhTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZpc3VhbE1ldGEgfHwgY29vcmRTeXMudHlwZSAhPT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1Zpc3VhbCBtYXAgb24gbGluZSBzdHlsZSBvbmx5IHN1cHBvcnQgeCBvciB5IGRpbWVuc2lvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBhcmVhIHRvIGJlIHJlbmRlcmVkIGlzIGJpZ2dlciB0aGFuIGFyZWEgZGVmaW5lZCBieSBMaW5lYXJHcmFkaWVudCxcbiAgICAgICAgLy8gdGhlIGNhbnZhcyBzcGVjIHByZXNjcmliZXMgdGhhdCB0aGUgY29sb3Igb2YgdGhlIGZpcnN0IHN0b3AgYW5kIHRoZSBsYXN0XG4gICAgICAgIC8vIHN0b3Agc2hvdWxkIGJlIHVzZWQuIEJ1dCBpZiB0d28gc3RvcHMgYXJlIGFkZGVkIGF0IG9mZnNldCAwLCBpbiBlZmZlY3RcbiAgICAgICAgLy8gYnJvd3NlcnMgdXNlIHRoZSBjb2xvciBvZiB0aGUgc2Vjb25kIHN0b3AgdG8gcmVuZGVyIGFyZWEgb3V0c2lkZVxuICAgICAgICAvLyBMaW5lYXJHcmFkaWVudC4gU28gd2UgY2FuIG9ubHkgaW5maW5pdGVzaW1hbGx5IGV4dGVuZCBhcmVhIGRlZmluZWQgaW5cbiAgICAgICAgLy8gTGluZWFyR3JhZGllbnQgdG8gcmVuZGVyIGBvdXRlckNvbG9yc2AuXG5cbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHZpc3VhbE1ldGEuZGltZW5zaW9uO1xuICAgICAgICB2YXIgZGltTmFtZSA9IGRhdGEuZGltZW5zaW9uc1tkaW1lbnNpb25dO1xuICAgICAgICB2YXIgYXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoZGltTmFtZSk7XG5cbiAgICAgICAgLy8gZGF0YVRvQ29vciBtYXBwaW5nIG1heSBub3QgYmUgbGluZWFyLCBidXQgbXVzdCBiZSBtb25vdG9uaWMuXG4gICAgICAgIHZhciBjb2xvclN0b3BzID0genJVdGlsLm1hcCh2aXN1YWxNZXRhLnN0b3BzLCBmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb29yZDogYXhpcy50b0dsb2JhbENvb3JkKGF4aXMuZGF0YVRvQ29vcmQoc3RvcC52YWx1ZSkpLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBzdG9wLmNvbG9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN0b3BMZW4gPSBjb2xvclN0b3BzLmxlbmd0aDtcbiAgICAgICAgdmFyIG91dGVyQ29sb3JzID0gdmlzdWFsTWV0YS5vdXRlckNvbG9ycy5zbGljZSgpO1xuXG4gICAgICAgIGlmIChzdG9wTGVuICYmIGNvbG9yU3RvcHNbMF0uY29vcmQgPiBjb2xvclN0b3BzW3N0b3BMZW4gLSAxXS5jb29yZCkge1xuICAgICAgICAgICAgY29sb3JTdG9wcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBvdXRlckNvbG9ycy5yZXZlcnNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGlueUV4dGVudCA9IDEwOyAvLyBBcmJpdHJhcnkgdmFsdWU6IDEwcHhcbiAgICAgICAgdmFyIG1pbkNvb3JkID0gY29sb3JTdG9wc1swXS5jb29yZCAtIHRpbnlFeHRlbnQ7XG4gICAgICAgIHZhciBtYXhDb29yZCA9IGNvbG9yU3RvcHNbc3RvcExlbiAtIDFdLmNvb3JkICsgdGlueUV4dGVudDtcbiAgICAgICAgdmFyIGNvb3JkU3BhbiA9IG1heENvb3JkIC0gbWluQ29vcmQ7XG5cbiAgICAgICAgaWYgKGNvb3JkU3BhbiA8IDFlLTMpIHtcbiAgICAgICAgICAgIHJldHVybiAndHJhbnNwYXJlbnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgenJVdGlsLmVhY2goY29sb3JTdG9wcywgZnVuY3Rpb24gKHN0b3ApIHtcbiAgICAgICAgICAgIHN0b3Aub2Zmc2V0ID0gKHN0b3AuY29vcmQgLSBtaW5Db29yZCkgLyBjb29yZFNwYW47XG4gICAgICAgIH0pO1xuICAgICAgICBjb2xvclN0b3BzLnB1c2goe1xuICAgICAgICAgICAgb2Zmc2V0OiBzdG9wTGVuID8gY29sb3JTdG9wc1tzdG9wTGVuIC0gMV0ub2Zmc2V0IDogMC41LFxuICAgICAgICAgICAgY29sb3I6IG91dGVyQ29sb3JzWzFdIHx8ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbG9yU3RvcHMudW5zaGlmdCh7IC8vIG5vdGljZSBjb2xvclN0b3BzLmxlbmd0aCBoYXZlIGJlZW4gY2hhbmdlZC5cbiAgICAgICAgICAgIG9mZnNldDogc3RvcExlbiA/IGNvbG9yU3RvcHNbMF0ub2Zmc2V0IDogMC41LFxuICAgICAgICAgICAgY29sb3I6IG91dGVyQ29sb3JzWzBdIHx8ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8genJVdGlsLmVhY2goY29sb3JTdG9wcywgZnVuY3Rpb24gKGNvbG9yU3RvcCkge1xuICAgICAgICAvLyAgICAgLy8gTWFrZSBzdXJlIGVhY2ggb2Zmc2V0IGhhcyByb3VuZGVkIHB4IHRvIGF2b2lkIG5vdCBzaGFycCBlZGdlXG4gICAgICAgIC8vICAgICBjb2xvclN0b3Aub2Zmc2V0ID0gKE1hdGgucm91bmQoY29sb3JTdG9wLm9mZnNldCAqIChlbmQgLSBzdGFydCkgKyBzdGFydCkgLSBzdGFydCkgLyAoZW5kIC0gc3RhcnQpO1xuICAgICAgICAvLyB9KTtcblxuICAgICAgICB2YXIgZ3JhZGllbnQgPSBuZXcgZ3JhcGhpYy5MaW5lYXJHcmFkaWVudCgwLCAwLCAwLCAwLCBjb2xvclN0b3BzLCB0cnVlKTtcbiAgICAgICAgZ3JhZGllbnRbZGltTmFtZV0gPSBtaW5Db29yZDtcbiAgICAgICAgZ3JhZGllbnRbZGltTmFtZSArICcyJ10gPSBtYXhDb29yZDtcblxuICAgICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDaGFydFZpZXcuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnbGluZScsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxpbmVHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICAgICAgICAgIHZhciBzeW1ib2xEcmF3ID0gbmV3IFN5bWJvbERyYXcoKTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKHN5bWJvbERyYXcuZ3JvdXApO1xuXG4gICAgICAgICAgICB0aGlzLl9zeW1ib2xEcmF3ID0gc3ltYm9sRHJhdztcbiAgICAgICAgICAgIHRoaXMuX2xpbmVHcm91cCA9IGxpbmVHcm91cDtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZS5ub3JtYWwnKTtcbiAgICAgICAgICAgIHZhciBhcmVhU3R5bGVNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdhcmVhU3R5bGUubm9ybWFsJyk7XG5cbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBkYXRhLm1hcEFycmF5KGRhdGEuZ2V0SXRlbUxheW91dCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBpc0Nvb3JkU3lzUG9sYXIgPSBjb29yZFN5cy50eXBlID09PSAncG9sYXInO1xuICAgICAgICAgICAgdmFyIHByZXZDb29yZFN5cyA9IHRoaXMuX2Nvb3JkU3lzO1xuXG4gICAgICAgICAgICB2YXIgc3ltYm9sRHJhdyA9IHRoaXMuX3N5bWJvbERyYXc7XG4gICAgICAgICAgICB2YXIgcG9seWxpbmUgPSB0aGlzLl9wb2x5bGluZTtcbiAgICAgICAgICAgIHZhciBwb2x5Z29uID0gdGhpcy5fcG9seWdvbjtcblxuICAgICAgICAgICAgdmFyIGxpbmVHcm91cCA9IHRoaXMuX2xpbmVHcm91cDtcblxuICAgICAgICAgICAgdmFyIGhhc0FuaW1hdGlvbiA9IHNlcmllc01vZGVsLmdldCgnYW5pbWF0aW9uJyk7XG5cbiAgICAgICAgICAgIHZhciBpc0FyZWFDaGFydCA9ICFhcmVhU3R5bGVNb2RlbC5pc0VtcHR5KCk7XG4gICAgICAgICAgICB2YXIgc3RhY2tlZE9uUG9pbnRzID0gZ2V0U3RhY2tlZE9uUG9pbnRzKGNvb3JkU3lzLCBkYXRhKTtcblxuICAgICAgICAgICAgdmFyIHNob3dTeW1ib2wgPSBzZXJpZXNNb2RlbC5nZXQoJ3Nob3dTeW1ib2wnKTtcblxuICAgICAgICAgICAgdmFyIGlzU3ltYm9sSWdub3JlID0gc2hvd1N5bWJvbCAmJiAhaXNDb29yZFN5c1BvbGFyICYmICFzZXJpZXNNb2RlbC5nZXQoJ3Nob3dBbGxTeW1ib2wnKVxuICAgICAgICAgICAgICAgICYmIHRoaXMuX2dldFN5bWJvbElnbm9yZUZ1bmMoZGF0YSwgY29vcmRTeXMpO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGVtcG9yYXJ5IHN5bWJvbHNcbiAgICAgICAgICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgICAgIG9sZERhdGEgJiYgb2xkRGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChlbC5fX3RlbXApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkRGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBjcmVhdGVkIHN5bWJvbHMgaWYgc2hvd1N5bWJvbCBjaGFuZ2VkIHRvIGZhbHNlXG4gICAgICAgICAgICBpZiAoIXNob3dTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xEcmF3LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncm91cC5hZGQobGluZUdyb3VwKTtcblxuICAgICAgICAgICAgLy8gRklYTUUgc3RlcCBub3Qgc3VwcG9ydCBwb2xhclxuICAgICAgICAgICAgdmFyIHN0ZXAgPSAhaXNDb29yZFN5c1BvbGFyICYmIHNlcmllc01vZGVsLmdldCgnc3RlcCcpO1xuICAgICAgICAgICAgLy8gSW5pdGlhbGl6YXRpb24gYW5pbWF0aW9uIG9yIGNvb3JkaW5hdGUgc3lzdGVtIGNoYW5nZWRcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhKHBvbHlsaW5lICYmIHByZXZDb29yZFN5cy50eXBlID09PSBjb29yZFN5cy50eXBlICYmIHN0ZXAgPT09IHRoaXMuX3N0ZXApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzaG93U3ltYm9sICYmIHN5bWJvbERyYXcudXBkYXRlRGF0YShkYXRhLCBpc1N5bWJvbElnbm9yZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIElmIHN0YWNrZWQgc2VyaWVzIGlzIG5vdCBzdGVwXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHR1cm5Qb2ludHNJbnRvU3RlcChwb2ludHMsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvbHlsaW5lID0gdGhpcy5fbmV3UG9seWxpbmUocG9pbnRzLCBjb29yZFN5cywgaGFzQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcmVhQ2hhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbiA9IHRoaXMuX25ld1BvbHlnb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMsIHN0YWNrZWRPblBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkU3lzLCBoYXNBbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZUdyb3VwLnNldENsaXBQYXRoKGNyZWF0ZUNsaXBTaGFwZShjb29yZFN5cywgdHJ1ZSwgc2VyaWVzTW9kZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc0FyZWFDaGFydCAmJiAhcG9seWdvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhcmVhU3R5bGUgaXMgYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbiA9IHRoaXMuX25ld1BvbHlnb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMsIHN0YWNrZWRPblBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkU3lzLCBoYXNBbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocG9seWdvbiAmJiAhaXNBcmVhQ2hhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYXJlYVN0eWxlIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgbGluZUdyb3VwLnJlbW92ZShwb2x5Z29uKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbiA9IHRoaXMuX3BvbHlnb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjbGlwUGF0aFxuICAgICAgICAgICAgICAgIGxpbmVHcm91cC5zZXRDbGlwUGF0aChjcmVhdGVDbGlwU2hhcGUoY29vcmRTeXMsIGZhbHNlLCBzZXJpZXNNb2RlbCkpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHVwZGF0ZSwgb3IgaXQgaXMgd3JvbmcgaW4gdGhlIGNhc2UgdHVybmluZyBvbiBsZWdlbmRcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHBvaW50cyBhcmUgbm90IGNoYW5nZWRcbiAgICAgICAgICAgICAgICBzaG93U3ltYm9sICYmIHN5bWJvbERyYXcudXBkYXRlRGF0YShkYXRhLCBpc1N5bWJvbElnbm9yZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9wIHN5bWJvbCBhbmltYXRpb24gYW5kIHN5bmMgd2l0aCBsaW5lIHBvaW50c1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIHBlcmZvcm1hbmNlP1xuICAgICAgICAgICAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnN0b3BBbmltYXRpb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBkYXRhIHpvb20gdHJpZ2dlcnJlZCByZWZyZXNoaW5nIGZyZXF1ZW50bHlcbiAgICAgICAgICAgICAgICAvLyBEYXRhIG1heSBub3QgY2hhbmdlIGlmIGxpbmUgaGFzIGEgY2F0ZWdvcnkgYXhpcy4gU28gaXQgc2hvdWxkIGFuaW1hdGUgbm90aGluZ1xuICAgICAgICAgICAgICAgIGlmICghaXNQb2ludHNTYW1lKHRoaXMuX3N0YWNrZWRPblBvaW50cywgc3RhY2tlZE9uUG9pbnRzKVxuICAgICAgICAgICAgICAgICAgICB8fCAhaXNQb2ludHNTYW1lKHRoaXMuX3BvaW50cywgcG9pbnRzKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmltYXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSwgc3RhY2tlZE9uUG9pbnRzLCBjb29yZFN5cywgYXBpLCBzdGVwXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGRvIGl0IGluIHVwZGF0ZSB3aXRoIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIElmIHN0YWNrZWQgc2VyaWVzIGlzIG5vdCBzdGVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrZWRPblBvaW50cyA9IHR1cm5Qb2ludHNJbnRvU3RlcChzdGFja2VkT25Qb2ludHMsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWxpbmUuc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb24gJiYgcG9seWdvbi5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25Qb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmlzdWFsQ29sb3IgPSBnZXRWaXN1YWxHcmFkaWVudChkYXRhLCBjb29yZFN5cykgfHwgZGF0YS5nZXRWaXN1YWwoJ2NvbG9yJyk7XG5cbiAgICAgICAgICAgIHBvbHlsaW5lLnVzZVN0eWxlKHpyVXRpbC5kZWZhdWx0cyhcbiAgICAgICAgICAgICAgICAvLyBVc2UgY29sb3IgaW4gbGluZVN0eWxlIGZpcnN0XG4gICAgICAgICAgICAgICAgbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogdmlzdWFsQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVKb2luOiAnYmV2ZWwnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIHZhciBzbW9vdGggPSBzZXJpZXNNb2RlbC5nZXQoJ3Ntb290aCcpO1xuICAgICAgICAgICAgc21vb3RoID0gZ2V0U21vb3RoKHNlcmllc01vZGVsLmdldCgnc21vb3RoJykpO1xuICAgICAgICAgICAgcG9seWxpbmUuc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgIHNtb290aDogc21vb3RoLFxuICAgICAgICAgICAgICAgIHNtb290aE1vbm90b25lOiBzZXJpZXNNb2RlbC5nZXQoJ3Ntb290aE1vbm90b25lJyksXG4gICAgICAgICAgICAgICAgY29ubmVjdE51bGxzOiBzZXJpZXNNb2RlbC5nZXQoJ2Nvbm5lY3ROdWxscycpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHBvbHlnb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uID0gZGF0YS5zdGFja2VkT247XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrZWRPblNtb290aCA9IDA7XG5cbiAgICAgICAgICAgICAgICBwb2x5Z29uLnVzZVN0eWxlKHpyVXRpbC5kZWZhdWx0cyhcbiAgICAgICAgICAgICAgICAgICAgYXJlYVN0eWxlTW9kZWwuZ2V0QXJlYVN0eWxlKCksXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IHZpc3VhbENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMC43LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUpvaW46ICdiZXZlbCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrZWRPbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uU2VyaWVzID0gc3RhY2tlZE9uLmhvc3RNb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uU21vb3RoID0gZ2V0U21vb3RoKHN0YWNrZWRPblNlcmllcy5nZXQoJ3Ntb290aCcpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwb2x5Z29uLnNldFNoYXBlKHtcbiAgICAgICAgICAgICAgICAgICAgc21vb3RoOiBzbW9vdGgsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrZWRPblNtb290aDogc3RhY2tlZE9uU21vb3RoLFxuICAgICAgICAgICAgICAgICAgICBzbW9vdGhNb25vdG9uZTogc2VyaWVzTW9kZWwuZ2V0KCdzbW9vdGhNb25vdG9uZScpLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0TnVsbHM6IHNlcmllc01vZGVsLmdldCgnY29ubmVjdE51bGxzJylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjb29yZGluYXRlIHN5c3RlbSBmb3IgdHJhbnNpdGlvbiBhbmltYXRpb24gd2hlbiBkYXRhIGNoYW5nZWRcbiAgICAgICAgICAgIHRoaXMuX2Nvb3JkU3lzID0gY29vcmRTeXM7XG4gICAgICAgICAgICB0aGlzLl9zdGFja2VkT25Qb2ludHMgPSBzdGFja2VkT25Qb2ludHM7XG4gICAgICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XG4gICAgICAgICAgICB0aGlzLl9zdGVwID0gc3RlcDtcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fSxcblxuICAgICAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIGlmICghKGRhdGFJbmRleCBpbnN0YW5jZW9mIEFycmF5KSAmJiBkYXRhSW5kZXggIT0gbnVsbCAmJiBkYXRhSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzeW1ib2wgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkgc3ltYm9sIGlmIGl0IGlzIG5vdCBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHB0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE51bGwgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IG5ldyBTeW1ib2woZGF0YSwgZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnBvc2l0aW9uID0gcHQ7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5zZXRaKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCd6bGV2ZWwnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgneicpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5pZ25vcmUgPSBpc05hTihwdFswXSkgfHwgaXNOYU4ocHRbMV0pO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2wuX190ZW1wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCwgc3ltYm9sKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIHNjYWxlIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wuc3RvcFN5bWJvbEFuaW1hdGlvbih0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChzeW1ib2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzeW1ib2wuaGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBIaWdobGlnaHQgd2hvbGUgc2VyaWVzXG4gICAgICAgICAgICAgICAgQ2hhcnRWaWV3LnByb3RvdHlwZS5oaWdobGlnaHQuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgdGhpcywgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZG93bnBsYXk6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgcGF5bG9hZCk7XG4gICAgICAgICAgICBpZiAoZGF0YUluZGV4ICE9IG51bGwgJiYgZGF0YUluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ltYm9sLl9fdGVtcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZShzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmRvd25wbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgIC8vIGNhbiBub3QgZG93bnBsYXkgY29tcGxldGVseS5cbiAgICAgICAgICAgICAgICAvLyBEb3ducGxheSB3aG9sZSBzZXJpZXNcbiAgICAgICAgICAgICAgICBDaGFydFZpZXcucHJvdG90eXBlLmRvd25wbGF5LmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwb2ludHNcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9uZXdQb2x5bGluZTogZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgICAgICAgdmFyIHBvbHlsaW5lID0gdGhpcy5fcG9seWxpbmU7XG4gICAgICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgY3JlYXRlZCBwb2x5bGluZVxuICAgICAgICAgICAgaWYgKHBvbHlsaW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZUdyb3VwLnJlbW92ZShwb2x5bGluZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvbHlsaW5lID0gbmV3IHBvbHlIZWxwZXIuUG9seWxpbmUoe1xuICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgejI6IDEwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fbGluZUdyb3VwLmFkZChwb2x5bGluZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lID0gcG9seWxpbmU7XG5cbiAgICAgICAgICAgIHJldHVybiBwb2x5bGluZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gc3RhY2tlZE9uUG9pbnRzXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gcG9pbnRzXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfbmV3UG9seWdvbjogZnVuY3Rpb24gKHBvaW50cywgc3RhY2tlZE9uUG9pbnRzKSB7XG4gICAgICAgICAgICB2YXIgcG9seWdvbiA9IHRoaXMuX3BvbHlnb247XG4gICAgICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgY3JlYXRlZCBwb2x5Z29uXG4gICAgICAgICAgICBpZiAocG9seWdvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVHcm91cC5yZW1vdmUocG9seWdvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvbHlnb24gPSBuZXcgcG9seUhlbHBlci5Qb2x5Z29uKHtcbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25Qb2ludHNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2xpbmVHcm91cC5hZGQocG9seWdvbik7XG5cbiAgICAgICAgICAgIHRoaXMuX3BvbHlnb24gPSBwb2x5Z29uO1xuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb247XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2dldFN5bWJvbElnbm9yZUZ1bmM6IGZ1bmN0aW9uIChkYXRhLCBjb29yZFN5cykge1xuICAgICAgICAgICAgdmFyIGNhdGVnb3J5QXhpcyA9IGNvb3JkU3lzLmdldEF4ZXNCeVNjYWxlKCdvcmRpbmFsJylbMF07XG4gICAgICAgICAgICAvLyBgZ2V0TGFiZWxJbnRlcnZhbGAgaXMgcHJvdmlkZWQgYnkgZWNoYXJ0cy9jb21wb25lbnQvYXhpc1xuICAgICAgICAgICAgaWYgKGNhdGVnb3J5QXhpcyAmJiBjYXRlZ29yeUF4aXMuaXNMYWJlbElnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4genJVdGlsLmJpbmQoY2F0ZWdvcnlBeGlzLmlzTGFiZWxJZ25vcmVkLCBjYXRlZ29yeUF4aXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gRklYTUUgVHdvIHZhbHVlIGF4aXNcbiAgICAgICAgX3VwZGF0ZUFuaW1hdGlvbjogZnVuY3Rpb24gKGRhdGEsIHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIGFwaSwgc3RlcCkge1xuICAgICAgICAgICAgdmFyIHBvbHlsaW5lID0gdGhpcy5fcG9seWxpbmU7XG4gICAgICAgICAgICB2YXIgcG9seWdvbiA9IHRoaXMuX3BvbHlnb247XG4gICAgICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcblxuICAgICAgICAgICAgdmFyIGRpZmYgPSBsaW5lQW5pbWF0aW9uRGlmZihcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhLCBkYXRhLFxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrZWRPblBvaW50cywgc3RhY2tlZE9uUG9pbnRzLFxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvb3JkU3lzLCBjb29yZFN5c1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBkaWZmLmN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgc3RhY2tlZE9uQ3VycmVudCA9IGRpZmYuc3RhY2tlZE9uQ3VycmVudDtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gZGlmZi5uZXh0O1xuICAgICAgICAgICAgdmFyIHN0YWNrZWRPbk5leHQgPSBkaWZmLnN0YWNrZWRPbk5leHQ7XG4gICAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gSWYgc3RhY2tlZCBzZXJpZXMgaXMgbm90IHN0ZXBcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdHVyblBvaW50c0ludG9TdGVwKGRpZmYuY3VycmVudCwgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgICAgICAgIHN0YWNrZWRPbkN1cnJlbnQgPSB0dXJuUG9pbnRzSW50b1N0ZXAoZGlmZi5zdGFja2VkT25DdXJyZW50LCBjb29yZFN5cywgc3RlcCk7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHR1cm5Qb2ludHNJbnRvU3RlcChkaWZmLm5leHQsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgICAgICAgICAgICBzdGFja2VkT25OZXh0ID0gdHVyblBvaW50c0ludG9TdGVwKGRpZmYuc3RhY2tlZE9uTmV4dCwgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYGRpZmYuY3VycmVudGAgaXMgc3Vic2V0IG9mIGBjdXJyZW50YCAod2hpY2ggc2hvdWxkIGJlIGVuc3VyZWQgYnlcbiAgICAgICAgICAgIC8vIHR1cm5Qb2ludHNJbnRvU3RlcCksIHNvIHBvaW50cyBpbiBgX19wb2ludHNgIGNhbiBiZSB1cGRhdGVkIHdoZW5cbiAgICAgICAgICAgIC8vIHBvaW50cyBpbiBgY3VycmVudGAgYXJlIHVwZGF0ZSBkdXJpbmcgYW5pbWF0aW9uLlxuICAgICAgICAgICAgcG9seWxpbmUuc2hhcGUuX19wb2ludHMgPSBkaWZmLmN1cnJlbnQ7XG4gICAgICAgICAgICBwb2x5bGluZS5zaGFwZS5wb2ludHMgPSBjdXJyZW50O1xuXG4gICAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHBvbHlsaW5lLCB7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBuZXh0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuXG4gICAgICAgICAgICBpZiAocG9seWdvbikge1xuICAgICAgICAgICAgICAgIHBvbHlnb24uc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrZWRPblBvaW50czogc3RhY2tlZE9uQ3VycmVudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMocG9seWdvbiwge1xuICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBuZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25OZXh0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1cGRhdGVkRGF0YUluZm8gPSBbXTtcbiAgICAgICAgICAgIHZhciBkaWZmU3RhdHVzID0gZGlmZi5zdGF0dXM7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZlN0YXR1cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbWQgPSBkaWZmU3RhdHVzW2ldLmNtZDtcbiAgICAgICAgICAgICAgICBpZiAoY21kID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRpZmZTdGF0dXNbaV0uaWR4MSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZERhdGFJbmZvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdElkeDogaSAgICAvLyBJbmRleCBvZiBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9seWxpbmUuYW5pbWF0b3JzICYmIHBvbHlsaW5lLmFuaW1hdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwb2x5bGluZS5hbmltYXRvcnNbMF0uZHVyaW5nKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVkRGF0YUluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHVwZGF0ZWREYXRhSW5mb1tpXS5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmF0dHIoJ3Bvc2l0aW9uJywgcG9seWxpbmUuc2hhcGUuX19wb2ludHNbdXBkYXRlZERhdGFJbmZvW2ldLnB0SWR4XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICAgICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICAgICAgdGhpcy5fbGluZUdyb3VwLnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgdGhpcy5fc3ltYm9sRHJhdy5yZW1vdmUodHJ1ZSk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGVtcG9yYXJ5IGNyZWF0ZWQgZWxlbWVudHMgd2hlbiBoaWdobGlnaHRpbmdcbiAgICAgICAgICAgIG9sZERhdGEgJiYgb2xkRGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChlbC5fX3RlbXApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkRGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lID1cbiAgICAgICAgICAgIHRoaXMuX3BvbHlnb24gPVxuICAgICAgICAgICAgdGhpcy5fY29vcmRTeXMgPVxuICAgICAgICAgICAgdGhpcy5fcG9pbnRzID1cbiAgICAgICAgICAgIHRoaXMuX3N0YWNrZWRPblBvaW50cyA9XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvTGluZVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n\n    var graphic = __webpack_require__(34);\n    var Symbol = __webpack_require__(174);\n\n    /**\n     * @constructor\n     * @alias module:echarts/chart/helper/SymbolDraw\n     * @param {module:zrender/graphic/Group} [symbolCtor]\n     */\n    function SymbolDraw(symbolCtor) {\n        this.group = new graphic.Group();\n\n        this._symbolCtor = symbolCtor || Symbol;\n    }\n\n    var symbolDrawProto = SymbolDraw.prototype;\n\n    function symbolNeedsDraw(data, idx, isIgnore) {\n        var point = data.getItemLayout(idx);\n        // Is an object\n        // if (point && point.hasOwnProperty('point')) {\n        //     point = point.point;\n        // }\n        return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx))\n                    && data.getItemVisual(idx, 'symbol') !== 'none';\n    }\n    /**\n     * Update symbols draw by new data\n     * @param {module:echarts/data/List} data\n     * @param {Array.<boolean>} [isIgnore]\n     */\n    symbolDrawProto.updateData = function (data, isIgnore) {\n        var group = this.group;\n        var seriesModel = data.hostModel;\n        var oldData = this._data;\n\n        var SymbolCtor = this._symbolCtor;\n\n        var seriesScope = {\n            itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),\n            hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),\n            symbolRotate: seriesModel.get('symbolRotate'),\n            symbolOffset: seriesModel.get('symbolOffset'),\n            hoverAnimation: seriesModel.get('hoverAnimation'),\n\n            labelModel: seriesModel.getModel('label.normal'),\n            hoverLabelModel: seriesModel.getModel('label.emphasis'),\n            cursorStyle: seriesModel.get('cursor')\n        };\n\n        data.diff(oldData)\n            .add(function (newIdx) {\n                var point = data.getItemLayout(newIdx);\n                if (symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n                    symbolEl.attr('position', point);\n                    data.setItemGraphicEl(newIdx, symbolEl);\n                    group.add(symbolEl);\n                }\n            })\n            .update(function (newIdx, oldIdx) {\n                var symbolEl = oldData.getItemGraphicEl(oldIdx);\n                var point = data.getItemLayout(newIdx);\n                if (!symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    group.remove(symbolEl);\n                    return;\n                }\n                if (!symbolEl) {\n                    symbolEl = new SymbolCtor(data, newIdx);\n                    symbolEl.attr('position', point);\n                }\n                else {\n                    symbolEl.updateData(data, newIdx, seriesScope);\n                    graphic.updateProps(symbolEl, {\n                        position: point\n                    }, seriesModel);\n                }\n\n                // Add back\n                group.add(symbolEl);\n\n                data.setItemGraphicEl(newIdx, symbolEl);\n            })\n            .remove(function (oldIdx) {\n                var el = oldData.getItemGraphicEl(oldIdx);\n                el && el.fadeOut(function () {\n                    group.remove(el);\n                });\n            })\n            .execute();\n\n        this._data = data;\n    };\n\n    symbolDrawProto.updateLayout = function () {\n        var data = this._data;\n        if (data) {\n            // Not use animation\n            data.eachItemGraphicEl(function (el, idx) {\n                var point = data.getItemLayout(idx);\n                el.attr('position', point);\n            });\n        }\n    };\n\n    symbolDrawProto.remove = function (enableAnimation) {\n        var group = this.group;\n        var data = this._data;\n        if (data) {\n            if (enableAnimation) {\n                data.eachItemGraphicEl(function (el) {\n                    el.fadeOut(function () {\n                        group.remove(el);\n                    });\n                });\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    };\n\n    module.exports = SymbolDraw;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3LmpzPzZiNzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkJBQTZCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QyxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTczLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY2hhcnQvaGVscGVyL1N5bWJvbERyYXdcbiAqL1xuXG5cbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciBTeW1ib2wgPSByZXF1aXJlKCcuL1N5bWJvbCcpO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3XG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwfSBbc3ltYm9sQ3Rvcl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTeW1ib2xEcmF3KHN5bWJvbEN0b3IpIHtcbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICAgICAgdGhpcy5fc3ltYm9sQ3RvciA9IHN5bWJvbEN0b3IgfHwgU3ltYm9sO1xuICAgIH1cblxuICAgIHZhciBzeW1ib2xEcmF3UHJvdG8gPSBTeW1ib2xEcmF3LnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIHN5bWJvbE5lZWRzRHJhdyhkYXRhLCBpZHgsIGlzSWdub3JlKSB7XG4gICAgICAgIHZhciBwb2ludCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgICAvLyBJcyBhbiBvYmplY3RcbiAgICAgICAgLy8gaWYgKHBvaW50ICYmIHBvaW50Lmhhc093blByb3BlcnR5KCdwb2ludCcpKSB7XG4gICAgICAgIC8vICAgICBwb2ludCA9IHBvaW50LnBvaW50O1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiBwb2ludCAmJiAhaXNOYU4ocG9pbnRbMF0pICYmICFpc05hTihwb2ludFsxXSkgJiYgIShpc0lnbm9yZSAmJiBpc0lnbm9yZShpZHgpKVxuICAgICAgICAgICAgICAgICAgICAmJiBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJykgIT09ICdub25lJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHN5bWJvbHMgZHJhdyBieSBuZXcgZGF0YVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheS48Ym9vbGVhbj59IFtpc0lnbm9yZV1cbiAgICAgKi9cbiAgICBzeW1ib2xEcmF3UHJvdG8udXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBpc0lnbm9yZSkge1xuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICAgICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHZhciBTeW1ib2xDdG9yID0gdGhpcy5fc3ltYm9sQ3RvcjtcblxuICAgICAgICB2YXIgc2VyaWVzU2NvcGUgPSB7XG4gICAgICAgICAgICBpdGVtU3R5bGU6IHNlcmllc01vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUubm9ybWFsJykuZ2V0SXRlbVN0eWxlKFsnY29sb3InXSksXG4gICAgICAgICAgICBob3Zlckl0ZW1TdHlsZTogc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZS5lbXBoYXNpcycpLmdldEl0ZW1TdHlsZSgpLFxuICAgICAgICAgICAgc3ltYm9sUm90YXRlOiBzZXJpZXNNb2RlbC5nZXQoJ3N5bWJvbFJvdGF0ZScpLFxuICAgICAgICAgICAgc3ltYm9sT2Zmc2V0OiBzZXJpZXNNb2RlbC5nZXQoJ3N5bWJvbE9mZnNldCcpLFxuICAgICAgICAgICAgaG92ZXJBbmltYXRpb246IHNlcmllc01vZGVsLmdldCgnaG92ZXJBbmltYXRpb24nKSxcblxuICAgICAgICAgICAgbGFiZWxNb2RlbDogc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLm5vcm1hbCcpLFxuICAgICAgICAgICAgaG92ZXJMYWJlbE1vZGVsOiBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnbGFiZWwuZW1waGFzaXMnKSxcbiAgICAgICAgICAgIGN1cnNvclN0eWxlOiBzZXJpZXNNb2RlbC5nZXQoJ2N1cnNvcicpXG4gICAgICAgIH07XG5cbiAgICAgICAgZGF0YS5kaWZmKG9sZERhdGEpXG4gICAgICAgICAgICAuYWRkKGZ1bmN0aW9uIChuZXdJZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBkYXRhLmdldEl0ZW1MYXlvdXQobmV3SWR4KTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sTmVlZHNEcmF3KGRhdGEsIG5ld0lkeCwgaXNJZ25vcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2xFbCA9IG5ldyBTeW1ib2xDdG9yKGRhdGEsIG5ld0lkeCwgc2VyaWVzU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xFbC5hdHRyKCdwb3NpdGlvbicsIHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgc3ltYm9sRWwpO1xuICAgICAgICAgICAgICAgICAgICBncm91cC5hZGQoc3ltYm9sRWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgICAgICAgICAgICAgIHZhciBzeW1ib2xFbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpO1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IGRhdGEuZ2V0SXRlbUxheW91dChuZXdJZHgpO1xuICAgICAgICAgICAgICAgIGlmICghc3ltYm9sTmVlZHNEcmF3KGRhdGEsIG5ld0lkeCwgaXNJZ25vcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShzeW1ib2xFbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzeW1ib2xFbCkge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xFbCA9IG5ldyBTeW1ib2xDdG9yKGRhdGEsIG5ld0lkeCk7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbEVsLmF0dHIoJ3Bvc2l0aW9uJywgcG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sRWwudXBkYXRlRGF0YShkYXRhLCBuZXdJZHgsIHNlcmllc1Njb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhzeW1ib2xFbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYmFja1xuICAgICAgICAgICAgICAgIGdyb3VwLmFkZChzeW1ib2xFbCk7XG5cbiAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBzeW1ib2xFbCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlbW92ZShmdW5jdGlvbiAob2xkSWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgICAgICAgICAgICAgZWwgJiYgZWwuZmFkZU91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmV4ZWN1dGUoKTtcblxuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9O1xuXG4gICAgc3ltYm9sRHJhd1Byb3RvLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gTm90IHVzZSBhbmltYXRpb25cbiAgICAgICAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICAgICAgICAgICAgICBlbC5hdHRyKCdwb3NpdGlvbicsIHBvaW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHN5bWJvbERyYXdQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoZW5hYmxlQW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChlbmFibGVBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5mYWRlT3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTeW1ib2xEcmF3O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("/**\n * @module echarts/chart/helper/Symbol\n */\n\n\n    var zrUtil = __webpack_require__(20);\n    var symbolUtil = __webpack_require__(127);\n    var graphic = __webpack_require__(34);\n    var numberUtil = __webpack_require__(23);\n    var labelHelper = __webpack_require__(175);\n\n    function getSymbolSize(data, idx) {\n        var symbolSize = data.getItemVisual(idx, 'symbolSize');\n        return symbolSize instanceof Array\n            ? symbolSize.slice()\n            : [+symbolSize, +symbolSize];\n    }\n\n    function getScale(symbolSize) {\n        return [symbolSize[0] / 2, symbolSize[1] / 2];\n    }\n\n    /**\n     * @constructor\n     * @alias {module:echarts/chart/helper/Symbol}\n     * @param {module:echarts/data/List} data\n     * @param {number} idx\n     * @extends {module:zrender/graphic/Group}\n     */\n    function Symbol(data, idx, seriesScope) {\n        graphic.Group.call(this);\n\n        this.updateData(data, idx, seriesScope);\n    }\n\n    var symbolProto = Symbol.prototype;\n\n    function driftSymbol(dx, dy) {\n        this.parent.drift(dx, dy);\n    }\n\n    symbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n        // Remove paths created before\n        this.removeAll();\n\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // var symbolPath = symbolUtil.createSymbol(\n        //     symbolType, -0.5, -0.5, 1, 1, color\n        // );\n        // If width/height are set too small (e.g., set to 1) on ios10\n        // and macOS Sierra, a circle stroke become a rect, no matter what\n        // the scale is set. So we set width/height as 2. See #4150.\n        var symbolPath = symbolUtil.createSymbol(\n            symbolType, -1, -1, 2, 2, color\n        );\n\n        symbolPath.attr({\n            z2: 100,\n            culling: true,\n            scale: [0, 0]\n        });\n        // Rewrite drift method\n        symbolPath.drift = driftSymbol;\n\n        graphic.initProps(symbolPath, {\n            scale: getScale(symbolSize)\n        }, seriesModel, idx);\n        this._symbolType = symbolType;\n\n        this.add(symbolPath);\n    };\n\n    /**\n     * Stop animation\n     * @param {boolean} toLastFrame\n     */\n    symbolProto.stopSymbolAnimation = function (toLastFrame) {\n        this.childAt(0).stopAnimation(toLastFrame);\n    };\n\n    /**\n     * Get symbol path element\n     */\n    symbolProto.getSymbolPath = function () {\n        return this.childAt(0);\n    };\n\n    /**\n     * Get scale(aka, current symbol size).\n     * Including the change caused by animation\n     */\n    symbolProto.getScale = function () {\n        return this.childAt(0).scale;\n    };\n\n    /**\n     * Highlight symbol\n     */\n    symbolProto.highlight = function () {\n        this.childAt(0).trigger('emphasis');\n    };\n\n    /**\n     * Downplay symbol\n     */\n    symbolProto.downplay = function () {\n        this.childAt(0).trigger('normal');\n    };\n\n    /**\n     * @param {number} zlevel\n     * @param {number} z\n     */\n    symbolProto.setZ = function (zlevel, z) {\n        var symbolPath = this.childAt(0);\n        symbolPath.zlevel = zlevel;\n        symbolPath.z = z;\n    };\n\n    symbolProto.setDraggable = function (draggable) {\n        var symbolPath = this.childAt(0);\n        symbolPath.draggable = draggable;\n        symbolPath.cursor = draggable ? 'move' : 'pointer';\n    };\n\n    /**\n     * Update symbol properties\n     * @param  {module:echarts/data/List} data\n     * @param  {number} idx\n     */\n    symbolProto.updateData = function (data, idx, seriesScope) {\n        this.silent = false;\n\n        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n        var seriesModel = data.hostModel;\n        var symbolSize = getSymbolSize(data, idx);\n\n        if (symbolType !== this._symbolType) {\n            this._createSymbol(symbolType, data, idx, symbolSize);\n        }\n        else {\n            var symbolPath = this.childAt(0);\n            symbolPath.silent = false;\n            graphic.updateProps(symbolPath, {\n                scale: getScale(symbolSize)\n            }, seriesModel, idx);\n        }\n        this._updateCommon(data, idx, symbolSize, seriesScope);\n        this._seriesModel = seriesModel;\n    };\n\n    // Update common properties\n    var normalStyleAccessPath = ['itemStyle', 'normal'];\n    var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];\n    var normalLabelAccessPath = ['label', 'normal'];\n    var emphasisLabelAccessPath = ['label', 'emphasis'];\n\n    symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n        var symbolPath = this.childAt(0);\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // Reset style\n        if (symbolPath.type !== 'image') {\n            symbolPath.useStyle({\n                strokeNoScale: true\n            });\n        }\n\n        seriesScope = seriesScope || null;\n\n        var itemStyle = seriesScope && seriesScope.itemStyle;\n        var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n        var symbolRotate = seriesScope && seriesScope.symbolRotate;\n        var symbolOffset = seriesScope && seriesScope.symbolOffset;\n        var labelModel = seriesScope && seriesScope.labelModel;\n        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n        var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n        var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n        if (!seriesScope || data.hasItemOption) {\n            var itemModel = data.getItemModel(idx);\n\n            // Color must be excluded.\n            // Because symbol provide setColor individually to set fill and stroke\n            itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n            hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n\n            symbolRotate = itemModel.getShallow('symbolRotate');\n            symbolOffset = itemModel.getShallow('symbolOffset');\n\n            labelModel = itemModel.getModel(normalLabelAccessPath);\n            hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n            hoverAnimation = itemModel.getShallow('hoverAnimation');\n            cursorStyle = itemModel.getShallow('cursor');\n        }\n        else {\n            hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n        }\n\n        var elStyle = symbolPath.style;\n\n        symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n        if (symbolOffset) {\n            symbolPath.attr('position', [\n                numberUtil.parsePercent(symbolOffset[0], symbolSize[0]),\n                numberUtil.parsePercent(symbolOffset[1], symbolSize[1])\n            ]);\n        }\n\n        cursorStyle && symbolPath.attr('cursor', cursorStyle);\n\n        // PENDING setColor before setStyle!!!\n        symbolPath.setColor(color);\n\n        symbolPath.setStyle(itemStyle);\n\n        var opacity = data.getItemVisual(idx, 'opacity');\n        if (opacity != null) {\n            elStyle.opacity = opacity;\n        }\n\n        var valueDim = labelHelper.findLabelValueDim(data);\n        labelHelper.setTextToStyle(\n            data, idx, valueDim, elStyle, seriesModel, labelModel, color\n        );\n        labelHelper.setTextToStyle(\n            data, idx, valueDim, hoverItemStyle, seriesModel, hoverLabelModel, color\n        );\n\n        symbolPath.off('mouseover')\n            .off('mouseout')\n            .off('emphasis')\n            .off('normal');\n\n        symbolPath.hoverStyle = hoverItemStyle;\n\n        graphic.setHoverStyle(symbolPath);\n\n        var scale = getScale(symbolSize);\n\n        if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n            var onEmphasis = function() {\n                var ratio = scale[1] / scale[0];\n                this.animateTo({\n                    scale: [\n                        Math.max(scale[0] * 1.1, scale[0] + 3),\n                        Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)\n                    ]\n                }, 400, 'elasticOut');\n            };\n            var onNormal = function() {\n                this.animateTo({\n                    scale: scale\n                }, 400, 'elasticOut');\n            };\n            symbolPath.on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n    };\n\n    symbolProto.fadeOut = function (cb) {\n        var symbolPath = this.childAt(0);\n        // Avoid mistaken hover when fading out\n        this.silent = symbolPath.silent = true;\n        // Not show text when animating\n        symbolPath.style.text = '';\n        graphic.updateProps(symbolPath, {\n            scale: [0, 0]\n        }, this._seriesModel, this.dataIndex, cb);\n    };\n\n    zrUtil.inherits(Symbol, graphic.Group);\n\n    module.exports = Symbol;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2wuanM/OWZhMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBIiwiZmlsZSI6IjE3NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NoYXJ0L2hlbHBlci9TeW1ib2xcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIHN5bWJvbFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3N5bWJvbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bWJlcicpO1xuICAgIHZhciBsYWJlbEhlbHBlciA9IHJlcXVpcmUoJy4vbGFiZWxIZWxwZXInKTtcblxuICAgIGZ1bmN0aW9uIGdldFN5bWJvbFNpemUoZGF0YSwgaWR4KSB7XG4gICAgICAgIHZhciBzeW1ib2xTaXplID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbFNpemUnKTtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFNpemUgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgPyBzeW1ib2xTaXplLnNsaWNlKClcbiAgICAgICAgICAgIDogWytzeW1ib2xTaXplLCArc3ltYm9sU2l6ZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2NhbGUoc3ltYm9sU2l6ZSkge1xuICAgICAgICByZXR1cm4gW3N5bWJvbFNpemVbMF0gLyAyLCBzeW1ib2xTaXplWzFdIC8gMl07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGFsaWFzIHttb2R1bGU6ZWNoYXJ0cy9jaGFydC9oZWxwZXIvU3ltYm9sfVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN5bWJvbChkYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgICAgIGdyYXBoaWMuR3JvdXAuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoZGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG4gICAgfVxuXG4gICAgdmFyIHN5bWJvbFByb3RvID0gU3ltYm9sLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIGRyaWZ0U3ltYm9sKGR4LCBkeSkge1xuICAgICAgICB0aGlzLnBhcmVudC5kcmlmdChkeCwgZHkpO1xuICAgIH1cblxuICAgIHN5bWJvbFByb3RvLl9jcmVhdGVTeW1ib2wgPSBmdW5jdGlvbiAoc3ltYm9sVHlwZSwgZGF0YSwgaWR4LCBzeW1ib2xTaXplKSB7XG4gICAgICAgIC8vIFJlbW92ZSBwYXRocyBjcmVhdGVkIGJlZm9yZVxuICAgICAgICB0aGlzLnJlbW92ZUFsbCgpO1xuXG4gICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICAgICAgICB2YXIgY29sb3IgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKTtcblxuICAgICAgICAvLyB2YXIgc3ltYm9sUGF0aCA9IHN5bWJvbFV0aWwuY3JlYXRlU3ltYm9sKFxuICAgICAgICAvLyAgICAgc3ltYm9sVHlwZSwgLTAuNSwgLTAuNSwgMSwgMSwgY29sb3JcbiAgICAgICAgLy8gKTtcbiAgICAgICAgLy8gSWYgd2lkdGgvaGVpZ2h0IGFyZSBzZXQgdG9vIHNtYWxsIChlLmcuLCBzZXQgdG8gMSkgb24gaW9zMTBcbiAgICAgICAgLy8gYW5kIG1hY09TIFNpZXJyYSwgYSBjaXJjbGUgc3Ryb2tlIGJlY29tZSBhIHJlY3QsIG5vIG1hdHRlciB3aGF0XG4gICAgICAgIC8vIHRoZSBzY2FsZSBpcyBzZXQuIFNvIHdlIHNldCB3aWR0aC9oZWlnaHQgYXMgMi4gU2VlICM0MTUwLlxuICAgICAgICB2YXIgc3ltYm9sUGF0aCA9IHN5bWJvbFV0aWwuY3JlYXRlU3ltYm9sKFxuICAgICAgICAgICAgc3ltYm9sVHlwZSwgLTEsIC0xLCAyLCAyLCBjb2xvclxuICAgICAgICApO1xuXG4gICAgICAgIHN5bWJvbFBhdGguYXR0cih7XG4gICAgICAgICAgICB6MjogMTAwLFxuICAgICAgICAgICAgY3VsbGluZzogdHJ1ZSxcbiAgICAgICAgICAgIHNjYWxlOiBbMCwgMF1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJld3JpdGUgZHJpZnQgbWV0aG9kXG4gICAgICAgIHN5bWJvbFBhdGguZHJpZnQgPSBkcmlmdFN5bWJvbDtcblxuICAgICAgICBncmFwaGljLmluaXRQcm9wcyhzeW1ib2xQYXRoLCB7XG4gICAgICAgICAgICBzY2FsZTogZ2V0U2NhbGUoc3ltYm9sU2l6ZSlcbiAgICAgICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgICAgIHRoaXMuX3N5bWJvbFR5cGUgPSBzeW1ib2xUeXBlO1xuXG4gICAgICAgIHRoaXMuYWRkKHN5bWJvbFBhdGgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdG9MYXN0RnJhbWVcbiAgICAgKi9cbiAgICBzeW1ib2xQcm90by5zdG9wU3ltYm9sQW5pbWF0aW9uID0gZnVuY3Rpb24gKHRvTGFzdEZyYW1lKSB7XG4gICAgICAgIHRoaXMuY2hpbGRBdCgwKS5zdG9wQW5pbWF0aW9uKHRvTGFzdEZyYW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHN5bWJvbCBwYXRoIGVsZW1lbnRcbiAgICAgKi9cbiAgICBzeW1ib2xQcm90by5nZXRTeW1ib2xQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZEF0KDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2NhbGUoYWthLCBjdXJyZW50IHN5bWJvbCBzaXplKS5cbiAgICAgKiBJbmNsdWRpbmcgdGhlIGNoYW5nZSBjYXVzZWQgYnkgYW5pbWF0aW9uXG4gICAgICovXG4gICAgc3ltYm9sUHJvdG8uZ2V0U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQXQoMCkuc2NhbGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhpZ2hsaWdodCBzeW1ib2xcbiAgICAgKi9cbiAgICBzeW1ib2xQcm90by5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRBdCgwKS50cmlnZ2VyKCdlbXBoYXNpcycpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEb3ducGxheSBzeW1ib2xcbiAgICAgKi9cbiAgICBzeW1ib2xQcm90by5kb3ducGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGlsZEF0KDApLnRyaWdnZXIoJ25vcm1hbCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpcbiAgICAgKi9cbiAgICBzeW1ib2xQcm90by5zZXRaID0gZnVuY3Rpb24gKHpsZXZlbCwgeikge1xuICAgICAgICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICAgICAgc3ltYm9sUGF0aC56bGV2ZWwgPSB6bGV2ZWw7XG4gICAgICAgIHN5bWJvbFBhdGgueiA9IHo7XG4gICAgfTtcblxuICAgIHN5bWJvbFByb3RvLnNldERyYWdnYWJsZSA9IGZ1bmN0aW9uIChkcmFnZ2FibGUpIHtcbiAgICAgICAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG4gICAgICAgIHN5bWJvbFBhdGguZHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xuICAgICAgICBzeW1ib2xQYXRoLmN1cnNvciA9IGRyYWdnYWJsZSA/ICdtb3ZlJyA6ICdwb2ludGVyJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHN5bWJvbCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBpZHhcbiAgICAgKi9cbiAgICBzeW1ib2xQcm90by51cGRhdGVEYXRhID0gZnVuY3Rpb24gKGRhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgICAgICAgdGhpcy5zaWxlbnQgPSBmYWxzZTtcblxuICAgICAgICB2YXIgc3ltYm9sVHlwZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKSB8fCAnY2lyY2xlJztcbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgICAgIHZhciBzeW1ib2xTaXplID0gZ2V0U3ltYm9sU2l6ZShkYXRhLCBpZHgpO1xuXG4gICAgICAgIGlmIChzeW1ib2xUeXBlICE9PSB0aGlzLl9zeW1ib2xUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVTeW1ib2woc3ltYm9sVHlwZSwgZGF0YSwgaWR4LCBzeW1ib2xTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICAgICAgICAgICAgc3ltYm9sUGF0aC5zaWxlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoc3ltYm9sUGF0aCwge1xuICAgICAgICAgICAgICAgIHNjYWxlOiBnZXRTY2FsZShzeW1ib2xTaXplKVxuICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQ29tbW9uKGRhdGEsIGlkeCwgc3ltYm9sU2l6ZSwgc2VyaWVzU2NvcGUpO1xuICAgICAgICB0aGlzLl9zZXJpZXNNb2RlbCA9IHNlcmllc01vZGVsO1xuICAgIH07XG5cbiAgICAvLyBVcGRhdGUgY29tbW9uIHByb3BlcnRpZXNcbiAgICB2YXIgbm9ybWFsU3R5bGVBY2Nlc3NQYXRoID0gWydpdGVtU3R5bGUnLCAnbm9ybWFsJ107XG4gICAgdmFyIGVtcGhhc2lzU3R5bGVBY2Nlc3NQYXRoID0gWydpdGVtU3R5bGUnLCAnZW1waGFzaXMnXTtcbiAgICB2YXIgbm9ybWFsTGFiZWxBY2Nlc3NQYXRoID0gWydsYWJlbCcsICdub3JtYWwnXTtcbiAgICB2YXIgZW1waGFzaXNMYWJlbEFjY2Vzc1BhdGggPSBbJ2xhYmVsJywgJ2VtcGhhc2lzJ107XG5cbiAgICBzeW1ib2xQcm90by5fdXBkYXRlQ29tbW9uID0gZnVuY3Rpb24gKGRhdGEsIGlkeCwgc3ltYm9sU2l6ZSwgc2VyaWVzU2NvcGUpIHtcbiAgICAgICAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG4gICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICAgICAgICB2YXIgY29sb3IgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKTtcblxuICAgICAgICAvLyBSZXNldCBzdHlsZVxuICAgICAgICBpZiAoc3ltYm9sUGF0aC50eXBlICE9PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgICBzeW1ib2xQYXRoLnVzZVN0eWxlKHtcbiAgICAgICAgICAgICAgICBzdHJva2VOb1NjYWxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlcmllc1Njb3BlID0gc2VyaWVzU2NvcGUgfHwgbnVsbDtcblxuICAgICAgICB2YXIgaXRlbVN0eWxlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuaXRlbVN0eWxlO1xuICAgICAgICB2YXIgaG92ZXJJdGVtU3R5bGUgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5ob3Zlckl0ZW1TdHlsZTtcbiAgICAgICAgdmFyIHN5bWJvbFJvdGF0ZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLnN5bWJvbFJvdGF0ZTtcbiAgICAgICAgdmFyIHN5bWJvbE9mZnNldCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLnN5bWJvbE9mZnNldDtcbiAgICAgICAgdmFyIGxhYmVsTW9kZWwgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5sYWJlbE1vZGVsO1xuICAgICAgICB2YXIgaG92ZXJMYWJlbE1vZGVsID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuaG92ZXJMYWJlbE1vZGVsO1xuICAgICAgICB2YXIgaG92ZXJBbmltYXRpb24gPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5ob3ZlckFuaW1hdGlvbjtcbiAgICAgICAgdmFyIGN1cnNvclN0eWxlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuY3Vyc29yU3R5bGU7XG5cbiAgICAgICAgaWYgKCFzZXJpZXNTY29wZSB8fCBkYXRhLmhhc0l0ZW1PcHRpb24pIHtcbiAgICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuXG4gICAgICAgICAgICAvLyBDb2xvciBtdXN0IGJlIGV4Y2x1ZGVkLlxuICAgICAgICAgICAgLy8gQmVjYXVzZSBzeW1ib2wgcHJvdmlkZSBzZXRDb2xvciBpbmRpdmlkdWFsbHkgdG8gc2V0IGZpbGwgYW5kIHN0cm9rZVxuICAgICAgICAgICAgaXRlbVN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKG5vcm1hbFN0eWxlQWNjZXNzUGF0aCkuZ2V0SXRlbVN0eWxlKFsnY29sb3InXSk7XG4gICAgICAgICAgICBob3Zlckl0ZW1TdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChlbXBoYXNpc1N0eWxlQWNjZXNzUGF0aCkuZ2V0SXRlbVN0eWxlKCk7XG5cbiAgICAgICAgICAgIHN5bWJvbFJvdGF0ZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2xSb3RhdGUnKTtcbiAgICAgICAgICAgIHN5bWJvbE9mZnNldCA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2xPZmZzZXQnKTtcblxuICAgICAgICAgICAgbGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChub3JtYWxMYWJlbEFjY2Vzc1BhdGgpO1xuICAgICAgICAgICAgaG92ZXJMYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKGVtcGhhc2lzTGFiZWxBY2Nlc3NQYXRoKTtcbiAgICAgICAgICAgIGhvdmVyQW5pbWF0aW9uID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ2hvdmVyQW5pbWF0aW9uJyk7XG4gICAgICAgICAgICBjdXJzb3JTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdjdXJzb3InKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvdmVySXRlbVN0eWxlID0genJVdGlsLmV4dGVuZCh7fSwgaG92ZXJJdGVtU3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsU3R5bGUgPSBzeW1ib2xQYXRoLnN0eWxlO1xuXG4gICAgICAgIHN5bWJvbFBhdGguYXR0cigncm90YXRpb24nLCAoc3ltYm9sUm90YXRlIHx8IDApICogTWF0aC5QSSAvIDE4MCB8fCAwKTtcblxuICAgICAgICBpZiAoc3ltYm9sT2Zmc2V0KSB7XG4gICAgICAgICAgICBzeW1ib2xQYXRoLmF0dHIoJ3Bvc2l0aW9uJywgW1xuICAgICAgICAgICAgICAgIG51bWJlclV0aWwucGFyc2VQZXJjZW50KHN5bWJvbE9mZnNldFswXSwgc3ltYm9sU2l6ZVswXSksXG4gICAgICAgICAgICAgICAgbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoc3ltYm9sT2Zmc2V0WzFdLCBzeW1ib2xTaXplWzFdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJzb3JTdHlsZSAmJiBzeW1ib2xQYXRoLmF0dHIoJ2N1cnNvcicsIGN1cnNvclN0eWxlKTtcblxuICAgICAgICAvLyBQRU5ESU5HIHNldENvbG9yIGJlZm9yZSBzZXRTdHlsZSEhIVxuICAgICAgICBzeW1ib2xQYXRoLnNldENvbG9yKGNvbG9yKTtcblxuICAgICAgICBzeW1ib2xQYXRoLnNldFN0eWxlKGl0ZW1TdHlsZSk7XG5cbiAgICAgICAgdmFyIG9wYWNpdHkgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnb3BhY2l0eScpO1xuICAgICAgICBpZiAob3BhY2l0eSAhPSBudWxsKSB7XG4gICAgICAgICAgICBlbFN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlRGltID0gbGFiZWxIZWxwZXIuZmluZExhYmVsVmFsdWVEaW0oZGF0YSk7XG4gICAgICAgIGxhYmVsSGVscGVyLnNldFRleHRUb1N0eWxlKFxuICAgICAgICAgICAgZGF0YSwgaWR4LCB2YWx1ZURpbSwgZWxTdHlsZSwgc2VyaWVzTW9kZWwsIGxhYmVsTW9kZWwsIGNvbG9yXG4gICAgICAgICk7XG4gICAgICAgIGxhYmVsSGVscGVyLnNldFRleHRUb1N0eWxlKFxuICAgICAgICAgICAgZGF0YSwgaWR4LCB2YWx1ZURpbSwgaG92ZXJJdGVtU3R5bGUsIHNlcmllc01vZGVsLCBob3ZlckxhYmVsTW9kZWwsIGNvbG9yXG4gICAgICAgICk7XG5cbiAgICAgICAgc3ltYm9sUGF0aC5vZmYoJ21vdXNlb3ZlcicpXG4gICAgICAgICAgICAub2ZmKCdtb3VzZW91dCcpXG4gICAgICAgICAgICAub2ZmKCdlbXBoYXNpcycpXG4gICAgICAgICAgICAub2ZmKCdub3JtYWwnKTtcblxuICAgICAgICBzeW1ib2xQYXRoLmhvdmVyU3R5bGUgPSBob3Zlckl0ZW1TdHlsZTtcblxuICAgICAgICBncmFwaGljLnNldEhvdmVyU3R5bGUoc3ltYm9sUGF0aCk7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gZ2V0U2NhbGUoc3ltYm9sU2l6ZSk7XG5cbiAgICAgICAgaWYgKGhvdmVyQW5pbWF0aW9uICYmIHNlcmllc01vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB2YXIgb25FbXBoYXNpcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByYXRpbyA9IHNjYWxlWzFdIC8gc2NhbGVbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlVG8oe1xuICAgICAgICAgICAgICAgICAgICBzY2FsZTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoc2NhbGVbMF0gKiAxLjEsIHNjYWxlWzBdICsgMyksXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChzY2FsZVsxXSAqIDEuMSwgc2NhbGVbMV0gKyAzICogcmF0aW8pXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LCA0MDAsICdlbGFzdGljT3V0Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9uTm9ybWFsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlVG8oe1xuICAgICAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGVcbiAgICAgICAgICAgICAgICB9LCA0MDAsICdlbGFzdGljT3V0Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3ltYm9sUGF0aC5vbignbW91c2VvdmVyJywgb25FbXBoYXNpcylcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0Jywgb25Ob3JtYWwpXG4gICAgICAgICAgICAgICAgLm9uKCdlbXBoYXNpcycsIG9uRW1waGFzaXMpXG4gICAgICAgICAgICAgICAgLm9uKCdub3JtYWwnLCBvbk5vcm1hbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc3ltYm9sUHJvdG8uZmFkZU91dCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICAgICAgLy8gQXZvaWQgbWlzdGFrZW4gaG92ZXIgd2hlbiBmYWRpbmcgb3V0XG4gICAgICAgIHRoaXMuc2lsZW50ID0gc3ltYm9sUGF0aC5zaWxlbnQgPSB0cnVlO1xuICAgICAgICAvLyBOb3Qgc2hvdyB0ZXh0IHdoZW4gYW5pbWF0aW5nXG4gICAgICAgIHN5bWJvbFBhdGguc3R5bGUudGV4dCA9ICcnO1xuICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHN5bWJvbFBhdGgsIHtcbiAgICAgICAgICAgIHNjYWxlOiBbMCwgMF1cbiAgICAgICAgfSwgdGhpcy5fc2VyaWVzTW9kZWwsIHRoaXMuZGF0YUluZGV4LCBjYik7XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhTeW1ib2wsIGdyYXBoaWMuR3JvdXApO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL1N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("/**\n * @module echarts/chart/helper/Symbol\n */\n\n\n    var graphic = __webpack_require__(34);\n    var zrUtil = __webpack_require__(20);\n    var modelUtil = __webpack_require__(21);\n\n    var helper = {};\n\n    helper.findLabelValueDim = function (data) {\n        var valueDim;\n        var labelDims = modelUtil.otherDimToDataDim(data, 'label');\n\n        if (labelDims.length) {\n            valueDim = labelDims[0];\n        }\n        else {\n            // Get last value dim\n            var dimensions = data.dimensions.slice();\n            var dataType;\n            while (dimensions.length && (\n                valueDim = dimensions.pop(),\n                dataType = data.getDimensionInfo(valueDim).type,\n                dataType === 'ordinal' || dataType === 'time'\n            )) {} // jshint ignore:line\n        }\n\n        return valueDim;\n    };\n\n    helper.setTextToStyle = function (\n        data, dataIndex, valueDim, elStyle, seriesModel, labelModel, color\n    ) {\n        if (valueDim != null && labelModel.getShallow('show')) {\n            graphic.setText(elStyle, labelModel, color);\n            elStyle.text = zrUtil.retrieve(\n                seriesModel.getFormattedLabel(dataIndex, 'normal'),\n                data.get(valueDim, dataIndex)\n            );\n        }\n        else {\n            elStyle.text = '';\n        }\n    };\n\n    module.exports = helper;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9sYWJlbEhlbHBlci5qcz8yZjQ5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxNzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jaGFydC9oZWxwZXIvU3ltYm9sXG4gKi9cblxuXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbW9kZWwnKTtcblxuICAgIHZhciBoZWxwZXIgPSB7fTtcblxuICAgIGhlbHBlci5maW5kTGFiZWxWYWx1ZURpbSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciB2YWx1ZURpbTtcbiAgICAgICAgdmFyIGxhYmVsRGltcyA9IG1vZGVsVXRpbC5vdGhlckRpbVRvRGF0YURpbShkYXRhLCAnbGFiZWwnKTtcblxuICAgICAgICBpZiAobGFiZWxEaW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFsdWVEaW0gPSBsYWJlbERpbXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBHZXQgbGFzdCB2YWx1ZSBkaW1cbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25zID0gZGF0YS5kaW1lbnNpb25zLnNsaWNlKCk7XG4gICAgICAgICAgICB2YXIgZGF0YVR5cGU7XG4gICAgICAgICAgICB3aGlsZSAoZGltZW5zaW9ucy5sZW5ndGggJiYgKFxuICAgICAgICAgICAgICAgIHZhbHVlRGltID0gZGltZW5zaW9ucy5wb3AoKSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZSA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyh2YWx1ZURpbSkudHlwZSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZSA9PT0gJ29yZGluYWwnIHx8IGRhdGFUeXBlID09PSAndGltZSdcbiAgICAgICAgICAgICkpIHt9IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlRGltO1xuICAgIH07XG5cbiAgICBoZWxwZXIuc2V0VGV4dFRvU3R5bGUgPSBmdW5jdGlvbiAoXG4gICAgICAgIGRhdGEsIGRhdGFJbmRleCwgdmFsdWVEaW0sIGVsU3R5bGUsIHNlcmllc01vZGVsLCBsYWJlbE1vZGVsLCBjb2xvclxuICAgICkge1xuICAgICAgICBpZiAodmFsdWVEaW0gIT0gbnVsbCAmJiBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Nob3cnKSkge1xuICAgICAgICAgICAgZ3JhcGhpYy5zZXRUZXh0KGVsU3R5bGUsIGxhYmVsTW9kZWwsIGNvbG9yKTtcbiAgICAgICAgICAgIGVsU3R5bGUudGV4dCA9IHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChkYXRhSW5kZXgsICdub3JtYWwnKSxcbiAgICAgICAgICAgICAgICBkYXRhLmdldCh2YWx1ZURpbSwgZGF0YUluZGV4KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsU3R5bGUudGV4dCA9ICcnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gaGVscGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9sYWJlbEhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("\n\n    // var arrayDiff = require('zrender/lib/core/arrayDiff');\n    // 'zrender/core/arrayDiff' has been used before, but it did\n    // not do well in performance when roam with fixed dataZoom window.\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n\n    function getStackedOnPoint(coordSys, data, idx) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        var stackedOnSameSign;\n        var stackedOn = data.stackedOn;\n        var val = data.get(valueDim, idx);\n        // Find first stacked value with same sign\n        while (stackedOn &&\n            sign(stackedOn.get(valueDim, idx)) === sign(val)\n        ) {\n            stackedOnSameSign = stackedOn;\n            break;\n        }\n        var stackedData = [];\n        stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n        stackedData[1 - baseDataOffset] = stackedOnSameSign\n            ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n        return coordSys.dataToPoint(stackedData);\n    }\n\n    // function convertToIntId(newIdList, oldIdList) {\n    //     // Generate int id instead of string id.\n    //     // Compare string maybe slow in score function of arrDiff\n\n    //     // Assume id in idList are all unique\n    //     var idIndicesMap = {};\n    //     var idx = 0;\n    //     for (var i = 0; i < newIdList.length; i++) {\n    //         idIndicesMap[newIdList[i]] = idx;\n    //         newIdList[i] = idx++;\n    //     }\n    //     for (var i = 0; i < oldIdList.length; i++) {\n    //         var oldId = oldIdList[i];\n    //         // Same with newIdList\n    //         if (idIndicesMap[oldId]) {\n    //             oldIdList[i] = idIndicesMap[oldId];\n    //         }\n    //         else {\n    //             oldIdList[i] = idx++;\n    //         }\n    //     }\n    // }\n\n    function diffData(oldData, newData) {\n        var diffResult = [];\n\n        newData.diff(oldData)\n            .add(function (idx) {\n                diffResult.push({cmd: '+', idx: idx});\n            })\n            .update(function (newIdx, oldIdx) {\n                diffResult.push({cmd: '=', idx: oldIdx, idx1: newIdx});\n            })\n            .remove(function (idx) {\n                diffResult.push({cmd: '-', idx: idx});\n            })\n            .execute();\n\n        return diffResult;\n    }\n\n    module.exports = function (\n        oldData, newData,\n        oldStackedOnPoints, newStackedOnPoints,\n        oldCoordSys, newCoordSys\n    ) {\n        var diff = diffData(oldData, newData);\n\n        // var newIdList = newData.mapArray(newData.getId);\n        // var oldIdList = oldData.mapArray(oldData.getId);\n\n        // convertToIntId(newIdList, oldIdList);\n\n        // // FIXME One data ?\n        // diff = arrayDiff(oldIdList, newIdList);\n\n        var currPoints = [];\n        var nextPoints = [];\n        // Points for stacking base line\n        var currStackedPoints = [];\n        var nextStackedPoints = [];\n\n        var status = [];\n        var sortedIndices = [];\n        var rawIndices = [];\n        var dims = newCoordSys.dimensions;\n        for (var i = 0; i < diff.length; i++) {\n            var diffItem = diff[i];\n            var pointAdded = true;\n\n            // FIXME, animation is not so perfect when dataZoom window moves fast\n            // Which is in case remvoing or add more than one data in the tail or head\n            switch (diffItem.cmd) {\n                case '=':\n                    var currentPt = oldData.getItemLayout(diffItem.idx);\n                    var nextPt = newData.getItemLayout(diffItem.idx1);\n                    // If previous data is NaN, use next point directly\n                    if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n                        currentPt = nextPt.slice();\n                    }\n                    currPoints.push(currentPt);\n                    nextPoints.push(nextPt);\n\n                    currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n                    nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n\n                    rawIndices.push(newData.getRawIndex(diffItem.idx1));\n                    break;\n                case '+':\n                    var idx = diffItem.idx;\n                    currPoints.push(\n                        oldCoordSys.dataToPoint([\n                            newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)\n                        ])\n                    );\n\n                    nextPoints.push(newData.getItemLayout(idx).slice());\n\n                    currStackedPoints.push(\n                        getStackedOnPoint(oldCoordSys, newData, idx)\n                    );\n                    nextStackedPoints.push(newStackedOnPoints[idx]);\n\n                    rawIndices.push(newData.getRawIndex(idx));\n                    break;\n                case '-':\n                    var idx = diffItem.idx;\n                    var rawIndex = oldData.getRawIndex(idx);\n                    // Data is replaced. In the case of dynamic data queue\n                    // FIXME FIXME FIXME\n                    if (rawIndex !== idx) {\n                        currPoints.push(oldData.getItemLayout(idx));\n                        nextPoints.push(newCoordSys.dataToPoint([\n                            oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)\n                        ]));\n\n                        currStackedPoints.push(oldStackedOnPoints[idx]);\n                        nextStackedPoints.push(\n                            getStackedOnPoint(\n                                newCoordSys, oldData, idx\n                            )\n                        );\n\n                        rawIndices.push(rawIndex);\n                    }\n                    else {\n                        pointAdded = false;\n                    }\n            }\n\n            // Original indices\n            if (pointAdded) {\n                status.push(diffItem);\n                sortedIndices.push(sortedIndices.length);\n            }\n        }\n\n        // Diff result may be crossed if all items are changed\n        // Sort by data index\n        sortedIndices.sort(function (a, b) {\n            return rawIndices[a] - rawIndices[b];\n        });\n\n        var sortedCurrPoints = [];\n        var sortedNextPoints = [];\n\n        var sortedCurrStackedPoints = [];\n        var sortedNextStackedPoints = [];\n\n        var sortedStatus = [];\n        for (var i = 0; i < sortedIndices.length; i++) {\n            var idx = sortedIndices[i];\n            sortedCurrPoints[i] = currPoints[idx];\n            sortedNextPoints[i] = nextPoints[idx];\n\n            sortedCurrStackedPoints[i] = currStackedPoints[idx];\n            sortedNextStackedPoints[i] = nextStackedPoints[idx];\n\n            sortedStatus[i] = status[idx];\n        }\n\n        return {\n            current: sortedCurrPoints,\n            next: sortedNextPoints,\n\n            stackedOnCurrent: sortedCurrStackedPoints,\n            stackedOnNext: sortedNextStackedPoints,\n\n            status: sortedStatus\n        };\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvbGluZUFuaW1hdGlvbkRpZmYuanM/OGRhNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxtQkFBbUI7QUFDcEQsYUFBYTtBQUNiO0FBQ0EsaUNBQWlDLG9DQUFvQztBQUNyRSxhQUFhO0FBQ2I7QUFDQSxpQ0FBaUMsbUJBQW1CO0FBQ3BELGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjE3Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgLy8gdmFyIGFycmF5RGlmZiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvYXJyYXlEaWZmJyk7XG4gICAgLy8gJ3pyZW5kZXIvY29yZS9hcnJheURpZmYnIGhhcyBiZWVuIHVzZWQgYmVmb3JlLCBidXQgaXQgZGlkXG4gICAgLy8gbm90IGRvIHdlbGwgaW4gcGVyZm9ybWFuY2Ugd2hlbiByb2FtIHdpdGggZml4ZWQgZGF0YVpvb20gd2luZG93LlxuXG4gICAgZnVuY3Rpb24gc2lnbih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+PSAwID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN0YWNrZWRPblBvaW50KGNvb3JkU3lzLCBkYXRhLCBpZHgpIHtcbiAgICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgdmFyIHZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gICAgICAgIHZhciB2YWx1ZVN0YXJ0ID0gYmFzZUF4aXMub25aZXJvXG4gICAgICAgICAgICA/IDAgOiB2YWx1ZUF4aXMuc2NhbGUuZ2V0RXh0ZW50KClbMF07XG5cbiAgICAgICAgdmFyIHZhbHVlRGltID0gdmFsdWVBeGlzLmRpbTtcbiAgICAgICAgdmFyIGJhc2VEYXRhT2Zmc2V0ID0gdmFsdWVEaW0gPT09ICd4JyB8fCB2YWx1ZURpbSA9PT0gJ3JhZGl1cycgPyAxIDogMDtcblxuICAgICAgICB2YXIgc3RhY2tlZE9uU2FtZVNpZ247XG4gICAgICAgIHZhciBzdGFja2VkT24gPSBkYXRhLnN0YWNrZWRPbjtcbiAgICAgICAgdmFyIHZhbCA9IGRhdGEuZ2V0KHZhbHVlRGltLCBpZHgpO1xuICAgICAgICAvLyBGaW5kIGZpcnN0IHN0YWNrZWQgdmFsdWUgd2l0aCBzYW1lIHNpZ25cbiAgICAgICAgd2hpbGUgKHN0YWNrZWRPbiAmJlxuICAgICAgICAgICAgc2lnbihzdGFja2VkT24uZ2V0KHZhbHVlRGltLCBpZHgpKSA9PT0gc2lnbih2YWwpXG4gICAgICAgICkge1xuICAgICAgICAgICAgc3RhY2tlZE9uU2FtZVNpZ24gPSBzdGFja2VkT247XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhY2tlZERhdGEgPSBbXTtcbiAgICAgICAgc3RhY2tlZERhdGFbYmFzZURhdGFPZmZzZXRdID0gZGF0YS5nZXQoYmFzZUF4aXMuZGltLCBpZHgpO1xuICAgICAgICBzdGFja2VkRGF0YVsxIC0gYmFzZURhdGFPZmZzZXRdID0gc3RhY2tlZE9uU2FtZVNpZ25cbiAgICAgICAgICAgID8gc3RhY2tlZE9uU2FtZVNpZ24uZ2V0KHZhbHVlRGltLCBpZHgsIHRydWUpIDogdmFsdWVTdGFydDtcblxuICAgICAgICByZXR1cm4gY29vcmRTeXMuZGF0YVRvUG9pbnQoc3RhY2tlZERhdGEpO1xuICAgIH1cblxuICAgIC8vIGZ1bmN0aW9uIGNvbnZlcnRUb0ludElkKG5ld0lkTGlzdCwgb2xkSWRMaXN0KSB7XG4gICAgLy8gICAgIC8vIEdlbmVyYXRlIGludCBpZCBpbnN0ZWFkIG9mIHN0cmluZyBpZC5cbiAgICAvLyAgICAgLy8gQ29tcGFyZSBzdHJpbmcgbWF5YmUgc2xvdyBpbiBzY29yZSBmdW5jdGlvbiBvZiBhcnJEaWZmXG5cbiAgICAvLyAgICAgLy8gQXNzdW1lIGlkIGluIGlkTGlzdCBhcmUgYWxsIHVuaXF1ZVxuICAgIC8vICAgICB2YXIgaWRJbmRpY2VzTWFwID0ge307XG4gICAgLy8gICAgIHZhciBpZHggPSAwO1xuICAgIC8vICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0lkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIC8vICAgICAgICAgaWRJbmRpY2VzTWFwW25ld0lkTGlzdFtpXV0gPSBpZHg7XG4gICAgLy8gICAgICAgICBuZXdJZExpc3RbaV0gPSBpZHgrKztcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZElkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIC8vICAgICAgICAgdmFyIG9sZElkID0gb2xkSWRMaXN0W2ldO1xuICAgIC8vICAgICAgICAgLy8gU2FtZSB3aXRoIG5ld0lkTGlzdFxuICAgIC8vICAgICAgICAgaWYgKGlkSW5kaWNlc01hcFtvbGRJZF0pIHtcbiAgICAvLyAgICAgICAgICAgICBvbGRJZExpc3RbaV0gPSBpZEluZGljZXNNYXBbb2xkSWRdO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICAgICAgZWxzZSB7XG4gICAgLy8gICAgICAgICAgICAgb2xkSWRMaXN0W2ldID0gaWR4Kys7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG5cbiAgICBmdW5jdGlvbiBkaWZmRGF0YShvbGREYXRhLCBuZXdEYXRhKSB7XG4gICAgICAgIHZhciBkaWZmUmVzdWx0ID0gW107XG5cbiAgICAgICAgbmV3RGF0YS5kaWZmKG9sZERhdGEpXG4gICAgICAgICAgICAuYWRkKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICBkaWZmUmVzdWx0LnB1c2goe2NtZDogJysnLCBpZHg6IGlkeH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgICAgICAgICAgICAgZGlmZlJlc3VsdC5wdXNoKHtjbWQ6ICc9JywgaWR4OiBvbGRJZHgsIGlkeDE6IG5ld0lkeH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZW1vdmUoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgIGRpZmZSZXN1bHQucHVzaCh7Y21kOiAnLScsIGlkeDogaWR4fSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmV4ZWN1dGUoKTtcblxuICAgICAgICByZXR1cm4gZGlmZlJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChcbiAgICAgICAgb2xkRGF0YSwgbmV3RGF0YSxcbiAgICAgICAgb2xkU3RhY2tlZE9uUG9pbnRzLCBuZXdTdGFja2VkT25Qb2ludHMsXG4gICAgICAgIG9sZENvb3JkU3lzLCBuZXdDb29yZFN5c1xuICAgICkge1xuICAgICAgICB2YXIgZGlmZiA9IGRpZmZEYXRhKG9sZERhdGEsIG5ld0RhdGEpO1xuXG4gICAgICAgIC8vIHZhciBuZXdJZExpc3QgPSBuZXdEYXRhLm1hcEFycmF5KG5ld0RhdGEuZ2V0SWQpO1xuICAgICAgICAvLyB2YXIgb2xkSWRMaXN0ID0gb2xkRGF0YS5tYXBBcnJheShvbGREYXRhLmdldElkKTtcblxuICAgICAgICAvLyBjb252ZXJ0VG9JbnRJZChuZXdJZExpc3QsIG9sZElkTGlzdCk7XG5cbiAgICAgICAgLy8gLy8gRklYTUUgT25lIGRhdGEgP1xuICAgICAgICAvLyBkaWZmID0gYXJyYXlEaWZmKG9sZElkTGlzdCwgbmV3SWRMaXN0KTtcblxuICAgICAgICB2YXIgY3VyclBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgbmV4dFBvaW50cyA9IFtdO1xuICAgICAgICAvLyBQb2ludHMgZm9yIHN0YWNraW5nIGJhc2UgbGluZVxuICAgICAgICB2YXIgY3VyclN0YWNrZWRQb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIG5leHRTdGFja2VkUG9pbnRzID0gW107XG5cbiAgICAgICAgdmFyIHN0YXR1cyA9IFtdO1xuICAgICAgICB2YXIgc29ydGVkSW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgcmF3SW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgZGltcyA9IG5ld0Nvb3JkU3lzLmRpbWVuc2lvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpZmZJdGVtID0gZGlmZltpXTtcbiAgICAgICAgICAgIHZhciBwb2ludEFkZGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gRklYTUUsIGFuaW1hdGlvbiBpcyBub3Qgc28gcGVyZmVjdCB3aGVuIGRhdGFab29tIHdpbmRvdyBtb3ZlcyBmYXN0XG4gICAgICAgICAgICAvLyBXaGljaCBpcyBpbiBjYXNlIHJlbXZvaW5nIG9yIGFkZCBtb3JlIHRoYW4gb25lIGRhdGEgaW4gdGhlIHRhaWwgb3IgaGVhZFxuICAgICAgICAgICAgc3dpdGNoIChkaWZmSXRlbS5jbWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICc9JzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRQdCA9IG9sZERhdGEuZ2V0SXRlbUxheW91dChkaWZmSXRlbS5pZHgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFB0ID0gbmV3RGF0YS5nZXRJdGVtTGF5b3V0KGRpZmZJdGVtLmlkeDEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBkYXRhIGlzIE5hTiwgdXNlIG5leHQgcG9pbnQgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGN1cnJlbnRQdFswXSkgfHwgaXNOYU4oY3VycmVudFB0WzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFB0ID0gbmV4dFB0LnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VyclBvaW50cy5wdXNoKGN1cnJlbnRQdCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb2ludHMucHVzaChuZXh0UHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJTdGFja2VkUG9pbnRzLnB1c2gob2xkU3RhY2tlZE9uUG9pbnRzW2RpZmZJdGVtLmlkeF0pO1xuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhY2tlZFBvaW50cy5wdXNoKG5ld1N0YWNrZWRPblBvaW50c1tkaWZmSXRlbS5pZHgxXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmF3SW5kaWNlcy5wdXNoKG5ld0RhdGEuZ2V0UmF3SW5kZXgoZGlmZkl0ZW0uaWR4MSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IGRpZmZJdGVtLmlkeDtcbiAgICAgICAgICAgICAgICAgICAgY3VyclBvaW50cy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkQ29vcmRTeXMuZGF0YVRvUG9pbnQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RhdGEuZ2V0KGRpbXNbMF0sIGlkeCwgdHJ1ZSksIG5ld0RhdGEuZ2V0KGRpbXNbMV0sIGlkeCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvaW50cy5wdXNoKG5ld0RhdGEuZ2V0SXRlbUxheW91dChpZHgpLnNsaWNlKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJTdGFja2VkUG9pbnRzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRTdGFja2VkT25Qb2ludChvbGRDb29yZFN5cywgbmV3RGF0YSwgaWR4KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhY2tlZFBvaW50cy5wdXNoKG5ld1N0YWNrZWRPblBvaW50c1tpZHhdKTtcblxuICAgICAgICAgICAgICAgICAgICByYXdJbmRpY2VzLnB1c2gobmV3RGF0YS5nZXRSYXdJbmRleChpZHgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBkaWZmSXRlbS5pZHg7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYXdJbmRleCA9IG9sZERhdGEuZ2V0UmF3SW5kZXgoaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGF0YSBpcyByZXBsYWNlZC4gSW4gdGhlIGNhc2Ugb2YgZHluYW1pYyBkYXRhIHF1ZXVlXG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIEZJWE1FIEZJWE1FXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdJbmRleCAhPT0gaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyUG9pbnRzLnB1c2gob2xkRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBvaW50cy5wdXNoKG5ld0Nvb3JkU3lzLmRhdGFUb1BvaW50KFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGREYXRhLmdldChkaW1zWzBdLCBpZHgsIHRydWUpLCBvbGREYXRhLmdldChkaW1zWzFdLCBpZHgsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJTdGFja2VkUG9pbnRzLnB1c2gob2xkU3RhY2tlZE9uUG9pbnRzW2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YWNrZWRQb2ludHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRTdGFja2VkT25Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29vcmRTeXMsIG9sZERhdGEsIGlkeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0luZGljZXMucHVzaChyYXdJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEFkZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgaW5kaWNlc1xuICAgICAgICAgICAgaWYgKHBvaW50QWRkZWQpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMucHVzaChkaWZmSXRlbSk7XG4gICAgICAgICAgICAgICAgc29ydGVkSW5kaWNlcy5wdXNoKHNvcnRlZEluZGljZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpZmYgcmVzdWx0IG1heSBiZSBjcm9zc2VkIGlmIGFsbCBpdGVtcyBhcmUgY2hhbmdlZFxuICAgICAgICAvLyBTb3J0IGJ5IGRhdGEgaW5kZXhcbiAgICAgICAgc29ydGVkSW5kaWNlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3SW5kaWNlc1thXSAtIHJhd0luZGljZXNbYl07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzb3J0ZWRDdXJyUG9pbnRzID0gW107XG4gICAgICAgIHZhciBzb3J0ZWROZXh0UG9pbnRzID0gW107XG5cbiAgICAgICAgdmFyIHNvcnRlZEN1cnJTdGFja2VkUG9pbnRzID0gW107XG4gICAgICAgIHZhciBzb3J0ZWROZXh0U3RhY2tlZFBvaW50cyA9IFtdO1xuXG4gICAgICAgIHZhciBzb3J0ZWRTdGF0dXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWRJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gc29ydGVkSW5kaWNlc1tpXTtcbiAgICAgICAgICAgIHNvcnRlZEN1cnJQb2ludHNbaV0gPSBjdXJyUG9pbnRzW2lkeF07XG4gICAgICAgICAgICBzb3J0ZWROZXh0UG9pbnRzW2ldID0gbmV4dFBvaW50c1tpZHhdO1xuXG4gICAgICAgICAgICBzb3J0ZWRDdXJyU3RhY2tlZFBvaW50c1tpXSA9IGN1cnJTdGFja2VkUG9pbnRzW2lkeF07XG4gICAgICAgICAgICBzb3J0ZWROZXh0U3RhY2tlZFBvaW50c1tpXSA9IG5leHRTdGFja2VkUG9pbnRzW2lkeF07XG5cbiAgICAgICAgICAgIHNvcnRlZFN0YXR1c1tpXSA9IHN0YXR1c1tpZHhdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnQ6IHNvcnRlZEN1cnJQb2ludHMsXG4gICAgICAgICAgICBuZXh0OiBzb3J0ZWROZXh0UG9pbnRzLFxuXG4gICAgICAgICAgICBzdGFja2VkT25DdXJyZW50OiBzb3J0ZWRDdXJyU3RhY2tlZFBvaW50cyxcbiAgICAgICAgICAgIHN0YWNrZWRPbk5leHQ6IHNvcnRlZE5leHRTdGFja2VkUG9pbnRzLFxuXG4gICAgICAgICAgICBzdGF0dXM6IHNvcnRlZFN0YXR1c1xuICAgICAgICB9O1xuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9saW5lQW5pbWF0aW9uRGlmZi5qc1xuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("// Poly path support NaN point\n\n\n    var Path = __webpack_require__(36);\n    var vec2 = __webpack_require__(26);\n\n    var vec2Min = vec2.min;\n    var vec2Max = vec2.max;\n\n    var scaleAndAdd = vec2.scaleAndAdd;\n    var v2Copy = vec2.copy;\n\n    // Temporary variable\n    var v = [];\n    var cp0 = [];\n    var cp1 = [];\n\n    function isPointNull(p) {\n        return isNaN(p[0]) || isNaN(p[1]);\n    }\n\n    function drawSegment(\n        ctx, points, start, segLen, allLen,\n        dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls\n    ) {\n        var prevIdx = 0;\n        var idx = start;\n        for (var k = 0; k < segLen; k++) {\n            var p = points[idx];\n            if (idx >= allLen || idx < 0) {\n                break;\n            }\n            if (isPointNull(p)) {\n                if (connectNulls) {\n                    idx += dir;\n                    continue;\n                }\n                break;\n            }\n\n            if (idx === start) {\n                ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n                v2Copy(cp0, p);\n            }\n            else {\n                if (smooth > 0) {\n                    var nextIdx = idx + dir;\n                    var nextP = points[nextIdx];\n                    if (connectNulls) {\n                        // Find next point not null\n                        while (nextP && isPointNull(points[nextIdx])) {\n                            nextIdx += dir;\n                            nextP = points[nextIdx];\n                        }\n                    }\n\n                    var ratioNextSeg = 0.5;\n                    var prevP = points[prevIdx];\n                    var nextP = points[nextIdx];\n                    // Last point\n                    if (!nextP || isPointNull(nextP)) {\n                        v2Copy(cp1, p);\n                    }\n                    else {\n                        // If next data is null in not connect case\n                        if (isPointNull(nextP) && !connectNulls) {\n                            nextP = p;\n                        }\n\n                        vec2.sub(v, nextP, prevP);\n\n                        var lenPrevSeg;\n                        var lenNextSeg;\n                        if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n                            var dim = smoothMonotone === 'x' ? 0 : 1;\n                            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n                            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n                        }\n                        else {\n                            lenPrevSeg = vec2.dist(p, prevP);\n                            lenNextSeg = vec2.dist(p, nextP);\n                        }\n\n                        // Use ratio of seg length\n                        ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n\n                        scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n                    }\n                    // Smooth constraint\n                    vec2Min(cp0, cp0, smoothMax);\n                    vec2Max(cp0, cp0, smoothMin);\n                    vec2Min(cp1, cp1, smoothMax);\n                    vec2Max(cp1, cp1, smoothMin);\n\n                    ctx.bezierCurveTo(\n                        cp0[0], cp0[1],\n                        cp1[0], cp1[1],\n                        p[0], p[1]\n                    );\n                    // cp0 of next segment\n                    scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n                }\n                else {\n                    ctx.lineTo(p[0], p[1]);\n                }\n            }\n\n            prevIdx = idx;\n            idx += dir;\n        }\n\n        return k;\n    }\n\n    function getBoundingBox(points, smoothConstraint) {\n        var ptMin = [Infinity, Infinity];\n        var ptMax = [-Infinity, -Infinity];\n        if (smoothConstraint) {\n            for (var i = 0; i < points.length; i++) {\n                var pt = points[i];\n                if (pt[0] < ptMin[0]) { ptMin[0] = pt[0]; }\n                if (pt[1] < ptMin[1]) { ptMin[1] = pt[1]; }\n                if (pt[0] > ptMax[0]) { ptMax[0] = pt[0]; }\n                if (pt[1] > ptMax[1]) { ptMax[1] = pt[1]; }\n            }\n        }\n        return {\n            min: smoothConstraint ? ptMin : ptMax,\n            max: smoothConstraint ? ptMax : ptMin\n        };\n    }\n\n    module.exports = {\n\n        Polyline: Path.extend({\n\n            type: 'ec-polyline',\n\n            shape: {\n                points: [],\n\n                smooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            style: {\n                fill: null,\n\n                stroke: '#000'\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n\n                var i = 0;\n                var len = points.length;\n\n                var result = getBoundingBox(points, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    i += drawSegment(\n                        ctx, points, i, len, len,\n                        1, result.min, result.max, shape.smooth,\n                        shape.smoothMonotone, shape.connectNulls\n                    ) + 1;\n                }\n            }\n        }),\n\n        Polygon: Path.extend({\n\n            type: 'ec-polygon',\n\n            shape: {\n                points: [],\n\n                // Offset between stacked base points and points\n                stackedOnPoints: [],\n\n                smooth: 0,\n\n                stackedOnSmooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n                var stackedOnPoints = shape.stackedOnPoints;\n\n                var i = 0;\n                var len = points.length;\n                var smoothMonotone = shape.smoothMonotone;\n                var bbox = getBoundingBox(points, shape.smoothConstraint);\n                var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    var k = drawSegment(\n                        ctx, points, i, len, len,\n                        1, bbox.min, bbox.max, shape.smooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    drawSegment(\n                        ctx, stackedOnPoints, i + k - 1, k, len,\n                        -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    i += k + 1;\n\n                    ctx.closePath();\n                }\n            }\n        })\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvcG9seS5qcz9jNzYwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0EsdUNBQXVDLGtCQUFrQjtBQUN6RCx1Q0FBdUMsa0JBQWtCO0FBQ3pELHVDQUF1QyxrQkFBa0I7QUFDekQsdUNBQXVDLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QiLCJmaWxlIjoiMTc3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gUG9seSBwYXRoIHN1cHBvcnQgTmFOIHBvaW50XG5cblxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoJyk7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xuXG4gICAgdmFyIHZlYzJNaW4gPSB2ZWMyLm1pbjtcbiAgICB2YXIgdmVjMk1heCA9IHZlYzIubWF4O1xuXG4gICAgdmFyIHNjYWxlQW5kQWRkID0gdmVjMi5zY2FsZUFuZEFkZDtcbiAgICB2YXIgdjJDb3B5ID0gdmVjMi5jb3B5O1xuXG4gICAgLy8gVGVtcG9yYXJ5IHZhcmlhYmxlXG4gICAgdmFyIHYgPSBbXTtcbiAgICB2YXIgY3AwID0gW107XG4gICAgdmFyIGNwMSA9IFtdO1xuXG4gICAgZnVuY3Rpb24gaXNQb2ludE51bGwocCkge1xuICAgICAgICByZXR1cm4gaXNOYU4ocFswXSkgfHwgaXNOYU4ocFsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd1NlZ21lbnQoXG4gICAgICAgIGN0eCwgcG9pbnRzLCBzdGFydCwgc2VnTGVuLCBhbGxMZW4sXG4gICAgICAgIGRpciwgc21vb3RoTWluLCBzbW9vdGhNYXgsIHNtb290aCwgc21vb3RoTW9ub3RvbmUsIGNvbm5lY3ROdWxsc1xuICAgICkge1xuICAgICAgICB2YXIgcHJldklkeCA9IDA7XG4gICAgICAgIHZhciBpZHggPSBzdGFydDtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzZWdMZW47IGsrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBwb2ludHNbaWR4XTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gYWxsTGVuIHx8IGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1BvaW50TnVsbChwKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0TnVsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWR4ICs9IGRpcjtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaWR4ID09PSBzdGFydCkge1xuICAgICAgICAgICAgICAgIGN0eFtkaXIgPiAwID8gJ21vdmVUbycgOiAnbGluZVRvJ10ocFswXSwgcFsxXSk7XG4gICAgICAgICAgICAgICAgdjJDb3B5KGNwMCwgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dElkeCA9IGlkeCArIGRpcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRQID0gcG9pbnRzW25leHRJZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdE51bGxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIG5leHQgcG9pbnQgbm90IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0UCAmJiBpc1BvaW50TnVsbChwb2ludHNbbmV4dElkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dElkeCArPSBkaXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFAgPSBwb2ludHNbbmV4dElkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcmF0aW9OZXh0U2VnID0gMC41O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlAgPSBwb2ludHNbcHJldklkeF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0UCA9IHBvaW50c1tuZXh0SWR4XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGFzdCBwb2ludFxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHRQIHx8IGlzUG9pbnROdWxsKG5leHRQKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdjJDb3B5KGNwMSwgcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBuZXh0IGRhdGEgaXMgbnVsbCBpbiBub3QgY29ubmVjdCBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQb2ludE51bGwobmV4dFApICYmICFjb25uZWN0TnVsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0UCA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuc3ViKHYsIG5leHRQLCBwcmV2UCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5QcmV2U2VnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbk5leHRTZWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc21vb3RoTW9ub3RvbmUgPT09ICd4JyB8fCBzbW9vdGhNb25vdG9uZSA9PT0gJ3knKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpbSA9IHNtb290aE1vbm90b25lID09PSAneCcgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5QcmV2U2VnID0gTWF0aC5hYnMocFtkaW1dIC0gcHJldlBbZGltXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuTmV4dFNlZyA9IE1hdGguYWJzKHBbZGltXSAtIG5leHRQW2RpbV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuUHJldlNlZyA9IHZlYzIuZGlzdChwLCBwcmV2UCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuTmV4dFNlZyA9IHZlYzIuZGlzdChwLCBuZXh0UCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSByYXRpbyBvZiBzZWcgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICByYXRpb05leHRTZWcgPSBsZW5OZXh0U2VnIC8gKGxlbk5leHRTZWcgKyBsZW5QcmV2U2VnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVBbmRBZGQoY3AxLCBwLCB2LCAtc21vb3RoICogKDEgLSByYXRpb05leHRTZWcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTbW9vdGggY29uc3RyYWludFxuICAgICAgICAgICAgICAgICAgICB2ZWMyTWluKGNwMCwgY3AwLCBzbW9vdGhNYXgpO1xuICAgICAgICAgICAgICAgICAgICB2ZWMyTWF4KGNwMCwgY3AwLCBzbW9vdGhNaW4pO1xuICAgICAgICAgICAgICAgICAgICB2ZWMyTWluKGNwMSwgY3AxLCBzbW9vdGhNYXgpO1xuICAgICAgICAgICAgICAgICAgICB2ZWMyTWF4KGNwMSwgY3AxLCBzbW9vdGhNaW4pO1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3AwWzBdLCBjcDBbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcDFbMF0sIGNwMVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBbMF0sIHBbMV1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3AwIG9mIG5leHQgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICBzY2FsZUFuZEFkZChjcDAsIHAsIHYsIHNtb290aCAqIHJhdGlvTmV4dFNlZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBbMF0sIHBbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldklkeCA9IGlkeDtcbiAgICAgICAgICAgIGlkeCArPSBkaXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveChwb2ludHMsIHNtb290aENvbnN0cmFpbnQpIHtcbiAgICAgICAgdmFyIHB0TWluID0gW0luZmluaXR5LCBJbmZpbml0eV07XG4gICAgICAgIHZhciBwdE1heCA9IFstSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIGlmIChzbW9vdGhDb25zdHJhaW50KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocHRbMF0gPCBwdE1pblswXSkgeyBwdE1pblswXSA9IHB0WzBdOyB9XG4gICAgICAgICAgICAgICAgaWYgKHB0WzFdIDwgcHRNaW5bMV0pIHsgcHRNaW5bMV0gPSBwdFsxXTsgfVxuICAgICAgICAgICAgICAgIGlmIChwdFswXSA+IHB0TWF4WzBdKSB7IHB0TWF4WzBdID0gcHRbMF07IH1cbiAgICAgICAgICAgICAgICBpZiAocHRbMV0gPiBwdE1heFsxXSkgeyBwdE1heFsxXSA9IHB0WzFdOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbjogc21vb3RoQ29uc3RyYWludCA/IHB0TWluIDogcHRNYXgsXG4gICAgICAgICAgICBtYXg6IHNtb290aENvbnN0cmFpbnQgPyBwdE1heCA6IHB0TWluXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgUG9seWxpbmU6IFBhdGguZXh0ZW5kKHtcblxuICAgICAgICAgICAgdHlwZTogJ2VjLXBvbHlsaW5lJyxcblxuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICBwb2ludHM6IFtdLFxuXG4gICAgICAgICAgICAgICAgc21vb3RoOiAwLFxuXG4gICAgICAgICAgICAgICAgc21vb3RoQ29uc3RyYWludDogdHJ1ZSxcblxuICAgICAgICAgICAgICAgIHNtb290aE1vbm90b25lOiBudWxsLFxuXG4gICAgICAgICAgICAgICAgY29ubmVjdE51bGxzOiBmYWxzZVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmaWxsOiBudWxsLFxuXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGdldEJvdW5kaW5nQm94KHBvaW50cywgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUuY29ubmVjdE51bGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE11c3QgcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IG51bGwgdmFsdWVzIGF2b2lkIGRyYXcgZXJyb3IgaW4gcG9seWdvblxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2xlbiAtIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gZHJhd1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgsIHBvaW50cywgaSwgbGVuLCBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAxLCByZXN1bHQubWluLCByZXN1bHQubWF4LCBzaGFwZS5zbW9vdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5zbW9vdGhNb25vdG9uZSwgc2hhcGUuY29ubmVjdE51bGxzXG4gICAgICAgICAgICAgICAgICAgICkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG5cbiAgICAgICAgUG9seWdvbjogUGF0aC5leHRlbmQoe1xuXG4gICAgICAgICAgICB0eXBlOiAnZWMtcG9seWdvbicsXG5cbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXSxcblxuICAgICAgICAgICAgICAgIC8vIE9mZnNldCBiZXR3ZWVuIHN0YWNrZWQgYmFzZSBwb2ludHMgYW5kIHBvaW50c1xuICAgICAgICAgICAgICAgIHN0YWNrZWRPblBvaW50czogW10sXG5cbiAgICAgICAgICAgICAgICBzbW9vdGg6IDAsXG5cbiAgICAgICAgICAgICAgICBzdGFja2VkT25TbW9vdGg6IDAsXG5cbiAgICAgICAgICAgICAgICBzbW9vdGhDb25zdHJhaW50OiB0cnVlLFxuXG4gICAgICAgICAgICAgICAgc21vb3RoTW9ub3RvbmU6IG51bGwsXG5cbiAgICAgICAgICAgICAgICBjb25uZWN0TnVsbHM6IGZhbHNlXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uUG9pbnRzID0gc2hhcGUuc3RhY2tlZE9uUG9pbnRzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBzbW9vdGhNb25vdG9uZSA9IHNoYXBlLnNtb290aE1vbm90b25lO1xuICAgICAgICAgICAgICAgIHZhciBiYm94ID0gZ2V0Qm91bmRpbmdCb3gocG9pbnRzLCBzaGFwZS5zbW9vdGhDb25zdHJhaW50KTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uQkJveCA9IGdldEJvdW5kaW5nQm94KHN0YWNrZWRPblBvaW50cywgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUuY29ubmVjdE51bGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE11c3QgcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IG51bGwgdmFsdWVzIGF2b2lkIGRyYXcgZXJyb3IgaW4gcG9seWdvblxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2xlbiAtIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gZHJhd1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgsIHBvaW50cywgaSwgbGVuLCBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAxLCBiYm94Lm1pbiwgYmJveC5tYXgsIHNoYXBlLnNtb290aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aE1vbm90b25lLCBzaGFwZS5jb25uZWN0TnVsbHNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZHJhd1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgsIHN0YWNrZWRPblBvaW50cywgaSArIGsgLSAxLCBrLCBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAtMSwgc3RhY2tlZE9uQkJveC5taW4sIHN0YWNrZWRPbkJCb3gubWF4LCBzaGFwZS5zdGFja2VkT25TbW9vdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhNb25vdG9uZSwgc2hhcGUuY29ubmVjdE51bGxzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gayArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvcG9seS5qc1xuLy8gbW9kdWxlIGlkID0gMTc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports){eval("\n\n    module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n\n        // Encoding visual for all series include which is filtered for legend drawing\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n\n            var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n            var symbolSize = seriesModel.get('symbolSize');\n\n            data.setVisual({\n                legendSymbol: legendSymbol || symbolType,\n                symbol: symbolType,\n                symbolSize: symbolSize\n            });\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof symbolSize === 'function') {\n                    data.each(function (idx) {\n                        var rawValue = seriesModel.getRawValue(idx);\n                        // FIXME\n                        var params = seriesModel.getDataParams(idx);\n                        data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n                    });\n                }\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var itemSymbolType = itemModel.getShallow('symbol', true);\n                    var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n                    // If has item symbol\n                    if (itemSymbolType != null) {\n                        data.setItemVisual(idx, 'symbol', itemSymbolType);\n                    }\n                    if (itemSymbolSize != null) {\n                        // PENDING Transform symbolSize ?\n                        data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n                    }\n                });\n            }\n        });\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3Zpc3VhbC9zeW1ib2wuanM/NTE4YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUIiwiZmlsZSI6IjE3OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgZGVmYXVsdFN5bWJvbFR5cGUsIGxlZ2VuZFN5bWJvbCwgZWNNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgLy8gRW5jb2RpbmcgdmlzdWFsIGZvciBhbGwgc2VyaWVzIGluY2x1ZGUgd2hpY2ggaXMgZmlsdGVyZWQgZm9yIGxlZ2VuZCBkcmF3aW5nXG4gICAgICAgIGVjTW9kZWwuZWFjaFJhd1Nlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgICAgICAgICB2YXIgc3ltYm9sVHlwZSA9IHNlcmllc01vZGVsLmdldCgnc3ltYm9sJykgfHwgZGVmYXVsdFN5bWJvbFR5cGU7XG4gICAgICAgICAgICB2YXIgc3ltYm9sU2l6ZSA9IHNlcmllc01vZGVsLmdldCgnc3ltYm9sU2l6ZScpO1xuXG4gICAgICAgICAgICBkYXRhLnNldFZpc3VhbCh7XG4gICAgICAgICAgICAgICAgbGVnZW5kU3ltYm9sOiBsZWdlbmRTeW1ib2wgfHwgc3ltYm9sVHlwZSxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IHN5bWJvbFR5cGUsXG4gICAgICAgICAgICAgICAgc3ltYm9sU2l6ZTogc3ltYm9sU2l6ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdmlzaWJsZSBzZXJpZXMgaGFzIGVhY2ggZGF0YSBiZSB2aXN1YWwgZW5jb2RlZFxuICAgICAgICAgICAgaWYgKCFlY01vZGVsLmlzU2VyaWVzRmlsdGVyZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzeW1ib2xTaXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3VmFsdWUgPSBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBzZXJpZXNNb2RlbC5nZXREYXRhUGFyYW1zKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScsIHN5bWJvbFNpemUocmF3VmFsdWUsIHBhcmFtcykpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtU3ltYm9sVHlwZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2wnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1TeW1ib2xTaXplID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbFNpemUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaGFzIGl0ZW0gc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtU3ltYm9sVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJywgaXRlbVN5bWJvbFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtU3ltYm9sU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQRU5ESU5HIFRyYW5zZm9ybSBzeW1ib2xTaXplID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xTaXplJywgaXRlbVN5bWJvbFNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvdmlzdWFsL3N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("\n\n    module.exports = function (seriesType, ecModel) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var coordSys = seriesModel.coordinateSystem;\n\n            if (!coordSys) {\n                return;\n            }\n\n            var dims = [];\n            var coordDims = coordSys.dimensions;\n            for (var i = 0; i < coordDims.length; i++) {\n                dims.push(seriesModel.coordDimToDataDim(coordSys.dimensions[i])[0]);\n            }\n\n            if (dims.length === 1) {\n                data.each(dims[0], function (x, idx) {\n                    // Also {Array.<number>}, not undefined to avoid if...else... statement\n                    data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));\n                });\n            }\n            else if (dims.length === 2) {\n                data.each(dims, function (x, y, idx) {\n                    // Also {Array.<number>}, not undefined to avoid if...else... statement\n                    data.setItemLayout(\n                        idx, (isNaN(x) || isNaN(y)) ? [NaN, NaN] : coordSys.dataToPoint([x, y])\n                    );\n                }, true);\n            }\n        });\n    };\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2xheW91dC9wb2ludHMuanM/NDMwMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsZUFBZTtBQUM1QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QiLCJmaWxlIjoiMTc5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBlY01vZGVsKSB7XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcblxuICAgICAgICAgICAgaWYgKCFjb29yZFN5cykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpbXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjb29yZERpbXMgPSBjb29yZFN5cy5kaW1lbnNpb25zO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZERpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkaW1zLnB1c2goc2VyaWVzTW9kZWwuY29vcmREaW1Ub0RhdGFEaW0oY29vcmRTeXMuZGltZW5zaW9uc1tpXSlbMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGltcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVhY2goZGltc1swXSwgZnVuY3Rpb24gKHgsIGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbHNvIHtBcnJheS48bnVtYmVyPn0sIG5vdCB1bmRlZmluZWQgdG8gYXZvaWQgaWYuLi5lbHNlLi4uIHN0YXRlbWVudFxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBpc05hTih4KSA/IFtOYU4sIE5hTl0gOiBjb29yZFN5cy5kYXRhVG9Qb2ludCh4KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaW1zLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGRhdGEuZWFjaChkaW1zLCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsc28ge0FycmF5LjxudW1iZXI+fSwgbm90IHVuZGVmaW5lZCB0byBhdm9pZCBpZi4uLmVsc2UuLi4gc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeCwgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSA/IFtOYU4sIE5hTl0gOiBjb29yZFN5cy5kYXRhVG9Qb2ludChbeCwgeV0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9sYXlvdXQvcG9pbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("\n    var samplers = {\n        average: function (frame) {\n            var sum = 0;\n            var count = 0;\n            for (var i = 0; i < frame.length; i++) {\n                if (!isNaN(frame[i])) {\n                    sum += frame[i];\n                    count++;\n                }\n            }\n            // Return NaN if count is 0\n            return count === 0 ? NaN : sum / count;\n        },\n        sum: function (frame) {\n            var sum = 0;\n            for (var i = 0; i < frame.length; i++) {\n                // Ignore NaN\n                sum += frame[i] || 0;\n            }\n            return sum;\n        },\n        max: function (frame) {\n            var max = -Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] > max && (max = frame[i]);\n            }\n            return max;\n        },\n        min: function (frame) {\n            var min = Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] < min && (min = frame[i]);\n            }\n            return min;\n        },\n        // TODO\n        // Median\n        nearest: function (frame) {\n            return frame[0];\n        }\n    };\n\n    var indexSampler = function (frame, value) {\n        return Math.round(frame.length / 2);\n    };\n    module.exports = function (seriesType, ecModel, api) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var sampling = seriesModel.get('sampling');\n            var coordSys = seriesModel.coordinateSystem;\n            // Only cartesian2d support down sampling\n            if (coordSys.type === 'cartesian2d' && sampling) {\n                var baseAxis = coordSys.getBaseAxis();\n                var valueAxis = coordSys.getOtherAxis(baseAxis);\n                var extent = baseAxis.getExtent();\n                // Coordinste system has been resized\n                var size = extent[1] - extent[0];\n                var rate = Math.round(data.count() / size);\n                if (rate > 1) {\n                    var sampler;\n                    if (typeof sampling === 'string') {\n                        sampler = samplers[sampling];\n                    }\n                    else if (typeof sampling === 'function') {\n                        sampler = sampling;\n                    }\n                    if (sampler) {\n                        data = data.downSample(\n                            valueAxis.dim, 1 / rate, sampler, indexSampler\n                        );\n                        seriesModel.setData(data);\n                    }\n                }\n            }\n        }, this);\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3Byb2Nlc3Nvci9kYXRhU2FtcGxlLmpzPzZmY2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUIiwiZmlsZSI6IjE4MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuICAgIHZhciBzYW1wbGVycyA9IHtcbiAgICAgICAgYXZlcmFnZTogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihmcmFtZVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IGZyYW1lW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgY291bnQgaXMgMFxuICAgICAgICAgICAgcmV0dXJuIGNvdW50ID09PSAwID8gTmFOIDogc3VtIC8gY291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHN1bTogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgTmFOXG4gICAgICAgICAgICAgICAgc3VtICs9IGZyYW1lW2ldIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9LFxuICAgICAgICBtYXg6IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAgICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmcmFtZVtpXSA+IG1heCAmJiAobWF4ID0gZnJhbWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfSxcbiAgICAgICAgbWluOiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmcmFtZVtpXSA8IG1pbiAmJiAobWluID0gZnJhbWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyBNZWRpYW5cbiAgICAgICAgbmVhcmVzdDogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhbWVbMF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGluZGV4U2FtcGxlciA9IGZ1bmN0aW9uIChmcmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZnJhbWUubGVuZ3RoIC8gMik7XG4gICAgfTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB2YXIgc2FtcGxpbmcgPSBzZXJpZXNNb2RlbC5nZXQoJ3NhbXBsaW5nJyk7XG4gICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgLy8gT25seSBjYXJ0ZXNpYW4yZCBzdXBwb3J0IGRvd24gc2FtcGxpbmdcbiAgICAgICAgICAgIGlmIChjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnICYmIHNhbXBsaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW50ID0gYmFzZUF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgICAgICAgICAgICAgLy8gQ29vcmRpbnN0ZSBzeXN0ZW0gaGFzIGJlZW4gcmVzaXplZFxuICAgICAgICAgICAgICAgIHZhciBzaXplID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICAgICAgICAgICAgICAgIHZhciByYXRlID0gTWF0aC5yb3VuZChkYXRhLmNvdW50KCkgLyBzaXplKTtcbiAgICAgICAgICAgICAgICBpZiAocmF0ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhbXBsZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2FtcGxpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVyID0gc2FtcGxlcnNbc2FtcGxpbmddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzYW1wbGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlciA9IHNhbXBsaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzYW1wbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5kb3duU2FtcGxlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlQXhpcy5kaW0sIDEgLyByYXRlLCBzYW1wbGVyLCBpbmRleFNhbXBsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5zZXREYXRhKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3Byb2Nlc3Nvci9kYXRhU2FtcGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n    var echarts = __webpack_require__(17);\n\n    __webpack_require__(182);\n    __webpack_require__(184);\n\n    __webpack_require__(185)('pie', [{\n        type: 'pieToggleSelect',\n        event: 'pieselectchanged',\n        method: 'toggleSelected'\n    }, {\n        type: 'pieSelect',\n        event: 'pieselected',\n        method: 'select'\n    }, {\n        type: 'pieUnSelect',\n        event: 'pieunselected',\n        method: 'unSelect'\n    }]);\n\n    echarts.registerVisual(zrUtil.curry(__webpack_require__(186), 'pie'));\n\n    echarts.registerLayout(zrUtil.curry(\n        __webpack_require__(187), 'pie'\n    ));\n\n    echarts.registerProcessor(zrUtil.curry(__webpack_require__(189), 'pie'));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L3BpZS5qcz9lYzE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxODEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uL2VjaGFydHMnKTtcblxuICAgIHJlcXVpcmUoJy4vcGllL1BpZVNlcmllcycpO1xuICAgIHJlcXVpcmUoJy4vcGllL1BpZVZpZXcnKTtcblxuICAgIHJlcXVpcmUoJy4uL2FjdGlvbi9jcmVhdGVEYXRhU2VsZWN0QWN0aW9uJykoJ3BpZScsIFt7XG4gICAgICAgIHR5cGU6ICdwaWVUb2dnbGVTZWxlY3QnLFxuICAgICAgICBldmVudDogJ3BpZXNlbGVjdGNoYW5nZWQnLFxuICAgICAgICBtZXRob2Q6ICd0b2dnbGVTZWxlY3RlZCdcbiAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdwaWVTZWxlY3QnLFxuICAgICAgICBldmVudDogJ3BpZXNlbGVjdGVkJyxcbiAgICAgICAgbWV0aG9kOiAnc2VsZWN0J1xuICAgIH0sIHtcbiAgICAgICAgdHlwZTogJ3BpZVVuU2VsZWN0JyxcbiAgICAgICAgZXZlbnQ6ICdwaWV1bnNlbGVjdGVkJyxcbiAgICAgICAgbWV0aG9kOiAndW5TZWxlY3QnXG4gICAgfV0pO1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlclZpc3VhbCh6clV0aWwuY3VycnkocmVxdWlyZSgnLi4vdmlzdWFsL2RhdGFDb2xvcicpLCAncGllJykpO1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlckxheW91dCh6clV0aWwuY3VycnkoXG4gICAgICAgIHJlcXVpcmUoJy4vcGllL3BpZUxheW91dCcpLCAncGllJ1xuICAgICkpO1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlclByb2Nlc3Nvcih6clV0aWwuY3VycnkocmVxdWlyZSgnLi4vcHJvY2Vzc29yL2RhdGFGaWx0ZXInKSwgJ3BpZScpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jaGFydC9waWUuanNcbi8vIG1vZHVsZSBpZCA9IDE4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var List = __webpack_require__(114);\n    var zrUtil = __webpack_require__(20);\n    var modelUtil = __webpack_require__(21);\n    var numberUtil = __webpack_require__(23);\n    var completeDimensions = __webpack_require__(126);\n\n    var dataSelectableMixin = __webpack_require__(183);\n\n    var PieSeries = __webpack_require__(17).extendSeriesModel({\n\n        type: 'series.pie',\n\n        // Overwrite\n        init: function (option) {\n            PieSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n\n            this.updateSelectedMap(option.data);\n\n            this._defaultLabelLine(option);\n        },\n\n        // Overwrite\n        mergeOption: function (newOption) {\n            PieSeries.superCall(this, 'mergeOption', newOption);\n            this.updateSelectedMap(this.option.data);\n        },\n\n        getInitialData: function (option, ecModel) {\n            var dimensions = completeDimensions(['value'], option.data);\n            var list = new List(dimensions, this);\n            list.initData(option.data);\n            return list;\n        },\n\n        // Overwrite\n        getDataParams: function (dataIndex) {\n            var data = this.getData();\n            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n            // FIXME toFixed?\n\n            var valueList = [];\n            data.each('value', function (value) {\n                valueList.push(value);\n            });\n\n            params.percent = numberUtil.getPercentWithPrecision(\n                valueList,\n                dataIndex,\n                data.hostModel.get('percentPrecision')\n            );\n\n            params.$vars.push('percent');\n            return params;\n        },\n\n        _defaultLabelLine: function (option) {\n            // Extend labelLine emphasis\n            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\n            var labelLineNormalOpt = option.labelLine.normal;\n            var labelLineEmphasisOpt = option.labelLine.emphasis;\n            // Not show label line if `label.normal.show = false`\n            labelLineNormalOpt.show = labelLineNormalOpt.show\n                && option.label.normal.show;\n            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n                && option.label.emphasis.show;\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // 默认全局居中\n            center: ['50%', '50%'],\n            radius: [0, '75%'],\n            // 默认顺时针\n            clockwise: true,\n            startAngle: 90,\n            // 最小角度改为0\n            minAngle: 0,\n            // 选中是扇区偏移量\n            selectedOffset: 10,\n\n            // If use strategy to avoid label overlapping\n            avoidLabelOverlap: true,\n            // 选择模式，默认关闭，可选single，multiple\n            // selectedMode: false,\n            // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）\n            // roseType: null,\n\n            percentPrecision: 2,\n\n            // If still show when all data zero.\n            stillShowZeroSum: true,\n\n            // cursor: null,\n\n            label: {\n                normal: {\n                    // If rotate around circle\n                    rotate: false,\n                    show: true,\n                    // 'outer', 'inside', 'center'\n                    position: 'outer'\n                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                    // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数\n                },\n                emphasis: {}\n            },\n            // Enabled when label.normal.position is 'outer'\n            labelLine: {\n                normal: {\n                    show: true,\n                    // 引导线两段中的第一段长度\n                    length: 15,\n                    // 引导线两段中的第二段长度\n                    length2: 15,\n                    smooth: false,\n                    lineStyle: {\n                        // color: 各异,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            },\n            itemStyle: {\n                normal: {\n                    borderWidth: 1\n                },\n                emphasis: {}\n            },\n\n            // Animation type canbe expansion, scale\n            animationType: 'expansion',\n\n            animationEasing: 'cubicOut',\n\n            data: []\n        }\n    });\n\n    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\n    module.exports = PieSeries;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L3BpZS9QaWVTZXJpZXMuanM/MmE1NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBIiwiZmlsZSI6IjE4Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIExpc3QgPSByZXF1aXJlKCcuLi8uLi9kYXRhL0xpc3QnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbnVtYmVyJyk7XG4gICAgdmFyIGNvbXBsZXRlRGltZW5zaW9ucyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9ucycpO1xuXG4gICAgdmFyIGRhdGFTZWxlY3RhYmxlTWl4aW4gPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnQvaGVscGVyL3NlbGVjdGFibGVNaXhpbicpO1xuXG4gICAgdmFyIFBpZVNlcmllcyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRTZXJpZXNNb2RlbCh7XG5cbiAgICAgICAgdHlwZTogJ3Nlcmllcy5waWUnLFxuXG4gICAgICAgIC8vIE92ZXJ3cml0ZVxuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICBQaWVTZXJpZXMuc3VwZXJBcHBseSh0aGlzLCAnaW5pdCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIC8vIEVuYWJsZSBsZWdlbmQgc2VsZWN0aW9uIGZvciBlYWNoIGRhdGEgaXRlbVxuICAgICAgICAgICAgLy8gVXNlIGEgZnVuY3Rpb24gaW5zdGVhZCBvZiBkaXJlY3QgYWNjZXNzIGJlY2F1c2UgZGF0YSByZWZlcmVuY2UgbWF5IGNoYW5nZWRcbiAgICAgICAgICAgIHRoaXMubGVnZW5kRGF0YVByb3ZpZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhd0RhdGEoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRNYXAob3B0aW9uLmRhdGEpO1xuXG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0TGFiZWxMaW5lKG9wdGlvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gT3ZlcndyaXRlXG4gICAgICAgIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAobmV3T3B0aW9uKSB7XG4gICAgICAgICAgICBQaWVTZXJpZXMuc3VwZXJDYWxsKHRoaXMsICdtZXJnZU9wdGlvbicsIG5ld09wdGlvbik7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkTWFwKHRoaXMub3B0aW9uLmRhdGEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEluaXRpYWxEYXRhOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGNvbXBsZXRlRGltZW5zaW9ucyhbJ3ZhbHVlJ10sIG9wdGlvbi5kYXRhKTtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gbmV3IExpc3QoZGltZW5zaW9ucywgdGhpcyk7XG4gICAgICAgICAgICBsaXN0LmluaXREYXRhKG9wdGlvbi5kYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE92ZXJ3cml0ZVxuICAgICAgICBnZXREYXRhUGFyYW1zOiBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFBpZVNlcmllcy5zdXBlckNhbGwodGhpcywgJ2dldERhdGFQYXJhbXMnLCBkYXRhSW5kZXgpO1xuICAgICAgICAgICAgLy8gRklYTUUgdG9GaXhlZD9cblxuICAgICAgICAgICAgdmFyIHZhbHVlTGlzdCA9IFtdO1xuICAgICAgICAgICAgZGF0YS5lYWNoKCd2YWx1ZScsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlTGlzdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwYXJhbXMucGVyY2VudCA9IG51bWJlclV0aWwuZ2V0UGVyY2VudFdpdGhQcmVjaXNpb24oXG4gICAgICAgICAgICAgICAgdmFsdWVMaXN0LFxuICAgICAgICAgICAgICAgIGRhdGFJbmRleCxcbiAgICAgICAgICAgICAgICBkYXRhLmhvc3RNb2RlbC5nZXQoJ3BlcmNlbnRQcmVjaXNpb24nKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcGFyYW1zLiR2YXJzLnB1c2goJ3BlcmNlbnQnKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RlZmF1bHRMYWJlbExpbmU6IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgIC8vIEV4dGVuZCBsYWJlbExpbmUgZW1waGFzaXNcbiAgICAgICAgICAgIG1vZGVsVXRpbC5kZWZhdWx0RW1waGFzaXMob3B0aW9uLmxhYmVsTGluZSwgWydzaG93J10pO1xuXG4gICAgICAgICAgICB2YXIgbGFiZWxMaW5lTm9ybWFsT3B0ID0gb3B0aW9uLmxhYmVsTGluZS5ub3JtYWw7XG4gICAgICAgICAgICB2YXIgbGFiZWxMaW5lRW1waGFzaXNPcHQgPSBvcHRpb24ubGFiZWxMaW5lLmVtcGhhc2lzO1xuICAgICAgICAgICAgLy8gTm90IHNob3cgbGFiZWwgbGluZSBpZiBgbGFiZWwubm9ybWFsLnNob3cgPSBmYWxzZWBcbiAgICAgICAgICAgIGxhYmVsTGluZU5vcm1hbE9wdC5zaG93ID0gbGFiZWxMaW5lTm9ybWFsT3B0LnNob3dcbiAgICAgICAgICAgICAgICAmJiBvcHRpb24ubGFiZWwubm9ybWFsLnNob3c7XG4gICAgICAgICAgICBsYWJlbExpbmVFbXBoYXNpc09wdC5zaG93ID0gbGFiZWxMaW5lRW1waGFzaXNPcHQuc2hvd1xuICAgICAgICAgICAgICAgICYmIG9wdGlvbi5sYWJlbC5lbXBoYXNpcy5zaG93O1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIHpsZXZlbDogMCxcbiAgICAgICAgICAgIHo6IDIsXG4gICAgICAgICAgICBsZWdlbmRIb3Zlckxpbms6IHRydWUsXG5cbiAgICAgICAgICAgIGhvdmVyQW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgLy8g6buY6K6k5YWo5bGA5bGF5LitXG4gICAgICAgICAgICBjZW50ZXI6IFsnNTAlJywgJzUwJSddLFxuICAgICAgICAgICAgcmFkaXVzOiBbMCwgJzc1JSddLFxuICAgICAgICAgICAgLy8g6buY6K6k6aG65pe26ZKIXG4gICAgICAgICAgICBjbG9ja3dpc2U6IHRydWUsXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiA5MCxcbiAgICAgICAgICAgIC8vIOacgOWwj+inkuW6puaUueS4ujBcbiAgICAgICAgICAgIG1pbkFuZ2xlOiAwLFxuICAgICAgICAgICAgLy8g6YCJ5Lit5piv5omH5Yy65YGP56e76YePXG4gICAgICAgICAgICBzZWxlY3RlZE9mZnNldDogMTAsXG5cbiAgICAgICAgICAgIC8vIElmIHVzZSBzdHJhdGVneSB0byBhdm9pZCBsYWJlbCBvdmVybGFwcGluZ1xuICAgICAgICAgICAgYXZvaWRMYWJlbE92ZXJsYXA6IHRydWUsXG4gICAgICAgICAgICAvLyDpgInmi6nmqKHlvI/vvIzpu5jorqTlhbPpl63vvIzlj6/pgIlzaW5nbGXvvIxtdWx0aXBsZVxuICAgICAgICAgICAgLy8gc2VsZWN0ZWRNb2RlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIOWNl+S4geagvOWwlOeOq+eRsOWbvuaooeW8j++8jCdyYWRpdXMn77yI5Y2K5b6E77yJIHwgJ2FyZWEn77yI6Z2i56ev77yJXG4gICAgICAgICAgICAvLyByb3NlVHlwZTogbnVsbCxcblxuICAgICAgICAgICAgcGVyY2VudFByZWNpc2lvbjogMixcblxuICAgICAgICAgICAgLy8gSWYgc3RpbGwgc2hvdyB3aGVuIGFsbCBkYXRhIHplcm8uXG4gICAgICAgICAgICBzdGlsbFNob3daZXJvU3VtOiB0cnVlLFxuXG4gICAgICAgICAgICAvLyBjdXJzb3I6IG51bGwsXG5cbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHJvdGF0ZSBhcm91bmQgY2lyY2xlXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIC8vICdvdXRlcicsICdpbnNpZGUnLCAnY2VudGVyJ1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ291dGVyJ1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3JtYXR0ZXI6IOagh+etvuaWh+acrOagvOW8j+WZqO+8jOWQjFRvb2x0aXAuZm9ybWF0dGVy77yM5LiN5pSv5oyB5byC5q2l5Zue6LCDXG4gICAgICAgICAgICAgICAgICAgIC8vIHRleHRTdHlsZTogbnVsbCAgICAgIC8vIOm7mOiupOS9v+eUqOWFqOWxgOaWh+acrOagt+W8j++8jOivpuingVRFWFRTVFlMRVxuICAgICAgICAgICAgICAgICAgICAvLyBkaXN0YW5jZTog5b2TcG9zaXRpb27kuLppbm5lcuaXtuacieaViO+8jOS4umxhYmVs5L2N572u5Yiw5ZyG5b+D55qE6Led56a75LiO5ZyG5Y2K5b6EKOeOr+eKtuWbvuS4uuWGheWkluWNiuW+hOWSjCnnmoTmr5Tkvovns7vmlbBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVtcGhhc2lzOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIEVuYWJsZWQgd2hlbiBsYWJlbC5ub3JtYWwucG9zaXRpb24gaXMgJ291dGVyJ1xuICAgICAgICAgICAgbGFiZWxMaW5lOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIOW8leWvvOe6v+S4pOauteS4reeahOesrOS4gOautemVv+W6plxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IDE1LFxuICAgICAgICAgICAgICAgICAgICAvLyDlvJXlr7znur/kuKTmrrXkuK3nmoTnrKzkuozmrrXplb/luqZcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMjogMTUsXG4gICAgICAgICAgICAgICAgICAgIHNtb290aDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29sb3I6IOWQhOW8gixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW1waGFzaXM6IHt9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBBbmltYXRpb24gdHlwZSBjYW5iZSBleHBhbnNpb24sIHNjYWxlXG4gICAgICAgICAgICBhbmltYXRpb25UeXBlOiAnZXhwYW5zaW9uJyxcblxuICAgICAgICAgICAgYW5pbWF0aW9uRWFzaW5nOiAnY3ViaWNPdXQnLFxuXG4gICAgICAgICAgICBkYXRhOiBbXVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB6clV0aWwubWl4aW4oUGllU2VyaWVzLCBkYXRhU2VsZWN0YWJsZU1peGluKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUGllU2VyaWVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NoYXJ0L3BpZS9QaWVTZXJpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n *\n * @module echarts/chart/helper/DataSelectable\n */\n\n\n    var zrUtil = __webpack_require__(20);\n\n    module.exports = {\n\n        updateSelectedMap: function (targetList) {\n            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n                targetMap.set(target.name, target);\n                return targetMap;\n            }, zrUtil.createHashMap());\n        },\n        /**\n         * @param {string} name\n         */\n        // PENGING If selectedMode is null ?\n        select: function (name) {\n            var targetMap = this._selectTargetMap;\n            var target = targetMap.get(name);\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                targetMap.each(function (target) {\n                    target.selected = false;\n                });\n            }\n            target && (target.selected = true);\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            var target = this._selectTargetMap.get(name);\n            // var selectedMode = this.get('selectedMode');\n            // selectedMode !== 'single' && target && (target.selected = false);\n            target && (target.selected = false);\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var target = this._selectTargetMap.get(name);\n            if (target != null) {\n                this[target.selected ? 'unSelect' : 'select'](name);\n                return target.selected;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var target = this._selectTargetMap.get(name);\n            return target && target.selected;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvc2VsZWN0YWJsZU1peGluLmpzP2FkNzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTgzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEYXRhIHNlbGVjdGFibGUgbWl4aW4gZm9yIGNoYXJ0IHNlcmllcy5cbiAqIFRvIGVhbmJsZSBkYXRhIHNlbGVjdCwgb3B0aW9uIG9mIHNlcmllcyBtdXN0IGhhdmUgYHNlbGVjdGVkTW9kZWAuXG4gKiBBbmQgZWFjaCBkYXRhIGl0ZW0gd2lsbCB1c2UgYHNlbGVjdGVkYCB0byB0b2dnbGUgaXRzZWxmIHNlbGVjdGVkIHN0YXR1c1xuICpcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jaGFydC9oZWxwZXIvRGF0YVNlbGVjdGFibGVcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICB1cGRhdGVTZWxlY3RlZE1hcDogZnVuY3Rpb24gKHRhcmdldExpc3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdFRhcmdldE1hcCA9IHpyVXRpbC5yZWR1Y2UodGFyZ2V0TGlzdCB8fCBbXSwgZnVuY3Rpb24gKHRhcmdldE1hcCwgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQubmFtZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0TWFwO1xuICAgICAgICAgICAgfSwgenJVdGlsLmNyZWF0ZUhhc2hNYXAoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gUEVOR0lORyBJZiBzZWxlY3RlZE1vZGUgaXMgbnVsbCA/XG4gICAgICAgIHNlbGVjdDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRNYXAgPSB0aGlzLl9zZWxlY3RUYXJnZXRNYXA7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0TWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZE1vZGUgPSB0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJyk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRNb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgICAgIHRhcmdldE1hcC5lYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQgJiYgKHRhcmdldC5zZWxlY3RlZCA9IHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgdW5TZWxlY3Q6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fc2VsZWN0VGFyZ2V0TWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgIC8vIHZhciBzZWxlY3RlZE1vZGUgPSB0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJyk7XG4gICAgICAgICAgICAvLyBzZWxlY3RlZE1vZGUgIT09ICdzaW5nbGUnICYmIHRhcmdldCAmJiAodGFyZ2V0LnNlbGVjdGVkID0gZmFsc2UpO1xuICAgICAgICAgICAgdGFyZ2V0ICYmICh0YXJnZXQuc2VsZWN0ZWQgPSBmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICB0b2dnbGVTZWxlY3RlZDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9zZWxlY3RUYXJnZXRNYXAuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0YXJnZXQuc2VsZWN0ZWQgPyAndW5TZWxlY3QnIDogJ3NlbGVjdCddKG5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuc2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3NlbGVjdFRhcmdldE1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0ICYmIHRhcmdldC5zZWxlY3RlZDtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9zZWxlY3RhYmxlTWl4aW4uanNcbi8vIG1vZHVsZSBpZCA9IDE4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n\n    var graphic = __webpack_require__(34);\n    var zrUtil = __webpack_require__(20);\n\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n        var data = seriesModel.getData();\n        var dataIndex = this.dataIndex;\n        var name = data.getName(dataIndex);\n        var selectedOffset = seriesModel.get('selectedOffset');\n\n        api.dispatchAction({\n            type: 'pieToggleSelect',\n            from: uid,\n            name: name,\n            seriesId: seriesModel.id\n        });\n\n        data.each(function (idx) {\n            toggleItemSelected(\n                data.getItemGraphicEl(idx),\n                data.getItemLayout(idx),\n                seriesModel.isSelected(data.getName(idx)),\n                selectedOffset,\n                hasAnimation\n            );\n        });\n    }\n\n    /**\n     * @param {module:zrender/graphic/Sector} el\n     * @param {Object} layout\n     * @param {boolean} isSelected\n     * @param {number} selectedOffset\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n\n        var offset = isSelected ? selectedOffset : 0;\n        var position = [dx * offset, dy * offset];\n\n        hasAnimation\n            // animateTo will stop revious animation like update transition\n            ? el.animate()\n                .when(200, {\n                    position: position\n                })\n                .start('bounceOut')\n            : el.attr('position', position);\n    }\n\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function PiePiece(data, idx) {\n\n        graphic.Group.call(this);\n\n        var sector = new graphic.Sector({\n            z2: 2\n        });\n        var polyline = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(sector);\n        this.add(polyline);\n        this.add(text);\n\n        this.updateData(data, idx, true);\n\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            polyline.ignore = polyline.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            polyline.ignore = polyline.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis)\n            .on('normal', onNormal)\n            .on('mouseover', onEmphasis)\n            .on('mouseout', onNormal);\n    }\n\n    var piePieceProto = PiePiece.prototype;\n\n    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n        return {\n            fill: textStyleModel.getTextColor()\n                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            opacity: data.getItemVisual(idx, 'opacity'),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(\n                data.hostModel.getFormattedLabel(idx, state), data.getName(idx)\n            )\n        };\n    }\n\n    piePieceProto.updateData = function (data, idx, firstCreate) {\n\n        var sector = this.childAt(0);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var sectorShape = zrUtil.extend({}, layout);\n        sectorShape.label = null;\n\n        if (firstCreate) {\n            sector.setShape(sectorShape);\n\n            var animationType = seriesModel.getShallow('animationType');\n            if (animationType === 'scale') {\n                sector.shape.r = layout.r0;\n                graphic.initProps(sector, {\n                    shape: {\n                        r: layout.r\n                    }\n                }, seriesModel, idx);\n            }\n            // Expansion\n            else {\n                sector.shape.endAngle = layout.startAngle;\n                graphic.updateProps(sector, {\n                    shape: {\n                        endAngle: layout.endAngle\n                    }\n                }, seriesModel, idx);\n            }\n\n        }\n        else {\n            graphic.updateProps(sector, {\n                shape: sectorShape\n            }, seriesModel, idx);\n        }\n\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        sector.useStyle(\n            zrUtil.defaults(\n                {\n                    lineJoin: 'bevel',\n                    fill: visualColor\n                },\n                itemStyleModel.getModel('normal').getItemStyle()\n            )\n        );\n        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n        var cursorStyle = itemModel.getShallow('cursor');\n        cursorStyle && sector.attr('cursor', cursorStyle);\n\n        // Toggle selected\n        toggleItemSelected(\n            this,\n            data.getItemLayout(idx),\n            itemModel.get('selected'),\n            seriesModel.get('selectedOffset'),\n            seriesModel.get('animation')\n        );\n\n        function onEmphasis() {\n            // Sector may has animation of updating data. Force to move to the last frame\n            // Or it may stopped on the wrong shape\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r + 10\n                }\n            }, 300, 'elasticOut');\n        }\n        function onNormal() {\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r\n                }\n            }, 300, 'elasticOut');\n        }\n        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n        if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n            sector\n                .on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n\n        this._updateLabel(data, idx);\n\n        graphic.setHoverStyle(this);\n    };\n\n    piePieceProto._updateLabel = function (data, idx) {\n\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || [\n                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n                ]\n            }\n        }, seriesModel, idx);\n\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textVerticalAlign: labelLayout.verticalAlign,\n                textAlign: labelLayout.textAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [labelLayout.x, labelLayout.y],\n            z2: 10\n        });\n\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor,\n            opacity: data.getItemVisual(idx, 'opacity')\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\n        var smooth = labelLineModel.get('smooth');\n        if (smooth && smooth === true) {\n            smooth = 0.4;\n        }\n        labelLine.setShape({\n            smooth: smooth\n        });\n    };\n\n    zrUtil.inherits(PiePiece, graphic.Group);\n\n\n    // Pie view\n    var Pie = __webpack_require__(96).extend({\n\n        type: 'pie',\n\n        init: function () {\n            var sectorGroup = new graphic.Group();\n            this._sectorGroup = sectorGroup;\n        },\n\n        render: function (seriesModel, ecModel, api, payload) {\n            if (payload && (payload.from === this.uid)) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n            var group = this.group;\n\n            var hasAnimation = ecModel.get('animation');\n            var isFirstRender = !oldData;\n            var animationType = seriesModel.get('animationType');\n\n            var onSectorClick = zrUtil.curry(\n                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n            );\n\n            var selectedMode = seriesModel.get('selectedMode');\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var piePiece = new PiePiece(data, idx);\n                    // Default expansion animation\n                    if (isFirstRender && animationType !== 'scale') {\n                        piePiece.eachChild(function (child) {\n                            child.stopAnimation(true);\n                        });\n                    }\n\n                    selectedMode && piePiece.on('click', onSectorClick);\n\n                    data.setItemGraphicEl(idx, piePiece);\n\n                    group.add(piePiece);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                    piePiece.updateData(data, newIdx);\n\n                    piePiece.off('click');\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                })\n                .remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                })\n                .execute();\n\n            if (\n                hasAnimation && isFirstRender && data.count() > 0\n                // Default expansion animation\n                && animationType !== 'scale'\n            ) {\n                var shape = data.getItemLayout(0);\n                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\n                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n                group.setClipPath(this._createClipPath(\n                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n                ));\n            }\n\n            this._data = data;\n        },\n\n        dispose: function () {},\n\n        _createClipPath: function (\n            cx, cy, r, startAngle, clockwise, cb, seriesModel\n        ) {\n            var clipPath = new graphic.Sector({\n                shape: {\n                    cx: cx,\n                    cy: cy,\n                    r0: 0,\n                    r: r,\n                    startAngle: startAngle,\n                    endAngle: startAngle,\n                    clockwise: clockwise\n                }\n            });\n\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n                }\n            }, seriesModel, cb);\n\n            return clipPath;\n        },\n\n        /**\n         * @implement\n         */\n        containPoint: function (point, seriesModel) {\n            var data = seriesModel.getData();\n            var itemLayout = data.getItemLayout(0);\n            if (itemLayout) {\n                var dx = point[0] - itemLayout.cx;\n                var dy = point[1] - itemLayout.cy;\n                var radius = Math.sqrt(dx * dx + dy * dy);\n                return radius <= itemLayout.r && radius >= itemLayout.r0;\n            }\n        }\n\n    });\n\n    module.exports = Pie;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L3BpZS9QaWVWaWV3LmpzP2MwODIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0MsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QyxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVCwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUwiLCJmaWxlIjoiMTg0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzQW5pbWF0aW9uXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlRGF0YVNlbGVjdGVkKHVpZCwgc2VyaWVzTW9kZWwsIGhhc0FuaW1hdGlvbiwgYXBpKSB7XG4gICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICB2YXIgZGF0YUluZGV4ID0gdGhpcy5kYXRhSW5kZXg7XG4gICAgICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCk7XG4gICAgICAgIHZhciBzZWxlY3RlZE9mZnNldCA9IHNlcmllc01vZGVsLmdldCgnc2VsZWN0ZWRPZmZzZXQnKTtcblxuICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgdHlwZTogJ3BpZVRvZ2dsZVNlbGVjdCcsXG4gICAgICAgICAgICBmcm9tOiB1aWQsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgc2VyaWVzSWQ6IHNlcmllc01vZGVsLmlkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICB0b2dnbGVJdGVtU2VsZWN0ZWQoXG4gICAgICAgICAgICAgICAgZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGlkeCksXG4gICAgICAgICAgICAgICAgZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCksXG4gICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuaXNTZWxlY3RlZChkYXRhLmdldE5hbWUoaWR4KSksXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRPZmZzZXQsXG4gICAgICAgICAgICAgICAgaGFzQW5pbWF0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU2VjdG9yfSBlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsYXlvdXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2VsZWN0ZWRPZmZzZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc0FuaW1hdGlvblxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvZ2dsZUl0ZW1TZWxlY3RlZChlbCwgbGF5b3V0LCBpc1NlbGVjdGVkLCBzZWxlY3RlZE9mZnNldCwgaGFzQW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciBtaWRBbmdsZSA9IChsYXlvdXQuc3RhcnRBbmdsZSArIGxheW91dC5lbmRBbmdsZSkgLyAyO1xuXG4gICAgICAgIHZhciBkeCA9IE1hdGguY29zKG1pZEFuZ2xlKTtcbiAgICAgICAgdmFyIGR5ID0gTWF0aC5zaW4obWlkQW5nbGUpO1xuXG4gICAgICAgIHZhciBvZmZzZXQgPSBpc1NlbGVjdGVkID8gc2VsZWN0ZWRPZmZzZXQgOiAwO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBbZHggKiBvZmZzZXQsIGR5ICogb2Zmc2V0XTtcblxuICAgICAgICBoYXNBbmltYXRpb25cbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyB3aWxsIHN0b3AgcmV2aW91cyBhbmltYXRpb24gbGlrZSB1cGRhdGUgdHJhbnNpdGlvblxuICAgICAgICAgICAgPyBlbC5hbmltYXRlKClcbiAgICAgICAgICAgICAgICAud2hlbigyMDAsIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuc3RhcnQoJ2JvdW5jZU91dCcpXG4gICAgICAgICAgICA6IGVsLmF0dHIoJ3Bvc2l0aW9uJywgcG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBpZWNlIG9mIHBpZSBpbmNsdWRpbmcgU2VjdG9yLCBMYWJlbCwgTGFiZWxMaW5lXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gUGllUGllY2UoZGF0YSwgaWR4KSB7XG5cbiAgICAgICAgZ3JhcGhpYy5Hcm91cC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHZhciBzZWN0b3IgPSBuZXcgZ3JhcGhpYy5TZWN0b3Ioe1xuICAgICAgICAgICAgejI6IDJcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwb2x5bGluZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKCk7XG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCgpO1xuICAgICAgICB0aGlzLmFkZChzZWN0b3IpO1xuICAgICAgICB0aGlzLmFkZChwb2x5bGluZSk7XG4gICAgICAgIHRoaXMuYWRkKHRleHQpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRGF0YShkYXRhLCBpZHgsIHRydWUpO1xuXG4gICAgICAgIC8vIEhvdmVyIHRvIGNoYW5nZSBsYWJlbCBhbmQgbGFiZWxMaW5lXG4gICAgICAgIGZ1bmN0aW9uIG9uRW1waGFzaXMoKSB7XG4gICAgICAgICAgICBwb2x5bGluZS5pZ25vcmUgPSBwb2x5bGluZS5ob3Zlcklnbm9yZTtcbiAgICAgICAgICAgIHRleHQuaWdub3JlID0gdGV4dC5ob3Zlcklnbm9yZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbk5vcm1hbCgpIHtcbiAgICAgICAgICAgIHBvbHlsaW5lLmlnbm9yZSA9IHBvbHlsaW5lLm5vcm1hbElnbm9yZTtcbiAgICAgICAgICAgIHRleHQuaWdub3JlID0gdGV4dC5ub3JtYWxJZ25vcmU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbignZW1waGFzaXMnLCBvbkVtcGhhc2lzKVxuICAgICAgICAgICAgLm9uKCdub3JtYWwnLCBvbk5vcm1hbClcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgb25FbXBoYXNpcylcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBvbk5vcm1hbCk7XG4gICAgfVxuXG4gICAgdmFyIHBpZVBpZWNlUHJvdG8gPSBQaWVQaWVjZS5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBnZXRMYWJlbFN0eWxlKGRhdGEsIGlkeCwgc3RhdGUsIGxhYmVsTW9kZWwsIGxhYmVsUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gbGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgICAgIHZhciBpc0xhYmVsSW5zaWRlID0gbGFiZWxQb3NpdGlvbiA9PT0gJ2luc2lkZScgfHwgbGFiZWxQb3NpdGlvbiA9PT0gJ2lubmVyJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpbGw6IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpXG4gICAgICAgICAgICAgICAgfHwgKGlzTGFiZWxJbnNpZGUgPyAnI2ZmZicgOiBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKSksXG4gICAgICAgICAgICBvcGFjaXR5OiBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnb3BhY2l0eScpLFxuICAgICAgICAgICAgdGV4dEZvbnQ6IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcbiAgICAgICAgICAgIHRleHQ6IHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICBkYXRhLmhvc3RNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChpZHgsIHN0YXRlKSwgZGF0YS5nZXROYW1lKGlkeClcbiAgICAgICAgICAgIClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwaWVQaWVjZVByb3RvLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgaWR4LCBmaXJzdENyZWF0ZSkge1xuXG4gICAgICAgIHZhciBzZWN0b3IgPSB0aGlzLmNoaWxkQXQoMCk7XG5cbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgICB2YXIgbGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgICAgIHZhciBzZWN0b3JTaGFwZSA9IHpyVXRpbC5leHRlbmQoe30sIGxheW91dCk7XG4gICAgICAgIHNlY3RvclNoYXBlLmxhYmVsID0gbnVsbDtcblxuICAgICAgICBpZiAoZmlyc3RDcmVhdGUpIHtcbiAgICAgICAgICAgIHNlY3Rvci5zZXRTaGFwZShzZWN0b3JTaGFwZSk7XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRpb25UeXBlID0gc2VyaWVzTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uVHlwZScpO1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvblR5cGUgPT09ICdzY2FsZScpIHtcbiAgICAgICAgICAgICAgICBzZWN0b3Iuc2hhcGUuciA9IGxheW91dC5yMDtcbiAgICAgICAgICAgICAgICBncmFwaGljLmluaXRQcm9wcyhzZWN0b3IsIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHI6IGxheW91dC5yXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4cGFuc2lvblxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VjdG9yLnNoYXBlLmVuZEFuZ2xlID0gbGF5b3V0LnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhzZWN0b3IsIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBsYXlvdXQuZW5kQW5nbGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHNlY3Rvciwge1xuICAgICAgICAgICAgICAgIHNoYXBlOiBzZWN0b3JTaGFwZVxuICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgY29tbW9uIHN0eWxlXG4gICAgICAgIHZhciBpdGVtU3R5bGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJyk7XG4gICAgICAgIHZhciB2aXN1YWxDb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuXG4gICAgICAgIHNlY3Rvci51c2VTdHlsZShcbiAgICAgICAgICAgIHpyVXRpbC5kZWZhdWx0cyhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVKb2luOiAnYmV2ZWwnLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiB2aXN1YWxDb2xvclxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlTW9kZWwuZ2V0TW9kZWwoJ25vcm1hbCcpLmdldEl0ZW1TdHlsZSgpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIHNlY3Rvci5ob3ZlclN0eWxlID0gaXRlbVN0eWxlTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJykuZ2V0SXRlbVN0eWxlKCk7XG5cbiAgICAgICAgdmFyIGN1cnNvclN0eWxlID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ2N1cnNvcicpO1xuICAgICAgICBjdXJzb3JTdHlsZSAmJiBzZWN0b3IuYXR0cignY3Vyc29yJywgY3Vyc29yU3R5bGUpO1xuXG4gICAgICAgIC8vIFRvZ2dsZSBzZWxlY3RlZFxuICAgICAgICB0b2dnbGVJdGVtU2VsZWN0ZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCksXG4gICAgICAgICAgICBpdGVtTW9kZWwuZ2V0KCdzZWxlY3RlZCcpLFxuICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCdzZWxlY3RlZE9mZnNldCcpLFxuICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCdhbmltYXRpb24nKVxuICAgICAgICApO1xuXG4gICAgICAgIGZ1bmN0aW9uIG9uRW1waGFzaXMoKSB7XG4gICAgICAgICAgICAvLyBTZWN0b3IgbWF5IGhhcyBhbmltYXRpb24gb2YgdXBkYXRpbmcgZGF0YS4gRm9yY2UgdG8gbW92ZSB0byB0aGUgbGFzdCBmcmFtZVxuICAgICAgICAgICAgLy8gT3IgaXQgbWF5IHN0b3BwZWQgb24gdGhlIHdyb25nIHNoYXBlXG4gICAgICAgICAgICBzZWN0b3Iuc3RvcEFuaW1hdGlvbih0cnVlKTtcbiAgICAgICAgICAgIHNlY3Rvci5hbmltYXRlVG8oe1xuICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIHI6IGxheW91dC5yICsgMTBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAzMDAsICdlbGFzdGljT3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Ob3JtYWwoKSB7XG4gICAgICAgICAgICBzZWN0b3Iuc3RvcEFuaW1hdGlvbih0cnVlKTtcbiAgICAgICAgICAgIHNlY3Rvci5hbmltYXRlVG8oe1xuICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIHI6IGxheW91dC5yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMzAwLCAnZWxhc3RpY091dCcpO1xuICAgICAgICB9XG4gICAgICAgIHNlY3Rvci5vZmYoJ21vdXNlb3ZlcicpLm9mZignbW91c2VvdXQnKS5vZmYoJ2VtcGhhc2lzJykub2ZmKCdub3JtYWwnKTtcbiAgICAgICAgaWYgKGl0ZW1Nb2RlbC5nZXQoJ2hvdmVyQW5pbWF0aW9uJykgJiYgc2VyaWVzTW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHNlY3RvclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgb25FbXBoYXNpcylcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0Jywgb25Ob3JtYWwpXG4gICAgICAgICAgICAgICAgLm9uKCdlbXBoYXNpcycsIG9uRW1waGFzaXMpXG4gICAgICAgICAgICAgICAgLm9uKCdub3JtYWwnLCBvbk5vcm1hbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVMYWJlbChkYXRhLCBpZHgpO1xuXG4gICAgICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgcGllUGllY2VQcm90by5fdXBkYXRlTGFiZWwgPSBmdW5jdGlvbiAoZGF0YSwgaWR4KSB7XG5cbiAgICAgICAgdmFyIGxhYmVsTGluZSA9IHRoaXMuY2hpbGRBdCgxKTtcbiAgICAgICAgdmFyIGxhYmVsVGV4dCA9IHRoaXMuY2hpbGRBdCgyKTtcblxuICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICAgICAgdmFyIGxhYmVsTGF5b3V0ID0gbGF5b3V0LmxhYmVsO1xuICAgICAgICB2YXIgdmlzdWFsQ29sb3IgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKTtcblxuICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGxhYmVsTGluZSwge1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICBwb2ludHM6IGxhYmVsTGF5b3V0LmxpbmVQb2ludHMgfHwgW1xuICAgICAgICAgICAgICAgICAgICBbbGFiZWxMYXlvdXQueCwgbGFiZWxMYXlvdXQueV0sIFtsYWJlbExheW91dC54LCBsYWJlbExheW91dC55XSwgW2xhYmVsTGF5b3V0LngsIGxhYmVsTGF5b3V0LnldXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcblxuICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGxhYmVsVGV4dCwge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICB4OiBsYWJlbExheW91dC54LFxuICAgICAgICAgICAgICAgIHk6IGxhYmVsTGF5b3V0LnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgICAgIGxhYmVsVGV4dC5hdHRyKHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IGxhYmVsTGF5b3V0LnZlcnRpY2FsQWxpZ24sXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiBsYWJlbExheW91dC50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6IGxhYmVsTGF5b3V0LmZvbnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByb3RhdGlvbjogbGFiZWxMYXlvdXQucm90YXRpb24sXG4gICAgICAgICAgICBvcmlnaW46IFtsYWJlbExheW91dC54LCBsYWJlbExheW91dC55XSxcbiAgICAgICAgICAgIHoyOiAxMFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwubm9ybWFsJyk7XG4gICAgICAgIHZhciBsYWJlbEhvdmVyTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLmVtcGhhc2lzJyk7XG4gICAgICAgIHZhciBsYWJlbExpbmVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWxMaW5lLm5vcm1hbCcpO1xuICAgICAgICB2YXIgbGFiZWxMaW5lSG92ZXJNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWxMaW5lLmVtcGhhc2lzJyk7XG4gICAgICAgIHZhciBsYWJlbFBvc2l0aW9uID0gbGFiZWxNb2RlbC5nZXQoJ3Bvc2l0aW9uJykgfHwgbGFiZWxIb3Zlck1vZGVsLmdldCgncG9zaXRpb24nKTtcblxuICAgICAgICBsYWJlbFRleHQuc2V0U3R5bGUoZ2V0TGFiZWxTdHlsZShkYXRhLCBpZHgsICdub3JtYWwnLCBsYWJlbE1vZGVsLCBsYWJlbFBvc2l0aW9uKSk7XG5cbiAgICAgICAgbGFiZWxUZXh0Lmlnbm9yZSA9IGxhYmVsVGV4dC5ub3JtYWxJZ25vcmUgPSAhbGFiZWxNb2RlbC5nZXQoJ3Nob3cnKTtcbiAgICAgICAgbGFiZWxUZXh0LmhvdmVySWdub3JlID0gIWxhYmVsSG92ZXJNb2RlbC5nZXQoJ3Nob3cnKTtcblxuICAgICAgICBsYWJlbExpbmUuaWdub3JlID0gbGFiZWxMaW5lLm5vcm1hbElnbm9yZSA9ICFsYWJlbExpbmVNb2RlbC5nZXQoJ3Nob3cnKTtcbiAgICAgICAgbGFiZWxMaW5lLmhvdmVySWdub3JlID0gIWxhYmVsTGluZUhvdmVyTW9kZWwuZ2V0KCdzaG93Jyk7XG5cbiAgICAgICAgLy8gRGVmYXVsdCB1c2UgaXRlbSB2aXN1YWwgY29sb3JcbiAgICAgICAgbGFiZWxMaW5lLnNldFN0eWxlKHtcbiAgICAgICAgICAgIHN0cm9rZTogdmlzdWFsQ29sb3IsXG4gICAgICAgICAgICBvcGFjaXR5OiBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnb3BhY2l0eScpXG4gICAgICAgIH0pO1xuICAgICAgICBsYWJlbExpbmUuc2V0U3R5bGUobGFiZWxMaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpKTtcblxuICAgICAgICBsYWJlbFRleHQuaG92ZXJTdHlsZSA9IGdldExhYmVsU3R5bGUoZGF0YSwgaWR4LCAnZW1waGFzaXMnLCBsYWJlbEhvdmVyTW9kZWwsIGxhYmVsUG9zaXRpb24pO1xuICAgICAgICBsYWJlbExpbmUuaG92ZXJTdHlsZSA9IGxhYmVsTGluZUhvdmVyTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpO1xuXG4gICAgICAgIHZhciBzbW9vdGggPSBsYWJlbExpbmVNb2RlbC5nZXQoJ3Ntb290aCcpO1xuICAgICAgICBpZiAoc21vb3RoICYmIHNtb290aCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc21vb3RoID0gMC40O1xuICAgICAgICB9XG4gICAgICAgIGxhYmVsTGluZS5zZXRTaGFwZSh7XG4gICAgICAgICAgICBzbW9vdGg6IHNtb290aFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKFBpZVBpZWNlLCBncmFwaGljLkdyb3VwKTtcblxuXG4gICAgLy8gUGllIHZpZXdcbiAgICB2YXIgUGllID0gcmVxdWlyZSgnLi4vLi4vdmlldy9DaGFydCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3BpZScsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlY3Rvckdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICAgICAgICAgIHRoaXMuX3NlY3Rvckdyb3VwID0gc2VjdG9yR3JvdXA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQgJiYgKHBheWxvYWQuZnJvbSA9PT0gdGhpcy51aWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG5cbiAgICAgICAgICAgIHZhciBoYXNBbmltYXRpb24gPSBlY01vZGVsLmdldCgnYW5pbWF0aW9uJyk7XG4gICAgICAgICAgICB2YXIgaXNGaXJzdFJlbmRlciA9ICFvbGREYXRhO1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvblR5cGUgPSBzZXJpZXNNb2RlbC5nZXQoJ2FuaW1hdGlvblR5cGUnKTtcblxuICAgICAgICAgICAgdmFyIG9uU2VjdG9yQ2xpY2sgPSB6clV0aWwuY3VycnkoXG4gICAgICAgICAgICAgICAgdXBkYXRlRGF0YVNlbGVjdGVkLCB0aGlzLnVpZCwgc2VyaWVzTW9kZWwsIGhhc0FuaW1hdGlvbiwgYXBpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRNb2RlID0gc2VyaWVzTW9kZWwuZ2V0KCdzZWxlY3RlZE1vZGUnKTtcblxuICAgICAgICAgICAgZGF0YS5kaWZmKG9sZERhdGEpXG4gICAgICAgICAgICAgICAgLmFkZChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwaWVQaWVjZSA9IG5ldyBQaWVQaWVjZShkYXRhLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGV4cGFuc2lvbiBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRmlyc3RSZW5kZXIgJiYgYW5pbWF0aW9uVHlwZSAhPT0gJ3NjYWxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGllUGllY2UuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnN0b3BBbmltYXRpb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkTW9kZSAmJiBwaWVQaWVjZS5vbignY2xpY2snLCBvblNlY3RvckNsaWNrKTtcblxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoaWR4LCBwaWVQaWVjZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKHBpZVBpZWNlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwaWVQaWVjZSA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBpZVBpZWNlLnVwZGF0ZURhdGEoZGF0YSwgbmV3SWR4KTtcblxuICAgICAgICAgICAgICAgICAgICBwaWVQaWVjZS5vZmYoJ2NsaWNrJyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkTW9kZSAmJiBwaWVQaWVjZS5vbignY2xpY2snLCBvblNlY3RvckNsaWNrKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKHBpZVBpZWNlKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgcGllUGllY2UpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlbW92ZShmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwaWVQaWVjZSA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChpZHgpO1xuICAgICAgICAgICAgICAgICAgICBncm91cC5yZW1vdmUocGllUGllY2UpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmV4ZWN1dGUoKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGhhc0FuaW1hdGlvbiAmJiBpc0ZpcnN0UmVuZGVyICYmIGRhdGEuY291bnQoKSA+IDBcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGV4cGFuc2lvbiBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAmJiBhbmltYXRpb25UeXBlICE9PSAnc2NhbGUnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBkYXRhLmdldEl0ZW1MYXlvdXQoMCk7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBNYXRoLm1heChhcGkuZ2V0V2lkdGgoKSwgYXBpLmdldEhlaWdodCgpKSAvIDI7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlQ2xpcFBhdGggPSB6clV0aWwuYmluZChncm91cC5yZW1vdmVDbGlwUGF0aCwgZ3JvdXApO1xuICAgICAgICAgICAgICAgIGdyb3VwLnNldENsaXBQYXRoKHRoaXMuX2NyZWF0ZUNsaXBQYXRoKFxuICAgICAgICAgICAgICAgICAgICBzaGFwZS5jeCwgc2hhcGUuY3ksIHIsIHNoYXBlLnN0YXJ0QW5nbGUsIHNoYXBlLmNsb2Nrd2lzZSwgcmVtb3ZlQ2xpcFBhdGgsIHNlcmllc01vZGVsXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgIF9jcmVhdGVDbGlwUGF0aDogZnVuY3Rpb24gKFxuICAgICAgICAgICAgY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBjbG9ja3dpc2UsIGNiLCBzZXJpZXNNb2RlbFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBjbGlwUGF0aCA9IG5ldyBncmFwaGljLlNlY3Rvcih7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgY3g6IGN4LFxuICAgICAgICAgICAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgICAgICAgICAgIHIwOiAwLFxuICAgICAgICAgICAgICAgICAgICByOiByLFxuICAgICAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgY2xvY2t3aXNlOiBjbG9ja3dpc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZ3JhcGhpYy5pbml0UHJvcHMoY2xpcFBhdGgsIHtcbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZTogc3RhcnRBbmdsZSArIChjbG9ja3dpc2UgPyAxIDogLTEpICogTWF0aC5QSSAqIDJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCwgY2IpO1xuXG4gICAgICAgICAgICByZXR1cm4gY2xpcFBhdGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbXBsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5Qb2ludDogZnVuY3Rpb24gKHBvaW50LCBzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB2YXIgaXRlbUxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dCgwKTtcbiAgICAgICAgICAgIGlmIChpdGVtTGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGR4ID0gcG9pbnRbMF0gLSBpdGVtTGF5b3V0LmN4O1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IHBvaW50WzFdIC0gaXRlbUxheW91dC5jeTtcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFkaXVzIDw9IGl0ZW1MYXlvdXQuciAmJiByYWRpdXMgPj0gaXRlbUxheW91dC5yMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBpZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jaGFydC9waWUvUGllVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("\n    var echarts = __webpack_require__(17);\n    var zrUtil = __webpack_require__(20);\n    module.exports = function (seriesType, actionInfos) {\n        zrUtil.each(actionInfos, function (actionInfo) {\n            actionInfo.update = 'updateView';\n            /**\n             * @payload\n             * @property {string} seriesName\n             * @property {string} name\n             */\n            echarts.registerAction(actionInfo, function (payload, ecModel) {\n                var selected = {};\n                ecModel.eachComponent(\n                    {mainType: 'series', subType: seriesType, query: payload},\n                    function (seriesModel) {\n                        if (seriesModel[actionInfo.method]) {\n                            seriesModel[actionInfo.method](payload.name);\n                        }\n                        var data = seriesModel.getData();\n                        // Create selected map\n                        data.each(function (idx) {\n                            var name = data.getName(idx);\n                            selected[name] = seriesModel.isSelected(name) || false;\n                        });\n                    }\n                );\n                return {\n                    name: payload.name,\n                    selected: selected\n                };\n            });\n        });\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2FjdGlvbi9jcmVhdGVEYXRhU2VsZWN0QWN0aW9uLmpzPzJjMmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakMsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQXdEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUIiwiZmlsZSI6IjE4NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vZWNoYXJ0cycpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBhY3Rpb25JbmZvcykge1xuICAgICAgICB6clV0aWwuZWFjaChhY3Rpb25JbmZvcywgZnVuY3Rpb24gKGFjdGlvbkluZm8pIHtcbiAgICAgICAgICAgIGFjdGlvbkluZm8udXBkYXRlID0gJ3VwZGF0ZVZpZXcnO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGF5bG9hZFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlcmllc05hbWVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVjaGFydHMucmVnaXN0ZXJBY3Rpb24oYWN0aW9uSW5mbywgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSB7fTtcbiAgICAgICAgICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICAgIHttYWluVHlwZTogJ3NlcmllcycsIHN1YlR5cGU6IHNlcmllc1R5cGUsIHF1ZXJ5OiBwYXlsb2FkfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VyaWVzTW9kZWxbYWN0aW9uSW5mby5tZXRob2RdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWxbYWN0aW9uSW5mby5tZXRob2RdKHBheWxvYWQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBzZWxlY3RlZCBtYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBkYXRhLmdldE5hbWUoaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFtuYW1lXSA9IHNlcmllc01vZGVsLmlzU2VsZWN0ZWQobmFtZSkgfHwgZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvYWN0aW9uL2NyZWF0ZURhdGFTZWxlY3RBY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\n\n\n    module.exports = function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    var filteredIdx = idxMap[rawIdx];\n\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null\n                        && data.getItemVisual(filteredIdx, 'color', true);\n\n                    if (!singleDataColor) {\n                        // FIXME Performance\n                        var itemModel = dataAll.getItemModel(rawIdx);\n                        var color = itemModel.get('itemStyle.normal.color')\n                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    }\n                    else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3Zpc3VhbC9kYXRhQ29sb3IuanM/ZmE4ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUIiwiZmlsZSI6IjE4Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFBpY2sgY29sb3IgZnJvbSBwYWxldHRlIGZvciBlYWNoIGRhdGEgaXRlbS5cbi8vIEFwcGxpY2FibGUgZm9yIGNoYXJ0cyB0aGF0IHJlcXVpcmUgYXBwbHlpbmcgY29sb3IgcGFsZXR0ZVxuLy8gaW4gZGF0YSBsZXZlbCAobGlrZSBwaWUsIGZ1bm5lbCwgY2hvcmQpLlxuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBlY01vZGVsKSB7XG4gICAgICAgIC8vIFBpZSBhbmQgZnVubmVsIG1heSB1c2UgZGlmZXJyZW50IHNjb3BlXG4gICAgICAgIHZhciBwYWxldHRlU2NvcGUgPSB7fTtcbiAgICAgICAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGRhdGFBbGwgPSBzZXJpZXNNb2RlbC5nZXRSYXdEYXRhKCk7XG4gICAgICAgICAgICB2YXIgaWR4TWFwID0ge307XG4gICAgICAgICAgICBpZiAoIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SWR4ID0gZGF0YS5nZXRSYXdJbmRleChpZHgpO1xuICAgICAgICAgICAgICAgICAgICBpZHhNYXBbcmF3SWR4XSA9IGlkeDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkYXRhQWxsLmVhY2goZnVuY3Rpb24gKHJhd0lkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWRJZHggPSBpZHhNYXBbcmF3SWR4XTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzZXJpZXMuaXRlbVN0eWxlLm5vcm1hbC5jb2xvciBpcyBhIGZ1bmN0aW9uLiBpdGVtVmlzdWFsIG1heSBiZSBlbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaW5nbGVEYXRhQ29sb3IgPSBmaWx0ZXJlZElkeCAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBkYXRhLmdldEl0ZW1WaXN1YWwoZmlsdGVyZWRJZHgsICdjb2xvcicsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2luZ2xlRGF0YUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBQZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGFBbGwuZ2V0SXRlbU1vZGVsKHJhd0lkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBpdGVtTW9kZWwuZ2V0KCdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBzZXJpZXNNb2RlbC5nZXRDb2xvckZyb21QYWxldHRlKGRhdGFBbGwuZ2V0TmFtZShyYXdJZHgpLCBwYWxldHRlU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVnZW5kIG1heSB1c2UgdGhlIHZpc3VhbCBpbmZvIGluIGRhdGEgYmVmb3JlIHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUFsbC5zZXRJdGVtVmlzdWFsKHJhd0lkeCwgJ2NvbG9yJywgY29sb3IpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEYXRhIGlzIG5vdCBmaWx0ZXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkSWR4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoZmlsdGVyZWRJZHgsICdjb2xvcicsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBkYXRhIGFsbCBjb2xvciBmb3IgbGVnZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhQWxsLnNldEl0ZW1WaXN1YWwocmF3SWR4LCAnY29sb3InLCBzaW5nbGVEYXRhQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvdmlzdWFsL2RhdGFDb2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMTg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n    var numberUtil = __webpack_require__(23);\n    var parsePercent = numberUtil.parsePercent;\n    var labelLayout = __webpack_require__(188);\n    var zrUtil = __webpack_require__(20);\n\n    var PI2 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n\n    module.exports = function (seriesType, ecModel, api, payload) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var center = seriesModel.get('center');\n            var radius = seriesModel.get('radius');\n\n            if (!zrUtil.isArray(radius)) {\n                radius = [0, radius];\n            }\n            if (!zrUtil.isArray(center)) {\n                center = [center, center];\n            }\n\n            var width = api.getWidth();\n            var height = api.getHeight();\n            var size = Math.min(width, height);\n            var cx = parsePercent(center[0], width);\n            var cy = parsePercent(center[1], height);\n            var r0 = parsePercent(radius[0], size / 2);\n            var r = parsePercent(radius[1], size / 2);\n\n            var data = seriesModel.getData();\n\n            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\n            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\n            var validDataCount = 0;\n            data.each('value', function (value) {\n                !isNaN(value) && validDataCount++;\n            });\n\n            var sum = data.getSum('value');\n            // Sum may be 0\n            var unitRadian = Math.PI / (sum || validDataCount) * 2;\n\n            var clockwise = seriesModel.get('clockwise');\n\n            var roseType = seriesModel.get('roseType');\n            var stillShowZeroSum = seriesModel.get('stillShowZeroSum');\n\n            // [0...max]\n            var extent = data.getDataExtent('value');\n            extent[0] = 0;\n\n            // In the case some sector angle is smaller than minAngle\n            var restAngle = PI2;\n            var valueSumLargerThanMinAngle = 0;\n\n            var currentAngle = startAngle;\n            var dir = clockwise ? 1 : -1;\n\n            data.each('value', function (value, idx) {\n                var angle;\n                if (isNaN(value)) {\n                    data.setItemLayout(idx, {\n                        angle: NaN,\n                        startAngle: NaN,\n                        endAngle: NaN,\n                        clockwise: clockwise,\n                        cx: cx,\n                        cy: cy,\n                        r0: r0,\n                        r: roseType\n                            ? NaN\n                            : r\n                    });\n                    return;\n                }\n\n                // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n                if (roseType !== 'area') {\n                    angle = (sum === 0 && stillShowZeroSum)\n                        ? unitRadian : (value * unitRadian);\n                }\n                else {\n                    angle = PI2 / validDataCount;\n                }\n\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                }\n                else {\n                    valueSumLargerThanMinAngle += value;\n                }\n\n                var endAngle = currentAngle + dir * angle;\n                data.setItemLayout(idx, {\n                    angle: angle,\n                    startAngle: currentAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType\n                        ? numberUtil.linearMap(value, extent, [r0, r])\n                        : r\n                });\n\n                currentAngle = endAngle;\n            }, true);\n\n            // Some sector is constrained by minAngle\n            // Rest sectors needs recalculate angle\n            if (restAngle < PI2 && validDataCount) {\n                // Average the angle if rest angle is not enough after all angles is\n                // Constrained by minAngle\n                if (restAngle <= 1e-3) {\n                    var angle = PI2 / validDataCount;\n                    data.each('value', function (value, idx) {\n                        if (!isNaN(value)) {\n                            var layout = data.getItemLayout(idx);\n                            layout.angle = angle;\n                            layout.startAngle = startAngle + dir * idx * angle;\n                            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                        }\n                    });\n                }\n                else {\n                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n                    currentAngle = startAngle;\n                    data.each('value', function (value, idx) {\n                        if (!isNaN(value)) {\n                            var layout = data.getItemLayout(idx);\n                            var angle = layout.angle === minAngle\n                                ? minAngle : value * unitRadian;\n                            layout.startAngle = currentAngle;\n                            layout.endAngle = currentAngle + dir * angle;\n                            currentAngle += dir * angle;\n                        }\n                    });\n                }\n            }\n\n            labelLayout(seriesModel, r, width, height);\n        });\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L3BpZS9waWVMYXlvdXQuanM/YjMyMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCIsImZpbGUiOiIxODcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgcGFyc2VQZXJjZW50ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQ7XG4gICAgdmFyIGxhYmVsTGF5b3V0ID0gcmVxdWlyZSgnLi9sYWJlbExheW91dCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICB2YXIgUkFESUFOID0gTWF0aC5QSSAvIDE4MDtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlcmllc1R5cGUsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoc2VyaWVzVHlwZSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gc2VyaWVzTW9kZWwuZ2V0KCdjZW50ZXInKTtcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBzZXJpZXNNb2RlbC5nZXQoJ3JhZGl1cycpO1xuXG4gICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHJhZGl1cykpIHtcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBbMCwgcmFkaXVzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkoY2VudGVyKSkge1xuICAgICAgICAgICAgICAgIGNlbnRlciA9IFtjZW50ZXIsIGNlbnRlcl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGFwaS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGFwaS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB2YXIgY3ggPSBwYXJzZVBlcmNlbnQoY2VudGVyWzBdLCB3aWR0aCk7XG4gICAgICAgICAgICB2YXIgY3kgPSBwYXJzZVBlcmNlbnQoY2VudGVyWzFdLCBoZWlnaHQpO1xuICAgICAgICAgICAgdmFyIHIwID0gcGFyc2VQZXJjZW50KHJhZGl1c1swXSwgc2l6ZSAvIDIpO1xuICAgICAgICAgICAgdmFyIHIgPSBwYXJzZVBlcmNlbnQocmFkaXVzWzFdLCBzaXplIC8gMik7XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IC1zZXJpZXNNb2RlbC5nZXQoJ3N0YXJ0QW5nbGUnKSAqIFJBRElBTjtcblxuICAgICAgICAgICAgdmFyIG1pbkFuZ2xlID0gc2VyaWVzTW9kZWwuZ2V0KCdtaW5BbmdsZScpICogUkFESUFOO1xuXG4gICAgICAgICAgICB2YXIgdmFsaWREYXRhQ291bnQgPSAwO1xuICAgICAgICAgICAgZGF0YS5lYWNoKCd2YWx1ZScsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICFpc05hTih2YWx1ZSkgJiYgdmFsaWREYXRhQ291bnQrKztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgc3VtID0gZGF0YS5nZXRTdW0oJ3ZhbHVlJyk7XG4gICAgICAgICAgICAvLyBTdW0gbWF5IGJlIDBcbiAgICAgICAgICAgIHZhciB1bml0UmFkaWFuID0gTWF0aC5QSSAvIChzdW0gfHwgdmFsaWREYXRhQ291bnQpICogMjtcblxuICAgICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IHNlcmllc01vZGVsLmdldCgnY2xvY2t3aXNlJyk7XG5cbiAgICAgICAgICAgIHZhciByb3NlVHlwZSA9IHNlcmllc01vZGVsLmdldCgncm9zZVR5cGUnKTtcbiAgICAgICAgICAgIHZhciBzdGlsbFNob3daZXJvU3VtID0gc2VyaWVzTW9kZWwuZ2V0KCdzdGlsbFNob3daZXJvU3VtJyk7XG5cbiAgICAgICAgICAgIC8vIFswLi4ubWF4XVxuICAgICAgICAgICAgdmFyIGV4dGVudCA9IGRhdGEuZ2V0RGF0YUV4dGVudCgndmFsdWUnKTtcbiAgICAgICAgICAgIGV4dGVudFswXSA9IDA7XG5cbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIHNvbWUgc2VjdG9yIGFuZ2xlIGlzIHNtYWxsZXIgdGhhbiBtaW5BbmdsZVxuICAgICAgICAgICAgdmFyIHJlc3RBbmdsZSA9IFBJMjtcbiAgICAgICAgICAgIHZhciB2YWx1ZVN1bUxhcmdlclRoYW5NaW5BbmdsZSA9IDA7XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50QW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgdmFyIGRpciA9IGNsb2Nrd2lzZSA/IDEgOiAtMTtcblxuICAgICAgICAgICAgZGF0YS5lYWNoKCd2YWx1ZScsIGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGU6IE5hTixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IE5hTixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBOYU4sXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9ja3dpc2U6IGNsb2Nrd2lzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIwOiByMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHI6IHJvc2VUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBOYU5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSDlhbzlrrkgMi4wIOS9huaYryByb3NlVHlwZSDmmK8gYXJlYSDnmoTml7blgJnmiY3mmK/ov5nmoLfvvJ9cbiAgICAgICAgICAgICAgICBpZiAocm9zZVR5cGUgIT09ICdhcmVhJykge1xuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IChzdW0gPT09IDAgJiYgc3RpbGxTaG93WmVyb1N1bSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdW5pdFJhZGlhbiA6ICh2YWx1ZSAqIHVuaXRSYWRpYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBQSTIgLyB2YWxpZERhdGFDb3VudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPCBtaW5BbmdsZSkge1xuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IG1pbkFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICByZXN0QW5nbGUgLT0gbWluQW5nbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVN1bUxhcmdlclRoYW5NaW5BbmdsZSArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBjdXJyZW50QW5nbGUgKyBkaXIgKiBhbmdsZTtcbiAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogY3VycmVudEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgICAgICAgICAgICAgICAgIGNsb2Nrd2lzZTogY2xvY2t3aXNlLFxuICAgICAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICAgICAgcjA6IHIwLFxuICAgICAgICAgICAgICAgICAgICByOiByb3NlVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBudW1iZXJVdGlsLmxpbmVhck1hcCh2YWx1ZSwgZXh0ZW50LCBbcjAsIHJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiByXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50QW5nbGUgPSBlbmRBbmdsZTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBTb21lIHNlY3RvciBpcyBjb25zdHJhaW5lZCBieSBtaW5BbmdsZVxuICAgICAgICAgICAgLy8gUmVzdCBzZWN0b3JzIG5lZWRzIHJlY2FsY3VsYXRlIGFuZ2xlXG4gICAgICAgICAgICBpZiAocmVzdEFuZ2xlIDwgUEkyICYmIHZhbGlkRGF0YUNvdW50KSB7XG4gICAgICAgICAgICAgICAgLy8gQXZlcmFnZSB0aGUgYW5nbGUgaWYgcmVzdCBhbmdsZSBpcyBub3QgZW5vdWdoIGFmdGVyIGFsbCBhbmdsZXMgaXNcbiAgICAgICAgICAgICAgICAvLyBDb25zdHJhaW5lZCBieSBtaW5BbmdsZVxuICAgICAgICAgICAgICAgIGlmIChyZXN0QW5nbGUgPD0gMWUtMykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBQSTIgLyB2YWxpZERhdGFDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5lYWNoKCd2YWx1ZScsIGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQuYW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQuc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBkaXIgKiBpZHggKiBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQuZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgZGlyICogKGlkeCArIDEpICogYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdFJhZGlhbiA9IHJlc3RBbmdsZSAvIHZhbHVlU3VtTGFyZ2VyVGhhbk1pbkFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmVhY2goJ3ZhbHVlJywgZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IGxheW91dC5hbmdsZSA9PT0gbWluQW5nbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBtaW5BbmdsZSA6IHZhbHVlICogdW5pdFJhZGlhbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQuc3RhcnRBbmdsZSA9IGN1cnJlbnRBbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQuZW5kQW5nbGUgPSBjdXJyZW50QW5nbGUgKyBkaXIgKiBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5nbGUgKz0gZGlyICogYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFiZWxMYXlvdXQoc2VyaWVzTW9kZWwsIHIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NoYXJ0L3BpZS9waWVMYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDE4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("'use strict';\n// FIXME emphasis label position is not same with normal label position\n\n\n    var textContain = __webpack_require__(24);\n\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n        list.sort(function (a, b) {\n            return a.y - b.y;\n        });\n\n        // 压\n        function shiftDown(start, end, delta, dir) {\n            for (var j = start; j < end; j++) {\n                list[j].y += delta;\n                if (j > start\n                    && j + 1 < end\n                    && list[j + 1].y > list[j].y + list[j].height\n                ) {\n                    shiftUp(j, delta / 2);\n                    return;\n                }\n            }\n\n            shiftUp(end - 1, delta / 2);\n        }\n\n        // 弹\n        function shiftUp(end, delta) {\n            for (var j = end; j >= 0; j--) {\n                list[j].y -= delta;\n                if (j > 0\n                    && list[j].y > list[j - 1].y + list[j - 1].height\n                ) {\n                    break;\n                }\n            }\n        }\n\n        function changeX(list, isDownList, cx, cy, r, dir) {\n            var lastDeltaX = dir > 0\n                ? isDownList                // 右侧\n                    ? Number.MAX_VALUE      // 下\n                    : 0                     // 上\n                : isDownList                // 左侧\n                    ? Number.MAX_VALUE      // 下\n                    : 0;                    // 上\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                // Not change x for center label\n                if (list[i].position === 'center') {\n                    continue;\n                }\n                var deltaY = Math.abs(list[i].y - cy);\n                var length = list[i].len;\n                var length2 = list[i].len2;\n                var deltaX = (deltaY < r + length)\n                    ? Math.sqrt(\n                          (r + length + length2) * (r + length + length2)\n                          - deltaY * deltaY\n                      )\n                    : Math.abs(list[i].x - cx);\n                if (isDownList && deltaX >= lastDeltaX) {\n                    // 右下，左下\n                    deltaX = lastDeltaX - 10;\n                }\n                if (!isDownList && deltaX <= lastDeltaX) {\n                    // 右上，左上\n                    deltaX = lastDeltaX + 10;\n                }\n\n                list[i].x = cx + deltaX * dir;\n                lastDeltaX = deltaX;\n            }\n        }\n\n        var lastY = 0;\n        var delta;\n        var len = list.length;\n        var upList = [];\n        var downList = [];\n        for (var i = 0; i < len; i++) {\n            delta = list[i].y - lastY;\n            if (delta < 0) {\n                shiftDown(i, len, -delta, dir);\n            }\n            lastY = list[i].y + list[i].height;\n        }\n        if (viewHeight - lastY < 0) {\n            shiftUp(len - 1, lastY - viewHeight);\n        }\n        for (var i = 0; i < len; i++) {\n            if (list[i].y >= cy) {\n                downList.push(list[i]);\n            }\n            else {\n                upList.push(list[i]);\n            }\n        }\n        changeX(upList, false, cx, cy, r, dir);\n        changeX(downList, true, cx, cy, r, dir);\n    }\n\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n        var leftList = [];\n        var rightList = [];\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            if (labelLayoutList[i].x < cx) {\n                leftList.push(labelLayoutList[i]);\n            }\n            else {\n                rightList.push(labelLayoutList[i]);\n            }\n        }\n\n        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            var linePoints = labelLayoutList[i].linePoints;\n            if (linePoints) {\n                var dist = linePoints[1][0] - linePoints[2][0];\n                if (labelLayoutList[i].x < cx) {\n                    linePoints[2][0] = labelLayoutList[i].x + 3;\n                }\n                else {\n                    linePoints[2][0] = labelLayoutList[i].x - 3;\n                }\n                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n                linePoints[1][0] = linePoints[2][0] + dist;\n            }\n        }\n    }\n\n    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n        var data = seriesModel.getData();\n        var labelLayoutList = [];\n        var cx;\n        var cy;\n        var hasLabelRotate = false;\n\n        data.each(function (idx) {\n            var layout = data.getItemLayout(idx);\n\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            // Use position in normal or emphasis\n            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n            var labelLineLen = labelLineModel.get('length');\n            var labelLineLen2 = labelLineModel.get('length2');\n\n            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n            var dx = Math.cos(midAngle);\n            var dy = Math.sin(midAngle);\n\n            var textX;\n            var textY;\n            var linePoints;\n            var textAlign;\n\n            cx = layout.cx;\n            cy = layout.cy;\n\n            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n            if (labelPosition === 'center') {\n                textX = layout.cx;\n                textY = layout.cy;\n                textAlign = 'center';\n            }\n            else {\n                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\n                textX = x1 + dx * 3;\n                textY = y1 + dy * 3;\n\n                if (!isLabelInside) {\n                    // For roseType\n                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n                    var y3 = y2;\n\n                    textX = x3 + (dx < 0 ? -5 : 5);\n                    textY = y3;\n                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n                }\n\n                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n            }\n            var font = labelModel.getModel('textStyle').getFont();\n\n            var labelRotate = labelModel.get('rotate')\n                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n            var text = seriesModel.getFormattedLabel(idx, 'normal')\n                        || data.getName(idx);\n            var textRect = textContain.getBoundingRect(\n                text, font, textAlign, 'top'\n            );\n            hasLabelRotate = !!labelRotate;\n            layout.label = {\n                x: textX,\n                y: textY,\n                position: labelPosition,\n                height: textRect.height,\n                len: labelLineLen,\n                len2: labelLineLen2,\n                linePoints: linePoints,\n                textAlign: textAlign,\n                verticalAlign: 'middle',\n                font: font,\n                rotation: labelRotate\n            };\n\n            // Not layout the inside label\n            if (!isLabelInside) {\n                labelLayoutList.push(layout.label);\n            }\n        });\n        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L3BpZS9sYWJlbExheW91dC5qcz9hN2M5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4Qiw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE4OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIEZJWE1FIGVtcGhhc2lzIGxhYmVsIHBvc2l0aW9uIGlzIG5vdCBzYW1lIHdpdGggbm9ybWFsIGxhYmVsIHBvc2l0aW9uXG5cblxuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xuXG4gICAgZnVuY3Rpb24gYWRqdXN0U2luZ2xlU2lkZShsaXN0LCBjeCwgY3ksIHIsIGRpciwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KSB7XG4gICAgICAgIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEueSAtIGIueTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8g5Y6LXG4gICAgICAgIGZ1bmN0aW9uIHNoaWZ0RG93bihzdGFydCwgZW5kLCBkZWx0YSwgZGlyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnQ7IGogPCBlbmQ7IGorKykge1xuICAgICAgICAgICAgICAgIGxpc3Rbal0ueSArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICBpZiAoaiA+IHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICYmIGogKyAxIDwgZW5kXG4gICAgICAgICAgICAgICAgICAgICYmIGxpc3RbaiArIDFdLnkgPiBsaXN0W2pdLnkgKyBsaXN0W2pdLmhlaWdodFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBzaGlmdFVwKGosIGRlbHRhIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNoaWZ0VXAoZW5kIC0gMSwgZGVsdGEgLyAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOW8uVxuICAgICAgICBmdW5jdGlvbiBzaGlmdFVwKGVuZCwgZGVsdGEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBlbmQ7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgbGlzdFtqXS55IC09IGRlbHRhO1xuICAgICAgICAgICAgICAgIGlmIChqID4gMFxuICAgICAgICAgICAgICAgICAgICAmJiBsaXN0W2pdLnkgPiBsaXN0W2ogLSAxXS55ICsgbGlzdFtqIC0gMV0uaGVpZ2h0XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNoYW5nZVgobGlzdCwgaXNEb3duTGlzdCwgY3gsIGN5LCByLCBkaXIpIHtcbiAgICAgICAgICAgIHZhciBsYXN0RGVsdGFYID0gZGlyID4gMFxuICAgICAgICAgICAgICAgID8gaXNEb3duTGlzdCAgICAgICAgICAgICAgICAvLyDlj7PkvqdcbiAgICAgICAgICAgICAgICAgICAgPyBOdW1iZXIuTUFYX1ZBTFVFICAgICAgLy8g5LiLXG4gICAgICAgICAgICAgICAgICAgIDogMCAgICAgICAgICAgICAgICAgICAgIC8vIOS4ilxuICAgICAgICAgICAgICAgIDogaXNEb3duTGlzdCAgICAgICAgICAgICAgICAvLyDlt6bkvqdcbiAgICAgICAgICAgICAgICAgICAgPyBOdW1iZXIuTUFYX1ZBTFVFICAgICAgLy8g5LiLXG4gICAgICAgICAgICAgICAgICAgIDogMDsgICAgICAgICAgICAgICAgICAgIC8vIOS4ilxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90IGNoYW5nZSB4IGZvciBjZW50ZXIgbGFiZWxcbiAgICAgICAgICAgICAgICBpZiAobGlzdFtpXS5wb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZWx0YVkgPSBNYXRoLmFicyhsaXN0W2ldLnkgLSBjeSk7XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGxpc3RbaV0ubGVuO1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGgyID0gbGlzdFtpXS5sZW4yO1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YVggPSAoZGVsdGFZIDwgciArIGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgPyBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChyICsgbGVuZ3RoICsgbGVuZ3RoMikgKiAociArIGxlbmd0aCArIGxlbmd0aDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC0gZGVsdGFZICogZGVsdGFZXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGguYWJzKGxpc3RbaV0ueCAtIGN4KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEb3duTGlzdCAmJiBkZWx0YVggPj0gbGFzdERlbHRhWCkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlj7PkuIvvvIzlt6bkuItcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFYID0gbGFzdERlbHRhWCAtIDEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzRG93bkxpc3QgJiYgZGVsdGFYIDw9IGxhc3REZWx0YVgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5Y+z5LiK77yM5bem5LiKXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhWCA9IGxhc3REZWx0YVggKyAxMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsaXN0W2ldLnggPSBjeCArIGRlbHRhWCAqIGRpcjtcbiAgICAgICAgICAgICAgICBsYXN0RGVsdGFYID0gZGVsdGFYO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3RZID0gMDtcbiAgICAgICAgdmFyIGRlbHRhO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciB1cExpc3QgPSBbXTtcbiAgICAgICAgdmFyIGRvd25MaXN0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGRlbHRhID0gbGlzdFtpXS55IC0gbGFzdFk7XG4gICAgICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgc2hpZnREb3duKGksIGxlbiwgLWRlbHRhLCBkaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdFkgPSBsaXN0W2ldLnkgKyBsaXN0W2ldLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlld0hlaWdodCAtIGxhc3RZIDwgMCkge1xuICAgICAgICAgICAgc2hpZnRVcChsZW4gLSAxLCBsYXN0WSAtIHZpZXdIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaXN0W2ldLnkgPj0gY3kpIHtcbiAgICAgICAgICAgICAgICBkb3duTGlzdC5wdXNoKGxpc3RbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBMaXN0LnB1c2gobGlzdFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlWCh1cExpc3QsIGZhbHNlLCBjeCwgY3ksIHIsIGRpcik7XG4gICAgICAgIGNoYW5nZVgoZG93bkxpc3QsIHRydWUsIGN4LCBjeSwgciwgZGlyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhdm9pZE92ZXJsYXAobGFiZWxMYXlvdXRMaXN0LCBjeCwgY3ksIHIsIHZpZXdXaWR0aCwgdmlld0hlaWdodCkge1xuICAgICAgICB2YXIgbGVmdExpc3QgPSBbXTtcbiAgICAgICAgdmFyIHJpZ2h0TGlzdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVsTGF5b3V0TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxhYmVsTGF5b3V0TGlzdFtpXS54IDwgY3gpIHtcbiAgICAgICAgICAgICAgICBsZWZ0TGlzdC5wdXNoKGxhYmVsTGF5b3V0TGlzdFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByaWdodExpc3QucHVzaChsYWJlbExheW91dExpc3RbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWRqdXN0U2luZ2xlU2lkZShyaWdodExpc3QsIGN4LCBjeSwgciwgMSwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KTtcbiAgICAgICAgYWRqdXN0U2luZ2xlU2lkZShsZWZ0TGlzdCwgY3gsIGN5LCByLCAtMSwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVsTGF5b3V0TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpbmVQb2ludHMgPSBsYWJlbExheW91dExpc3RbaV0ubGluZVBvaW50cztcbiAgICAgICAgICAgIGlmIChsaW5lUG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBsaW5lUG9pbnRzWzFdWzBdIC0gbGluZVBvaW50c1syXVswXTtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWxMYXlvdXRMaXN0W2ldLnggPCBjeCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lUG9pbnRzWzJdWzBdID0gbGFiZWxMYXlvdXRMaXN0W2ldLnggKyAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZVBvaW50c1syXVswXSA9IGxhYmVsTGF5b3V0TGlzdFtpXS54IC0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZVBvaW50c1sxXVsxXSA9IGxpbmVQb2ludHNbMl1bMV0gPSBsYWJlbExheW91dExpc3RbaV0ueTtcbiAgICAgICAgICAgICAgICBsaW5lUG9pbnRzWzFdWzBdID0gbGluZVBvaW50c1syXVswXSArIGRpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgciwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KSB7XG4gICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICB2YXIgbGFiZWxMYXlvdXRMaXN0ID0gW107XG4gICAgICAgIHZhciBjeDtcbiAgICAgICAgdmFyIGN5O1xuICAgICAgICB2YXIgaGFzTGFiZWxSb3RhdGUgPSBmYWxzZTtcblxuICAgICAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuXG4gICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgICAgICAgIHZhciBsYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbC5ub3JtYWwnKTtcbiAgICAgICAgICAgIC8vIFVzZSBwb3NpdGlvbiBpbiBub3JtYWwgb3IgZW1waGFzaXNcbiAgICAgICAgICAgIHZhciBsYWJlbFBvc2l0aW9uID0gbGFiZWxNb2RlbC5nZXQoJ3Bvc2l0aW9uJykgfHwgaXRlbU1vZGVsLmdldCgnbGFiZWwuZW1waGFzaXMucG9zaXRpb24nKTtcblxuICAgICAgICAgICAgdmFyIGxhYmVsTGluZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbExpbmUubm9ybWFsJyk7XG4gICAgICAgICAgICB2YXIgbGFiZWxMaW5lTGVuID0gbGFiZWxMaW5lTW9kZWwuZ2V0KCdsZW5ndGgnKTtcbiAgICAgICAgICAgIHZhciBsYWJlbExpbmVMZW4yID0gbGFiZWxMaW5lTW9kZWwuZ2V0KCdsZW5ndGgyJyk7XG5cbiAgICAgICAgICAgIHZhciBtaWRBbmdsZSA9IChsYXlvdXQuc3RhcnRBbmdsZSArIGxheW91dC5lbmRBbmdsZSkgLyAyO1xuICAgICAgICAgICAgdmFyIGR4ID0gTWF0aC5jb3MobWlkQW5nbGUpO1xuICAgICAgICAgICAgdmFyIGR5ID0gTWF0aC5zaW4obWlkQW5nbGUpO1xuXG4gICAgICAgICAgICB2YXIgdGV4dFg7XG4gICAgICAgICAgICB2YXIgdGV4dFk7XG4gICAgICAgICAgICB2YXIgbGluZVBvaW50cztcbiAgICAgICAgICAgIHZhciB0ZXh0QWxpZ247XG5cbiAgICAgICAgICAgIGN4ID0gbGF5b3V0LmN4O1xuICAgICAgICAgICAgY3kgPSBsYXlvdXQuY3k7XG5cbiAgICAgICAgICAgIHZhciBpc0xhYmVsSW5zaWRlID0gbGFiZWxQb3NpdGlvbiA9PT0gJ2luc2lkZScgfHwgbGFiZWxQb3NpdGlvbiA9PT0gJ2lubmVyJztcbiAgICAgICAgICAgIGlmIChsYWJlbFBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIHRleHRYID0gbGF5b3V0LmN4O1xuICAgICAgICAgICAgICAgIHRleHRZID0gbGF5b3V0LmN5O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHgxID0gKGlzTGFiZWxJbnNpZGUgPyAobGF5b3V0LnIgKyBsYXlvdXQucjApIC8gMiAqIGR4IDogbGF5b3V0LnIgKiBkeCkgKyBjeDtcbiAgICAgICAgICAgICAgICB2YXIgeTEgPSAoaXNMYWJlbEluc2lkZSA/IChsYXlvdXQuciArIGxheW91dC5yMCkgLyAyICogZHkgOiBsYXlvdXQuciAqIGR5KSArIGN5O1xuXG4gICAgICAgICAgICAgICAgdGV4dFggPSB4MSArIGR4ICogMztcbiAgICAgICAgICAgICAgICB0ZXh0WSA9IHkxICsgZHkgKiAzO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc0xhYmVsSW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciByb3NlVHlwZVxuICAgICAgICAgICAgICAgICAgICB2YXIgeDIgPSB4MSArIGR4ICogKGxhYmVsTGluZUxlbiArIHIgLSBsYXlvdXQucik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MiA9IHkxICsgZHkgKiAobGFiZWxMaW5lTGVuICsgciAtIGxheW91dC5yKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgzID0geDIgKyAoKGR4IDwgMCA/IC0xIDogMSkgKiBsYWJlbExpbmVMZW4yKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkzID0geTI7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dFggPSB4MyArIChkeCA8IDAgPyAtNSA6IDUpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0WSA9IHkzO1xuICAgICAgICAgICAgICAgICAgICBsaW5lUG9pbnRzID0gW1t4MSwgeTFdLCBbeDIsIHkyXSwgW3gzLCB5M11dO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IGlzTGFiZWxJbnNpZGUgPyAnY2VudGVyJyA6IChkeCA+IDAgPyAnbGVmdCcgOiAncmlnaHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmb250ID0gbGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJykuZ2V0Rm9udCgpO1xuXG4gICAgICAgICAgICB2YXIgbGFiZWxSb3RhdGUgPSBsYWJlbE1vZGVsLmdldCgncm90YXRlJylcbiAgICAgICAgICAgICAgICA/IChkeCA8IDAgPyAtbWlkQW5nbGUgKyBNYXRoLlBJIDogLW1pZEFuZ2xlKSA6IDA7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHNlcmllc01vZGVsLmdldEZvcm1hdHRlZExhYmVsKGlkeCwgJ25vcm1hbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBkYXRhLmdldE5hbWUoaWR4KTtcbiAgICAgICAgICAgIHZhciB0ZXh0UmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChcbiAgICAgICAgICAgICAgICB0ZXh0LCBmb250LCB0ZXh0QWxpZ24sICd0b3AnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaGFzTGFiZWxSb3RhdGUgPSAhIWxhYmVsUm90YXRlO1xuICAgICAgICAgICAgbGF5b3V0LmxhYmVsID0ge1xuICAgICAgICAgICAgICAgIHg6IHRleHRYLFxuICAgICAgICAgICAgICAgIHk6IHRleHRZLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBsYWJlbFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGV4dFJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxlbjogbGFiZWxMaW5lTGVuLFxuICAgICAgICAgICAgICAgIGxlbjI6IGxhYmVsTGluZUxlbjIsXG4gICAgICAgICAgICAgICAgbGluZVBvaW50czogbGluZVBvaW50cyxcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICBmb250OiBmb250LFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBsYWJlbFJvdGF0ZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gTm90IGxheW91dCB0aGUgaW5zaWRlIGxhYmVsXG4gICAgICAgICAgICBpZiAoIWlzTGFiZWxJbnNpZGUpIHtcbiAgICAgICAgICAgICAgICBsYWJlbExheW91dExpc3QucHVzaChsYXlvdXQubGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFoYXNMYWJlbFJvdGF0ZSAmJiBzZXJpZXNNb2RlbC5nZXQoJ2F2b2lkTGFiZWxPdmVybGFwJykpIHtcbiAgICAgICAgICAgIGF2b2lkT3ZlcmxhcChsYWJlbExheW91dExpc3QsIGN4LCBjeSwgciwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY2hhcnQvcGllL2xhYmVsTGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxODhcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports){eval("\n    module.exports = function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL3Byb2Nlc3Nvci9kYXRhRmlsdGVyLmpzP2Q2ZTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlCQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCIsImZpbGUiOiIxODkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBlY01vZGVsKSB7XG4gICAgICAgIHZhciBsZWdlbmRNb2RlbHMgPSBlY01vZGVsLmZpbmRDb21wb25lbnRzKHtcbiAgICAgICAgICAgIG1haW5UeXBlOiAnbGVnZW5kJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFsZWdlbmRNb2RlbHMgfHwgIWxlZ2VuZE1vZGVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoc2VyaWVzVHlwZSwgZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXMuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgZGF0YS5maWx0ZXJTZWxmKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGRhdGEuZ2V0TmFtZShpZHgpO1xuICAgICAgICAgICAgICAgIC8vIElmIGluIGFueSBsZWdlbmQgY29tcG9uZW50IHRoZSBzdGF0dXMgaXMgbm90IHNlbGVjdGVkLlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVnZW5kTW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVnZW5kTW9kZWxzW2ldLmlzU2VsZWN0ZWQobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3Byb2Nlc3Nvci9kYXRhRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxODlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n    var echarts = __webpack_require__(17);\n\n    __webpack_require__(191);\n    __webpack_require__(192);\n\n    echarts.registerVisual(zrUtil.curry(__webpack_require__(186), 'funnel'));\n    echarts.registerLayout(__webpack_require__(193));\n\n    echarts.registerProcessor(zrUtil.curry(__webpack_require__(189), 'funnel'));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2Z1bm5lbC5qcz8zNmM5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTkwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGVjaGFydHMgPSByZXF1aXJlKCcuLi9lY2hhcnRzJyk7XG5cbiAgICByZXF1aXJlKCcuL2Z1bm5lbC9GdW5uZWxTZXJpZXMnKTtcbiAgICByZXF1aXJlKCcuL2Z1bm5lbC9GdW5uZWxWaWV3Jyk7XG5cbiAgICBlY2hhcnRzLnJlZ2lzdGVyVmlzdWFsKHpyVXRpbC5jdXJyeShyZXF1aXJlKCcuLi92aXN1YWwvZGF0YUNvbG9yJyksICdmdW5uZWwnKSk7XG4gICAgZWNoYXJ0cy5yZWdpc3RlckxheW91dChyZXF1aXJlKCcuL2Z1bm5lbC9mdW5uZWxMYXlvdXQnKSk7XG5cbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJvY2Vzc29yKHpyVXRpbC5jdXJyeShyZXF1aXJlKCcuLi9wcm9jZXNzb3IvZGF0YUZpbHRlcicpLCAnZnVubmVsJykpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NoYXJ0L2Z1bm5lbC5qc1xuLy8gbW9kdWxlIGlkID0gMTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var List = __webpack_require__(114);\n    var modelUtil = __webpack_require__(21);\n    var completeDimensions = __webpack_require__(126);\n\n    var FunnelSeries = __webpack_require__(17).extendSeriesModel({\n\n        type: 'series.funnel',\n\n        init: function (option) {\n            FunnelSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n            // Extend labelLine emphasis\n            this._defaultLabelLine(option);\n        },\n\n        getInitialData: function (option, ecModel) {\n            var dimensions = completeDimensions(['value'], option.data);\n            var list = new List(dimensions, this);\n            list.initData(option.data);\n            return list;\n        },\n\n        _defaultLabelLine: function (option) {\n            // Extend labelLine emphasis\n            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\n            var labelLineNormalOpt = option.labelLine.normal;\n            var labelLineEmphasisOpt = option.labelLine.emphasis;\n            // Not show label line if `label.normal.show = false`\n            labelLineNormalOpt.show = labelLineNormalOpt.show\n                && option.label.normal.show;\n            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n                && option.label.emphasis.show;\n        },\n\n        // Overwrite\n        getDataParams: function (dataIndex) {\n            var data = this.getData();\n            var params = FunnelSeries.superCall(this, 'getDataParams', dataIndex);\n            var sum = data.getSum('value');\n            // Percent is 0 if sum is 0\n            params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\n            params.$vars.push('percent');\n            return params;\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // 一级层叠\n            z: 2,                       // 二级层叠\n            legendHoverLink: true,\n            left: 80,\n            top: 60,\n            right: 80,\n            bottom: 60,\n            // width: {totalWidth} - left - right,\n            // height: {totalHeight} - top - bottom,\n\n            // 默认取数据最小最大值\n            // min: 0,\n            // max: 100,\n            minSize: '0%',\n            maxSize: '100%',\n            sort: 'descending', // 'ascending', 'descending'\n            gap: 0,\n            funnelAlign: 'center',\n            label: {\n                normal: {\n                    show: true,\n                    position: 'outer'\n                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                emphasis: {\n                    show: true\n                }\n            },\n            labelLine: {\n                normal: {\n                    show: true,\n                    length: 20,\n                    lineStyle: {\n                        // color: 各异,\n                        width: 1,\n                        type: 'solid'\n                    }\n                },\n                emphasis: {}\n            },\n            itemStyle: {\n                normal: {\n                    // color: 各异,\n                    borderColor: '#fff',\n                    borderWidth: 1\n                },\n                emphasis: {\n                    // color: 各异,\n                }\n            }\n        }\n    });\n\n    module.exports = FunnelSeries;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2Z1bm5lbC9GdW5uZWxTZXJpZXMuanM/MjcwZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDLHdCQUF3QixZQUFZOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCIsImZpbGUiOiIxOTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBMaXN0ID0gcmVxdWlyZSgnLi4vLi4vZGF0YS9MaXN0Jyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgY29tcGxldGVEaW1lbnNpb25zID0gcmVxdWlyZSgnLi4vLi4vZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zJyk7XG5cbiAgICB2YXIgRnVubmVsU2VyaWVzID0gcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLmV4dGVuZFNlcmllc01vZGVsKHtcblxuICAgICAgICB0eXBlOiAnc2VyaWVzLmZ1bm5lbCcsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgRnVubmVsU2VyaWVzLnN1cGVyQXBwbHkodGhpcywgJ2luaXQnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAvLyBFbmFibGUgbGVnZW5kIHNlbGVjdGlvbiBmb3IgZWFjaCBkYXRhIGl0ZW1cbiAgICAgICAgICAgIC8vIFVzZSBhIGZ1bmN0aW9uIGluc3RlYWQgb2YgZGlyZWN0IGFjY2VzcyBiZWNhdXNlIGRhdGEgcmVmZXJlbmNlIG1heSBjaGFuZ2VkXG4gICAgICAgICAgICB0aGlzLmxlZ2VuZERhdGFQcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSYXdEYXRhKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gRXh0ZW5kIGxhYmVsTGluZSBlbXBoYXNpc1xuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdExhYmVsTGluZShvcHRpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEluaXRpYWxEYXRhOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGNvbXBsZXRlRGltZW5zaW9ucyhbJ3ZhbHVlJ10sIG9wdGlvbi5kYXRhKTtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gbmV3IExpc3QoZGltZW5zaW9ucywgdGhpcyk7XG4gICAgICAgICAgICBsaXN0LmluaXREYXRhKG9wdGlvbi5kYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kZWZhdWx0TGFiZWxMaW5lOiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICAvLyBFeHRlbmQgbGFiZWxMaW5lIGVtcGhhc2lzXG4gICAgICAgICAgICBtb2RlbFV0aWwuZGVmYXVsdEVtcGhhc2lzKG9wdGlvbi5sYWJlbExpbmUsIFsnc2hvdyddKTtcblxuICAgICAgICAgICAgdmFyIGxhYmVsTGluZU5vcm1hbE9wdCA9IG9wdGlvbi5sYWJlbExpbmUubm9ybWFsO1xuICAgICAgICAgICAgdmFyIGxhYmVsTGluZUVtcGhhc2lzT3B0ID0gb3B0aW9uLmxhYmVsTGluZS5lbXBoYXNpcztcbiAgICAgICAgICAgIC8vIE5vdCBzaG93IGxhYmVsIGxpbmUgaWYgYGxhYmVsLm5vcm1hbC5zaG93ID0gZmFsc2VgXG4gICAgICAgICAgICBsYWJlbExpbmVOb3JtYWxPcHQuc2hvdyA9IGxhYmVsTGluZU5vcm1hbE9wdC5zaG93XG4gICAgICAgICAgICAgICAgJiYgb3B0aW9uLmxhYmVsLm5vcm1hbC5zaG93O1xuICAgICAgICAgICAgbGFiZWxMaW5lRW1waGFzaXNPcHQuc2hvdyA9IGxhYmVsTGluZUVtcGhhc2lzT3B0LnNob3dcbiAgICAgICAgICAgICAgICAmJiBvcHRpb24ubGFiZWwuZW1waGFzaXMuc2hvdztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBPdmVyd3JpdGVcbiAgICAgICAgZ2V0RGF0YVBhcmFtczogZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBGdW5uZWxTZXJpZXMuc3VwZXJDYWxsKHRoaXMsICdnZXREYXRhUGFyYW1zJywgZGF0YUluZGV4KTtcbiAgICAgICAgICAgIHZhciBzdW0gPSBkYXRhLmdldFN1bSgndmFsdWUnKTtcbiAgICAgICAgICAgIC8vIFBlcmNlbnQgaXMgMCBpZiBzdW0gaXMgMFxuICAgICAgICAgICAgcGFyYW1zLnBlcmNlbnQgPSAhc3VtID8gMCA6ICsoZGF0YS5nZXQoJ3ZhbHVlJywgZGF0YUluZGV4KSAvIHN1bSAqIDEwMCkudG9GaXhlZCgyKTtcblxuICAgICAgICAgICAgcGFyYW1zLiR2YXJzLnB1c2goJ3BlcmNlbnQnKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xuICAgICAgICAgICAgemxldmVsOiAwLCAgICAgICAgICAgICAgICAgIC8vIOS4gOe6p+WxguWPoFxuICAgICAgICAgICAgejogMiwgICAgICAgICAgICAgICAgICAgICAgIC8vIOS6jOe6p+WxguWPoFxuICAgICAgICAgICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgICAgICAgICAgbGVmdDogODAsXG4gICAgICAgICAgICB0b3A6IDYwLFxuICAgICAgICAgICAgcmlnaHQ6IDgwLFxuICAgICAgICAgICAgYm90dG9tOiA2MCxcbiAgICAgICAgICAgIC8vIHdpZHRoOiB7dG90YWxXaWR0aH0gLSBsZWZ0IC0gcmlnaHQsXG4gICAgICAgICAgICAvLyBoZWlnaHQ6IHt0b3RhbEhlaWdodH0gLSB0b3AgLSBib3R0b20sXG5cbiAgICAgICAgICAgIC8vIOm7mOiupOWPluaVsOaNruacgOWwj+acgOWkp+WAvFxuICAgICAgICAgICAgLy8gbWluOiAwLFxuICAgICAgICAgICAgLy8gbWF4OiAxMDAsXG4gICAgICAgICAgICBtaW5TaXplOiAnMCUnLFxuICAgICAgICAgICAgbWF4U2l6ZTogJzEwMCUnLFxuICAgICAgICAgICAgc29ydDogJ2Rlc2NlbmRpbmcnLCAvLyAnYXNjZW5kaW5nJywgJ2Rlc2NlbmRpbmcnXG4gICAgICAgICAgICBnYXA6IDAsXG4gICAgICAgICAgICBmdW5uZWxBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ291dGVyJ1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3JtYXR0ZXI6IOagh+etvuaWh+acrOagvOW8j+WZqO+8jOWQjFRvb2x0aXAuZm9ybWF0dGVy77yM5LiN5pSv5oyB5byC5q2l5Zue6LCDXG4gICAgICAgICAgICAgICAgICAgIC8vIHRleHRTdHlsZTogbnVsbCAgICAgIC8vIOm7mOiupOS9v+eUqOWFqOWxgOaWh+acrOagt+W8j++8jOivpuingVRFWFRTVFlMRVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW1waGFzaXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbExpbmU6IHtcbiAgICAgICAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiAyMCxcbiAgICAgICAgICAgICAgICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb2xvcjog5ZCE5byCLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc29saWQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVtcGhhc2lzOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2xvcjog5ZCE5byCLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW1waGFzaXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29sb3I6IOWQhOW8gixcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gRnVubmVsU2VyaWVzO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY2hhcnQvZnVubmVsL0Z1bm5lbFNlcmllcy5qc1xuLy8gbW9kdWxlIGlkID0gMTkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n    var graphic = __webpack_require__(34);\n    var zrUtil = __webpack_require__(20);\n\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function FunnelPiece(data, idx) {\n\n        graphic.Group.call(this);\n\n        var polygon = new graphic.Polygon();\n        var labelLine = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(polygon);\n        this.add(labelLine);\n        this.add(text);\n\n        this.updateData(data, idx, true);\n\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            labelLine.ignore = labelLine.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            labelLine.ignore = labelLine.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis)\n            .on('normal', onNormal)\n            .on('mouseover', onEmphasis)\n            .on('mouseout', onNormal);\n    }\n\n    var funnelPieceProto = FunnelPiece.prototype;\n\n    function getLabelStyle(data, idx, state, labelModel) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var position = labelModel.get('position');\n        var isLabelInside = position === 'inside' || position === 'inner' || position === 'center';\n        return {\n            fill: textStyleModel.getTextColor()\n                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(\n                data.hostModel.getFormattedLabel(idx, state),\n                data.getName(idx)\n            )\n        };\n    }\n\n    var opacityAccessPath = ['itemStyle', 'normal', 'opacity'];\n    funnelPieceProto.updateData = function (data, idx, firstCreate) {\n\n        var polygon = this.childAt(0);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var opacity = data.getItemModel(idx).get(opacityAccessPath);\n        opacity = opacity == null ? 1 : opacity;\n\n        // Reset style\n        polygon.useStyle({});\n\n        if (firstCreate) {\n            polygon.setShape({\n                points: layout.points\n            });\n            polygon.setStyle({ opacity : 0 });\n            graphic.initProps(polygon, {\n                style: {\n                    opacity: opacity\n                }\n            }, seriesModel, idx);\n        }\n        else {\n            graphic.updateProps(polygon, {\n                style: {\n                    opacity: opacity\n                },\n                shape: {\n                    points: layout.points\n                }\n            }, seriesModel, idx);\n        }\n\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        polygon.setStyle(\n            zrUtil.defaults(\n                {\n                    lineJoin: 'round',\n                    fill: visualColor\n                },\n                itemStyleModel.getModel('normal').getItemStyle(['opacity'])\n            )\n        );\n        polygon.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n        this._updateLabel(data, idx);\n\n        graphic.setHoverStyle(this);\n    };\n\n    funnelPieceProto._updateLabel = function (data, idx) {\n\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || labelLayout.linePoints\n            }\n        }, seriesModel, idx);\n\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textAlign: labelLayout.textAlign,\n                textVerticalAlign: labelLayout.verticalAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [labelLayout.x, labelLayout.y],\n            z2: 10\n        });\n\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel));\n\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n    };\n\n    zrUtil.inherits(FunnelPiece, graphic.Group);\n\n\n    var Funnel = __webpack_require__(96).extend({\n\n        type: 'funnel',\n\n        render: function (seriesModel, ecModel, api) {\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            var group = this.group;\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var funnelPiece = new FunnelPiece(data, idx);\n\n                    data.setItemGraphicEl(idx, funnelPiece);\n\n                    group.add(funnelPiece);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                    piePiece.updateData(data, newIdx);\n\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                })\n                .remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                })\n                .execute();\n\n            this._data = data;\n        },\n\n        remove: function () {\n            this.group.removeAll();\n            this._data = null;\n        },\n\n        dispose: function () {}\n    });\n\n    module.exports = Funnel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2Z1bm5lbC9GdW5uZWxWaWV3LmpzPzExZGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMIiwiZmlsZSI6IjE5Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICAvKipcbiAgICAgKiBQaWVjZSBvZiBwaWUgaW5jbHVkaW5nIFNlY3RvciwgTGFiZWwsIExhYmVsTGluZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZ1bm5lbFBpZWNlKGRhdGEsIGlkeCkge1xuXG4gICAgICAgIGdyYXBoaWMuR3JvdXAuY2FsbCh0aGlzKTtcblxuICAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBncmFwaGljLlBvbHlnb24oKTtcbiAgICAgICAgdmFyIGxhYmVsTGluZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKCk7XG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCgpO1xuICAgICAgICB0aGlzLmFkZChwb2x5Z29uKTtcbiAgICAgICAgdGhpcy5hZGQobGFiZWxMaW5lKTtcbiAgICAgICAgdGhpcy5hZGQodGV4dCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKGRhdGEsIGlkeCwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gSG92ZXIgdG8gY2hhbmdlIGxhYmVsIGFuZCBsYWJlbExpbmVcbiAgICAgICAgZnVuY3Rpb24gb25FbXBoYXNpcygpIHtcbiAgICAgICAgICAgIGxhYmVsTGluZS5pZ25vcmUgPSBsYWJlbExpbmUuaG92ZXJJZ25vcmU7XG4gICAgICAgICAgICB0ZXh0Lmlnbm9yZSA9IHRleHQuaG92ZXJJZ25vcmU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Ob3JtYWwoKSB7XG4gICAgICAgICAgICBsYWJlbExpbmUuaWdub3JlID0gbGFiZWxMaW5lLm5vcm1hbElnbm9yZTtcbiAgICAgICAgICAgIHRleHQuaWdub3JlID0gdGV4dC5ub3JtYWxJZ25vcmU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbignZW1waGFzaXMnLCBvbkVtcGhhc2lzKVxuICAgICAgICAgICAgLm9uKCdub3JtYWwnLCBvbk5vcm1hbClcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgb25FbXBoYXNpcylcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBvbk5vcm1hbCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bm5lbFBpZWNlUHJvdG8gPSBGdW5uZWxQaWVjZS5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBnZXRMYWJlbFN0eWxlKGRhdGEsIGlkeCwgc3RhdGUsIGxhYmVsTW9kZWwpIHtcbiAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gbGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgICAgICB2YXIgaXNMYWJlbEluc2lkZSA9IHBvc2l0aW9uID09PSAnaW5zaWRlJyB8fCBwb3NpdGlvbiA9PT0gJ2lubmVyJyB8fCBwb3NpdGlvbiA9PT0gJ2NlbnRlcic7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKVxuICAgICAgICAgICAgICAgIHx8IChpc0xhYmVsSW5zaWRlID8gJyNmZmYnIDogZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2NvbG9yJykpLFxuICAgICAgICAgICAgdGV4dEZvbnQ6IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcbiAgICAgICAgICAgIHRleHQ6IHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICBkYXRhLmhvc3RNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChpZHgsIHN0YXRlKSxcbiAgICAgICAgICAgICAgICBkYXRhLmdldE5hbWUoaWR4KVxuICAgICAgICAgICAgKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBvcGFjaXR5QWNjZXNzUGF0aCA9IFsnaXRlbVN0eWxlJywgJ25vcm1hbCcsICdvcGFjaXR5J107XG4gICAgZnVubmVsUGllY2VQcm90by51cGRhdGVEYXRhID0gZnVuY3Rpb24gKGRhdGEsIGlkeCwgZmlyc3RDcmVhdGUpIHtcblxuICAgICAgICB2YXIgcG9seWdvbiA9IHRoaXMuY2hpbGRBdCgwKTtcblxuICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpLmdldChvcGFjaXR5QWNjZXNzUGF0aCk7XG4gICAgICAgIG9wYWNpdHkgPSBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eTtcblxuICAgICAgICAvLyBSZXNldCBzdHlsZVxuICAgICAgICBwb2x5Z29uLnVzZVN0eWxlKHt9KTtcblxuICAgICAgICBpZiAoZmlyc3RDcmVhdGUpIHtcbiAgICAgICAgICAgIHBvbHlnb24uc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgIHBvaW50czogbGF5b3V0LnBvaW50c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb2x5Z29uLnNldFN0eWxlKHsgb3BhY2l0eSA6IDAgfSk7XG4gICAgICAgICAgICBncmFwaGljLmluaXRQcm9wcyhwb2x5Z29uLCB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2x5Z29uLCB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBsYXlvdXQucG9pbnRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgY29tbW9uIHN0eWxlXG4gICAgICAgIHZhciBpdGVtU3R5bGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJyk7XG4gICAgICAgIHZhciB2aXN1YWxDb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuXG4gICAgICAgIHBvbHlnb24uc2V0U3R5bGUoXG4gICAgICAgICAgICB6clV0aWwuZGVmYXVsdHMoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsaW5lSm9pbjogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogdmlzdWFsQ29sb3JcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGl0ZW1TdHlsZU1vZGVsLmdldE1vZGVsKCdub3JtYWwnKS5nZXRJdGVtU3R5bGUoWydvcGFjaXR5J10pXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIHBvbHlnb24uaG92ZXJTdHlsZSA9IGl0ZW1TdHlsZU1vZGVsLmdldE1vZGVsKCdlbXBoYXNpcycpLmdldEl0ZW1TdHlsZSgpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxhYmVsKGRhdGEsIGlkeCk7XG5cbiAgICAgICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKHRoaXMpO1xuICAgIH07XG5cbiAgICBmdW5uZWxQaWVjZVByb3RvLl91cGRhdGVMYWJlbCA9IGZ1bmN0aW9uIChkYXRhLCBpZHgpIHtcblxuICAgICAgICB2YXIgbGFiZWxMaW5lID0gdGhpcy5jaGlsZEF0KDEpO1xuICAgICAgICB2YXIgbGFiZWxUZXh0ID0gdGhpcy5jaGlsZEF0KDIpO1xuXG4gICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgICB2YXIgbGFiZWxMYXlvdXQgPSBsYXlvdXQubGFiZWw7XG4gICAgICAgIHZhciB2aXN1YWxDb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuXG4gICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMobGFiZWxMaW5lLCB7XG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgIHBvaW50czogbGFiZWxMYXlvdXQubGluZVBvaW50cyB8fCBsYWJlbExheW91dC5saW5lUG9pbnRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuXG4gICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMobGFiZWxUZXh0LCB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHg6IGxhYmVsTGF5b3V0LngsXG4gICAgICAgICAgICAgICAgeTogbGFiZWxMYXlvdXQueVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICAgICAgbGFiZWxUZXh0LmF0dHIoe1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IGxhYmVsTGF5b3V0LnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogbGFiZWxMYXlvdXQudmVydGljYWxBbGlnbixcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogbGFiZWxMYXlvdXQuZm9udFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBsYWJlbExheW91dC5yb3RhdGlvbixcbiAgICAgICAgICAgIG9yaWdpbjogW2xhYmVsTGF5b3V0LngsIGxhYmVsTGF5b3V0LnldLFxuICAgICAgICAgICAgejI6IDEwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBsYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbC5ub3JtYWwnKTtcbiAgICAgICAgdmFyIGxhYmVsSG92ZXJNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwuZW1waGFzaXMnKTtcbiAgICAgICAgdmFyIGxhYmVsTGluZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbExpbmUubm9ybWFsJyk7XG4gICAgICAgIHZhciBsYWJlbExpbmVIb3Zlck1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbExpbmUuZW1waGFzaXMnKTtcblxuICAgICAgICBsYWJlbFRleHQuc2V0U3R5bGUoZ2V0TGFiZWxTdHlsZShkYXRhLCBpZHgsICdub3JtYWwnLCBsYWJlbE1vZGVsKSk7XG5cbiAgICAgICAgbGFiZWxUZXh0Lmlnbm9yZSA9IGxhYmVsVGV4dC5ub3JtYWxJZ25vcmUgPSAhbGFiZWxNb2RlbC5nZXQoJ3Nob3cnKTtcbiAgICAgICAgbGFiZWxUZXh0LmhvdmVySWdub3JlID0gIWxhYmVsSG92ZXJNb2RlbC5nZXQoJ3Nob3cnKTtcblxuICAgICAgICBsYWJlbExpbmUuaWdub3JlID0gbGFiZWxMaW5lLm5vcm1hbElnbm9yZSA9ICFsYWJlbExpbmVNb2RlbC5nZXQoJ3Nob3cnKTtcbiAgICAgICAgbGFiZWxMaW5lLmhvdmVySWdub3JlID0gIWxhYmVsTGluZUhvdmVyTW9kZWwuZ2V0KCdzaG93Jyk7XG5cbiAgICAgICAgLy8gRGVmYXVsdCB1c2UgaXRlbSB2aXN1YWwgY29sb3JcbiAgICAgICAgbGFiZWxMaW5lLnNldFN0eWxlKHtcbiAgICAgICAgICAgIHN0cm9rZTogdmlzdWFsQ29sb3JcbiAgICAgICAgfSk7XG4gICAgICAgIGxhYmVsTGluZS5zZXRTdHlsZShsYWJlbExpbmVNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKCkpO1xuXG4gICAgICAgIGxhYmVsVGV4dC5ob3ZlclN0eWxlID0gZ2V0TGFiZWxTdHlsZShkYXRhLCBpZHgsICdlbXBoYXNpcycsIGxhYmVsSG92ZXJNb2RlbCk7XG4gICAgICAgIGxhYmVsTGluZS5ob3ZlclN0eWxlID0gbGFiZWxMaW5lSG92ZXJNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKCk7XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhGdW5uZWxQaWVjZSwgZ3JhcGhpYy5Hcm91cCk7XG5cblxuICAgIHZhciBGdW5uZWwgPSByZXF1aXJlKCcuLi8uLi92aWV3L0NoYXJ0JykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnZnVubmVsJyxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcblxuICAgICAgICAgICAgZGF0YS5kaWZmKG9sZERhdGEpXG4gICAgICAgICAgICAgICAgLmFkZChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5uZWxQaWVjZSA9IG5ldyBGdW5uZWxQaWVjZShkYXRhLCBpZHgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIGZ1bm5lbFBpZWNlKTtcblxuICAgICAgICAgICAgICAgICAgICBncm91cC5hZGQoZnVubmVsUGllY2UpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShmdW5jdGlvbiAobmV3SWR4LCBvbGRJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpZVBpZWNlID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGllUGllY2UudXBkYXRlRGF0YShkYXRhLCBuZXdJZHgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmFkZChwaWVQaWVjZSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIHBpZVBpZWNlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGllUGllY2UgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwoaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKHBpZVBpZWNlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5leGVjdXRlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHt9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEZ1bm5lbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jaGFydC9mdW5uZWwvRnVubmVsVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("\n\n    var layout = __webpack_require__(87);\n    var number = __webpack_require__(23);\n\n    var parsePercent = number.parsePercent;\n\n    function getViewRect(seriesModel, api) {\n        return layout.getLayoutRect(\n            seriesModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }\n        );\n    }\n\n    function getSortedIndices(data, sort) {\n        var valueArr = data.mapArray('value', function (val) {\n            return val;\n        });\n        var indices = [];\n        var isAscending = sort === 'ascending';\n        for (var i = 0, len = data.count(); i < len; i++) {\n            indices[i] = i;\n        }\n\n        // Add custom sortable function & none sortable opetion by \"options.sort\"\n        if (typeof sort === 'function') {\n            indices.sort(sort);\n        } else if (sort !== 'none') {\n            indices.sort(function (a, b) {\n                return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];\n            });\n        }\n        return indices;\n    }\n\n    function labelLayout (data) {\n        data.each(function (idx) {\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            var labelPosition = labelModel.get('position');\n\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n\n            var layout = data.getItemLayout(idx);\n            var points = layout.points;\n\n            var isLabelInside = labelPosition === 'inner'\n                || labelPosition === 'inside' || labelPosition === 'center';\n\n            var textAlign;\n            var textX;\n            var textY;\n            var linePoints;\n\n            if (isLabelInside) {\n                textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4;\n                textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4;\n                textAlign = 'center';\n                linePoints = [\n                    [textX, textY], [textX, textY]\n                ];\n            }\n            else {\n                var x1;\n                var y1;\n                var x2;\n                var labelLineLen = labelLineModel.get('length');\n                if (labelPosition === 'left') {\n                    // Left side\n                    x1 = (points[3][0] + points[0][0]) / 2;\n                    y1 = (points[3][1] + points[0][1]) / 2;\n                    x2 = x1 - labelLineLen;\n                    textX = x2 - 5;\n                    textAlign = 'right';\n                }\n                else {\n                    // Right side\n                    x1 = (points[1][0] + points[2][0]) / 2;\n                    y1 = (points[1][1] + points[2][1]) / 2;\n                    x2 = x1 + labelLineLen;\n                    textX = x2 + 5;\n                    textAlign = 'left';\n                }\n                var y2 = y1;\n\n                linePoints = [[x1, y1], [x2, y2]];\n                textY = y2;\n            }\n\n            layout.label = {\n                linePoints: linePoints,\n                x: textX,\n                y: textY,\n                verticalAlign: 'middle',\n                textAlign: textAlign,\n                inside: isLabelInside\n            };\n        });\n    }\n\n    module.exports = function (ecModel, api, payload) {\n        ecModel.eachSeriesByType('funnel', function (seriesModel) {\n            var data = seriesModel.getData();\n            var sort = seriesModel.get('sort');\n            var viewRect = getViewRect(seriesModel, api);\n            var indices = getSortedIndices(data, sort);\n\n            var sizeExtent = [\n                parsePercent(seriesModel.get('minSize'), viewRect.width),\n                parsePercent(seriesModel.get('maxSize'), viewRect.width)\n            ];\n            var dataExtent = data.getDataExtent('value');\n            var min = seriesModel.get('min');\n            var max = seriesModel.get('max');\n            if (min == null) {\n                min = Math.min(dataExtent[0], 0);\n            }\n            if (max == null) {\n                max = dataExtent[1];\n            }\n\n            var funnelAlign = seriesModel.get('funnelAlign');\n            var gap = seriesModel.get('gap');\n            var itemHeight = (viewRect.height - gap * (data.count() - 1)) / data.count();\n\n            var y = viewRect.y;\n\n            var getLinePoints = function (idx, offY) {\n                // End point index is data.count() and we assign it 0\n                var val = data.get('value', idx) || 0;\n                var itemWidth = number.linearMap(val, [min, max], sizeExtent, true);\n                var x0;\n                switch (funnelAlign) {\n                    case 'left':\n                        x0 = viewRect.x;\n                        break;\n                    case 'center':\n                        x0 = viewRect.x + (viewRect.width - itemWidth) / 2;\n                        break;\n                    case 'right':\n                        x0 = viewRect.x + viewRect.width - itemWidth;\n                        break;\n                }\n                return [\n                    [x0, offY],\n                    [x0 + itemWidth, offY]\n                ];\n            };\n\n            if (sort === 'ascending') {\n                // From bottom to top\n                itemHeight = -itemHeight;\n                gap = -gap;\n                y += viewRect.height;\n                indices = indices.reverse();\n            }\n\n            for (var i = 0; i < indices.length; i++) {\n                var idx = indices[i];\n                var nextIdx = indices[i + 1];\n                var start = getLinePoints(idx, y);\n                var end = getLinePoints(nextIdx, y + itemHeight);\n\n                y += itemHeight + gap;\n\n                data.setItemLayout(idx, {\n                    points: start.concat(end.slice().reverse())\n                });\n            }\n\n            labelLayout(data);\n        });\n    };\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L2Z1bm5lbC9mdW5uZWxMYXlvdXQuanM/NTgzNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQSxTQUFTO0FBQ1QiLCJmaWxlIjoiMTkzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgbGF5b3V0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9sYXlvdXQnKTtcbiAgICB2YXIgbnVtYmVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9udW1iZXInKTtcblxuICAgIHZhciBwYXJzZVBlcmNlbnQgPSBudW1iZXIucGFyc2VQZXJjZW50O1xuXG4gICAgZnVuY3Rpb24gZ2V0Vmlld1JlY3Qoc2VyaWVzTW9kZWwsIGFwaSkge1xuICAgICAgICByZXR1cm4gbGF5b3V0LmdldExheW91dFJlY3QoXG4gICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKSwge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNvcnRlZEluZGljZXMoZGF0YSwgc29ydCkge1xuICAgICAgICB2YXIgdmFsdWVBcnIgPSBkYXRhLm1hcEFycmF5KCd2YWx1ZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgaXNBc2NlbmRpbmcgPSBzb3J0ID09PSAnYXNjZW5kaW5nJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpbmRpY2VzW2ldID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBjdXN0b20gc29ydGFibGUgZnVuY3Rpb24gJiBub25lIHNvcnRhYmxlIG9wZXRpb24gYnkgXCJvcHRpb25zLnNvcnRcIlxuICAgICAgICBpZiAodHlwZW9mIHNvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGluZGljZXMuc29ydChzb3J0KTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3J0ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGluZGljZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0FzY2VuZGluZyA/IHZhbHVlQXJyW2FdIC0gdmFsdWVBcnJbYl0gOiB2YWx1ZUFycltiXSAtIHZhbHVlQXJyW2FdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGljZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFiZWxMYXlvdXQgKGRhdGEpIHtcbiAgICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgICAgICAgdmFyIGxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLm5vcm1hbCcpO1xuICAgICAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSBsYWJlbE1vZGVsLmdldCgncG9zaXRpb24nKTtcblxuICAgICAgICAgICAgdmFyIGxhYmVsTGluZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbExpbmUubm9ybWFsJyk7XG5cbiAgICAgICAgICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBsYXlvdXQucG9pbnRzO1xuXG4gICAgICAgICAgICB2YXIgaXNMYWJlbEluc2lkZSA9IGxhYmVsUG9zaXRpb24gPT09ICdpbm5lcidcbiAgICAgICAgICAgICAgICB8fCBsYWJlbFBvc2l0aW9uID09PSAnaW5zaWRlJyB8fCBsYWJlbFBvc2l0aW9uID09PSAnY2VudGVyJztcblxuICAgICAgICAgICAgdmFyIHRleHRBbGlnbjtcbiAgICAgICAgICAgIHZhciB0ZXh0WDtcbiAgICAgICAgICAgIHZhciB0ZXh0WTtcbiAgICAgICAgICAgIHZhciBsaW5lUG9pbnRzO1xuXG4gICAgICAgICAgICBpZiAoaXNMYWJlbEluc2lkZSkge1xuICAgICAgICAgICAgICAgIHRleHRYID0gKHBvaW50c1swXVswXSArIHBvaW50c1sxXVswXSArIHBvaW50c1syXVswXSArIHBvaW50c1szXVswXSkgLyA0O1xuICAgICAgICAgICAgICAgIHRleHRZID0gKHBvaW50c1swXVsxXSArIHBvaW50c1sxXVsxXSArIHBvaW50c1syXVsxXSArIHBvaW50c1szXVsxXSkgLyA0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGxpbmVQb2ludHMgPSBbXG4gICAgICAgICAgICAgICAgICAgIFt0ZXh0WCwgdGV4dFldLCBbdGV4dFgsIHRleHRZXVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgeDE7XG4gICAgICAgICAgICAgICAgdmFyIHkxO1xuICAgICAgICAgICAgICAgIHZhciB4MjtcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxMaW5lTGVuID0gbGFiZWxMaW5lTW9kZWwuZ2V0KCdsZW5ndGgnKTtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWxQb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlZnQgc2lkZVxuICAgICAgICAgICAgICAgICAgICB4MSA9IChwb2ludHNbM11bMF0gKyBwb2ludHNbMF1bMF0pIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSAocG9pbnRzWzNdWzFdICsgcG9pbnRzWzBdWzFdKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHgyID0geDEgLSBsYWJlbExpbmVMZW47XG4gICAgICAgICAgICAgICAgICAgIHRleHRYID0geDIgLSA1O1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmlnaHQgc2lkZVxuICAgICAgICAgICAgICAgICAgICB4MSA9IChwb2ludHNbMV1bMF0gKyBwb2ludHNbMl1bMF0pIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSAocG9pbnRzWzFdWzFdICsgcG9pbnRzWzJdWzFdKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHgyID0geDEgKyBsYWJlbExpbmVMZW47XG4gICAgICAgICAgICAgICAgICAgIHRleHRYID0geDIgKyA1O1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB5MiA9IHkxO1xuXG4gICAgICAgICAgICAgICAgbGluZVBvaW50cyA9IFtbeDEsIHkxXSwgW3gyLCB5Ml1dO1xuICAgICAgICAgICAgICAgIHRleHRZID0geTI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxheW91dC5sYWJlbCA9IHtcbiAgICAgICAgICAgICAgICBsaW5lUG9pbnRzOiBsaW5lUG9pbnRzLFxuICAgICAgICAgICAgICAgIHg6IHRleHRYLFxuICAgICAgICAgICAgICAgIHk6IHRleHRZLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgIGluc2lkZTogaXNMYWJlbEluc2lkZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgnZnVubmVsJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBzb3J0ID0gc2VyaWVzTW9kZWwuZ2V0KCdzb3J0Jyk7XG4gICAgICAgICAgICB2YXIgdmlld1JlY3QgPSBnZXRWaWV3UmVjdChzZXJpZXNNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gZ2V0U29ydGVkSW5kaWNlcyhkYXRhLCBzb3J0KTtcblxuICAgICAgICAgICAgdmFyIHNpemVFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgcGFyc2VQZXJjZW50KHNlcmllc01vZGVsLmdldCgnbWluU2l6ZScpLCB2aWV3UmVjdC53aWR0aCksXG4gICAgICAgICAgICAgICAgcGFyc2VQZXJjZW50KHNlcmllc01vZGVsLmdldCgnbWF4U2l6ZScpLCB2aWV3UmVjdC53aWR0aClcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgZGF0YUV4dGVudCA9IGRhdGEuZ2V0RGF0YUV4dGVudCgndmFsdWUnKTtcbiAgICAgICAgICAgIHZhciBtaW4gPSBzZXJpZXNNb2RlbC5nZXQoJ21pbicpO1xuICAgICAgICAgICAgdmFyIG1heCA9IHNlcmllc01vZGVsLmdldCgnbWF4Jyk7XG4gICAgICAgICAgICBpZiAobWluID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihkYXRhRXh0ZW50WzBdLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1heCA9IGRhdGFFeHRlbnRbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmdW5uZWxBbGlnbiA9IHNlcmllc01vZGVsLmdldCgnZnVubmVsQWxpZ24nKTtcbiAgICAgICAgICAgIHZhciBnYXAgPSBzZXJpZXNNb2RlbC5nZXQoJ2dhcCcpO1xuICAgICAgICAgICAgdmFyIGl0ZW1IZWlnaHQgPSAodmlld1JlY3QuaGVpZ2h0IC0gZ2FwICogKGRhdGEuY291bnQoKSAtIDEpKSAvIGRhdGEuY291bnQoKTtcblxuICAgICAgICAgICAgdmFyIHkgPSB2aWV3UmVjdC55O1xuXG4gICAgICAgICAgICB2YXIgZ2V0TGluZVBvaW50cyA9IGZ1bmN0aW9uIChpZHgsIG9mZlkpIHtcbiAgICAgICAgICAgICAgICAvLyBFbmQgcG9pbnQgaW5kZXggaXMgZGF0YS5jb3VudCgpIGFuZCB3ZSBhc3NpZ24gaXQgMFxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBkYXRhLmdldCgndmFsdWUnLCBpZHgpIHx8IDA7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1XaWR0aCA9IG51bWJlci5saW5lYXJNYXAodmFsLCBbbWluLCBtYXhdLCBzaXplRXh0ZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgeDA7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmdW5uZWxBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0gdmlld1JlY3QueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSB2aWV3UmVjdC54ICsgKHZpZXdSZWN0LndpZHRoIC0gaXRlbVdpZHRoKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSB2aWV3UmVjdC54ICsgdmlld1JlY3Qud2lkdGggLSBpdGVtV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgW3gwLCBvZmZZXSxcbiAgICAgICAgICAgICAgICAgICAgW3gwICsgaXRlbVdpZHRoLCBvZmZZXVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoc29ydCA9PT0gJ2FzY2VuZGluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBGcm9tIGJvdHRvbSB0byB0b3BcbiAgICAgICAgICAgICAgICBpdGVtSGVpZ2h0ID0gLWl0ZW1IZWlnaHQ7XG4gICAgICAgICAgICAgICAgZ2FwID0gLWdhcDtcbiAgICAgICAgICAgICAgICB5ICs9IHZpZXdSZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICBpbmRpY2VzID0gaW5kaWNlcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBpbmRpY2VzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0SWR4ID0gaW5kaWNlc1tpICsgMV07XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZ2V0TGluZVBvaW50cyhpZHgsIHkpO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBnZXRMaW5lUG9pbnRzKG5leHRJZHgsIHkgKyBpdGVtSGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIHkgKz0gaXRlbUhlaWdodCArIGdhcDtcblxuICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBzdGFydC5jb25jYXQoZW5kLnNsaWNlKCkucmV2ZXJzZSgpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYWJlbExheW91dChkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NoYXJ0L2Z1bm5lbC9mdW5uZWxMYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDE5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n    var echarts = __webpack_require__(17);\n\n    // Must use radar component\n    __webpack_require__(195);\n\n    __webpack_require__(200);\n    __webpack_require__(201);\n\n    echarts.registerVisual(zrUtil.curry(__webpack_require__(186), 'radar'));\n    echarts.registerVisual(zrUtil.curry(\n        __webpack_require__(178), 'radar', 'circle', null\n    ));\n    echarts.registerLayout(__webpack_require__(202));\n\n    echarts.registerProcessor(\n        zrUtil.curry(__webpack_require__(189), 'radar')\n    );\n\n    echarts.registerPreprocessor(__webpack_require__(203));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L3JhZGFyLmpzPzcwNDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxOTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uL2VjaGFydHMnKTtcblxuICAgIC8vIE11c3QgdXNlIHJhZGFyIGNvbXBvbmVudFxuICAgIHJlcXVpcmUoJy4uL2NvbXBvbmVudC9yYWRhcicpO1xuXG4gICAgcmVxdWlyZSgnLi9yYWRhci9SYWRhclNlcmllcycpO1xuICAgIHJlcXVpcmUoJy4vcmFkYXIvUmFkYXJWaWV3Jyk7XG5cbiAgICBlY2hhcnRzLnJlZ2lzdGVyVmlzdWFsKHpyVXRpbC5jdXJyeShyZXF1aXJlKCcuLi92aXN1YWwvZGF0YUNvbG9yJyksICdyYWRhcicpKTtcbiAgICBlY2hhcnRzLnJlZ2lzdGVyVmlzdWFsKHpyVXRpbC5jdXJyeShcbiAgICAgICAgcmVxdWlyZSgnLi4vdmlzdWFsL3N5bWJvbCcpLCAncmFkYXInLCAnY2lyY2xlJywgbnVsbFxuICAgICkpO1xuICAgIGVjaGFydHMucmVnaXN0ZXJMYXlvdXQocmVxdWlyZSgnLi9yYWRhci9yYWRhckxheW91dCcpKTtcblxuICAgIGVjaGFydHMucmVnaXN0ZXJQcm9jZXNzb3IoXG4gICAgICAgIHpyVXRpbC5jdXJyeShyZXF1aXJlKCcuLi9wcm9jZXNzb3IvZGF0YUZpbHRlcicpLCAncmFkYXInKVxuICAgICk7XG5cbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKHJlcXVpcmUoJy4vcmFkYXIvYmFja3dhcmRDb21wYXQnKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY2hhcnQvcmFkYXIuanNcbi8vIG1vZHVsZSBpZCA9IDE5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n\n    __webpack_require__(196);\n    __webpack_require__(198);\n\n    __webpack_require__(199);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9yYWRhci5qcz8wYzliIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIxOTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHJlcXVpcmUoJy4uL2Nvb3JkL3JhZGFyL1JhZGFyJyk7XG4gICAgcmVxdWlyZSgnLi4vY29vcmQvcmFkYXIvUmFkYXJNb2RlbCcpO1xuXG4gICAgcmVxdWlyZSgnLi9yYWRhci9SYWRhclZpZXcnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jb21wb25lbnQvcmFkYXIuanNcbi8vIG1vZHVsZSBpZCA9IDE5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("// TODO clockwise\n\n\n    var zrUtil = __webpack_require__(20);\n    var IndicatorAxis = __webpack_require__(197);\n    var IntervalScale = __webpack_require__(120);\n    var numberUtil = __webpack_require__(23);\n    var axisHelper = __webpack_require__(117);\n\n    function Radar(radarModel, ecModel, api) {\n\n        this._model = radarModel;\n        /**\n         * Radar dimensions\n         * @type {Array.<string>}\n         */\n        this.dimensions = [];\n\n        this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {\n            var dim = 'indicator_' + idx;\n            var indicatorAxis = new IndicatorAxis(dim, new IntervalScale());\n            indicatorAxis.name = indicatorModel.get('name');\n            // Inject model and axis\n            indicatorAxis.model = indicatorModel;\n            indicatorModel.axis = indicatorAxis;\n            this.dimensions.push(dim);\n            return indicatorAxis;\n        }, this);\n\n        this.resize(radarModel, api);\n\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.cx;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.cy;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.r;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.startAngle;\n    }\n\n    Radar.prototype.getIndicatorAxes = function () {\n        return this._indicatorAxes;\n    };\n\n    Radar.prototype.dataToPoint = function (value, indicatorIndex) {\n        var indicatorAxis = this._indicatorAxes[indicatorIndex];\n\n        return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);\n    };\n\n    Radar.prototype.coordToPoint = function (coord, indicatorIndex) {\n        var indicatorAxis = this._indicatorAxes[indicatorIndex];\n        var angle = indicatorAxis.angle;\n        var x = this.cx + coord * Math.cos(angle);\n        var y = this.cy - coord * Math.sin(angle);\n        return [x, y];\n    };\n\n    Radar.prototype.pointToData = function (pt) {\n        var dx = pt[0] - this.cx;\n        var dy = pt[1] - this.cy;\n        var radius = Math.sqrt(dx * dx + dy * dy);\n        dx /= radius;\n        dy /= radius;\n\n        var radian = Math.atan2(-dy, dx);\n\n        // Find the closest angle\n        // FIXME index can calculated directly\n        var minRadianDiff = Infinity;\n        var closestAxis;\n        var closestAxisIdx = -1;\n        for (var i = 0; i < this._indicatorAxes.length; i++) {\n            var indicatorAxis = this._indicatorAxes[i];\n            var diff = Math.abs(radian - indicatorAxis.angle);\n            if (diff < minRadianDiff) {\n                closestAxis = indicatorAxis;\n                closestAxisIdx = i;\n                minRadianDiff = diff;\n            }\n        }\n\n        return [closestAxisIdx, +(closestAxis && closestAxis.coodToData(radius))];\n    };\n\n    Radar.prototype.resize = function (radarModel, api) {\n        var center = radarModel.get('center');\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n        var viewSize = Math.min(viewWidth, viewHeight) / 2;\n        this.cx = numberUtil.parsePercent(center[0], viewWidth);\n        this.cy = numberUtil.parsePercent(center[1], viewHeight);\n\n        this.startAngle = radarModel.get('startAngle') * Math.PI / 180;\n\n        this.r = numberUtil.parsePercent(radarModel.get('radius'), viewSize);\n\n        zrUtil.each(this._indicatorAxes, function (indicatorAxis, idx) {\n            indicatorAxis.setExtent(0, this.r);\n            var angle = (this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length);\n            // Normalize to [-PI, PI]\n            angle = Math.atan2(Math.sin(angle), Math.cos(angle));\n            indicatorAxis.angle = angle;\n        }, this);\n    };\n\n    Radar.prototype.update = function (ecModel, api) {\n        var indicatorAxes = this._indicatorAxes;\n        var radarModel = this._model;\n        zrUtil.each(indicatorAxes, function (indicatorAxis) {\n            indicatorAxis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeriesByType('radar', function (radarSeries, idx) {\n            if (radarSeries.get('coordinateSystem') !== 'radar'\n                || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel\n            ) {\n                return;\n            }\n            var data = radarSeries.getData();\n            zrUtil.each(indicatorAxes, function (indicatorAxis) {\n                indicatorAxis.scale.unionExtentFromData(data, indicatorAxis.dim);\n            });\n        }, this);\n\n        var splitNumber = radarModel.get('splitNumber');\n\n        function increaseInterval(interval) {\n            var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10));\n            // Increase interval\n            var f = interval / exp10;\n            if (f === 2) {\n                f = 5;\n            }\n            else { // f is 2 or 5\n                f *= 2;\n            }\n            return f * exp10;\n        }\n        // Force all the axis fixing the maxSplitNumber.\n        zrUtil.each(indicatorAxes, function (indicatorAxis, idx) {\n            var rawExtent = axisHelper.getScaleExtent(indicatorAxis.scale, indicatorAxis.model);\n            axisHelper.niceScaleExtent(indicatorAxis.scale, indicatorAxis.model);\n\n            var axisModel = indicatorAxis.model;\n            var scale = indicatorAxis.scale;\n            var fixedMin = axisModel.getMin();\n            var fixedMax = axisModel.getMax();\n            var interval = scale.getInterval();\n\n            if (fixedMin != null && fixedMax != null) {\n                // User set min, max, divide to get new interval\n                scale.setExtent(+fixedMin, +fixedMax);\n                scale.setInterval(\n                    (fixedMax - fixedMin) / splitNumber\n                );\n            }\n            else if (fixedMin != null) {\n                var max;\n                // User set min, expand extent on the other side\n                do {\n                    max = fixedMin + interval * splitNumber;\n                    scale.setExtent(+fixedMin, max);\n                    // Interval must been set after extent\n                    // FIXME\n                    scale.setInterval(interval);\n\n                    interval = increaseInterval(interval);\n                } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));\n            }\n            else if (fixedMax != null) {\n                var min;\n                // User set min, expand extent on the other side\n                do {\n                    min = fixedMax - interval * splitNumber;\n                    scale.setExtent(min, +fixedMax);\n                    scale.setInterval(interval);\n                    interval = increaseInterval(interval);\n                } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));\n            }\n            else {\n                var nicedSplitNumber = scale.getTicks().length - 1;\n                if (nicedSplitNumber > splitNumber) {\n                    interval = increaseInterval(interval);\n                }\n                // PENDING\n                var center = Math.round((rawExtent[0] + rawExtent[1]) / 2 / interval) * interval;\n                var halfSplitNumber = Math.round(splitNumber / 2);\n                scale.setExtent(\n                    numberUtil.round(center - halfSplitNumber * interval),\n                    numberUtil.round(center + (splitNumber - halfSplitNumber) * interval)\n                );\n                scale.setInterval(interval);\n            }\n        });\n    };\n\n    /**\n     * Radar dimensions is based on the data\n     * @type {Array}\n     */\n    Radar.dimensions = [];\n\n    Radar.create = function (ecModel, api) {\n        var radarList = [];\n        ecModel.eachComponent('radar', function (radarModel) {\n            var radar = new Radar(radarModel, ecModel, api);\n            radarList.push(radar);\n            radarModel.coordinateSystem = radar;\n        });\n        ecModel.eachSeriesByType('radar', function (radarSeries) {\n            if (radarSeries.get('coordinateSystem') === 'radar') {\n                // Inject coordinate system\n                radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];\n            }\n        });\n        return radarList;\n    };\n\n    __webpack_require__(92).register('radar', Radar);\n    module.exports = Radar;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2Nvb3JkL3JhZGFyL1JhZGFyLmpzP2VhNTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIxOTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPIGNsb2Nrd2lzZVxuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIEluZGljYXRvckF4aXMgPSByZXF1aXJlKCcuL0luZGljYXRvckF4aXMnKTtcbiAgICB2YXIgSW50ZXJ2YWxTY2FsZSA9IHJlcXVpcmUoJy4uLy4uL3NjYWxlL0ludGVydmFsJyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bWJlcicpO1xuICAgIHZhciBheGlzSGVscGVyID0gcmVxdWlyZSgnLi4vYXhpc0hlbHBlcicpO1xuXG4gICAgZnVuY3Rpb24gUmFkYXIocmFkYXJNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgdGhpcy5fbW9kZWwgPSByYWRhck1vZGVsO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmFkYXIgZGltZW5zaW9uc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMgPSBbXTtcblxuICAgICAgICB0aGlzLl9pbmRpY2F0b3JBeGVzID0genJVdGlsLm1hcChyYWRhck1vZGVsLmdldEluZGljYXRvck1vZGVscygpLCBmdW5jdGlvbiAoaW5kaWNhdG9yTW9kZWwsIGlkeCkge1xuICAgICAgICAgICAgdmFyIGRpbSA9ICdpbmRpY2F0b3JfJyArIGlkeDtcbiAgICAgICAgICAgIHZhciBpbmRpY2F0b3JBeGlzID0gbmV3IEluZGljYXRvckF4aXMoZGltLCBuZXcgSW50ZXJ2YWxTY2FsZSgpKTtcbiAgICAgICAgICAgIGluZGljYXRvckF4aXMubmFtZSA9IGluZGljYXRvck1vZGVsLmdldCgnbmFtZScpO1xuICAgICAgICAgICAgLy8gSW5qZWN0IG1vZGVsIGFuZCBheGlzXG4gICAgICAgICAgICBpbmRpY2F0b3JBeGlzLm1vZGVsID0gaW5kaWNhdG9yTW9kZWw7XG4gICAgICAgICAgICBpbmRpY2F0b3JNb2RlbC5heGlzID0gaW5kaWNhdG9yQXhpcztcbiAgICAgICAgICAgIHRoaXMuZGltZW5zaW9ucy5wdXNoKGRpbSk7XG4gICAgICAgICAgICByZXR1cm4gaW5kaWNhdG9yQXhpcztcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5yZXNpemUocmFkYXJNb2RlbCwgYXBpKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN4O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN5O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRBbmdsZTtcbiAgICB9XG5cbiAgICBSYWRhci5wcm90b3R5cGUuZ2V0SW5kaWNhdG9yQXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZGljYXRvckF4ZXM7XG4gICAgfTtcblxuICAgIFJhZGFyLnByb3RvdHlwZS5kYXRhVG9Qb2ludCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kaWNhdG9ySW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGljYXRvckF4aXMgPSB0aGlzLl9pbmRpY2F0b3JBeGVzW2luZGljYXRvckluZGV4XTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb29yZFRvUG9pbnQoaW5kaWNhdG9yQXhpcy5kYXRhVG9Db29yZCh2YWx1ZSksIGluZGljYXRvckluZGV4KTtcbiAgICB9O1xuXG4gICAgUmFkYXIucHJvdG90eXBlLmNvb3JkVG9Qb2ludCA9IGZ1bmN0aW9uIChjb29yZCwgaW5kaWNhdG9ySW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGljYXRvckF4aXMgPSB0aGlzLl9pbmRpY2F0b3JBeGVzW2luZGljYXRvckluZGV4XTtcbiAgICAgICAgdmFyIGFuZ2xlID0gaW5kaWNhdG9yQXhpcy5hbmdsZTtcbiAgICAgICAgdmFyIHggPSB0aGlzLmN4ICsgY29vcmQgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHZhciB5ID0gdGhpcy5jeSAtIGNvb3JkICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH07XG5cbiAgICBSYWRhci5wcm90b3R5cGUucG9pbnRUb0RhdGEgPSBmdW5jdGlvbiAocHQpIHtcbiAgICAgICAgdmFyIGR4ID0gcHRbMF0gLSB0aGlzLmN4O1xuICAgICAgICB2YXIgZHkgPSBwdFsxXSAtIHRoaXMuY3k7XG4gICAgICAgIHZhciByYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICBkeCAvPSByYWRpdXM7XG4gICAgICAgIGR5IC89IHJhZGl1cztcblxuICAgICAgICB2YXIgcmFkaWFuID0gTWF0aC5hdGFuMigtZHksIGR4KTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IGFuZ2xlXG4gICAgICAgIC8vIEZJWE1FIGluZGV4IGNhbiBjYWxjdWxhdGVkIGRpcmVjdGx5XG4gICAgICAgIHZhciBtaW5SYWRpYW5EaWZmID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBjbG9zZXN0QXhpcztcbiAgICAgICAgdmFyIGNsb3Nlc3RBeGlzSWR4ID0gLTE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW5kaWNhdG9yQXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGluZGljYXRvckF4aXMgPSB0aGlzLl9pbmRpY2F0b3JBeGVzW2ldO1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhyYWRpYW4gLSBpbmRpY2F0b3JBeGlzLmFuZ2xlKTtcbiAgICAgICAgICAgIGlmIChkaWZmIDwgbWluUmFkaWFuRGlmZikge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RBeGlzID0gaW5kaWNhdG9yQXhpcztcbiAgICAgICAgICAgICAgICBjbG9zZXN0QXhpc0lkeCA9IGk7XG4gICAgICAgICAgICAgICAgbWluUmFkaWFuRGlmZiA9IGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2Nsb3Nlc3RBeGlzSWR4LCArKGNsb3Nlc3RBeGlzICYmIGNsb3Nlc3RBeGlzLmNvb2RUb0RhdGEocmFkaXVzKSldO1xuICAgIH07XG5cbiAgICBSYWRhci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHJhZGFyTW9kZWwsIGFwaSkge1xuICAgICAgICB2YXIgY2VudGVyID0gcmFkYXJNb2RlbC5nZXQoJ2NlbnRlcicpO1xuICAgICAgICB2YXIgdmlld1dpZHRoID0gYXBpLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciB2aWV3SGVpZ2h0ID0gYXBpLmdldEhlaWdodCgpO1xuICAgICAgICB2YXIgdmlld1NpemUgPSBNYXRoLm1pbih2aWV3V2lkdGgsIHZpZXdIZWlnaHQpIC8gMjtcbiAgICAgICAgdGhpcy5jeCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGNlbnRlclswXSwgdmlld1dpZHRoKTtcbiAgICAgICAgdGhpcy5jeSA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGNlbnRlclsxXSwgdmlld0hlaWdodCk7XG5cbiAgICAgICAgdGhpcy5zdGFydEFuZ2xlID0gcmFkYXJNb2RlbC5nZXQoJ3N0YXJ0QW5nbGUnKSAqIE1hdGguUEkgLyAxODA7XG5cbiAgICAgICAgdGhpcy5yID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQocmFkYXJNb2RlbC5nZXQoJ3JhZGl1cycpLCB2aWV3U2l6ZSk7XG5cbiAgICAgICAgenJVdGlsLmVhY2godGhpcy5faW5kaWNhdG9yQXhlcywgZnVuY3Rpb24gKGluZGljYXRvckF4aXMsIGlkeCkge1xuICAgICAgICAgICAgaW5kaWNhdG9yQXhpcy5zZXRFeHRlbnQoMCwgdGhpcy5yKTtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyBpZHggKiBNYXRoLlBJICogMiAvIHRoaXMuX2luZGljYXRvckF4ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBbLVBJLCBQSV1cbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihNYXRoLnNpbihhbmdsZSksIE1hdGguY29zKGFuZ2xlKSk7XG4gICAgICAgICAgICBpbmRpY2F0b3JBeGlzLmFuZ2xlID0gYW5nbGU7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICBSYWRhci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICB2YXIgaW5kaWNhdG9yQXhlcyA9IHRoaXMuX2luZGljYXRvckF4ZXM7XG4gICAgICAgIHZhciByYWRhck1vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgICAgIHpyVXRpbC5lYWNoKGluZGljYXRvckF4ZXMsIGZ1bmN0aW9uIChpbmRpY2F0b3JBeGlzKSB7XG4gICAgICAgICAgICBpbmRpY2F0b3JBeGlzLnNjYWxlLnNldEV4dGVudChJbmZpbml0eSwgLUluZmluaXR5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgncmFkYXInLCBmdW5jdGlvbiAocmFkYXJTZXJpZXMsIGlkeCkge1xuICAgICAgICAgICAgaWYgKHJhZGFyU2VyaWVzLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpICE9PSAncmFkYXInXG4gICAgICAgICAgICAgICAgfHwgZWNNb2RlbC5nZXRDb21wb25lbnQoJ3JhZGFyJywgcmFkYXJTZXJpZXMuZ2V0KCdyYWRhckluZGV4JykpICE9PSByYWRhck1vZGVsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHJhZGFyU2VyaWVzLmdldERhdGEoKTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGluZGljYXRvckF4ZXMsIGZ1bmN0aW9uIChpbmRpY2F0b3JBeGlzKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yQXhpcy5zY2FsZS51bmlvbkV4dGVudEZyb21EYXRhKGRhdGEsIGluZGljYXRvckF4aXMuZGltKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB2YXIgc3BsaXROdW1iZXIgPSByYWRhck1vZGVsLmdldCgnc3BsaXROdW1iZXInKTtcblxuICAgICAgICBmdW5jdGlvbiBpbmNyZWFzZUludGVydmFsKGludGVydmFsKSB7XG4gICAgICAgICAgICB2YXIgZXhwMTAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhpbnRlcnZhbCkgLyBNYXRoLkxOMTApKTtcbiAgICAgICAgICAgIC8vIEluY3JlYXNlIGludGVydmFsXG4gICAgICAgICAgICB2YXIgZiA9IGludGVydmFsIC8gZXhwMTA7XG4gICAgICAgICAgICBpZiAoZiA9PT0gMikge1xuICAgICAgICAgICAgICAgIGYgPSA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIGYgaXMgMiBvciA1XG4gICAgICAgICAgICAgICAgZiAqPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGYgKiBleHAxMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3JjZSBhbGwgdGhlIGF4aXMgZml4aW5nIHRoZSBtYXhTcGxpdE51bWJlci5cbiAgICAgICAgenJVdGlsLmVhY2goaW5kaWNhdG9yQXhlcywgZnVuY3Rpb24gKGluZGljYXRvckF4aXMsIGlkeCkge1xuICAgICAgICAgICAgdmFyIHJhd0V4dGVudCA9IGF4aXNIZWxwZXIuZ2V0U2NhbGVFeHRlbnQoaW5kaWNhdG9yQXhpcy5zY2FsZSwgaW5kaWNhdG9yQXhpcy5tb2RlbCk7XG4gICAgICAgICAgICBheGlzSGVscGVyLm5pY2VTY2FsZUV4dGVudChpbmRpY2F0b3JBeGlzLnNjYWxlLCBpbmRpY2F0b3JBeGlzLm1vZGVsKTtcblxuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGluZGljYXRvckF4aXMubW9kZWw7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBpbmRpY2F0b3JBeGlzLnNjYWxlO1xuICAgICAgICAgICAgdmFyIGZpeGVkTWluID0gYXhpc01vZGVsLmdldE1pbigpO1xuICAgICAgICAgICAgdmFyIGZpeGVkTWF4ID0gYXhpc01vZGVsLmdldE1heCgpO1xuICAgICAgICAgICAgdmFyIGludGVydmFsID0gc2NhbGUuZ2V0SW50ZXJ2YWwoKTtcblxuICAgICAgICAgICAgaWYgKGZpeGVkTWluICE9IG51bGwgJiYgZml4ZWRNYXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFVzZXIgc2V0IG1pbiwgbWF4LCBkaXZpZGUgdG8gZ2V0IG5ldyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIHNjYWxlLnNldEV4dGVudCgrZml4ZWRNaW4sICtmaXhlZE1heCk7XG4gICAgICAgICAgICAgICAgc2NhbGUuc2V0SW50ZXJ2YWwoXG4gICAgICAgICAgICAgICAgICAgIChmaXhlZE1heCAtIGZpeGVkTWluKSAvIHNwbGl0TnVtYmVyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpeGVkTWluICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4O1xuICAgICAgICAgICAgICAgIC8vIFVzZXIgc2V0IG1pbiwgZXhwYW5kIGV4dGVudCBvbiB0aGUgb3RoZXIgc2lkZVxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gZml4ZWRNaW4gKyBpbnRlcnZhbCAqIHNwbGl0TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBzY2FsZS5zZXRFeHRlbnQoK2ZpeGVkTWluLCBtYXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnRlcnZhbCBtdXN0IGJlZW4gc2V0IGFmdGVyIGV4dGVudFxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgICAgICBzY2FsZS5zZXRJbnRlcnZhbChpbnRlcnZhbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSBpbmNyZWFzZUludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChtYXggPCByYXdFeHRlbnRbMV0gJiYgaXNGaW5pdGUobWF4KSAmJiBpc0Zpbml0ZShyYXdFeHRlbnRbMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpeGVkTWF4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluO1xuICAgICAgICAgICAgICAgIC8vIFVzZXIgc2V0IG1pbiwgZXhwYW5kIGV4dGVudCBvbiB0aGUgb3RoZXIgc2lkZVxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gZml4ZWRNYXggLSBpbnRlcnZhbCAqIHNwbGl0TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBzY2FsZS5zZXRFeHRlbnQobWluLCArZml4ZWRNYXgpO1xuICAgICAgICAgICAgICAgICAgICBzY2FsZS5zZXRJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsID0gaW5jcmVhc2VJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAobWluID4gcmF3RXh0ZW50WzBdICYmIGlzRmluaXRlKG1pbikgJiYgaXNGaW5pdGUocmF3RXh0ZW50WzBdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbmljZWRTcGxpdE51bWJlciA9IHNjYWxlLmdldFRpY2tzKCkubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAobmljZWRTcGxpdE51bWJlciA+IHNwbGl0TnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsID0gaW5jcmVhc2VJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyID0gTWF0aC5yb3VuZCgocmF3RXh0ZW50WzBdICsgcmF3RXh0ZW50WzFdKSAvIDIgLyBpbnRlcnZhbCkgKiBpbnRlcnZhbDtcbiAgICAgICAgICAgICAgICB2YXIgaGFsZlNwbGl0TnVtYmVyID0gTWF0aC5yb3VuZChzcGxpdE51bWJlciAvIDIpO1xuICAgICAgICAgICAgICAgIHNjYWxlLnNldEV4dGVudChcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyVXRpbC5yb3VuZChjZW50ZXIgLSBoYWxmU3BsaXROdW1iZXIgKiBpbnRlcnZhbCksXG4gICAgICAgICAgICAgICAgICAgIG51bWJlclV0aWwucm91bmQoY2VudGVyICsgKHNwbGl0TnVtYmVyIC0gaGFsZlNwbGl0TnVtYmVyKSAqIGludGVydmFsKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgc2NhbGUuc2V0SW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmFkYXIgZGltZW5zaW9ucyBpcyBiYXNlZCBvbiB0aGUgZGF0YVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBSYWRhci5kaW1lbnNpb25zID0gW107XG5cbiAgICBSYWRhci5jcmVhdGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHZhciByYWRhckxpc3QgPSBbXTtcbiAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdyYWRhcicsIGZ1bmN0aW9uIChyYWRhck1vZGVsKSB7XG4gICAgICAgICAgICB2YXIgcmFkYXIgPSBuZXcgUmFkYXIocmFkYXJNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgIHJhZGFyTGlzdC5wdXNoKHJhZGFyKTtcbiAgICAgICAgICAgIHJhZGFyTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA9IHJhZGFyO1xuICAgICAgICB9KTtcbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCdyYWRhcicsIGZ1bmN0aW9uIChyYWRhclNlcmllcykge1xuICAgICAgICAgICAgaWYgKHJhZGFyU2VyaWVzLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpID09PSAncmFkYXInKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5qZWN0IGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICAgICAgICAgICAgcmFkYXJTZXJpZXMuY29vcmRpbmF0ZVN5c3RlbSA9IHJhZGFyTGlzdFtyYWRhclNlcmllcy5nZXQoJ3JhZGFySW5kZXgnKSB8fCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByYWRhckxpc3Q7XG4gICAgfTtcblxuICAgIHJlcXVpcmUoJy4uLy4uL0Nvb3JkaW5hdGVTeXN0ZW0nKS5yZWdpc3RlcigncmFkYXInLCBSYWRhcik7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSYWRhcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jb29yZC9yYWRhci9SYWRhci5qc1xuLy8gbW9kdWxlIGlkID0gMTk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("\n\n    var zrUtil = __webpack_require__(20);\n    var Axis = __webpack_require__(116);\n\n    function IndicatorAxis(dim, scale, radiusExtent) {\n        Axis.call(this, dim, scale, radiusExtent);\n\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = 'value';\n\n        this.angle = 0;\n\n        /**\n         * Indicator name\n         * @type {string}\n         */\n        this.name = '';\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.model;\n    }\n\n    zrUtil.inherits(IndicatorAxis, Axis);\n\n    module.exports = IndicatorAxis;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2Nvb3JkL3JhZGFyL0luZGljYXRvckF4aXMuanM/NDU3OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiMTk3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIEF4aXMgPSByZXF1aXJlKCcuLi9BeGlzJyk7XG5cbiAgICBmdW5jdGlvbiBJbmRpY2F0b3JBeGlzKGRpbSwgc2NhbGUsIHJhZGl1c0V4dGVudCkge1xuICAgICAgICBBeGlzLmNhbGwodGhpcywgZGltLCBzY2FsZSwgcmFkaXVzRXh0ZW50KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXhpcyB0eXBlXG4gICAgICAgICAqICAtICdjYXRlZ29yeSdcbiAgICAgICAgICogIC0gJ3ZhbHVlJ1xuICAgICAgICAgKiAgLSAndGltZSdcbiAgICAgICAgICogIC0gJ2xvZydcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9ICd2YWx1ZSc7XG5cbiAgICAgICAgdGhpcy5hbmdsZSA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRvciBuYW1lXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW9kZWw7XG4gICAgfVxuXG4gICAgenJVdGlsLmluaGVyaXRzKEluZGljYXRvckF4aXMsIEF4aXMpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBJbmRpY2F0b3JBeGlzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2Nvb3JkL3JhZGFyL0luZGljYXRvckF4aXMuanNcbi8vIG1vZHVsZSBpZCA9IDE5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n\n\n    var axisDefault = __webpack_require__(160);\n    var valueAxisDefault = axisDefault.valueAxis;\n    var Model = __webpack_require__(28);\n    var zrUtil = __webpack_require__(20);\n\n    var axisModelCommonMixin = __webpack_require__(128);\n\n    function defaultsShow(opt, show) {\n        return zrUtil.defaults({\n            show: show\n        }, opt);\n    }\n\n    var RadarModel = __webpack_require__(17).extendComponentModel({\n\n        type: 'radar',\n\n        optionUpdated: function () {\n            var boundaryGap = this.get('boundaryGap');\n            var splitNumber = this.get('splitNumber');\n            var scale = this.get('scale');\n            var axisLine = this.get('axisLine');\n            var axisTick = this.get('axisTick');\n            var axisLabel = this.get('axisLabel');\n            var nameTextStyle = this.get('name.textStyle');\n            var showName = this.get('name.show');\n            var nameFormatter = this.get('name.formatter');\n            var nameGap = this.get('nameGap');\n            var triggerEvent = this.get('triggerEvent');\n\n            var indicatorModels = zrUtil.map(this.get('indicator') || [], function (indicatorOpt) {\n                // PENDING\n                if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {\n                    indicatorOpt.min = 0;\n                }\n                else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {\n                    indicatorOpt.max = 0;\n                }\n                // Use same configuration\n                indicatorOpt = zrUtil.merge(zrUtil.clone(indicatorOpt), {\n                    boundaryGap: boundaryGap,\n                    splitNumber: splitNumber,\n                    scale: scale,\n                    axisLine: axisLine,\n                    axisTick: axisTick,\n                    axisLabel: axisLabel,\n                    // Competitable with 2 and use text\n                    name: indicatorOpt.text,\n                    nameLocation: 'end',\n                    nameGap: nameGap,\n                    // min: 0,\n                    nameTextStyle: nameTextStyle,\n                    triggerEvent: triggerEvent\n                }, false);\n                if (!showName) {\n                    indicatorOpt.name = '';\n                }\n                if (typeof nameFormatter === 'string') {\n                    var indName = indicatorOpt.name;\n                    indicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : '');\n                }\n                else if (typeof nameFormatter === 'function') {\n                    indicatorOpt.name = nameFormatter(\n                        indicatorOpt.name, indicatorOpt\n                    );\n                }\n                var model = zrUtil.extend(\n                    new Model(indicatorOpt, null, this.ecModel),\n                    axisModelCommonMixin\n                );\n\n                // For triggerEvent.\n                model.mainType = 'radar';\n                model.componentIndex = this.componentIndex;\n\n                return model;\n            }, this);\n\n            this.getIndicatorModels = function () {\n                return indicatorModels;\n            };\n        },\n\n        defaultOption: {\n\n            zlevel: 0,\n\n            z: 0,\n\n            center: ['50%', '50%'],\n\n            radius: '75%',\n\n            startAngle: 90,\n\n            name: {\n                show: true\n                // formatter: null\n                // textStyle: {}\n            },\n\n            boundaryGap: [0, 0],\n\n            splitNumber: 5,\n\n            nameGap: 15,\n\n            scale: false,\n\n            // Polygon or circle\n            shape: 'polygon',\n\n            axisLine: zrUtil.merge(\n                {\n                    lineStyle: {\n                        color: '#bbb'\n                    }\n                },\n                valueAxisDefault.axisLine\n            ),\n            axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),\n            axisTick: defaultsShow(valueAxisDefault.axisTick, false),\n            splitLine: defaultsShow(valueAxisDefault.splitLine, true),\n            splitArea: defaultsShow(valueAxisDefault.splitArea, true),\n\n            // {text, min, max}\n            indicator: []\n        }\n    });\n\n    module.exports = RadarModel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2Nvb3JkL3JhZGFyL1JhZGFyTW9kZWwuanM/NjI1YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxNQUFNO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLEtBQUs7O0FBRUwiLCJmaWxlIjoiMTk4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cblxuICAgIHZhciBheGlzRGVmYXVsdCA9IHJlcXVpcmUoJy4uL2F4aXNEZWZhdWx0Jyk7XG4gICAgdmFyIHZhbHVlQXhpc0RlZmF1bHQgPSBheGlzRGVmYXVsdC52YWx1ZUF4aXM7XG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvTW9kZWwnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgYXhpc01vZGVsQ29tbW9uTWl4aW4gPSByZXF1aXJlKCcuLi9heGlzTW9kZWxDb21tb25NaXhpbicpO1xuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHNTaG93KG9wdCwgc2hvdykge1xuICAgICAgICByZXR1cm4genJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgICAgIHNob3c6IHNob3dcbiAgICAgICAgfSwgb3B0KTtcbiAgICB9XG5cbiAgICB2YXIgUmFkYXJNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRDb21wb25lbnRNb2RlbCh7XG5cbiAgICAgICAgdHlwZTogJ3JhZGFyJyxcblxuICAgICAgICBvcHRpb25VcGRhdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYm91bmRhcnlHYXAgPSB0aGlzLmdldCgnYm91bmRhcnlHYXAnKTtcbiAgICAgICAgICAgIHZhciBzcGxpdE51bWJlciA9IHRoaXMuZ2V0KCdzcGxpdE51bWJlcicpO1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXQoJ3NjYWxlJyk7XG4gICAgICAgICAgICB2YXIgYXhpc0xpbmUgPSB0aGlzLmdldCgnYXhpc0xpbmUnKTtcbiAgICAgICAgICAgIHZhciBheGlzVGljayA9IHRoaXMuZ2V0KCdheGlzVGljaycpO1xuICAgICAgICAgICAgdmFyIGF4aXNMYWJlbCA9IHRoaXMuZ2V0KCdheGlzTGFiZWwnKTtcbiAgICAgICAgICAgIHZhciBuYW1lVGV4dFN0eWxlID0gdGhpcy5nZXQoJ25hbWUudGV4dFN0eWxlJyk7XG4gICAgICAgICAgICB2YXIgc2hvd05hbWUgPSB0aGlzLmdldCgnbmFtZS5zaG93Jyk7XG4gICAgICAgICAgICB2YXIgbmFtZUZvcm1hdHRlciA9IHRoaXMuZ2V0KCduYW1lLmZvcm1hdHRlcicpO1xuICAgICAgICAgICAgdmFyIG5hbWVHYXAgPSB0aGlzLmdldCgnbmFtZUdhcCcpO1xuICAgICAgICAgICAgdmFyIHRyaWdnZXJFdmVudCA9IHRoaXMuZ2V0KCd0cmlnZ2VyRXZlbnQnKTtcblxuICAgICAgICAgICAgdmFyIGluZGljYXRvck1vZGVscyA9IHpyVXRpbC5tYXAodGhpcy5nZXQoJ2luZGljYXRvcicpIHx8IFtdLCBmdW5jdGlvbiAoaW5kaWNhdG9yT3B0KSB7XG4gICAgICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgICAgIGlmIChpbmRpY2F0b3JPcHQubWF4ICE9IG51bGwgJiYgaW5kaWNhdG9yT3B0Lm1heCA+IDAgJiYgIWluZGljYXRvck9wdC5taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yT3B0Lm1pbiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZGljYXRvck9wdC5taW4gIT0gbnVsbCAmJiBpbmRpY2F0b3JPcHQubWluIDwgMCAmJiAhaW5kaWNhdG9yT3B0Lm1heCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3JPcHQubWF4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVXNlIHNhbWUgY29uZmlndXJhdGlvblxuICAgICAgICAgICAgICAgIGluZGljYXRvck9wdCA9IHpyVXRpbC5tZXJnZSh6clV0aWwuY2xvbmUoaW5kaWNhdG9yT3B0KSwge1xuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeUdhcDogYm91bmRhcnlHYXAsXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0TnVtYmVyOiBzcGxpdE51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICAgICAgICAgICAgICBheGlzTGluZTogYXhpc0xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGF4aXNUaWNrOiBheGlzVGljayxcbiAgICAgICAgICAgICAgICAgICAgYXhpc0xhYmVsOiBheGlzTGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXBldGl0YWJsZSB3aXRoIDIgYW5kIHVzZSB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGluZGljYXRvck9wdC50ZXh0LFxuICAgICAgICAgICAgICAgICAgICBuYW1lTG9jYXRpb246ICdlbmQnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lR2FwOiBuYW1lR2FwLFxuICAgICAgICAgICAgICAgICAgICAvLyBtaW46IDAsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVUZXh0U3R5bGU6IG5hbWVUZXh0U3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudDogdHJpZ2dlckV2ZW50XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmICghc2hvd05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yT3B0Lm5hbWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lRm9ybWF0dGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kTmFtZSA9IGluZGljYXRvck9wdC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3JPcHQubmFtZSA9IG5hbWVGb3JtYXR0ZXIucmVwbGFjZSgne3ZhbHVlfScsIGluZE5hbWUgIT0gbnVsbCA/IGluZE5hbWUgOiAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBuYW1lRm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvck9wdC5uYW1lID0gbmFtZUZvcm1hdHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGljYXRvck9wdC5uYW1lLCBpbmRpY2F0b3JPcHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1vZGVsID0genJVdGlsLmV4dGVuZChcbiAgICAgICAgICAgICAgICAgICAgbmV3IE1vZGVsKGluZGljYXRvck9wdCwgbnVsbCwgdGhpcy5lY01vZGVsKSxcbiAgICAgICAgICAgICAgICAgICAgYXhpc01vZGVsQ29tbW9uTWl4aW5cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIHRyaWdnZXJFdmVudC5cbiAgICAgICAgICAgICAgICBtb2RlbC5tYWluVHlwZSA9ICdyYWRhcic7XG4gICAgICAgICAgICAgICAgbW9kZWwuY29tcG9uZW50SW5kZXggPSB0aGlzLmNvbXBvbmVudEluZGV4O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0SW5kaWNhdG9yTW9kZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRpY2F0b3JNb2RlbHM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcblxuICAgICAgICAgICAgemxldmVsOiAwLFxuXG4gICAgICAgICAgICB6OiAwLFxuXG4gICAgICAgICAgICBjZW50ZXI6IFsnNTAlJywgJzUwJSddLFxuXG4gICAgICAgICAgICByYWRpdXM6ICc3NSUnLFxuXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiA5MCxcblxuICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgIHNob3c6IHRydWVcbiAgICAgICAgICAgICAgICAvLyBmb3JtYXR0ZXI6IG51bGxcbiAgICAgICAgICAgICAgICAvLyB0ZXh0U3R5bGU6IHt9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBib3VuZGFyeUdhcDogWzAsIDBdLFxuXG4gICAgICAgICAgICBzcGxpdE51bWJlcjogNSxcblxuICAgICAgICAgICAgbmFtZUdhcDogMTUsXG5cbiAgICAgICAgICAgIHNjYWxlOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gUG9seWdvbiBvciBjaXJjbGVcbiAgICAgICAgICAgIHNoYXBlOiAncG9seWdvbicsXG5cbiAgICAgICAgICAgIGF4aXNMaW5lOiB6clV0aWwubWVyZ2UoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI2JiYidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmFsdWVBeGlzRGVmYXVsdC5heGlzTGluZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGF4aXNMYWJlbDogZGVmYXVsdHNTaG93KHZhbHVlQXhpc0RlZmF1bHQuYXhpc0xhYmVsLCBmYWxzZSksXG4gICAgICAgICAgICBheGlzVGljazogZGVmYXVsdHNTaG93KHZhbHVlQXhpc0RlZmF1bHQuYXhpc1RpY2ssIGZhbHNlKSxcbiAgICAgICAgICAgIHNwbGl0TGluZTogZGVmYXVsdHNTaG93KHZhbHVlQXhpc0RlZmF1bHQuc3BsaXRMaW5lLCB0cnVlKSxcbiAgICAgICAgICAgIHNwbGl0QXJlYTogZGVmYXVsdHNTaG93KHZhbHVlQXhpc0RlZmF1bHQuc3BsaXRBcmVhLCB0cnVlKSxcblxuICAgICAgICAgICAgLy8ge3RleHQsIG1pbiwgbWF4fVxuICAgICAgICAgICAgaW5kaWNhdG9yOiBbXVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJhZGFyTW9kZWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29vcmQvcmFkYXIvUmFkYXJNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n    var AxisBuilder = __webpack_require__(140);\n    var zrUtil = __webpack_require__(20);\n    var graphic = __webpack_require__(34);\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n\n    module.exports = __webpack_require__(17).extendComponentView({\n\n        type: 'radar',\n\n        render: function (radarModel, ecModel, api) {\n            var group = this.group;\n            group.removeAll();\n\n            this._buildAxes(radarModel);\n            this._buildSplitLineAndArea(radarModel);\n        },\n\n        _buildAxes: function (radarModel) {\n            var radar = radarModel.coordinateSystem;\n            var indicatorAxes = radar.getIndicatorAxes();\n            var axisBuilders = zrUtil.map(indicatorAxes, function (indicatorAxis) {\n                var axisBuilder = new AxisBuilder(indicatorAxis.model, {\n                    position: [radar.cx, radar.cy],\n                    rotation: indicatorAxis.angle,\n                    labelDirection: -1,\n                    tickDirection: -1,\n                    nameDirection: 1\n                });\n                return axisBuilder;\n            });\n\n            zrUtil.each(axisBuilders, function (axisBuilder) {\n                zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n                this.group.add(axisBuilder.getGroup());\n            }, this);\n        },\n\n        _buildSplitLineAndArea: function (radarModel) {\n            var radar = radarModel.coordinateSystem;\n            var indicatorAxes = radar.getIndicatorAxes();\n            if (!indicatorAxes.length) {\n                return;\n            }\n            var shape = radarModel.get('shape');\n            var splitLineModel = radarModel.getModel('splitLine');\n            var splitAreaModel = radarModel.getModel('splitArea');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n\n            var showSplitLine = splitLineModel.get('show');\n            var showSplitArea = splitAreaModel.get('show');\n            var splitLineColors = lineStyleModel.get('color');\n            var splitAreaColors = areaStyleModel.get('color');\n\n            splitLineColors = zrUtil.isArray(splitLineColors) ? splitLineColors : [splitLineColors];\n            splitAreaColors = zrUtil.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];\n\n            var splitLines = [];\n            var splitAreas = [];\n\n            function getColorIndex(areaOrLine, areaOrLineColorList, idx) {\n                var colorIndex = idx % areaOrLineColorList.length;\n                areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];\n                return colorIndex;\n            }\n\n            if (shape === 'circle') {\n                var ticksRadius = indicatorAxes[0].getTicksCoords();\n                var cx = radar.cx;\n                var cy = radar.cy;\n                for (var i = 0; i < ticksRadius.length; i++) {\n                    if (showSplitLine) {\n                        var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n                        splitLines[colorIndex].push(new graphic.Circle({\n                            shape: {\n                                cx: cx,\n                                cy: cy,\n                                r: ticksRadius[i]\n                            }\n                        }));\n                    }\n                    if (showSplitArea && i < ticksRadius.length - 1) {\n                        var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);\n                        splitAreas[colorIndex].push(new graphic.Ring({\n                            shape: {\n                                cx: cx,\n                                cy: cy,\n                                r0: ticksRadius[i],\n                                r: ticksRadius[i + 1]\n                            }\n                        }));\n                    }\n                }\n            }\n            // Polyyon\n            else {\n                var realSplitNumber;\n                var axesTicksPoints = zrUtil.map(indicatorAxes, function (indicatorAxis, idx) {\n                    var ticksCoords = indicatorAxis.getTicksCoords();\n                    realSplitNumber = realSplitNumber == null\n                        ? ticksCoords.length - 1\n                        : Math.min(ticksCoords.length - 1, realSplitNumber);\n                    return zrUtil.map(ticksCoords, function (tickCoord) {\n                        return radar.coordToPoint(tickCoord, idx);\n                    });\n                });\n\n                var prevPoints = [];\n                for (var i = 0; i <= realSplitNumber; i++) {\n                    var points = [];\n                    for (var j = 0; j < indicatorAxes.length; j++) {\n                        points.push(axesTicksPoints[j][i]);\n                    }\n                    // Close\n                    if (points[0]) {\n                        points.push(points[0].slice());\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.error('Can\\'t draw value axis ' + i);\n                        }\n                    }\n\n                    if (showSplitLine) {\n                        var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n                        splitLines[colorIndex].push(new graphic.Polyline({\n                            shape: {\n                                points: points\n                            }\n                        }));\n                    }\n                    if (showSplitArea && prevPoints) {\n                        var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);\n                        splitAreas[colorIndex].push(new graphic.Polygon({\n                            shape: {\n                                points: points.concat(prevPoints)\n                            }\n                        }));\n                    }\n                    prevPoints = points.slice().reverse();\n                }\n            }\n\n            var lineStyle = lineStyleModel.getLineStyle();\n            var areaStyle = areaStyleModel.getAreaStyle();\n            // Add splitArea before splitLine\n            zrUtil.each(splitAreas, function (splitAreas, idx) {\n                this.group.add(graphic.mergePath(\n                    splitAreas, {\n                        style: zrUtil.defaults({\n                            stroke: 'none',\n                            fill: splitAreaColors[idx % splitAreaColors.length]\n                        }, areaStyle),\n                        silent: true\n                    }\n                ));\n            }, this);\n\n            zrUtil.each(splitLines, function (splitLines, idx) {\n                this.group.add(graphic.mergePath(\n                    splitLines, {\n                        style: zrUtil.defaults({\n                            fill: 'none',\n                            stroke: splitLineColors[idx % splitLineColors.length]\n                        }, lineStyle),\n                        silent: true\n                    }\n                ));\n            }, this);\n\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9yYWRhci9SYWRhclZpZXcuanM/ZjFmZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakI7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEO0FBQ0EsbUNBQW1DLDBCQUEwQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLEtBQUsiLCJmaWxlIjoiMTk5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgQXhpc0J1aWxkZXIgPSByZXF1aXJlKCcuLi9heGlzL0F4aXNCdWlsZGVyJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG5cbiAgICB2YXIgYXhpc0J1aWxkZXJBdHRycyA9IFtcbiAgICAgICAgJ2F4aXNMaW5lJywgJ2F4aXNMYWJlbCcsICdheGlzVGljaycsICdheGlzTmFtZSdcbiAgICBdO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJykuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ3JhZGFyJyxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChyYWRhck1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgICAgICAgICBncm91cC5yZW1vdmVBbGwoKTtcblxuICAgICAgICAgICAgdGhpcy5fYnVpbGRBeGVzKHJhZGFyTW9kZWwpO1xuICAgICAgICAgICAgdGhpcy5fYnVpbGRTcGxpdExpbmVBbmRBcmVhKHJhZGFyTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9idWlsZEF4ZXM6IGZ1bmN0aW9uIChyYWRhck1vZGVsKSB7XG4gICAgICAgICAgICB2YXIgcmFkYXIgPSByYWRhck1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICB2YXIgaW5kaWNhdG9yQXhlcyA9IHJhZGFyLmdldEluZGljYXRvckF4ZXMoKTtcbiAgICAgICAgICAgIHZhciBheGlzQnVpbGRlcnMgPSB6clV0aWwubWFwKGluZGljYXRvckF4ZXMsIGZ1bmN0aW9uIChpbmRpY2F0b3JBeGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNCdWlsZGVyID0gbmV3IEF4aXNCdWlsZGVyKGluZGljYXRvckF4aXMubW9kZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFtyYWRhci5jeCwgcmFkYXIuY3ldLFxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogaW5kaWNhdG9yQXhpcy5hbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEaXJlY3Rpb246IC0xLFxuICAgICAgICAgICAgICAgICAgICB0aWNrRGlyZWN0aW9uOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZURpcmVjdGlvbjogMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBheGlzQnVpbGRlcjtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB6clV0aWwuZWFjaChheGlzQnVpbGRlcnMsIGZ1bmN0aW9uIChheGlzQnVpbGRlcikge1xuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKGF4aXNCdWlsZGVyQXR0cnMsIGF4aXNCdWlsZGVyLmFkZCwgYXhpc0J1aWxkZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKGF4aXNCdWlsZGVyLmdldEdyb3VwKCkpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2J1aWxkU3BsaXRMaW5lQW5kQXJlYTogZnVuY3Rpb24gKHJhZGFyTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciByYWRhciA9IHJhZGFyTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIHZhciBpbmRpY2F0b3JBeGVzID0gcmFkYXIuZ2V0SW5kaWNhdG9yQXhlcygpO1xuICAgICAgICAgICAgaWYgKCFpbmRpY2F0b3JBeGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHJhZGFyTW9kZWwuZ2V0KCdzaGFwZScpO1xuICAgICAgICAgICAgdmFyIHNwbGl0TGluZU1vZGVsID0gcmFkYXJNb2RlbC5nZXRNb2RlbCgnc3BsaXRMaW5lJyk7XG4gICAgICAgICAgICB2YXIgc3BsaXRBcmVhTW9kZWwgPSByYWRhck1vZGVsLmdldE1vZGVsKCdzcGxpdEFyZWEnKTtcbiAgICAgICAgICAgIHZhciBsaW5lU3R5bGVNb2RlbCA9IHNwbGl0TGluZU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKTtcbiAgICAgICAgICAgIHZhciBhcmVhU3R5bGVNb2RlbCA9IHNwbGl0QXJlYU1vZGVsLmdldE1vZGVsKCdhcmVhU3R5bGUnKTtcblxuICAgICAgICAgICAgdmFyIHNob3dTcGxpdExpbmUgPSBzcGxpdExpbmVNb2RlbC5nZXQoJ3Nob3cnKTtcbiAgICAgICAgICAgIHZhciBzaG93U3BsaXRBcmVhID0gc3BsaXRBcmVhTW9kZWwuZ2V0KCdzaG93Jyk7XG4gICAgICAgICAgICB2YXIgc3BsaXRMaW5lQ29sb3JzID0gbGluZVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuICAgICAgICAgICAgdmFyIHNwbGl0QXJlYUNvbG9ycyA9IGFyZWFTdHlsZU1vZGVsLmdldCgnY29sb3InKTtcblxuICAgICAgICAgICAgc3BsaXRMaW5lQ29sb3JzID0genJVdGlsLmlzQXJyYXkoc3BsaXRMaW5lQ29sb3JzKSA/IHNwbGl0TGluZUNvbG9ycyA6IFtzcGxpdExpbmVDb2xvcnNdO1xuICAgICAgICAgICAgc3BsaXRBcmVhQ29sb3JzID0genJVdGlsLmlzQXJyYXkoc3BsaXRBcmVhQ29sb3JzKSA/IHNwbGl0QXJlYUNvbG9ycyA6IFtzcGxpdEFyZWFDb2xvcnNdO1xuXG4gICAgICAgICAgICB2YXIgc3BsaXRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHNwbGl0QXJlYXMgPSBbXTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q29sb3JJbmRleChhcmVhT3JMaW5lLCBhcmVhT3JMaW5lQ29sb3JMaXN0LCBpZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3JJbmRleCA9IGlkeCAlIGFyZWFPckxpbmVDb2xvckxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGFyZWFPckxpbmVbY29sb3JJbmRleF0gPSBhcmVhT3JMaW5lW2NvbG9ySW5kZXhdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvckluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hhcGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpY2tzUmFkaXVzID0gaW5kaWNhdG9yQXhlc1swXS5nZXRUaWNrc0Nvb3JkcygpO1xuICAgICAgICAgICAgICAgIHZhciBjeCA9IHJhZGFyLmN4O1xuICAgICAgICAgICAgICAgIHZhciBjeSA9IHJhZGFyLmN5O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3NSYWRpdXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dTcGxpdExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvckluZGV4ID0gZ2V0Q29sb3JJbmRleChzcGxpdExpbmVzLCBzcGxpdExpbmVDb2xvcnMsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRMaW5lc1tjb2xvckluZGV4XS5wdXNoKG5ldyBncmFwaGljLkNpcmNsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3g6IGN4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHI6IHRpY2tzUmFkaXVzW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG93U3BsaXRBcmVhICYmIGkgPCB0aWNrc1JhZGl1cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3JJbmRleCA9IGdldENvbG9ySW5kZXgoc3BsaXRBcmVhcywgc3BsaXRBcmVhQ29sb3JzLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0QXJlYXNbY29sb3JJbmRleF0ucHVzaChuZXcgZ3JhcGhpYy5SaW5nKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcjA6IHRpY2tzUmFkaXVzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByOiB0aWNrc1JhZGl1c1tpICsgMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQb2x5eW9uXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVhbFNwbGl0TnVtYmVyO1xuICAgICAgICAgICAgICAgIHZhciBheGVzVGlja3NQb2ludHMgPSB6clV0aWwubWFwKGluZGljYXRvckF4ZXMsIGZ1bmN0aW9uIChpbmRpY2F0b3JBeGlzLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpY2tzQ29vcmRzID0gaW5kaWNhdG9yQXhpcy5nZXRUaWNrc0Nvb3JkcygpO1xuICAgICAgICAgICAgICAgICAgICByZWFsU3BsaXROdW1iZXIgPSByZWFsU3BsaXROdW1iZXIgPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aWNrc0Nvb3Jkcy5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKHRpY2tzQ29vcmRzLmxlbmd0aCAtIDEsIHJlYWxTcGxpdE51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB6clV0aWwubWFwKHRpY2tzQ29vcmRzLCBmdW5jdGlvbiAodGlja0Nvb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFkYXIuY29vcmRUb1BvaW50KHRpY2tDb29yZCwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJldlBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHJlYWxTcGxpdE51bWJlcjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbmRpY2F0b3JBeGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChheGVzVGlja3NQb2ludHNbal1baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENsb3NlXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50c1swXS5zbGljZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2FuXFwndCBkcmF3IHZhbHVlIGF4aXMgJyArIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dTcGxpdExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvckluZGV4ID0gZ2V0Q29sb3JJbmRleChzcGxpdExpbmVzLCBzcGxpdExpbmVDb2xvcnMsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRMaW5lc1tjb2xvckluZGV4XS5wdXNoKG5ldyBncmFwaGljLlBvbHlsaW5lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd1NwbGl0QXJlYSAmJiBwcmV2UG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3JJbmRleCA9IGdldENvbG9ySW5kZXgoc3BsaXRBcmVhcywgc3BsaXRBcmVhQ29sb3JzLCBpIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdEFyZWFzW2NvbG9ySW5kZXhdLnB1c2gobmV3IGdyYXBoaWMuUG9seWdvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMuY29uY2F0KHByZXZQb2ludHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByZXZQb2ludHMgPSBwb2ludHMuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGluZVN0eWxlID0gbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCk7XG4gICAgICAgICAgICB2YXIgYXJlYVN0eWxlID0gYXJlYVN0eWxlTW9kZWwuZ2V0QXJlYVN0eWxlKCk7XG4gICAgICAgICAgICAvLyBBZGQgc3BsaXRBcmVhIGJlZm9yZSBzcGxpdExpbmVcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHNwbGl0QXJlYXMsIGZ1bmN0aW9uIChzcGxpdEFyZWFzLCBpZHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChncmFwaGljLm1lcmdlUGF0aChcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRBcmVhcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogc3BsaXRBcmVhQ29sb3JzW2lkeCAlIHNwbGl0QXJlYUNvbG9ycy5sZW5ndGhdXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBhcmVhU3R5bGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB6clV0aWwuZWFjaChzcGxpdExpbmVzLCBmdW5jdGlvbiAoc3BsaXRMaW5lcywgaWR4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoZ3JhcGhpYy5tZXJnZVBhdGgoXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0TGluZXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHNwbGl0TGluZUNvbG9yc1tpZHggJSBzcGxpdExpbmVDb2xvcnMubGVuZ3RoXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgbGluZVN0eWxlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29tcG9uZW50L3JhZGFyL1JhZGFyVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("'use strict';\n\n\n    var SeriesModel = __webpack_require__(94);\n    var List = __webpack_require__(114);\n    var completeDimensions = __webpack_require__(126);\n    var zrUtil = __webpack_require__(20);\n    var encodeHTML = __webpack_require__(22).encodeHTML;\n\n    var RadarSeries = SeriesModel.extend({\n\n        type: 'series.radar',\n\n        dependencies: ['radar'],\n\n\n        // Overwrite\n        init: function (option) {\n            RadarSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n        },\n\n        getInitialData: function (option, ecModel) {\n            var data = option.data || [];\n            var dimensions = completeDimensions(\n                [], data, {extraPrefix: 'indicator_', extraFromZero: true}\n            );\n            var list = new List(dimensions, this);\n            list.initData(data);\n            return list;\n        },\n\n        formatTooltip: function (dataIndex) {\n            var value = this.getRawValue(dataIndex);\n            var coordSys = this.coordinateSystem;\n            var indicatorAxes = coordSys.getIndicatorAxes();\n            var name = this.getData().getName(dataIndex);\n            return encodeHTML(name === '' ? this.name : name) + '<br/>'\n                + zrUtil.map(indicatorAxes, function (axis, idx) {\n                    return encodeHTML(axis.name + ' : ' + value[idx]);\n                }).join('<br />');\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            coordinateSystem: 'radar',\n            legendHoverLink: true,\n            radarIndex: 0,\n            lineStyle: {\n                normal: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            label: {\n                normal: {\n                    position: 'top'\n                }\n            },\n            // areaStyle: {\n            // },\n            // itemStyle: {}\n            symbol: 'emptyCircle',\n            symbolSize: 4\n            // symbolRotate: null\n        }\n    });\n\n    module.exports = RadarSeries;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L3JhZGFyL1JhZGFyU2VyaWVzLmpzPzVlNGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMIiwiZmlsZSI6IjIwMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIFNlcmllc01vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvU2VyaWVzJyk7XG4gICAgdmFyIExpc3QgPSByZXF1aXJlKCcuLi8uLi9kYXRhL0xpc3QnKTtcbiAgICB2YXIgY29tcGxldGVEaW1lbnNpb25zID0gcmVxdWlyZSgnLi4vLi4vZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBlbmNvZGVIVE1MID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9mb3JtYXQnKS5lbmNvZGVIVE1MO1xuXG4gICAgdmFyIFJhZGFyU2VyaWVzID0gU2VyaWVzTW9kZWwuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnc2VyaWVzLnJhZGFyJyxcblxuICAgICAgICBkZXBlbmRlbmNpZXM6IFsncmFkYXInXSxcblxuXG4gICAgICAgIC8vIE92ZXJ3cml0ZVxuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICBSYWRhclNlcmllcy5zdXBlckFwcGx5KHRoaXMsICdpbml0JywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgLy8gRW5hYmxlIGxlZ2VuZCBzZWxlY3Rpb24gZm9yIGVhY2ggZGF0YSBpdGVtXG4gICAgICAgICAgICAvLyBVc2UgYSBmdW5jdGlvbiBpbnN0ZWFkIG9mIGRpcmVjdCBhY2Nlc3MgYmVjYXVzZSBkYXRhIHJlZmVyZW5jZSBtYXkgY2hhbmdlZFxuICAgICAgICAgICAgdGhpcy5sZWdlbmREYXRhUHJvdmlkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmF3RGF0YSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRJbml0aWFsRGF0YTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBvcHRpb24uZGF0YSB8fCBbXTtcbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25zID0gY29tcGxldGVEaW1lbnNpb25zKFxuICAgICAgICAgICAgICAgIFtdLCBkYXRhLCB7ZXh0cmFQcmVmaXg6ICdpbmRpY2F0b3JfJywgZXh0cmFGcm9tWmVybzogdHJ1ZX1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgbGlzdCA9IG5ldyBMaXN0KGRpbWVuc2lvbnMsIHRoaXMpO1xuICAgICAgICAgICAgbGlzdC5pbml0RGF0YShkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGZvcm1hdFRvb2x0aXA6IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0UmF3VmFsdWUoZGF0YUluZGV4KTtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIHZhciBpbmRpY2F0b3JBeGVzID0gY29vcmRTeXMuZ2V0SW5kaWNhdG9yQXhlcygpO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmdldERhdGEoKS5nZXROYW1lKGRhdGFJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlSFRNTChuYW1lID09PSAnJyA/IHRoaXMubmFtZSA6IG5hbWUpICsgJzxici8+J1xuICAgICAgICAgICAgICAgICsgenJVdGlsLm1hcChpbmRpY2F0b3JBeGVzLCBmdW5jdGlvbiAoYXhpcywgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVIVE1MKGF4aXMubmFtZSArICcgOiAnICsgdmFsdWVbaWR4XSk7XG4gICAgICAgICAgICAgICAgfSkuam9pbignPGJyIC8+Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xuICAgICAgICAgICAgemxldmVsOiAwLFxuICAgICAgICAgICAgejogMixcbiAgICAgICAgICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdyYWRhcicsXG4gICAgICAgICAgICBsZWdlbmRIb3Zlckxpbms6IHRydWUsXG4gICAgICAgICAgICByYWRhckluZGV4OiAwLFxuICAgICAgICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc29saWQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAndG9wJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBhcmVhU3R5bGU6IHtcbiAgICAgICAgICAgIC8vIH0sXG4gICAgICAgICAgICAvLyBpdGVtU3R5bGU6IHt9XG4gICAgICAgICAgICBzeW1ib2w6ICdlbXB0eUNpcmNsZScsXG4gICAgICAgICAgICBzeW1ib2xTaXplOiA0XG4gICAgICAgICAgICAvLyBzeW1ib2xSb3RhdGU6IG51bGxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSYWRhclNlcmllcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jaGFydC9yYWRhci9SYWRhclNlcmllcy5qc1xuLy8gbW9kdWxlIGlkID0gMjAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n\n    var graphic = __webpack_require__(34);\n    var zrUtil = __webpack_require__(20);\n    var symbolUtil = __webpack_require__(127);\n\n    function normalizeSymbolSize(symbolSize) {\n        if (!zrUtil.isArray(symbolSize)) {\n            symbolSize = [+symbolSize, +symbolSize];\n        }\n        return symbolSize;\n    }\n    module.exports = __webpack_require__(17).extendChartView({\n        type: 'radar',\n\n        render: function (seriesModel, ecModel, api) {\n            var polar = seriesModel.coordinateSystem;\n            var group = this.group;\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            function createSymbol(data, idx) {\n                var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n                var color = data.getItemVisual(idx, 'color');\n                if (symbolType === 'none') {\n                    return;\n                }\n                var symbolPath = symbolUtil.createSymbol(\n                    symbolType, -0.5, -0.5, 1, 1, color\n                );\n                symbolPath.attr({\n                    style: {\n                        strokeNoScale: true\n                    },\n                    z2: 100,\n                    scale: normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'))\n                });\n                return symbolPath;\n            }\n\n            function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {\n                // Simply rerender all\n                symbolGroup.removeAll();\n                for (var i = 0; i < newPoints.length - 1; i++) {\n                    var symbolPath = createSymbol(data, idx);\n                    if (symbolPath) {\n                        symbolPath.__dimIdx = i;\n                        if (oldPoints[i]) {\n                            symbolPath.attr('position', oldPoints[i]);\n                            graphic[isInit ? 'initProps' : 'updateProps'](\n                                symbolPath, {\n                                    position: newPoints[i]\n                                }, seriesModel, idx\n                            );\n                        }\n                        else {\n                            symbolPath.attr('position', newPoints[i]);\n                        }\n                        symbolGroup.add(symbolPath);\n                    }\n                }\n            }\n\n            function getInitialPoints(points) {\n                return zrUtil.map(points, function (pt) {\n                    return [polar.cx, polar.cy];\n                });\n            }\n            data.diff(oldData)\n                .add(function (idx) {\n                    var points = data.getItemLayout(idx);\n                    if (!points) {\n                        return;\n                    }\n                    var polygon = new graphic.Polygon();\n                    var polyline = new graphic.Polyline();\n                    var target = {\n                        shape: {\n                            points: points\n                        }\n                    };\n                    polygon.shape.points = getInitialPoints(points);\n                    polyline.shape.points = getInitialPoints(points);\n                    graphic.initProps(polygon, target, seriesModel, idx);\n                    graphic.initProps(polyline, target, seriesModel, idx);\n\n                    var itemGroup = new graphic.Group();\n                    var symbolGroup = new graphic.Group();\n                    itemGroup.add(polyline);\n                    itemGroup.add(polygon);\n                    itemGroup.add(symbolGroup);\n\n                    updateSymbols(\n                        polyline.shape.points, points, symbolGroup, data, idx, true\n                    );\n\n                    data.setItemGraphicEl(idx, itemGroup);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var itemGroup = oldData.getItemGraphicEl(oldIdx);\n                    var polyline = itemGroup.childAt(0);\n                    var polygon = itemGroup.childAt(1);\n                    var symbolGroup = itemGroup.childAt(2);\n                    var target = {\n                        shape: {\n                            points: data.getItemLayout(newIdx)\n                        }\n                    };\n                    if (!target.shape.points) {\n                        return;\n                    }\n                    updateSymbols(\n                        polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false\n                    );\n\n                    graphic.updateProps(polyline, target, seriesModel);\n                    graphic.updateProps(polygon, target, seriesModel);\n\n                    data.setItemGraphicEl(newIdx, itemGroup);\n                })\n                .remove(function (idx) {\n                    group.remove(oldData.getItemGraphicEl(idx));\n                })\n                .execute();\n\n            data.eachItemGraphicEl(function (itemGroup, idx) {\n                var itemModel = data.getItemModel(idx);\n                var polyline = itemGroup.childAt(0);\n                var polygon = itemGroup.childAt(1);\n                var symbolGroup = itemGroup.childAt(2);\n                var color = data.getItemVisual(idx, 'color');\n\n                group.add(itemGroup);\n\n                polyline.useStyle(\n                    zrUtil.defaults(\n                        itemModel.getModel('lineStyle.normal').getLineStyle(),\n                        {\n                            fill: 'none',\n                            stroke: color\n                        }\n                    )\n                );\n                polyline.hoverStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();\n\n                var areaStyleModel = itemModel.getModel('areaStyle.normal');\n                var hoverAreaStyleModel = itemModel.getModel('areaStyle.emphasis');\n                var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();\n                var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();\n\n                hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;\n                polygon.ignore = polygonIgnore;\n\n                polygon.useStyle(\n                    zrUtil.defaults(\n                        areaStyleModel.getAreaStyle(),\n                        {\n                            fill: color,\n                            opacity: 0.7\n                        }\n                    )\n                );\n                polygon.hoverStyle = hoverAreaStyleModel.getAreaStyle();\n\n                var itemStyle = itemModel.getModel('itemStyle.normal').getItemStyle(['color']);\n                var itemHoverStyle = itemModel.getModel('itemStyle.emphasis').getItemStyle();\n                var labelModel = itemModel.getModel('label.normal');\n                var labelHoverModel = itemModel.getModel('label.emphasis');\n                symbolGroup.eachChild(function (symbolPath) {\n                    symbolPath.setStyle(itemStyle);\n                    symbolPath.hoverStyle = zrUtil.clone(itemHoverStyle);\n\n                    var defaultText = data.get(data.dimensions[symbolPath.__dimIdx], idx);\n                    graphic.setText(symbolPath.style, labelModel, color);\n                    symbolPath.setStyle({\n                        text: labelModel.get('show') ? zrUtil.retrieve(\n                            seriesModel.getFormattedLabel(\n                                idx, 'normal', null, symbolPath.__dimIdx\n                            ),\n                            defaultText\n                        ) : ''\n                    });\n\n                    graphic.setText(symbolPath.hoverStyle, labelHoverModel, color);\n                    symbolPath.hoverStyle.text = labelHoverModel.get('show') ? zrUtil.retrieve(\n                        seriesModel.getFormattedLabel(\n                            idx, 'emphasis', null, symbolPath.__dimIdx\n                        ),\n                        defaultText\n                    ) : '';\n                });\n\n                function onEmphasis() {\n                    polygon.attr('ignore', hoverPolygonIgnore);\n                }\n\n                function onNormal() {\n                    polygon.attr('ignore', polygonIgnore);\n                }\n\n                itemGroup.off('mouseover').off('mouseout').off('normal').off('emphasis');\n                itemGroup.on('emphasis', onEmphasis)\n                    .on('mouseover', onEmphasis)\n                    .on('normal', onNormal)\n                    .on('mouseout', onNormal);\n\n                graphic.setHoverStyle(itemGroup);\n            });\n\n            this._data = data;\n        },\n\n        remove: function () {\n            this.group.removeAll();\n            this._data = null;\n        },\n\n        dispose: function () {}\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L3JhZGFyL1JhZGFyVmlldy5qcz81NTgyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQTBCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLIiwiZmlsZSI6IjIwMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIHN5bWJvbFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3N5bWJvbCcpO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplU3ltYm9sU2l6ZShzeW1ib2xTaXplKSB7XG4gICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkoc3ltYm9sU2l6ZSkpIHtcbiAgICAgICAgICAgIHN5bWJvbFNpemUgPSBbK3N5bWJvbFNpemUsICtzeW1ib2xTaXplXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ltYm9sU2l6ZTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJykuZXh0ZW5kQ2hhcnRWaWV3KHtcbiAgICAgICAgdHlwZTogJ3JhZGFyJyxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgcG9sYXIgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcblxuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVN5bWJvbChkYXRhLCBpZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sVHlwZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKSB8fCAnY2lyY2xlJztcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sVHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbFBhdGggPSBzeW1ib2xVdGlsLmNyZWF0ZVN5bWJvbChcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sVHlwZSwgLTAuNSwgLTAuNSwgMSwgMSwgY29sb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHN5bWJvbFBhdGguYXR0cih7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VOb1NjYWxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHoyOiAxMDAsXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiBub3JtYWxpemVTeW1ib2xTaXplKGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xTaXplJykpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFBhdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVN5bWJvbHMob2xkUG9pbnRzLCBuZXdQb2ludHMsIHN5bWJvbEdyb3VwLCBkYXRhLCBpZHgsIGlzSW5pdCkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBseSByZXJlbmRlciBhbGxcbiAgICAgICAgICAgICAgICBzeW1ib2xHcm91cC5yZW1vdmVBbGwoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1BvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbFBhdGggPSBjcmVhdGVTeW1ib2woZGF0YSwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN5bWJvbFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbFBhdGguX19kaW1JZHggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFBvaW50c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbFBhdGguYXR0cigncG9zaXRpb24nLCBvbGRQb2ludHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWNbaXNJbml0ID8gJ2luaXRQcm9wcycgOiAndXBkYXRlUHJvcHMnXShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sUGF0aCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5ld1BvaW50c1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbFBhdGguYXR0cigncG9zaXRpb24nLCBuZXdQb2ludHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sR3JvdXAuYWRkKHN5bWJvbFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRJbml0aWFsUG9pbnRzKHBvaW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB6clV0aWwubWFwKHBvaW50cywgZnVuY3Rpb24gKHB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbcG9sYXIuY3gsIHBvbGFyLmN5XTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEuZGlmZihvbGREYXRhKVxuICAgICAgICAgICAgICAgIC5hZGQoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvbHlnb24gPSBuZXcgZ3JhcGhpYy5Qb2x5Z29uKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2x5bGluZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb24uc2hhcGUucG9pbnRzID0gZ2V0SW5pdGlhbFBvaW50cyhwb2ludHMpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5bGluZS5zaGFwZS5wb2ludHMgPSBnZXRJbml0aWFsUG9pbnRzKHBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKHBvbHlnb24sIHRhcmdldCwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKHBvbHlsaW5lLCB0YXJnZXQsIHNlcmllc01vZGVsLCBpZHgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9sR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtR3JvdXAuYWRkKHBvbHlsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUdyb3VwLmFkZChwb2x5Z29uKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUdyb3VwLmFkZChzeW1ib2xHcm91cCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU3ltYm9scyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lLnNoYXBlLnBvaW50cywgcG9pbnRzLCBzeW1ib2xHcm91cCwgZGF0YSwgaWR4LCB0cnVlXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgaXRlbUdyb3VwKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtR3JvdXAgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvbHlsaW5lID0gaXRlbUdyb3VwLmNoaWxkQXQoMCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2x5Z29uID0gaXRlbUdyb3VwLmNoaWxkQXQoMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2xHcm91cCA9IGl0ZW1Hcm91cC5jaGlsZEF0KDIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IGRhdGEuZ2V0SXRlbUxheW91dChuZXdJZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0LnNoYXBlLnBvaW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN5bWJvbHMoXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5bGluZS5zaGFwZS5wb2ludHMsIHRhcmdldC5zaGFwZS5wb2ludHMsIHN5bWJvbEdyb3VwLCBkYXRhLCBuZXdJZHgsIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2x5bGluZSwgdGFyZ2V0LCBzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMocG9seWdvbiwgdGFyZ2V0LCBzZXJpZXNNb2RlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgaXRlbUdyb3VwKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICBncm91cC5yZW1vdmUob2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKGlkeCkpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmV4ZWN1dGUoKTtcblxuICAgICAgICAgICAgZGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoaXRlbUdyb3VwLCBpZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgICAgICAgICAgICB2YXIgcG9seWxpbmUgPSBpdGVtR3JvdXAuY2hpbGRBdCgwKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9seWdvbiA9IGl0ZW1Hcm91cC5jaGlsZEF0KDEpO1xuICAgICAgICAgICAgICAgIHZhciBzeW1ib2xHcm91cCA9IGl0ZW1Hcm91cC5jaGlsZEF0KDIpO1xuICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuXG4gICAgICAgICAgICAgICAgZ3JvdXAuYWRkKGl0ZW1Hcm91cCk7XG5cbiAgICAgICAgICAgICAgICBwb2x5bGluZS51c2VTdHlsZShcbiAgICAgICAgICAgICAgICAgICAgenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUubm9ybWFsJykuZ2V0TGluZVN0eWxlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcG9seWxpbmUuaG92ZXJTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlLmVtcGhhc2lzJykuZ2V0TGluZVN0eWxlKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXJlYVN0eWxlTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2FyZWFTdHlsZS5ub3JtYWwnKTtcbiAgICAgICAgICAgICAgICB2YXIgaG92ZXJBcmVhU3R5bGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnYXJlYVN0eWxlLmVtcGhhc2lzJyk7XG4gICAgICAgICAgICAgICAgdmFyIHBvbHlnb25JZ25vcmUgPSBhcmVhU3R5bGVNb2RlbC5pc0VtcHR5KCkgJiYgYXJlYVN0eWxlTW9kZWwucGFyZW50TW9kZWwuaXNFbXB0eSgpO1xuICAgICAgICAgICAgICAgIHZhciBob3ZlclBvbHlnb25JZ25vcmUgPSBob3ZlckFyZWFTdHlsZU1vZGVsLmlzRW1wdHkoKSAmJiBob3ZlckFyZWFTdHlsZU1vZGVsLnBhcmVudE1vZGVsLmlzRW1wdHkoKTtcblxuICAgICAgICAgICAgICAgIGhvdmVyUG9seWdvbklnbm9yZSA9IGhvdmVyUG9seWdvbklnbm9yZSAmJiBwb2x5Z29uSWdub3JlO1xuICAgICAgICAgICAgICAgIHBvbHlnb24uaWdub3JlID0gcG9seWdvbklnbm9yZTtcblxuICAgICAgICAgICAgICAgIHBvbHlnb24udXNlU3R5bGUoXG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5kZWZhdWx0cyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZWFTdHlsZU1vZGVsLmdldEFyZWFTdHlsZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuN1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwb2x5Z29uLmhvdmVyU3R5bGUgPSBob3ZlckFyZWFTdHlsZU1vZGVsLmdldEFyZWFTdHlsZSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1TdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlLm5vcm1hbCcpLmdldEl0ZW1TdHlsZShbJ2NvbG9yJ10pO1xuICAgICAgICAgICAgICAgIHZhciBpdGVtSG92ZXJTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlLmVtcGhhc2lzJykuZ2V0SXRlbVN0eWxlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLm5vcm1hbCcpO1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbEhvdmVyTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLmVtcGhhc2lzJyk7XG4gICAgICAgICAgICAgICAgc3ltYm9sR3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChzeW1ib2xQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFBhdGguc2V0U3R5bGUoaXRlbVN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sUGF0aC5ob3ZlclN0eWxlID0genJVdGlsLmNsb25lKGl0ZW1Ib3ZlclN0eWxlKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdFRleHQgPSBkYXRhLmdldChkYXRhLmRpbWVuc2lvbnNbc3ltYm9sUGF0aC5fX2RpbUlkeF0sIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0VGV4dChzeW1ib2xQYXRoLnN0eWxlLCBsYWJlbE1vZGVsLCBjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFBhdGguc2V0U3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWxNb2RlbC5nZXQoJ3Nob3cnKSA/IHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4LCAnbm9ybWFsJywgbnVsbCwgc3ltYm9sUGF0aC5fX2RpbUlkeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICkgOiAnJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBncmFwaGljLnNldFRleHQoc3ltYm9sUGF0aC5ob3ZlclN0eWxlLCBsYWJlbEhvdmVyTW9kZWwsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sUGF0aC5ob3ZlclN0eWxlLnRleHQgPSBsYWJlbEhvdmVyTW9kZWwuZ2V0KCdzaG93JykgPyB6clV0aWwucmV0cmlldmUoXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHgsICdlbXBoYXNpcycsIG51bGwsIHN5bWJvbFBhdGguX19kaW1JZHhcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VGV4dFxuICAgICAgICAgICAgICAgICAgICApIDogJyc7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBvbkVtcGhhc2lzKCkge1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLmF0dHIoJ2lnbm9yZScsIGhvdmVyUG9seWdvbklnbm9yZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gb25Ob3JtYWwoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb24uYXR0cignaWdub3JlJywgcG9seWdvbklnbm9yZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbUdyb3VwLm9mZignbW91c2VvdmVyJykub2ZmKCdtb3VzZW91dCcpLm9mZignbm9ybWFsJykub2ZmKCdlbXBoYXNpcycpO1xuICAgICAgICAgICAgICAgIGl0ZW1Hcm91cC5vbignZW1waGFzaXMnLCBvbkVtcGhhc2lzKVxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIG9uRW1waGFzaXMpXG4gICAgICAgICAgICAgICAgICAgIC5vbignbm9ybWFsJywgb25Ob3JtYWwpXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBvbk5vcm1hbCk7XG5cbiAgICAgICAgICAgICAgICBncmFwaGljLnNldEhvdmVyU3R5bGUoaXRlbUdyb3VwKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NoYXJ0L3JhZGFyL1JhZGFyVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMjAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("\n\n    module.exports = function (ecModel) {\n        ecModel.eachSeriesByType('radar', function (seriesModel) {\n            var data = seriesModel.getData();\n            var points = [];\n            var coordSys = seriesModel.coordinateSystem;\n            if (!coordSys) {\n                return;\n            }\n\n            function pointsConverter(val, idx) {\n                points[idx] = points[idx] || [];\n                points[idx][i] = coordSys.dataToPoint(val, i);\n            }\n            for (var i = 0; i < coordSys.getIndicatorAxes().length; i++) {\n                var dim = data.dimensions[i];\n                data.each(dim, pointsConverter);\n            }\n\n            data.each(function (idx) {\n                // Close polygon\n                points[idx][0] && points[idx].push(points[idx][0].slice());\n                data.setItemLayout(idx, points[idx]);\n            });\n        });\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L3JhZGFyL3JhZGFyTGF5b3V0LmpzP2U2MTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdDQUF3QztBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUIiwiZmlsZSI6IjIwMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ3JhZGFyJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICBpZiAoIWNvb3JkU3lzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBwb2ludHNDb252ZXJ0ZXIodmFsLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBwb2ludHNbaWR4XSA9IHBvaW50c1tpZHhdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHBvaW50c1tpZHhdW2ldID0gY29vcmRTeXMuZGF0YVRvUG9pbnQodmFsLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRTeXMuZ2V0SW5kaWNhdG9yQXhlcygpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpbSA9IGRhdGEuZGltZW5zaW9uc1tpXTtcbiAgICAgICAgICAgICAgICBkYXRhLmVhY2goZGltLCBwb2ludHNDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgIC8vIENsb3NlIHBvbHlnb25cbiAgICAgICAgICAgICAgICBwb2ludHNbaWR4XVswXSAmJiBwb2ludHNbaWR4XS5wdXNoKHBvaW50c1tpZHhdWzBdLnNsaWNlKCkpO1xuICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIHBvaW50c1tpZHhdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NoYXJ0L3JhZGFyL3JhZGFyTGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("// Backward compat for radar chart in 2\n\n\n    var zrUtil = __webpack_require__(20);\n\n    module.exports = function (option) {\n        var polarOptArr = option.polar;\n        if (polarOptArr) {\n            if (!zrUtil.isArray(polarOptArr)) {\n                polarOptArr = [polarOptArr];\n            }\n            var polarNotRadar = [];\n            zrUtil.each(polarOptArr, function (polarOpt, idx) {\n                if (polarOpt.indicator) {\n                    if (polarOpt.type && !polarOpt.shape) {\n                        polarOpt.shape = polarOpt.type;\n                    }\n                    option.radar = option.radar || [];\n                    if (!zrUtil.isArray(option.radar)) {\n                        option.radar = [option.radar];\n                    }\n                    option.radar.push(polarOpt);\n                }\n                else {\n                    polarNotRadar.push(polarOpt);\n                }\n            });\n            option.polar = polarNotRadar;\n        }\n        zrUtil.each(option.series, function (seriesOpt) {\n            if (seriesOpt.type === 'radar' && seriesOpt.polarIndex) {\n                seriesOpt.radarIndex = seriesOpt.polarIndex;\n            }\n        });\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2VjaGFydHMvbGliL2NoYXJ0L3JhZGFyL2JhY2t3YXJkQ29tcGF0LmpzPzRlM2EiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QiLCJmaWxlIjoiMjAzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQmFja3dhcmQgY29tcGF0IGZvciByYWRhciBjaGFydCBpbiAyXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB2YXIgcG9sYXJPcHRBcnIgPSBvcHRpb24ucG9sYXI7XG4gICAgICAgIGlmIChwb2xhck9wdEFycikge1xuICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShwb2xhck9wdEFycikpIHtcbiAgICAgICAgICAgICAgICBwb2xhck9wdEFyciA9IFtwb2xhck9wdEFycl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcG9sYXJOb3RSYWRhciA9IFtdO1xuICAgICAgICAgICAgenJVdGlsLmVhY2gocG9sYXJPcHRBcnIsIGZ1bmN0aW9uIChwb2xhck9wdCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvbGFyT3B0LmluZGljYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9sYXJPcHQudHlwZSAmJiAhcG9sYXJPcHQuc2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbGFyT3B0LnNoYXBlID0gcG9sYXJPcHQudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcHRpb24ucmFkYXIgPSBvcHRpb24ucmFkYXIgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkob3B0aW9uLnJhZGFyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnJhZGFyID0gW29wdGlvbi5yYWRhcl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnJhZGFyLnB1c2gocG9sYXJPcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9sYXJOb3RSYWRhci5wdXNoKHBvbGFyT3B0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9wdGlvbi5wb2xhciA9IHBvbGFyTm90UmFkYXI7XG4gICAgICAgIH1cbiAgICAgICAgenJVdGlsLmVhY2gob3B0aW9uLnNlcmllcywgZnVuY3Rpb24gKHNlcmllc09wdCkge1xuICAgICAgICAgICAgaWYgKHNlcmllc09wdC50eXBlID09PSAncmFkYXInICYmIHNlcmllc09wdC5wb2xhckluZGV4KSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzT3B0LnJhZGFySW5kZXggPSBzZXJpZXNPcHQucG9sYXJJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jaGFydC9yYWRhci9iYWNrd2FyZENvbXBhdC5qc1xuLy8gbW9kdWxlIGlkID0gMjAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n/* styles */\n__webpack_require__(205)\n\nvar Component = __webpack_require__(9)(\n  /* script */\n  __webpack_require__(207),\n  /* template */\n  __webpack_require__(209),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tb250aC52dWU/NTFkZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQSx1QkFBOEs7O0FBRTlLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMjA0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKiBzdHlsZXMgKi9cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9taW5pbWl6ZSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi03Yjc1ZmU5YlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IXNhc3MtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vbW9udGgudnVlXCIpXG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL21vbnRoLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtN2I3NWZlOWJcXFwifSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vbW9udGgudnVlXCIpLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIGNzc01vZHVsZXMgKi9cbiAgbnVsbFxuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL21vbnRoLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(206);\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(7)(\"09322ff9\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tb250aC52dWU/NmUwOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLHFDQUEwTTtBQUMxTTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/bWluaW1pemUhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtN2I3NWZlOWJcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9tb250aC52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjA5MzIyZmY5XCIsIGNvbnRlbnQsIHRydWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyP21pbmltaXplIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTdiNzVmZTliXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vc2Fzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tb250aC52dWVcbi8vIG1vZHVsZSBpZCA9IDIwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(6)();\n// imports\n\n\n// module\nexports.push([module.id, ".analysis{color:#f2a6b4;text-align:center;margin-top:20px;font-size:26px}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tb250aC52dWU/MWY3NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLG9DQUFvQyxjQUFjLGtCQUFrQixnQkFBZ0IsZUFBZTs7QUFFbkciLCJmaWxlIjoiMjA2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmFuYWx5c2lze2NvbG9yOiNmMmE2YjQ7dGV4dC1hbGlnbjpjZW50ZXI7bWFyZ2luLXRvcDoyMHB4O2ZvbnQtc2l6ZToyNnB4fVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP21pbmltaXplIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTdiNzVmZTliXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vc2Fzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tb250aC52dWVcbi8vIG1vZHVsZSBpZCA9IDIwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _pie = __webpack_require__(208);\n\nvar _pie2 = _interopRequireDefault(_pie);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n    data: function data() {\n        return {\n            chartData: {\n                columns: ['date', 'expend'],\n                rows: []\n            },\n            result: [],\n            maxExpend: \" \",\n            TotalExpend: \" \",\n            MaxClass: \" \",\n            flag: false,\n            edu: false,\n            trip: false,\n            entertain: false,\n            clothes: false,\n            normal: false,\n            food: false\n        };\n    },\n\n    components: {\n        VePie: _pie2.default\n    },\n    created: function created() {\n        var _this = this;\n\n        fetch(\"api/get_month/\").then(function (res) {\n            return res.json();\n        }).then(function (res) {\n            _this.chartData = {\n                columns: ['class', 'expend'],\n                rows: res.result\n            };\n            _this.MaxClass = res.MaxClass;\n            _this.maxExpend = res.maxExpend;\n            _this.TotalExpend = res.TotalExpend;\n            if (_this.TotalExpend != 0) _this.flag = true;\n            if (_this.MaxClass == \"教育\") _this.edu = true;else if (_this.MaxClass == \"出行\") _this.trip = true;else if (_this.MaxClass == \"一般\") _this.normal = true;else if (_this.MaxClass == \"服饰\") _this.clothes = true;else if (_this.MaxClass == \"娱乐\") _this.entertain = true;else if (_this.MaxClass == \"饮食\") _this.food = true;\n        });\n        this.chartSettings = {\n            dimension: 'class',\n            metrics: 'expend',\n            selectedMode: 'single',\n            hoverAnimation: false,\n            radius: 100,\n            offsetY: 200\n        };\n        this.chartColors = ['#ffb876', '#d4eeff', '#40c0cb', '#ffe9d4', '#ef767a', '#b4c3ff'];\n        this.legend_position = 'bottom';\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbW9udGgudnVlP2ZjNTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBZ0NBOzs7Ozs7OzBCQUVBOzs7a0NBR0E7c0JBRUE7QUFIQTtvQkFJQTt1QkFDQTt5QkFDQTtzQkFDQTtrQkFDQTtpQkFDQTtrQkFDQTt1QkFDQTtxQkFDQTtvQkFDQTtrQkFFQTtBQWhCQTtBQWlCQTs7O0FBR0E7QUFGQTs7QUFHQTs7b0RBQ0E7dUJBQ0E7QUFDQSwrQkFDQTs7bUNBRUE7MEJBRUE7QUFIQTtpQ0FJQTtrQ0FDQTtvQ0FDQTtxQ0FDQSxnQkFDQTtrQ0FDQSxrQkFDQSxnQ0FDQSxtQkFDQSxnQ0FDQSxxQkFDQSxnQ0FDQSxzQkFDQSxnQ0FDQSx3QkFDQSxnQ0FDQSxtQkFDQTtBQUNBOzt1QkFFQTtxQkFDQTswQkFDQTs0QkFDQTtvQkFDQTtxQkFFQTtBQVBBO21GQVFBOytCQUNBO0FBQ0E7QUE1REEiLCJmaWxlIjoiMjA3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICAgIDxkaXY+XG4gICAgPHZlLXBpZVxuICAgICAgOmRhdGE9XCJjaGFydERhdGFcIlxuICAgICAgOnNldHRpbmdzPVwiY2hhcnRTZXR0aW5nc1wiXG4gICAgICA6Y29sb3JzID0gXCJjaGFydENvbG9yc1wiXG4gICAgICB0b29sdGlwLXZpc2libGVcbiAgICAgIDpsZWdlbmQtcG9zaXRpb249XCJsZWdlbmRfcG9zaXRpb25cIlxuICAgICAgbGVnZW5kLXZpc2libGU+XG4gICAgICA8L3ZlLXBpZT5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cIndvcmRcIj7mnKzmnIjmgqjkuIDlhbHoirHotLk8L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm1heFwiPnt7VG90YWxFeHBlbmR9fTwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwid29yZFwiPuWFgzwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgdi1pZj1cInRoaXMuZmxhZ1wiIGNsYXNzPVwiY29udGVudFwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ3b3JkXCI+5YW25LitPC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJtYXhcIj57e01heENsYXNzfX08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cIndvcmRcIj7oirHotLnmnIDlpJos5YWx6K6hPC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJtYXhcIj57e21heEV4cGVuZH19PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ3b3JkXCI+5YWDPC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiB2LWlmPVwiZWR1XCIgY2xhc3M9XCJhbmFseXNpc1wiPuS9oOecn+aYr+S4queIseWtpuS5oOeahOWlveWuneWunTwvZGl2PlxuICAgICAgICA8ZGl2IHYtaWY9XCJub3JtYWxcIiBjbGFzcz1cImFuYWx5c2lzXCI+5raI6LS56Jm95piT77yM55Sf5rS75LiN5piTPC9kaXY+XG4gICAgICAgIDxkaXYgdi1pZj1cImZvb2RcIiBjbGFzcz1cImFuYWx5c2lzXCI+5ZOI5ZOI77yM5L2g5piv5Liq5bCP5ZCD6LSnPC9kaXY+XG4gICAgICAgIDxkaXYgdi1pZj1cInRyaXBcIiBjbGFzcz1cImFuYWx5c2lzXCI+6KGM5LiH6YeM6Lev55qE5L2g5Y6755yL5LqG5pu05aSn55qE5LiW55WM5ZCX77yfPC9kaXY+XG4gICAgICAgIDxkaXYgdi1pZj1cImVudGVydGFpblwiIGNsYXNzPVwiYW5hbHlzaXNcIj7mtarmtarmtarmtarvvIzov5jkuI3ljrvlrabkuaDvvJ88L2Rpdj5cbiAgICAgICAgPGRpdiB2LWlmPVwiY2xvdGhlc1wiIGNsYXNzPVwiYW5hbHlzaXNcIj7mjZXojrfkuIDlj6rniLHnvo7nmoTkvaA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuaW1wb3J0IFZlUGllIGZyb20gJ3YtY2hhcnRzL2xpYi9waWUnXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZGF0YSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFydERhdGE6e1xuICAgICAgICAgICAgICAgIGNvbHVtbnM6IFsnZGF0ZScsICdleHBlbmQnXSxcbiAgICAgICAgICAgICAgICByb3dzIDogW11cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdWx0OiBbXSxcbiAgICAgICAgICAgIG1heEV4cGVuZDogXCIgXCIsXG4gICAgICAgICAgICBUb3RhbEV4cGVuZDogXCIgXCIsXG4gICAgICAgICAgICBNYXhDbGFzczogXCIgXCIsXG4gICAgICAgICAgICBmbGFnOiBmYWxzZSxcbiAgICAgICAgICAgIGVkdTogZmFsc2UsXG4gICAgICAgICAgICB0cmlwOiBmYWxzZSxcbiAgICAgICAgICAgIGVudGVydGFpbjogZmFsc2UsXG4gICAgICAgICAgICBjbG90aGVzOiBmYWxzZSxcbiAgICAgICAgICAgIG5vcm1hbDogZmFsc2UsXG4gICAgICAgICAgICBmb29kOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb21wb25lbnRzOiB7XG4gICAgICAgICAgICBWZVBpZVxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVkKCl7XG4gICAgICAgICAgICBmZXRjaChcImFwaS9nZXRfbW9udGgvXCIpLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmpzb24oKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFydERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IFsnY2xhc3MnLCAnZXhwZW5kJ10sXG4gICAgICAgICAgICAgICAgICAgIHJvd3MgOiByZXMucmVzdWx0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuTWF4Q2xhc3MgPSByZXMuTWF4Q2xhc3NcbiAgICAgICAgICAgICAgICB0aGlzLm1heEV4cGVuZCA9IHJlcy5tYXhFeHBlbmRcbiAgICAgICAgICAgICAgICB0aGlzLlRvdGFsRXhwZW5kID0gcmVzLlRvdGFsRXhwZW5kXG4gICAgICAgICAgICAgICAgaWYodGhpcy5Ub3RhbEV4cGVuZCAhPTApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxhZyA9IHRydWVcbiAgICAgICAgICAgICAgICBpZih0aGlzLk1heENsYXNzPT1cIuaVmeiCslwiKVxuICAgICAgICAgICAgICAgIHRoaXMuZWR1ID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHRoaXMuTWF4Q2xhc3M9PVwi5Ye66KGMXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaXAgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodGhpcy5NYXhDbGFzcz09XCLkuIDoiKxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9ybWFsID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHRoaXMuTWF4Q2xhc3M9PVwi5pyN6aWwXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3RoZXMgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodGhpcy5NYXhDbGFzcz09XCLlqLHkuZBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJ0YWluID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHRoaXMuTWF4Q2xhc3M9PVwi6aWu6aOfXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvb2QgPSB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdGhpcy5jaGFydFNldHRpbmdzID0ge1xuICAgICAgICAgICAgZGltZW5zaW9uOiAnY2xhc3MnLFxuICAgICAgICAgICAgbWV0cmljczogJ2V4cGVuZCcsXG4gICAgICAgICAgICBzZWxlY3RlZE1vZGU6ICdzaW5nbGUnLFxuICAgICAgICAgICAgaG92ZXJBbmltYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgcmFkaXVzOiAxMDAsXG4gICAgICAgICAgICBvZmZzZXRZOiAyMDBcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoYXJ0Q29sb3JzID0gWycjZmZiODc2JywnI2Q0ZWVmZicsJyM0MGMwY2InLCcjZmZlOWQ0JywnI2VmNzY3YScsJyNiNGMzZmYnXVxuICAgICAgICAgICAgdGhpcy5sZWdlbmRfcG9zaXRpb249J2JvdHRvbSdcbiAgICAgICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGUgbGFuZz1cInNhc3NcIj5cbi5hbmFseXNpcyB7XG4gICAgY29sb3I6ICNmMmE2YjQ7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIG1hcmdpbi10b3A6IDIwcHg7XG4gICAgZm9udC1zaXplOiAyNnB4O1xufVxuPC9zdHlsZT5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbW9udGgudnVlPzNiM2UxYzljIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar echarts = _interopDefault(__webpack_require__(17));\n__webpack_require__(129);\n__webpack_require__(146);\n__webpack_require__(181);\n\nif (typeof Object.assign !== 'function') {\n  Object.assign = function (target) {\n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    target = Object(target);\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n      if (source != null) {\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n    }\n    return target;\n  };\n}\n\necharts.registerTheme('ve-chart', {\n  color: ['#19d4ae', '#5ab1ef', '#fa6e86', '#ffb980', '#0067a6', '#c4b4e4', '#d87a80', '#9cbbff', '#d9d0c7', '#87a997', '#d49ea2', '#5b4947', '#7ba3a8'],\n  categoryAxis: {\n    axisLine: { show: false },\n    axisTick: { show: false },\n    splitLine: { show: false }\n  },\n  valueAxis: {\n    axisLine: { show: false }\n  },\n  line: {\n    smooth: true\n  },\n  grid: {\n    containLabel: true,\n    left: 10,\n    right: 10\n  }\n});\n\nvar itemPoint = function itemPoint(color) {\n  return ['<span style=\"', 'background-color:' + color + ';', 'display: inline-block;', 'width: 10px;', 'height: 10px;', 'border-radius: 50%;', 'margin-right:2px;', '\"></span>'].join('');\n};\n\nvar numberFormat = function numberFormat(val) {\n  var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n\n  if (isNaN(+val)) return val;\n\n  var symbolMap = [{ value: 1E18, symbol: 'E' }, { value: 1E15, symbol: 'P' }, { value: 1E12, symbol: 'T' }, { value: 1E9, symbol: 'B' }, { value: 1E6, symbol: 'M' }, { value: 1E3, symbol: 'k' }];\n\n  for (var i = 0; i < symbolMap.length; i++) {\n    if (Math.abs(val) >= symbolMap[i].value) {\n      return (val / symbolMap[i].value).toFixed(digits) + symbolMap[i].symbol;\n    }\n  }\n\n  return val.toString();\n};\n\nvar formatTausends = function formatTausends(num) {\n  return String(num).replace(/^(\\s+|-)?\\d+(?=.?\\d*($|\\s))/g, function (m) {\n    return m.replace(/(?=(?!\\b)(\\d{3})+$)/g, ',');\n  });\n};\n\nvar getFormated = function getFormated(val, type) {\n  switch (type) {\n    case 'KMB':\n      return numberFormat(val);\n    case 'percent':\n      return parseFloat((val * 100).toFixed(2)) + '%';\n    case 'normal':\n      return formatTausends(val);\n    default:\n      return val;\n  }\n};\n\nvar pieRadius = 100;\nvar ringRadius = [80, 100];\nvar pieOffsetY = 200;\n\nfunction getPieSeries(args) {\n  var rows = args.rows,\n      dataType = args.dataType,\n      percentShow = args.percentShow,\n      dimension = args.dimension,\n      metrics = args.metrics,\n      radius = args.radius,\n      offsetY = args.offsetY,\n      selectedMode = args.selectedMode,\n      hoverAnimation = args.hoverAnimation;\n\n\n  var series = {\n    type: 'pie',\n    radius: radius,\n    selectedMode: selectedMode,\n    hoverAnimation: hoverAnimation,\n    data: [],\n    center: ['50%', offsetY]\n  };\n  if (percentShow) {\n    series.label = {\n      normal: {\n        show: true,\n        formatter: function formatter(item) {\n          var tpl = [];\n          tpl.push(item.name + ':');\n          tpl.push(getFormated(item.value, dataType));\n          tpl.push('(' + item.percent + '%)');\n          return tpl.join(' ');\n        }\n      }\n    };\n  }\n  series.data = rows.map(function (row) {\n    return {\n      name: row[dimension],\n      value: row[metrics]\n    };\n  });\n\n  return series;\n}\n\nfunction getPieLegend(args) {\n  var rows = args.rows,\n      dimension = args.dimension,\n      legendLimit = args.legendLimit;\n\n  var legend = rows.map(function (row) {\n    return row[dimension];\n  });\n  return legend.length ? { data: legend, show: legend.length < legendLimit } : false;\n}\n\nfunction getPieTooltip(dataType) {\n  return {\n    formatter: function formatter(item) {\n      var tpl = [];\n      tpl.push(itemPoint(item.color));\n      tpl.push(item.name + ':');\n      tpl.push(getFormated(item.value, dataType));\n      tpl.push('(' + item.percent + '%)');\n      return tpl.join(' ');\n    }\n  };\n}\n\nvar pie = function pie(columns, rows, settings, extra, isRing) {\n  var _settings$dataType = settings.dataType,\n      dataType = _settings$dataType === undefined ? 'normal' : _settings$dataType,\n      percentShow = settings.percentShow,\n      _settings$dimension = settings.dimension,\n      dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,\n      _settings$metrics = settings.metrics,\n      metrics = _settings$metrics === undefined ? columns[1] : _settings$metrics,\n      _settings$radius = settings.radius,\n      radius = _settings$radius === undefined ? isRing ? ringRadius : pieRadius : _settings$radius,\n      _settings$offsetY = settings.offsetY,\n      offsetY = _settings$offsetY === undefined ? pieOffsetY : _settings$offsetY,\n      _settings$legendLimit = settings.legendLimit,\n      legendLimit = _settings$legendLimit === undefined ? 30 : _settings$legendLimit,\n      _settings$selectedMod = settings.selectedMode,\n      selectedMode = _settings$selectedMod === undefined ? false : _settings$selectedMod,\n      _settings$hoverAnimat = settings.hoverAnimation,\n      hoverAnimation = _settings$hoverAnimat === undefined ? true : _settings$hoverAnimat;\n  var tooltipVisible = extra.tooltipVisible,\n      legendVisible = extra.legendVisible;\n\n  var seriesParams = {\n    rows: rows,\n    dataType: dataType,\n    percentShow: percentShow,\n    dimension: dimension,\n    metrics: metrics,\n    radius: radius,\n    offsetY: offsetY,\n    selectedMode: selectedMode,\n    hoverAnimation: hoverAnimation\n  };\n  var series = getPieSeries(seriesParams);\n  var legend = legendVisible && getPieLegend({ rows: rows, dimension: dimension, legendLimit: legendLimit });\n  var tooltip = tooltipVisible && getPieTooltip(dataType);\n  var options = { series: series, legend: legend, tooltip: tooltip };\n  return options;\n};\n\nvar chartMixin = {\n  props: {\n    data: { type: [Object, Array], default: null },\n    settings: { type: Object, default: function _default() {\n        return {};\n      }\n    },\n    width: { type: String, default: 'auto' },\n    height: { type: String, default: '400px' },\n    beforeConfig: { type: Function },\n    afterConfig: { type: Function },\n    events: { type: Object },\n    grid: { type: Object },\n    colors: { type: Array },\n    tooltipVisible: { type: Boolean, default: true },\n    legendVisible: { type: Boolean, default: true },\n    legendPosition: { type: String },\n    markLine: { type: Object },\n    markArea: { type: Object },\n    markPoint: { type: Object },\n    visualMap: { type: [Object, Array] },\n    dataZoom: { type: [Object, Array] },\n    toolbox: { type: Object },\n    initOptions: { type: Object, default: function _default() {\n        return {};\n      }\n    }\n  },\n\n  watch: {\n    data: {\n      deep: true,\n      handler: function handler(v) {\n        if (v) {\n          this.dataHandler(v);\n        }\n      }\n    },\n\n    settings: {\n      deep: true,\n      handler: function handler(v) {\n        if (v.type && this.chartLib) this.chartHandler = this.chartLib[v.type];\n        this.dataHandler(this.data);\n      }\n    }\n  },\n\n  computed: {\n    canvasStyle: function canvasStyle() {\n      return {\n        width: this.width,\n        height: this.height,\n        position: 'relative'\n      };\n    }\n  },\n\n  methods: {\n    dataHandler: function dataHandler(data) {\n      var _this = this;\n\n      if (!this.chartHandler) return;\n      if (!data || !Array.isArray(data.columns) || !Array.isArray(data.rows)) return false;\n      var _data = data,\n          columns = _data.columns,\n          rows = _data.rows;\n\n      var extra = {\n        tooltipVisible: this.tooltipVisible,\n        legendVisible: this.legendVisible\n      };\n      if (this.beforeConfig) data = this.beforeConfig(data);\n\n      var options = this.chartHandler(columns, rows, this.settings, extra);\n\n      if (options) {\n        if (this.colors) options.color = this.colors;\n        if (this.grid) options.grid = this.grid;\n        if (this.legendPosition && options.legend) {\n          options.legend[this.legendPosition] = 10;\n          if (~['left', 'right'].indexOf(this.legendPosition)) {\n            options.legend.top = 'middle';\n            options.legend.orient = 'vertical';\n          }\n        }\n        if (this.dataZoom) options.dataZoom = this.dataZoom;\n        if (this.visualMap) options.visualMap = this.visualMap;\n        if (this.toolbox) options.toolbox = this.toolbox;\n        if (this.markArea || this.markLine || this.markPoint) {\n          var marks = {\n            markArea: this.markArea,\n            markLine: this.markLine,\n            markPoint: this.markPoint\n          };\n          var series = options.series;\n          if (this.getType(series) === '[object Array]') {\n            series.forEach(function (item) {\n              _this.addMark(item, marks);\n            });\n          } else if (this.getType(series) === '[object Object]') {\n            this.addMark(series, marks);\n          }\n        }\n        if (this.afterConfig) options = this.afterConfig(options);\n        this.echarts.setOption(options, true);\n      }\n    },\n    addMark: function addMark(seriesItem, marks) {\n      Object.keys(marks).forEach(function (key) {\n        if (marks[key]) {\n          seriesItem[key] = marks[key];\n        }\n      });\n    },\n    getType: function getType(v) {\n      return Object.prototype.toString.call(v);\n    },\n    init: function init() {\n      if (this.echarts) return;\n      this.echarts = this.echartsLib.init(this.$refs.canvas, 've-chart', this.initOptions);\n      if (this.data) this.dataHandler(this.data);\n      if (this.events) this.bindEvents();\n    },\n    bindEvents: function bindEvents() {\n      var _this2 = this;\n\n      Object.keys(this.events).forEach(function (event) {\n        _this2.echarts.on(event, _this2.events[event]);\n      });\n    }\n  },\n\n  mounted: function mounted() {\n    var _this3 = this;\n\n    this.$nextTick(function () {\n      _this3.init();\n      window.addEventListener('resize', _this3.echarts.resize);\n    });\n  },\n  beforeDestory: function beforeDestory() {\n    window.removeEventListener('resize', this.echarts.resize);\n    this.echarts.dispose();\n  }\n};\n\nvar index = {\n  render: function render() {\n    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: \"canvas\", staticClass: \"ve-pie\", style: _vm.canvasStyle });\n  },\n  staticRenderFns: [],\n  name: 'VePie',\n  mixins: [chartMixin],\n  created: function created() {\n    this.chartHandler = pie;\n    this.echartsLib = echarts;\n  }\n};\n\nmodule.exports = index;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3YtY2hhcnRzL2xpYi9waWUuanM/NWY1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSwrQkFBK0IsaUZBQWlGOztBQUVoSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0EsZUFBZTtBQUNmLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsMkRBQTJELDBCQUEwQixnQkFBZ0IsaUJBQWlCLHVCQUF1QixxQkFBcUI7QUFDbEs7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsMEJBQTBCLEdBQUcsMEJBQTBCLEdBQUcsMEJBQTBCOztBQUVsTSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxFQUFFO0FBQ3JDLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCwwQkFBMEIsa0RBQWtEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw2REFBNkQ7QUFDM0c7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQsZUFBZTtBQUNmO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxnQ0FBZ0M7QUFDNUMsYUFBYSxpQ0FBaUM7QUFDOUMsbUJBQW1CLGlCQUFpQjtBQUNwQyxrQkFBa0IsaUJBQWlCO0FBQ25DLGFBQWEsZUFBZTtBQUM1QixXQUFXLGVBQWU7QUFDMUIsYUFBYSxjQUFjO0FBQzNCLHFCQUFxQiwrQkFBK0I7QUFDcEQsb0JBQW9CLCtCQUErQjtBQUNuRCxxQkFBcUIsZUFBZTtBQUNwQyxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQix3QkFBd0I7QUFDeEMsZUFBZSx3QkFBd0I7QUFDdkMsY0FBYyxlQUFlO0FBQzdCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0Qiw0QkFBNEIsa0JBQWtCLCtEQUErRDtBQUM1SixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIyMDguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgZWNoYXJ0cyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdlY2hhcnRzL2xpYi9lY2hhcnRzJykpO1xucmVxdWlyZSgnZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAnKTtcbnJlcXVpcmUoJ2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQnKTtcbnJlcXVpcmUoJ2VjaGFydHMvbGliL2NoYXJ0L3BpZScpO1xuXG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgT2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgIH1cblxuICAgIHRhcmdldCA9IE9iamVjdCh0YXJnZXQpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG59XG5cbmVjaGFydHMucmVnaXN0ZXJUaGVtZSgndmUtY2hhcnQnLCB7XG4gIGNvbG9yOiBbJyMxOWQ0YWUnLCAnIzVhYjFlZicsICcjZmE2ZTg2JywgJyNmZmI5ODAnLCAnIzAwNjdhNicsICcjYzRiNGU0JywgJyNkODdhODAnLCAnIzljYmJmZicsICcjZDlkMGM3JywgJyM4N2E5OTcnLCAnI2Q0OWVhMicsICcjNWI0OTQ3JywgJyM3YmEzYTgnXSxcbiAgY2F0ZWdvcnlBeGlzOiB7XG4gICAgYXhpc0xpbmU6IHsgc2hvdzogZmFsc2UgfSxcbiAgICBheGlzVGljazogeyBzaG93OiBmYWxzZSB9LFxuICAgIHNwbGl0TGluZTogeyBzaG93OiBmYWxzZSB9XG4gIH0sXG4gIHZhbHVlQXhpczoge1xuICAgIGF4aXNMaW5lOiB7IHNob3c6IGZhbHNlIH1cbiAgfSxcbiAgbGluZToge1xuICAgIHNtb290aDogdHJ1ZVxuICB9LFxuICBncmlkOiB7XG4gICAgY29udGFpbkxhYmVsOiB0cnVlLFxuICAgIGxlZnQ6IDEwLFxuICAgIHJpZ2h0OiAxMFxuICB9XG59KTtcblxudmFyIGl0ZW1Qb2ludCA9IGZ1bmN0aW9uIGl0ZW1Qb2ludChjb2xvcikge1xuICByZXR1cm4gWyc8c3BhbiBzdHlsZT1cIicsICdiYWNrZ3JvdW5kLWNvbG9yOicgKyBjb2xvciArICc7JywgJ2Rpc3BsYXk6IGlubGluZS1ibG9jazsnLCAnd2lkdGg6IDEwcHg7JywgJ2hlaWdodDogMTBweDsnLCAnYm9yZGVyLXJhZGl1czogNTAlOycsICdtYXJnaW4tcmlnaHQ6MnB4OycsICdcIj48L3NwYW4+J10uam9pbignJyk7XG59O1xuXG52YXIgbnVtYmVyRm9ybWF0ID0gZnVuY3Rpb24gbnVtYmVyRm9ybWF0KHZhbCkge1xuICB2YXIgZGlnaXRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAyO1xuXG4gIGlmIChpc05hTigrdmFsKSkgcmV0dXJuIHZhbDtcblxuICB2YXIgc3ltYm9sTWFwID0gW3sgdmFsdWU6IDFFMTgsIHN5bWJvbDogJ0UnIH0sIHsgdmFsdWU6IDFFMTUsIHN5bWJvbDogJ1AnIH0sIHsgdmFsdWU6IDFFMTIsIHN5bWJvbDogJ1QnIH0sIHsgdmFsdWU6IDFFOSwgc3ltYm9sOiAnQicgfSwgeyB2YWx1ZTogMUU2LCBzeW1ib2w6ICdNJyB9LCB7IHZhbHVlOiAxRTMsIHN5bWJvbDogJ2snIH1dO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9sTWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKE1hdGguYWJzKHZhbCkgPj0gc3ltYm9sTWFwW2ldLnZhbHVlKSB7XG4gICAgICByZXR1cm4gKHZhbCAvIHN5bWJvbE1hcFtpXS52YWx1ZSkudG9GaXhlZChkaWdpdHMpICsgc3ltYm9sTWFwW2ldLnN5bWJvbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsLnRvU3RyaW5nKCk7XG59O1xuXG52YXIgZm9ybWF0VGF1c2VuZHMgPSBmdW5jdGlvbiBmb3JtYXRUYXVzZW5kcyhudW0pIHtcbiAgcmV0dXJuIFN0cmluZyhudW0pLnJlcGxhY2UoL14oXFxzK3wtKT9cXGQrKD89Lj9cXGQqKCR8XFxzKSkvZywgZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gbS5yZXBsYWNlKC8oPz0oPyFcXGIpKFxcZHszfSkrJCkvZywgJywnKTtcbiAgfSk7XG59O1xuXG52YXIgZ2V0Rm9ybWF0ZWQgPSBmdW5jdGlvbiBnZXRGb3JtYXRlZCh2YWwsIHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnS01CJzpcbiAgICAgIHJldHVybiBudW1iZXJGb3JtYXQodmFsKTtcbiAgICBjYXNlICdwZXJjZW50JzpcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KCh2YWwgKiAxMDApLnRvRml4ZWQoMikpICsgJyUnO1xuICAgIGNhc2UgJ25vcm1hbCc6XG4gICAgICByZXR1cm4gZm9ybWF0VGF1c2VuZHModmFsKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZhbDtcbiAgfVxufTtcblxudmFyIHBpZVJhZGl1cyA9IDEwMDtcbnZhciByaW5nUmFkaXVzID0gWzgwLCAxMDBdO1xudmFyIHBpZU9mZnNldFkgPSAyMDA7XG5cbmZ1bmN0aW9uIGdldFBpZVNlcmllcyhhcmdzKSB7XG4gIHZhciByb3dzID0gYXJncy5yb3dzLFxuICAgICAgZGF0YVR5cGUgPSBhcmdzLmRhdGFUeXBlLFxuICAgICAgcGVyY2VudFNob3cgPSBhcmdzLnBlcmNlbnRTaG93LFxuICAgICAgZGltZW5zaW9uID0gYXJncy5kaW1lbnNpb24sXG4gICAgICBtZXRyaWNzID0gYXJncy5tZXRyaWNzLFxuICAgICAgcmFkaXVzID0gYXJncy5yYWRpdXMsXG4gICAgICBvZmZzZXRZID0gYXJncy5vZmZzZXRZLFxuICAgICAgc2VsZWN0ZWRNb2RlID0gYXJncy5zZWxlY3RlZE1vZGUsXG4gICAgICBob3ZlckFuaW1hdGlvbiA9IGFyZ3MuaG92ZXJBbmltYXRpb247XG5cblxuICB2YXIgc2VyaWVzID0ge1xuICAgIHR5cGU6ICdwaWUnLFxuICAgIHJhZGl1czogcmFkaXVzLFxuICAgIHNlbGVjdGVkTW9kZTogc2VsZWN0ZWRNb2RlLFxuICAgIGhvdmVyQW5pbWF0aW9uOiBob3ZlckFuaW1hdGlvbixcbiAgICBkYXRhOiBbXSxcbiAgICBjZW50ZXI6IFsnNTAlJywgb2Zmc2V0WV1cbiAgfTtcbiAgaWYgKHBlcmNlbnRTaG93KSB7XG4gICAgc2VyaWVzLmxhYmVsID0ge1xuICAgICAgbm9ybWFsOiB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKGl0ZW0pIHtcbiAgICAgICAgICB2YXIgdHBsID0gW107XG4gICAgICAgICAgdHBsLnB1c2goaXRlbS5uYW1lICsgJzonKTtcbiAgICAgICAgICB0cGwucHVzaChnZXRGb3JtYXRlZChpdGVtLnZhbHVlLCBkYXRhVHlwZSkpO1xuICAgICAgICAgIHRwbC5wdXNoKCcoJyArIGl0ZW0ucGVyY2VudCArICclKScpO1xuICAgICAgICAgIHJldHVybiB0cGwuam9pbignICcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBzZXJpZXMuZGF0YSA9IHJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogcm93W2RpbWVuc2lvbl0sXG4gICAgICB2YWx1ZTogcm93W21ldHJpY3NdXG4gICAgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNlcmllcztcbn1cblxuZnVuY3Rpb24gZ2V0UGllTGVnZW5kKGFyZ3MpIHtcbiAgdmFyIHJvd3MgPSBhcmdzLnJvd3MsXG4gICAgICBkaW1lbnNpb24gPSBhcmdzLmRpbWVuc2lvbixcbiAgICAgIGxlZ2VuZExpbWl0ID0gYXJncy5sZWdlbmRMaW1pdDtcblxuICB2YXIgbGVnZW5kID0gcm93cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgIHJldHVybiByb3dbZGltZW5zaW9uXTtcbiAgfSk7XG4gIHJldHVybiBsZWdlbmQubGVuZ3RoID8geyBkYXRhOiBsZWdlbmQsIHNob3c6IGxlZ2VuZC5sZW5ndGggPCBsZWdlbmRMaW1pdCB9IDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFBpZVRvb2x0aXAoZGF0YVR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcihpdGVtKSB7XG4gICAgICB2YXIgdHBsID0gW107XG4gICAgICB0cGwucHVzaChpdGVtUG9pbnQoaXRlbS5jb2xvcikpO1xuICAgICAgdHBsLnB1c2goaXRlbS5uYW1lICsgJzonKTtcbiAgICAgIHRwbC5wdXNoKGdldEZvcm1hdGVkKGl0ZW0udmFsdWUsIGRhdGFUeXBlKSk7XG4gICAgICB0cGwucHVzaCgnKCcgKyBpdGVtLnBlcmNlbnQgKyAnJSknKTtcbiAgICAgIHJldHVybiB0cGwuam9pbignICcpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHBpZSA9IGZ1bmN0aW9uIHBpZShjb2x1bW5zLCByb3dzLCBzZXR0aW5ncywgZXh0cmEsIGlzUmluZykge1xuICB2YXIgX3NldHRpbmdzJGRhdGFUeXBlID0gc2V0dGluZ3MuZGF0YVR5cGUsXG4gICAgICBkYXRhVHlwZSA9IF9zZXR0aW5ncyRkYXRhVHlwZSA9PT0gdW5kZWZpbmVkID8gJ25vcm1hbCcgOiBfc2V0dGluZ3MkZGF0YVR5cGUsXG4gICAgICBwZXJjZW50U2hvdyA9IHNldHRpbmdzLnBlcmNlbnRTaG93LFxuICAgICAgX3NldHRpbmdzJGRpbWVuc2lvbiA9IHNldHRpbmdzLmRpbWVuc2lvbixcbiAgICAgIGRpbWVuc2lvbiA9IF9zZXR0aW5ncyRkaW1lbnNpb24gPT09IHVuZGVmaW5lZCA/IGNvbHVtbnNbMF0gOiBfc2V0dGluZ3MkZGltZW5zaW9uLFxuICAgICAgX3NldHRpbmdzJG1ldHJpY3MgPSBzZXR0aW5ncy5tZXRyaWNzLFxuICAgICAgbWV0cmljcyA9IF9zZXR0aW5ncyRtZXRyaWNzID09PSB1bmRlZmluZWQgPyBjb2x1bW5zWzFdIDogX3NldHRpbmdzJG1ldHJpY3MsXG4gICAgICBfc2V0dGluZ3MkcmFkaXVzID0gc2V0dGluZ3MucmFkaXVzLFxuICAgICAgcmFkaXVzID0gX3NldHRpbmdzJHJhZGl1cyA9PT0gdW5kZWZpbmVkID8gaXNSaW5nID8gcmluZ1JhZGl1cyA6IHBpZVJhZGl1cyA6IF9zZXR0aW5ncyRyYWRpdXMsXG4gICAgICBfc2V0dGluZ3Mkb2Zmc2V0WSA9IHNldHRpbmdzLm9mZnNldFksXG4gICAgICBvZmZzZXRZID0gX3NldHRpbmdzJG9mZnNldFkgPT09IHVuZGVmaW5lZCA/IHBpZU9mZnNldFkgOiBfc2V0dGluZ3Mkb2Zmc2V0WSxcbiAgICAgIF9zZXR0aW5ncyRsZWdlbmRMaW1pdCA9IHNldHRpbmdzLmxlZ2VuZExpbWl0LFxuICAgICAgbGVnZW5kTGltaXQgPSBfc2V0dGluZ3MkbGVnZW5kTGltaXQgPT09IHVuZGVmaW5lZCA/IDMwIDogX3NldHRpbmdzJGxlZ2VuZExpbWl0LFxuICAgICAgX3NldHRpbmdzJHNlbGVjdGVkTW9kID0gc2V0dGluZ3Muc2VsZWN0ZWRNb2RlLFxuICAgICAgc2VsZWN0ZWRNb2RlID0gX3NldHRpbmdzJHNlbGVjdGVkTW9kID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9zZXR0aW5ncyRzZWxlY3RlZE1vZCxcbiAgICAgIF9zZXR0aW5ncyRob3ZlckFuaW1hdCA9IHNldHRpbmdzLmhvdmVyQW5pbWF0aW9uLFxuICAgICAgaG92ZXJBbmltYXRpb24gPSBfc2V0dGluZ3MkaG92ZXJBbmltYXQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfc2V0dGluZ3MkaG92ZXJBbmltYXQ7XG4gIHZhciB0b29sdGlwVmlzaWJsZSA9IGV4dHJhLnRvb2x0aXBWaXNpYmxlLFxuICAgICAgbGVnZW5kVmlzaWJsZSA9IGV4dHJhLmxlZ2VuZFZpc2libGU7XG5cbiAgdmFyIHNlcmllc1BhcmFtcyA9IHtcbiAgICByb3dzOiByb3dzLFxuICAgIGRhdGFUeXBlOiBkYXRhVHlwZSxcbiAgICBwZXJjZW50U2hvdzogcGVyY2VudFNob3csXG4gICAgZGltZW5zaW9uOiBkaW1lbnNpb24sXG4gICAgbWV0cmljczogbWV0cmljcyxcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBvZmZzZXRZOiBvZmZzZXRZLFxuICAgIHNlbGVjdGVkTW9kZTogc2VsZWN0ZWRNb2RlLFxuICAgIGhvdmVyQW5pbWF0aW9uOiBob3ZlckFuaW1hdGlvblxuICB9O1xuICB2YXIgc2VyaWVzID0gZ2V0UGllU2VyaWVzKHNlcmllc1BhcmFtcyk7XG4gIHZhciBsZWdlbmQgPSBsZWdlbmRWaXNpYmxlICYmIGdldFBpZUxlZ2VuZCh7IHJvd3M6IHJvd3MsIGRpbWVuc2lvbjogZGltZW5zaW9uLCBsZWdlbmRMaW1pdDogbGVnZW5kTGltaXQgfSk7XG4gIHZhciB0b29sdGlwID0gdG9vbHRpcFZpc2libGUgJiYgZ2V0UGllVG9vbHRpcChkYXRhVHlwZSk7XG4gIHZhciBvcHRpb25zID0geyBzZXJpZXM6IHNlcmllcywgbGVnZW5kOiBsZWdlbmQsIHRvb2x0aXA6IHRvb2x0aXAgfTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG52YXIgY2hhcnRNaXhpbiA9IHtcbiAgcHJvcHM6IHtcbiAgICBkYXRhOiB7IHR5cGU6IFtPYmplY3QsIEFycmF5XSwgZGVmYXVsdDogbnVsbCB9LFxuICAgIHNldHRpbmdzOiB7IHR5cGU6IE9iamVjdCwgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdpZHRoOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ2F1dG8nIH0sXG4gICAgaGVpZ2h0OiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJzQwMHB4JyB9LFxuICAgIGJlZm9yZUNvbmZpZzogeyB0eXBlOiBGdW5jdGlvbiB9LFxuICAgIGFmdGVyQ29uZmlnOiB7IHR5cGU6IEZ1bmN0aW9uIH0sXG4gICAgZXZlbnRzOiB7IHR5cGU6IE9iamVjdCB9LFxuICAgIGdyaWQ6IHsgdHlwZTogT2JqZWN0IH0sXG4gICAgY29sb3JzOiB7IHR5cGU6IEFycmF5IH0sXG4gICAgdG9vbHRpcFZpc2libGU6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogdHJ1ZSB9LFxuICAgIGxlZ2VuZFZpc2libGU6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogdHJ1ZSB9LFxuICAgIGxlZ2VuZFBvc2l0aW9uOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIG1hcmtMaW5lOiB7IHR5cGU6IE9iamVjdCB9LFxuICAgIG1hcmtBcmVhOiB7IHR5cGU6IE9iamVjdCB9LFxuICAgIG1hcmtQb2ludDogeyB0eXBlOiBPYmplY3QgfSxcbiAgICB2aXN1YWxNYXA6IHsgdHlwZTogW09iamVjdCwgQXJyYXldIH0sXG4gICAgZGF0YVpvb206IHsgdHlwZTogW09iamVjdCwgQXJyYXldIH0sXG4gICAgdG9vbGJveDogeyB0eXBlOiBPYmplY3QgfSxcbiAgICBpbml0T3B0aW9uczogeyB0eXBlOiBPYmplY3QsIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgZGF0YToge1xuICAgICAgZGVlcDogdHJ1ZSxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIodikge1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgIHRoaXMuZGF0YUhhbmRsZXIodik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0dGluZ3M6IHtcbiAgICAgIGRlZXA6IHRydWUsXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHYpIHtcbiAgICAgICAgaWYgKHYudHlwZSAmJiB0aGlzLmNoYXJ0TGliKSB0aGlzLmNoYXJ0SGFuZGxlciA9IHRoaXMuY2hhcnRMaWJbdi50eXBlXTtcbiAgICAgICAgdGhpcy5kYXRhSGFuZGxlcih0aGlzLmRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIGNhbnZhc1N0eWxlOiBmdW5jdGlvbiBjYW52YXNTdHlsZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGRhdGFIYW5kbGVyOiBmdW5jdGlvbiBkYXRhSGFuZGxlcihkYXRhKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuY2hhcnRIYW5kbGVyKSByZXR1cm47XG4gICAgICBpZiAoIWRhdGEgfHwgIUFycmF5LmlzQXJyYXkoZGF0YS5jb2x1bW5zKSB8fCAhQXJyYXkuaXNBcnJheShkYXRhLnJvd3MpKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgX2RhdGEgPSBkYXRhLFxuICAgICAgICAgIGNvbHVtbnMgPSBfZGF0YS5jb2x1bW5zLFxuICAgICAgICAgIHJvd3MgPSBfZGF0YS5yb3dzO1xuXG4gICAgICB2YXIgZXh0cmEgPSB7XG4gICAgICAgIHRvb2x0aXBWaXNpYmxlOiB0aGlzLnRvb2x0aXBWaXNpYmxlLFxuICAgICAgICBsZWdlbmRWaXNpYmxlOiB0aGlzLmxlZ2VuZFZpc2libGVcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5iZWZvcmVDb25maWcpIGRhdGEgPSB0aGlzLmJlZm9yZUNvbmZpZyhkYXRhKTtcblxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmNoYXJ0SGFuZGxlcihjb2x1bW5zLCByb3dzLCB0aGlzLnNldHRpbmdzLCBleHRyYSk7XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbG9ycykgb3B0aW9ucy5jb2xvciA9IHRoaXMuY29sb3JzO1xuICAgICAgICBpZiAodGhpcy5ncmlkKSBvcHRpb25zLmdyaWQgPSB0aGlzLmdyaWQ7XG4gICAgICAgIGlmICh0aGlzLmxlZ2VuZFBvc2l0aW9uICYmIG9wdGlvbnMubGVnZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5sZWdlbmRbdGhpcy5sZWdlbmRQb3NpdGlvbl0gPSAxMDtcbiAgICAgICAgICBpZiAoflsnbGVmdCcsICdyaWdodCddLmluZGV4T2YodGhpcy5sZWdlbmRQb3NpdGlvbikpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubGVnZW5kLnRvcCA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgb3B0aW9ucy5sZWdlbmQub3JpZW50ID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGF0YVpvb20pIG9wdGlvbnMuZGF0YVpvb20gPSB0aGlzLmRhdGFab29tO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxNYXApIG9wdGlvbnMudmlzdWFsTWFwID0gdGhpcy52aXN1YWxNYXA7XG4gICAgICAgIGlmICh0aGlzLnRvb2xib3gpIG9wdGlvbnMudG9vbGJveCA9IHRoaXMudG9vbGJveDtcbiAgICAgICAgaWYgKHRoaXMubWFya0FyZWEgfHwgdGhpcy5tYXJrTGluZSB8fCB0aGlzLm1hcmtQb2ludCkge1xuICAgICAgICAgIHZhciBtYXJrcyA9IHtcbiAgICAgICAgICAgIG1hcmtBcmVhOiB0aGlzLm1hcmtBcmVhLFxuICAgICAgICAgICAgbWFya0xpbmU6IHRoaXMubWFya0xpbmUsXG4gICAgICAgICAgICBtYXJrUG9pbnQ6IHRoaXMubWFya1BvaW50XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgc2VyaWVzID0gb3B0aW9ucy5zZXJpZXM7XG4gICAgICAgICAgaWYgKHRoaXMuZ2V0VHlwZShzZXJpZXMpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICBzZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICBfdGhpcy5hZGRNYXJrKGl0ZW0sIG1hcmtzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5nZXRUeXBlKHNlcmllcykgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE1hcmsoc2VyaWVzLCBtYXJrcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFmdGVyQ29uZmlnKSBvcHRpb25zID0gdGhpcy5hZnRlckNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5lY2hhcnRzLnNldE9wdGlvbihvcHRpb25zLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFkZE1hcms6IGZ1bmN0aW9uIGFkZE1hcmsoc2VyaWVzSXRlbSwgbWFya3MpIHtcbiAgICAgIE9iamVjdC5rZXlzKG1hcmtzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKG1hcmtzW2tleV0pIHtcbiAgICAgICAgICBzZXJpZXNJdGVtW2tleV0gPSBtYXJrc1trZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldFR5cGU6IGZ1bmN0aW9uIGdldFR5cGUodikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KTtcbiAgICB9LFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBpZiAodGhpcy5lY2hhcnRzKSByZXR1cm47XG4gICAgICB0aGlzLmVjaGFydHMgPSB0aGlzLmVjaGFydHNMaWIuaW5pdCh0aGlzLiRyZWZzLmNhbnZhcywgJ3ZlLWNoYXJ0JywgdGhpcy5pbml0T3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5kYXRhKSB0aGlzLmRhdGFIYW5kbGVyKHRoaXMuZGF0YSk7XG4gICAgICBpZiAodGhpcy5ldmVudHMpIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIH0sXG4gICAgYmluZEV2ZW50czogZnVuY3Rpb24gYmluZEV2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmV2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMyLmVjaGFydHMub24oZXZlbnQsIF90aGlzMi5ldmVudHNbZXZlbnRdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMzLmluaXQoKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBfdGhpczMuZWNoYXJ0cy5yZXNpemUpO1xuICAgIH0pO1xuICB9LFxuICBiZWZvcmVEZXN0b3J5OiBmdW5jdGlvbiBiZWZvcmVEZXN0b3J5KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmVjaGFydHMucmVzaXplKTtcbiAgICB0aGlzLmVjaGFydHMuZGlzcG9zZSgpO1xuICB9XG59O1xuXG52YXIgaW5kZXggPSB7XG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdm0gPSB0aGlzO3ZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7cmV0dXJuIF9jKCdkaXYnLCB7IHJlZjogXCJjYW52YXNcIiwgc3RhdGljQ2xhc3M6IFwidmUtcGllXCIsIHN0eWxlOiBfdm0uY2FudmFzU3R5bGUgfSk7XG4gIH0sXG4gIHN0YXRpY1JlbmRlckZuczogW10sXG4gIG5hbWU6ICdWZVBpZScsXG4gIG1peGluczogW2NoYXJ0TWl4aW5dLFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMuY2hhcnRIYW5kbGVyID0gcGllO1xuICAgIHRoaXMuZWNoYXJ0c0xpYiA9IGVjaGFydHM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW5kZXg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdi1jaGFydHMvbGliL3BpZS5qc1xuLy8gbW9kdWxlIGlkID0gMjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', [_c(\'ve-pie\', {\n    attrs: {\n      "data": _vm.chartData,\n      "settings": _vm.chartSettings,\n      "colors": _vm.chartColors,\n      "tooltip-visible": "",\n      "legend-position": _vm.legend_position,\n      "legend-visible": ""\n    }\n  }), _vm._v(" "), _c(\'div\', {\n    staticClass: "content"\n  }, [_c(\'span\', {\n    staticClass: "word"\n  }, [_vm._v("本月您一共花费")]), _vm._v(" "), _c(\'span\', {\n    staticClass: "max"\n  }, [_vm._v(_vm._s(_vm.TotalExpend))]), _vm._v(" "), _c(\'span\', {\n    staticClass: "word"\n  }, [_vm._v("元")])]), _vm._v(" "), (this.flag) ? _c(\'div\', {\n    staticClass: "content"\n  }, [_c(\'span\', {\n    staticClass: "word"\n  }, [_vm._v("其中")]), _vm._v(" "), _c(\'span\', {\n    staticClass: "max"\n  }, [_vm._v(_vm._s(_vm.MaxClass))]), _vm._v(" "), _c(\'span\', {\n    staticClass: "word"\n  }, [_vm._v("花费最多,共计")]), _vm._v(" "), _c(\'span\', {\n    staticClass: "max"\n  }, [_vm._v(_vm._s(_vm.maxExpend))]), _vm._v(" "), _c(\'span\', {\n    staticClass: "word"\n  }, [_vm._v("元")])]) : _vm._e(), _vm._v(" "), (_vm.edu) ? _c(\'div\', {\n    staticClass: "analysis"\n  }, [_vm._v("你真是个爱学习的好宝宝")]) : _vm._e(), _vm._v(" "), (_vm.normal) ? _c(\'div\', {\n    staticClass: "analysis"\n  }, [_vm._v("消费虽易，生活不易")]) : _vm._e(), _vm._v(" "), (_vm.food) ? _c(\'div\', {\n    staticClass: "analysis"\n  }, [_vm._v("哈哈，你是个小吃货")]) : _vm._e(), _vm._v(" "), (_vm.trip) ? _c(\'div\', {\n    staticClass: "analysis"\n  }, [_vm._v("行万里路的你去看了更大的世界吗？")]) : _vm._e(), _vm._v(" "), (_vm.entertain) ? _c(\'div\', {\n    staticClass: "analysis"\n  }, [_vm._v("浪浪浪浪，还不去学习？")]) : _vm._e(), _vm._v(" "), (_vm.clothes) ? _c(\'div\', {\n    staticClass: "analysis"\n  }, [_vm._v("捕获一只爱美的你")]) : _vm._e()], 1)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tb250aC52dWU/YjNiZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDIiwiZmlsZSI6IjIwOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2JywgW19jKCd2ZS1waWUnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiZGF0YVwiOiBfdm0uY2hhcnREYXRhLFxuICAgICAgXCJzZXR0aW5nc1wiOiBfdm0uY2hhcnRTZXR0aW5ncyxcbiAgICAgIFwiY29sb3JzXCI6IF92bS5jaGFydENvbG9ycyxcbiAgICAgIFwidG9vbHRpcC12aXNpYmxlXCI6IFwiXCIsXG4gICAgICBcImxlZ2VuZC1wb3NpdGlvblwiOiBfdm0ubGVnZW5kX3Bvc2l0aW9uLFxuICAgICAgXCJsZWdlbmQtdmlzaWJsZVwiOiBcIlwiXG4gICAgfVxuICB9KSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjb250ZW50XCJcbiAgfSwgW19jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcIndvcmRcIlxuICB9LCBbX3ZtLl92KFwi5pys5pyI5oKo5LiA5YWx6Iqx6LS5XCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1heFwiXG4gIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5Ub3RhbEV4cGVuZCkpXSksIF92bS5fdihcIiBcIiksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcIndvcmRcIlxuICB9LCBbX3ZtLl92KFwi5YWDXCIpXSldKSwgX3ZtLl92KFwiIFwiKSwgKHRoaXMuZmxhZykgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbnRlbnRcIlxuICB9LCBbX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwid29yZFwiXG4gIH0sIFtfdm0uX3YoXCLlhbbkuK1cIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibWF4XCJcbiAgfSwgW192bS5fdihfdm0uX3MoX3ZtLk1heENsYXNzKSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwid29yZFwiXG4gIH0sIFtfdm0uX3YoXCLoirHotLnmnIDlpJos5YWx6K6hXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1heFwiXG4gIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5tYXhFeHBlbmQpKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJ3b3JkXCJcbiAgfSwgW192bS5fdihcIuWFg1wiKV0pXSkgOiBfdm0uX2UoKSwgX3ZtLl92KFwiIFwiKSwgKF92bS5lZHUpID8gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJhbmFseXNpc1wiXG4gIH0sIFtfdm0uX3YoXCLkvaDnnJ/mmK/kuKrniLHlrabkuaDnmoTlpb3lrp3lrp1cIildKSA6IF92bS5fZSgpLCBfdm0uX3YoXCIgXCIpLCAoX3ZtLm5vcm1hbCkgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImFuYWx5c2lzXCJcbiAgfSwgW192bS5fdihcIua2iOi0ueiZveaYk++8jOeUn+a0u+S4jeaYk1wiKV0pIDogX3ZtLl9lKCksIF92bS5fdihcIiBcIiksIChfdm0uZm9vZCkgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImFuYWx5c2lzXCJcbiAgfSwgW192bS5fdihcIuWTiOWTiO+8jOS9oOaYr+S4quWwj+WQg+i0p1wiKV0pIDogX3ZtLl9lKCksIF92bS5fdihcIiBcIiksIChfdm0udHJpcCkgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImFuYWx5c2lzXCJcbiAgfSwgW192bS5fdihcIuihjOS4h+mHjOi3r+eahOS9oOWOu+eci+S6huabtOWkp+eahOS4lueVjOWQl++8n1wiKV0pIDogX3ZtLl9lKCksIF92bS5fdihcIiBcIiksIChfdm0uZW50ZXJ0YWluKSA/IF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiYW5hbHlzaXNcIlxuICB9LCBbX3ZtLl92KFwi5rWq5rWq5rWq5rWq77yM6L+Y5LiN5Y675a2m5Lmg77yfXCIpXSkgOiBfdm0uX2UoKSwgX3ZtLl92KFwiIFwiKSwgKF92bS5jbG90aGVzKSA/IF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiYW5hbHlzaXNcIlxuICB9LCBbX3ZtLl92KFwi5o2V6I635LiA5Y+q54ix576O55qE5L2gXCIpXSkgOiBfdm0uX2UoKV0sIDEpXG59LHN0YXRpY1JlbmRlckZuczogW119XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtN2I3NWZlOWJcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21vbnRoLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290IjoiIn0=')}]);